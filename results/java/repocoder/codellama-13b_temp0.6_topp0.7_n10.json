{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.6301507537688441,
    "pass@1": 0.4095477386934673,
    "compile@3": 0.7411641541038525,
    "pass@3": 0.4690536013400334,
    "compile@5": 0.7816662678471723,
    "pass@5": 0.49036850921273045
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration methods, adding deserializers\n    /**********************************************************",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration methods, adding deserializers\n    /**********************************************************",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_keySerializers == null) {\n            _keySerializers = new SimpleSerializers();\n        }\n        _keySerializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }\n\n     /*\n     /**********************************************************\n     /* Configuration methods, adding deserializers\n     /**********************************************************",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }\n\n    /*\n    /**********************************************************\n    /* Configuration methods, adding deserializers\n    /**********************************************************"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, false);\n    }"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int nRows = m.getRowDimension();\n        final RealMatrix out = createMatrix(nRows, nRows);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n        return out;\n    } else {\n        final int nCols = m.getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, 1);\n        for (int i = 0; i < nCols; ++i) {\n            out.setEntry(i, 0, m.getEntry(i, i));\n        }\n        return out;\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) {\n        final int n = m.getColumnDimension();\n        final double[][] d = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            d[i][i] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final int n = m.getRowDimension();\n        final double[][] d = new double[n][1];\n        for (int i = 0; i < n; i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    if (nRows == nCols) {\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, i, m.getEntry(i, i));\n        }\n        return out;\n    } else if (nRows == 1) {\n        final RealMatrix out = createMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            out.setEntry(i, i, m.getEntry(0, i));\n        }\n        return out;\n    } else {\n        throw new IllegalArgumentException(\"m must be a column or n-by-n matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final double[][] d = new double[nRows][nCols];\n    for (int r = 0; r < nRows; r++) {\n        for (int c = 0; c < nCols; c++) {\n            if (r == c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final double[][] d = new double[nRows][nCols];\n    for (int r = 0; r < nRows; r++) {\n        for (int c = 0; c < nCols; c++) {\n            if (r == c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int nRows = m.getRowDimension();\n        final RealMatrix out = createMatrix(nRows, nRows);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n        return out;\n    } else if (m.getRowDimension() == 1) {\n        final int nCols = m.getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; ++i) {\n            out.setEntry(i, i, m.getEntry(0, i));\n        }\n        return out;\n    } else {\n        throw new IllegalArgumentException(\"m must be a column or row matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final double[][] d = new double[nRows][nCols];\n    for (int r = 0; r < nRows; r++) {\n        for (int c = 0; c < nCols; c++) {\n            if (r == c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r == c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    if (nRows == nCols) {\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, i, m.getEntry(i, i));\n        }\n    } else {\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n        {\n            int offset = parseOffset(id);\n            if (offset == 0L) \n            {\n                return UTC;\n            } \n            else \n            {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) \n        {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) \n        {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) \n        {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                convId = printOffset(offset);\n                return fixedOffsetZone(convId, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Parse the offset\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                convId = printOffset(offset);\n                return fixedOffsetZone(convId, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                convId = printOffset(offset);\n                return fixedOffsetZone(convId, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                convId = printOffset(offset);\n                return fixedOffsetZone(convId, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        if (convId != null) {\n            id = convId;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            id = id.substring(3);\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Handle fixed offset zones.\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n\n    // Handle special cases\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    // range check x\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[i] = rh - rl * RADIX;\n    }\n\n    if (result.mant[mant.length-1] == 0) {\n        // normalize\n        result.shiftLeft();\n        final int r = rl * RADIX;        // compute the next digit and put it in\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[0] = rh - rl * RADIX;\n    }\n\n    final int excp = result.round(rl * RADIX);  // do the rounding\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, result, result);\n    }\n\n    return result;\n\n}",
      "private Dfp multiplyFast(final int x)  {\n\n    // range check x\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[i] = rh - rl * RADIX;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    // range check x\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[i] = rh - rl * RADIX;\n    }\n\n    if (result.mant[mant.length-1] == 0) {\n        // normalize\n        result.shiftLeft();\n        final int r = rl * RADIX;        // compute the next digit and put it in\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[0] = rh - rl * RADIX;\n    }\n\n    final int excp = result.round(rl * RADIX);  // do the rounding\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, this, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[0] = rh - rl * RADIX;\n        }\n\n        final int excp = result.round(rl * RADIX);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, this, result);\n        }\n\n        return result;\n\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n    // Handle special cases\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    // range check divisor\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[i] = rh - rl * RADIX;\n    }\n\n    if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    int excp = result.round(rl);\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, result, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n\n    // Handle special cases\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    // range check divisor\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = rh / RADIX;\n        result.mant[i] = rh - rl * RADIX;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[0] = rh - rl * RADIX;\n        }\n\n        final int excp = result.round(rl * RADIX);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, this, result);\n        }\n\n        return result;\n\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkArgument(exportedFunction.isFunction());\n\n    Node function = IR.function(\n        exportedFunction.getFirstChild().cloneNode(),\n        IR.block());\n\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    function.setJSDocInfo(new JSDocInfo());\n\n    Node params = IR.paramList();\n    for (Node param : exportedFunction.getFirstChild().children()) {\n        params.addChildToBack(IR.name(param.getString()));\n    }\n    function.addChildToFront(params);\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node fn = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    fn.setJSType(exportedFunction.getJSType());\n    fn.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return fn;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n      Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n      function.setJSType(exportedFunction.getJSType());\n\n      // This is an indirect way of telling the typed code generator\n      // \"print the type of this\"\n      function.setJSDocInfo(new JSDocInfo());\n\n      for (Node child = exportedFunction.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        if (child.isParamList()) {\n          for (Node param = child.getFirstChild();\n               param != null;\n               param = param.getNext()) {\n            function.addChildToBack(\n                IR.param(\n                    IR.name(param.getString()),\n                    param.getJSType(),\n                    param.getJSDocInfo()));\n          }\n        } else if (child.isBlock()) {\n          // Don't add the block node.\n        } else {\n          function.addChildToBack(child.cloneNode());\n        }\n      }\n\n      return function;\n    }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node fn = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    fn.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    fn.setJSDocInfo(new JSDocInfo());\n\n    // TODO(user): handle function parameters\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n      if (child.isParamList()) {\n        for (Node param = child.getFirstChild();\n             param != null;\n             param = param.getNext()) {\n          fn.addChildToFront(IR.param(param.getString()));\n        }\n      }\n    }\n\n    return fn;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n      if (child.isParamList()) {\n        for (Node grandChild = child.getFirstChild();\n             grandChild != null;\n             grandChild = grandChild.getNext()) {\n          function.addChildToBack(grandChild.cloneTree());\n        }\n      }\n    }\n\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkArgument(exportedFunction.isFunction());\n  Preconditions.checkArgument(exportedFunction.getJSType() != null);\n\n  JSType returnType = exportedFunction.getJSType().getReturnType();\n  JSType functionType = exportedFunction.getJSType();\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(functionType);\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  if (returnType != null) {\n    function.setJSType(returnType);\n  } else {\n    compiler.report(JSError.make(exportedFunction,\n        \"Function to export is missing return type.\"));\n  }\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkArgument(exportedFunction.isFunction());\n    Node fn = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    fn.setJSType(exportedFunction.getJSType());\n    JSDocInfo info = new JSDocInfo();\n    info.setType(new JSTypeExpression(new Node(Token.BANG),\n        exportedFunction.getJSType()));\n    fn.setJSDocInfo(info);\n    return fn;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n      Node fn = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n      fn.setJSType(exportedFunction.getJSType());\n\n      // This is an indirect way of telling the typed code generator\n      // \"print the type of this\"\n      fn.setJSDocInfo(new JSDocInfo());\n\n      Node params = IR.paramList();\n      for (Node child = exportedFunction.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        if (child.isParamList()) {\n          for (Node grandChild = child.getFirstChild();\n               grandChild != null;\n               grandChild = grandChild.getNext()) {\n            params.addChildToBack(\n                IR.name(grandChild.getString()));\n          }\n        }\n      }\n      fn.addChildToBack(params);\n      return fn;\n    }"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params,\n                                               covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final RealMatrix covarianceMatrix = computeCovariances(params,\n                                                                covarianceSingularityThreshold);\n        final double[] std = new double[params.length];\n        for (int i = 0; i < std.length; i++) {\n            std[i] = FastMath.sqrt(covarianceMatrix.getEntry(i, i));\n        }\n        return std;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // compute covariance matrix\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        // compute standard deviation\n        final double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        final int n = covariance.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        int n = covariance.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final RealMatrix covarianceMatrix = computeCovariances(params,\n                                                                covarianceSingularityThreshold);\n        final double[] std = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            std[i] = FastMath.sqrt(covarianceMatrix.getEntry(i, i));\n        }\n        return std;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final RealMatrix covarianceMatrix = computeCovariances(params,\n                                                               covarianceSingularityThreshold);\n        final double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covarianceMatrix.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        final int n = covariance.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final double[][] covariance = computeCovariances(params,\n                                                          covarianceSingularityThreshold);\n        final int n = covariance.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        final double[][] covariance = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        final double[] sigma = new double[covariance.length];\n        for (int i = 0; i < sigma.length; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected for variable \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  throws IllegalArgumentException {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic variable reference: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected for variable \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic variable reference: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Find the transitive closure of the dependencies.\n  Set<INPUT> closure = Sets.newHashSet();\n  Queue<INPUT> queue = Lists.newLinkedList();\n  queue.addAll(roots);\n  while (!queue.isEmpty()) {\n    INPUT input = queue.remove();\n    if (closure.add(input)) {\n      for (INPUT dep : getTypeAlternatives(input.getType())) {\n        queue.add(dep);\n      }\n    }\n  }\n\n  // Return the inputs in the order they were passed in.\n  List<INPUT> result = Lists.newArrayList(closure);\n  if (sorted) {\n    result.sort(new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all symbols provided in these files.\n  for (INPUT input : inputs) {\n    Collection<String> currentProvides = input.getProvides();\n    if (currentProvides.isEmpty()) {\n      noProvides.add(input);\n    }\n\n    for (String provide : currentProvides) {\n      provideMap.put(provide, input);\n    }\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this\n  // as an exercise to the reader.\n  if (sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  if (sorted) {\n    return sortedList;\n  } else {\n    return inputs;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Collect all symbols provided in these files.\n  for (INPUT input : inputs) {\n    Collection<String> currentProvides = input.getProvides();\n    if (currentProvides.isEmpty()) {\n      noProvides.add(input);\n    }\n\n    for (String provide : currentProvides) {\n      provideMap.put(provide, input);\n    }\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this\n  // as an exercise to the reader.\n  if (sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  if (sorted) {\n    return sortedList;\n  } else {\n    return inputs;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // TODO: Implement this method\n  return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return getInputsWithoutProvides();\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Collect all symbols provided in these files.\n  for (INPUT input : inputs) {\n    Collection<String> currentProvides = input.getProvides();\n    if (currentProvides.isEmpty()) {\n      noProvides.add(input);\n    }\n\n    for (String provide : currentProvides) {\n      provideMap.put(provide, input);\n    }\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this\n  // as an exercise to the reader.\n  if (sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  // Return the inputs in the order they were passed in.\n  if (sorted) {\n    return sortedList;\n  } else {\n    return inputs;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all symbols provided in these files.\n  for (INPUT input : inputs) {\n    Collection<String> currentProvides = input.getProvides();\n    if (currentProvides.isEmpty()) {\n      noProvides.add(input);\n    }\n\n    for (String provide : currentProvides) {\n      provideMap.put(provide, input);\n    }\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this\n  // as an exercise to the reader.\n  if (sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  // Return the roots in the correct order.\n  if (sorted) {\n    return sortedList;\n  } else {\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      result.add(root);\n    }\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Create a list of all the inputs.\n    List<INPUT> allInputs = Lists.newArrayList(inputs);\n\n    // Get the direct dependencies.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (String req : input.getRequires()) {\n            INPUT dep = provideMap.get(req);\n            if (dep != null && dep != input) {\n                deps.put(input, dep);\n            }\n        }\n    }\n\n    // Get the sorted list of dependencies.\n    List<INPUT> sortedList = topologicalStableSort(allInputs, deps);\n\n    // Return the sorted list if the caller wants it.\n    if (sorted) {\n        return sortedList;\n    }\n\n    // Otherwise, return the roots and their dependencies.\n    List<INPUT> result = Lists.newArrayList(roots);\n    result.addAll(getDependenciesOf(roots, sortedList, deps));\n    return result;\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    return swapCase(str, true, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    return swapCase(str, true, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    return capitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n          sig += (400 - sig) % 4;\n          leading = false;\n        }\n\n        if (sig == (a.getRadixDigits() / 2) * 4) {\n          sp = i;\n          break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = new Dfp(a.getField(), new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n              sig += (400 - sig) % 4;\n              leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n              sp = i;\n              break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = new Dfp(a.getField(), new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n              sig += (400 - sig) % 4;\n              leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = new Dfp(a.getField(), new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = new Dfp(a.getField(), new String(buf));\n\n        return result;\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n          sig += (400 - sig) % 4;\n          leading = false;\n        }\n\n        if (sig == (a.getRadixDigits() / 2) * 4) {\n          sp = i;\n          break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = new Dfp(a.getField(), new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = new Dfp(a.getField(), new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n    }"
    ],
    [
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null && !id().isEmpty()) {\n        selector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            selector = parent().cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (hasClass()) {\n            for (String clazz : classNames()) {\n                selector += \".\" + clazz;\n            }\n        }\n        selector += \":nth-child(\" + elementSiblingIndex() + \")\";\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0)\n        selector = \"#\" + id();\n    else {\n        if (parent() != null)\n            selector = parent().cssSelector() + \" > \";\n        selector += tagName();\n        if (className().length() > 0)\n            selector += \".\" + className().replace(' ','.');\n        selector += \":nth-child(\" + elementSiblingIndex() + \")\";\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0) {\n        selector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            selector = parent().cssSelector();\n        }\n        if (siblingIndex() == 0) {\n            selector += tagName();\n        } else {\n            selector += tagName() + \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0)\n    {\n        selector = \"#\" + id();\n    }\n    else\n    {\n        Elements parents = parents();\n        if (parents.size() > 0)\n        {\n            selector = parents.get(0).cssSelector() + \" > \";\n        }\n        selector += tagName;\n        if (classNames().size() > 0)\n        {\n            selector += \".\" + StringUtil.join(classNames(), \".\");\n        }\n        selector += \":nth-child(\" + elementSiblingIndex() + \")\";\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0) {\n        selector = \"#\" + id();\n    }\n    else {\n        if (parent() != null) {\n            selector = parent().cssSelector() + \" > \";\n        }\n        selector += tagName;\n        if (className().length() > 0) {\n            selector += \".\" + className().replace(' ', '.');\n        }\n        selector += \":nth-child(\" + elementSiblingIndex() + \")\";\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) {\n        return \"#\" + id();\n    }\n    else {\n        Elements parents = parents();\n        if (parents.size() == 0) {\n            return tagName;\n        }\n        else {\n            Element parent = parents.first();\n            String parentCss = parent.cssSelector();\n            return String.format(\"%s > %s:nth-child(%d)\", parentCss, tagName, elementSiblingIndex());\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else {\n        Element p = parent();\n        if (p == null)\n            return tagName;\n        else {\n            String pcs = p.cssSelector();\n            return (pcs.length() > 0) ? (pcs + \" > \" + uniqueSelector()) : uniqueSelector();\n        }\n    }\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0)\n        selector = \"#\" + id();\n    else if (parent() != null)\n        selector = parent().cssSelector() + \">\" + tagName;\n    else\n        selector = tagName;\n\n    if (classNames().size() > 0)\n        selector += \".\" + String.join(\".\", classNames());\n\n    return selector;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        Elements parents = parent().parents();\n        StringBuilder selector = new StringBuilder();\n        for (int i = 0; i < parents.size(); i++) \n        {\n            Element parent = parents.get(i);\n            String parentSelector = parent.cssSelector();\n            if (parentSelector.length() > 0) \n            {\n                selector.append(parentSelector).append(\" > \");\n            }\n        }\n        selector.append(tagName());\n        if (classNames().size() > 0) \n        {\n            selector.append(\".\").append(String.join(\".\", classNames()));\n        }\n        if (siblingIndex() != 0) \n        {\n            selector.append(\":nth-child(\").append(siblingIndex() + 1).append(\")\");\n        }\n        return selector.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParen()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    if (n.isNot()) {\n        result = 1;\n    } else if (n.isAnd() || n.isOr()) {\n        result = 2;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (c.isNot() || c.isAnd() || c.isOr()) {\n            result += estimateCostOneLevel(c);\n        }\n    }\n    return result;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParen()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    if (n.isNot()) {\n        result++;\n    }\n    if (n.isParen()) {\n        result++;\n    }\n    return result;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.LP:\n        cost = 1;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 2;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost++;\n            break;\n        case Token.PAREN:\n            cost++;\n            break;\n        case Token.AND:\n        case Token.OR:\n            cost += 2;\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n            cost += 2;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost++;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost += 2;\n        break;\n      case Token.HOOK:\n        cost += 3;\n        break;\n      case Token.PARAM_LIST:\n        cost += 1;\n        break;\n      case Token.COMMA:\n        cost += 2;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParen()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost = 1;\n    }\n    if (n.isParen()) {\n        cost = 1;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        result = 1;\n        break;\n      case Token.PAREN:\n        result = 2;\n        break;\n      case Token.AND:\n      case Token.OR:\n        result = 3;\n        break;\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) {\n        int j = size - i - 1;\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) \n    {\n        int j = size - i - 1;\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final char[] buf = buffer;\n    for (int i = 0, j = size - 1; j > i; i++, j--) {\n        final char temp = buf[i];\n        buf[i] = buf[j];\n        buf[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    int len = size;\n    final char[] buf = buffer;\n    for (int i = 0, mid = len / 2, j = len - 1; i < mid; i++, j--) \n    {\n        char ch = buf[i];\n        buf[i] = buf[j];\n        buf[j] = ch;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final int half = size / 2;\n    for (int left = 0, right = size - 1; left < half; left++, right--) {\n        final char swap = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left] = rightChar;\n        buffer[right] = leftChar;\n        left++;\n        right--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode newText = new TextNode(tail, getBaseUri());\n    setText(head);\n    return newText;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode headText = new TextNode(head);\n    TextNode tailText = new TextNode(tail);\n    this.replaceWith(headText);\n    headText.after(tailText);\n    return tailText;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n        String head = getWholeText().substring(0, offset);\n        String tail = getWholeText().substring(offset);\n        TextNode headText = new TextNode(head);\n        TextNode tailText = new TextNode(tail);\n        this.replaceWith(headText);\n        headText.getParentNode().appendChild(tailText);\n        return tailText;\n    }",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > getWholeText().length()) {\n        throw new IllegalArgumentException(\"offset must be between 0 and \" + getWholeText().length());\n    }\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n    this.replaceWith(headNode);\n    headNode.getParentNode().insertBefore(tailNode, headNode.getNextSibling());\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > getWholeText().length()) {\n        throw new IllegalArgumentException(\"Split offset must be not be negative and not larger than current text length\");\n    }\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headText = new TextNode(head);\n    TextNode tailText = new TextNode(tail);\n\n    this.replaceWith(headText);\n    headText.after(tailText);\n\n    return tailText;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n        String head = getWholeText().substring(0, offset);\n        String tail = getWholeText().substring(offset);\n        TextNode headText = new TextNode(head);\n        TextNode tailText = new TextNode(tail);\n        replaceWith(headText);\n        headText.getParentNode().addSibling(tailText);\n        return tailText;\n    }",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode newTail = new TextNode(tail, getBaseUri());\n    TextNode newHead = new TextNode(head, getBaseUri());\n    replaceWith(newHead);\n    newHead.setNextSibling(newTail);\n    return newTail;\n}",
      "public TextNode splitText(int offset)  {\n    // check if offset is valid\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    // create new text node with remainder of text\n    TextNode newTextNode = new TextNode(getWholeText().substring(offset));\n\n    // update this text node to have remaining text\n    text = getWholeText().substring(0, offset);\n\n    // return the new text node\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n        String head = getWholeText().substring(0, offset);\n        String tail = getWholeText().substring(offset);\n        TextNode headText = new TextNode(head);\n        TextNode tailText = new TextNode(tail);\n        this.replaceWith(headText);\n        headText.after(tailText);\n        return tailText;\n    }",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    if (offset == 0)\n        return this;\n    else if (offset == getWholeText().length())\n        return null;\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode headText = new TextNode(head);\n    TextNode tailText = new TextNode(tail);\n    replaceWith(headText);\n    headText.setNextSibling(tailText);\n    return tailText;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[DWORD];\n        putLong(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int start = bytes.length > 8 ? bytes.length - 8 : 0;\n    int end = bytes.length > 8 ? 8 : bytes.length;\n    for (int i = start; i < end; i++) {\n        result[i] = bytes[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value.longValue(), 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[DWORD];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[DWORD];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        putLong(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n    int length = temp.length;\n    if (length > 8) {\n        length = 8;\n    }\n    int start = temp.length - length;\n    for (int i = 0; i < length; i++) {\n        result[i] = temp[start + i];\n    }\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return new CholeskyDecomposition(this).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final EigenDecomposition ed = new EigenDecomposition(this);\n    final RealMatrix squareRoot = MatrixUtils.createRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < getRowDimension(); i++) {\n        final double eigenvalue = ed.getRealEigenvalue(i);\n        if (eigenvalue < 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n        final RealVector eigenVector = ed.getEigenvector(i);\n        final double eigenVectorNorm = eigenVector.getNorm();\n        final RealVector unitEigenVector = eigenVector.mapDivide(eigenVectorNorm);\n        squareRoot.setColumnVector(i, unitEigenVector.mapMultiply(FastMath.sqrt(eigenvalue)));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Compute the eigen decomposition of the matrix\n    EigenDecomposition eigen = new EigenDecomposition(this);\n\n    // Compute the square-root of the eigenvalues\n    double[] sqrtEigenvalues = new double[eigen.getRealEigenvalues().length];\n    for (int i = 0; i < sqrtEigenvalues.length; i++) {\n        sqrtEigenvalues[i] = FastMath.sqrt(eigen.getRealEigenvalues()[i]);\n    }\n\n    // Compute the square-root of the matrix\n    return eigen.getV().multiply(new Array2DRowRealMatrix(sqrtEigenvalues, sqrtEigenvalues.length).multiply(eigen.getV().transpose()));\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    EigenDecomposition eigen = new EigenDecomposition(this);\n    return eigen.getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n\n    // check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n\n    // check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    // compute the Cholesky decomposition of the matrix\n    RealMatrix l = new CholeskyDecomposition(this).getL();\n\n    // compute the matrix square root\n    RealMatrix sqrt = l.multiply(l.transpose());\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    EigenDecomposition ed = new EigenDecomposition(this);\n    return MatrixUtils.createRealMatrix(ed.getSquareRoot());\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix squareRoot = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < getRowDimension(); i++) {\n        squareRoot.setEntry(i, i, FastMath.sqrt(getEntry(i, i)));\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n\n    // Check if the matrix is symmetric and positive definite.\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Compute the Cholesky decomposition of the matrix.\n    RealMatrix cholesky = new CholeskyDecomposition(this).getL();\n\n    // Compute the square-root of the Cholesky decomposition.\n    RealMatrix squareRoot = new RealMatrix(cholesky.getRowDimension(), cholesky.getColumnDimension());\n    for (int i = 0; i < cholesky.getRowDimension(); i++) {\n        for (int j = 0; j < cholesky.getColumnDimension(); j++) {\n            squareRoot.setEntry(i, j, FastMath.sqrt(cholesky.getEntry(i, j)));\n        }\n    }\n\n    // Return the square-root of the matrix.\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return MatrixUtils.createRealMatrix(eigenDecomposition().getSquareRoot());\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    // use Cholesky decomposition to get the square root of the matrix\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n    return cholesky.getSquareRoot();\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case ID_START_OBJECT:\n            return mapObject(p, ctxt);\n        case ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case ID_START_ARRAY:\n            return mapArray(p, ctxt);\n        case ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case ID_STRING:\n            return p.getText();\n        case ID_NUMBER_INT:\n            return p.getNumberValue(); // should be optimal, whatever it is\n        case ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getNumberValue();\n        case ID_END_ARRAY:\n            return null;\n        case ID_END_OBJECT:\n            return null;\n        }\n        throw ctxt.mappingException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            return mapArray(p, ctxt);\n        case END_ARRAY:\n            return deserialize(p, ctxt);\n        case FIELD_NAME:\n            return mapObject(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case END_OBJECT:\n            return deserialize(p, ctxt);\n        case NOT_AVAILABLE: // should only get this for START_OBJECT\n            return deserialize(p, ctxt);\n        default:\n        }\n        return deserialize(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case ID_START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case ID_START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case ID_FIELD_NAME:\n            return deserializeFromObjectUsingFieldName(p, ctxt);\n        case ID_STRING:\n            return deserializeFromString(p, ctxt);\n        case ID_NUMBER_INT:\n            return deserializeFromNumber(p, ctxt);\n        case ID_NUMBER_FLOAT:\n            return deserializeFromDouble(p, ctxt);\n        case ID_EMBEDDED_OBJECT:\n            return deserializeFromEmbedded(p, ctxt);\n        case ID_END_OBJECT:\n        case ID_END_ARRAY:\n        case ID_END_INPUT:\n            throw ctxt.mappingException(\"Unexpected end-of-input when binding data into \" + baseTypeName());\n        case ID_NULL:\n            return deserializeFromNull(p, ctxt);\n        case ID_TRUE:\n            return deserializeFromBoolean(p, ctxt, true);\n        case ID_FALSE:\n            return deserializeFromBoolean(p, ctxt, false);\n        default:\n            throw ctxt.mappingException(\"Unexpected token (\"+t+\") when binding data into \" + baseTypeName());\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getNumberValue();\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getNumberValue();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return mapArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return mapObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return p.getEmbeddedObject();\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return null;\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return null;\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            return null;\n        }\n        if (t == JsonToken.NOT_AVAILABLE) {\n            return null;\n        }\n        return null;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getNumberValue();\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText().trim();\n            if (text.length() == 0) {\n                return _coerceEmptyString(ctxt, _primitive);\n            }\n            if (_hasTextualNull(text)) {\n                return _coerceTextualNull(ctxt, _primitive);\n            }\n            _verifyStringForScalarCoercion(ctxt, text);\n            try {\n                return _parse(ctxt, text);\n            } catch (IllegalArgumentException iae) {\n                return ctxt.handleWeirdStringValue(_valueClass, text,\n                        \"not a valid %s value\", _typeDesc);\n            }\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _coerceNullToken(ctxt, _primitive);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return p.getEmbeddedObject();\n        }\n        return ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\tif (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n    \t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\treturn deserializeFromNumber(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_STRING) {\n    \t\treturn deserializeFromString(p, ctxt);\n    \t}\n    \tif (t == JsonToken.START_ARRAY) {\n    \t\tif (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\treturn deserializeFromArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.START_OBJECT) {\n    \t\treturn deserializeFromObject(p, ctxt);\n    \t}\n    \treturn deserializeFromOther(p, ctxt, t);\n    \t}\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromNumber(p, ctxt);\n            }\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromString(p, ctxt);\n            }\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromDouble(p, ctxt);\n            }\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromBoolean(p, ctxt);\n            }\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromBoolean(p, ctxt);\n            }\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return deserializeFromNull(p, ctxt);\n            }\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tswitch (t.id()) {\n    \tcase ID_START_OBJECT:\n    \t\treturn mapObject(p, ctxt);\n    \tcase ID_FIELD_NAME:\n    \t\treturn mapObject(p, ctxt);\n    \tcase ID_START_ARRAY:\n    \t\treturn mapArray(p, ctxt);\n    \tcase ID_END_ARRAY:\n    \t\treturn mapArray(p, ctxt);\n    \tcase ID_EMBEDDED_OBJECT:\n    \t\treturn p.getEmbeddedObject();\n    \tcase ID_STRING:\n    \t\treturn p.getText();\n    \tcase ID_NUMBER_INT:\n    \t\treturn p.getNumberValue(); // should be optimal, whatever it is\n    \tcase ID_NUMBER_FLOAT:\n    \t\treturn p.getNumberValue();\n    \tdefault:\n    \t}\n    \treturn null;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************\n     */",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tswitch (t) {\n    \tcase START_OBJECT:\n    \t\treturn deserializeFromObject(p, ctxt);\n    \tcase START_ARRAY:\n    \t\treturn deserializeFromArray(p, ctxt);\n    \tcase END_ARRAY:\n    \tcase END_OBJECT:\n    \tcase FIELD_NAME:\n    \tcase NOT_AVAILABLE:\n    \t\treturn deserializeFromEmpty(p, ctxt);\n    \tcase VALUE_EMBEDDED_OBJECT:\n    \t\treturn p.getEmbeddedObject();\n    \tcase VALUE_STRING:\n    \t\treturn p.getText();\n    \tcase VALUE_NUMBER_INT:\n    \t\treturn p.getNumberValue();\n    \tcase VALUE_NUMBER_FLOAT:\n    \t\tif (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n    \t\t\treturn p.getDecimalValue();\n    \t\t}\n    \t\treturn p.getNumberValue();\n    \tcase VALUE_TRUE:\n    \tcase VALUE_FALSE:\n    \t\treturn p.getBooleanValue();\n    \tcase VALUE_NULL:\n    \t\treturn null;\n    \tdefault:\n    \t}\n    \tthrow ctxt.mappingException(handledType());\n    \t}\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t.id()) {\n        case ID_START_OBJECT:\n            return mapObject(p, ctxt);\n        case ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case ID_START_ARRAY:\n            return mapArray(p, ctxt);\n        case ID_END_ARRAY:\n            return null;\n        case ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case ID_STRING:\n            return p.getText();\n        case ID_NUMBER_INT:\n            return p.getNumberValue(); // should be optimal, whatever it is\n        case ID_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        case ID_NULL:\n            return null;\n        case ID_END_OBJECT:\n            return null;\n        }\n        return null;\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 1) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 1) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    double sum = 0;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int offset = fullChunk.length;\n         Object[] result = new Object[offset];\n         System.arraycopy(fullChunk, 0, result, 0, offset);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int offset = fullChunk.length;\n         int newSize = offset + offset;\n         if (newSize < MIN_COPY_ARRAY_SIZE) {\n             newSize = MIN_COPY_ARRAY_SIZE;\n         }\n         Object[] result = new Object[newSize];\n         System.arraycopy(fullChunk, 0, result, 0, offset);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int len = fullChunk.length;\n         int offset = _bufferedLen;\n         int newSize = offset + len;\n         if (newSize > _data.length) {\n             // Let's grow buffer then\n             int newLen = Math.max(newSize, _data.length + (newSize >> 1));\n             _data = Arrays.copyOf(_data, newLen);\n         }\n         System.arraycopy(fullChunk, 0, _data, offset, len);\n         _bufferedLen = newSize;\n         return _data;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's find out how many elements we have\n         int len = 0;\n         for (int i = 0, end = fullChunk.length; i < end; ++i) {\n             if (fullChunk[i] != null) {\n                 ++len;\n             }\n         }\n         // And then we'll need to expand buffer to hold that many\n         int offset = _size;\n         _size += len;\n         if (_buffer == null) {\n             _buffer = new Object[Math.max(64, _size)];\n         } else if (_size > _buffer.length) {\n             _buffer = Arrays.copyOf(_buffer, Math.max(_buffer.length << 1, _size));\n         }\n         // And finally, let's copy stuff over\n         int ptr = offset;\n         for (int i = 0, end = fullChunk.length; i < end; ++i) {\n             Object value = fullChunk[i];\n             if (value != null) {\n                 _buffer[ptr++] = value;\n             }\n         }\n         return _buffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // First, let's append the full chunk:\n         int offset = _bufferedLen;\n         int length = fullChunk.length;\n         if (offset + length > _data.length) {\n             // Need to grow buffer\n             int newSize = Math.max(offset + length, _data.length + (offset >> 1));\n             Object[] newData = new Object[newSize];\n             System.arraycopy(_data, 0, newData, 0, offset);\n             _data = newData;\n         }\n         System.arraycopy(fullChunk, 0, _data, offset, length);\n         _bufferedLen = offset + length;\n         // and then return a new buffer\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     "
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    parsePatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    parsePatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.UNION) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.RECORD) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.ARRAY) {\n    return parseArrayType(token);\n  } else {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.unexpected.token\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case STRING:\n      return parseTypeName(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case LC:\n      return parseUnionType(token);\n    case LB:\n      return parseArrayType(token);\n    case LBRACE:\n      return parseRecordType(token);\n    default:\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case STAR:\n            return newNode(Token.STAR);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case STRING:\n            return parseTypeName(token);\n        case FUNCTION:\n            return parseFunctionType(token);\n        case LC:\n            return parseUnionType(token);\n        case LB:\n            return parseArrayType(token);\n        case LBRACE:\n            return parseRecordType(token);\n        default:\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseRecordType(token);\n    case LB:\n      return parseArrayType(token);\n    case LPAREN:\n      return parseFunctionType(token);\n    case LT:\n      return parseUnionType(token);\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n        case STAR:\n            return newNode(Token.STAR);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case STRING:\n            return parseTypeName(token);\n        case FUNCTION:\n            return parseFunctionType(token);\n        case LC:\n            return parseUnionType(token);\n        case LB:\n            return parseArrayType(token);\n        default:\n            return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseRecordType(token);\n    case LS:\n      return parseArrayType(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case UNION:\n      return parseUnionType(token);\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n        case STAR:\n            return newNode(Token.STAR);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case LT:\n            return parseUnionType(next());\n        case LC:\n            return parseRecordType(next());\n        case LB:\n            return parseArrayType(next());\n        case FUNCTION:\n            return parseFunctionType(next());\n        case STRING:\n            return parseTypeName(token);\n        default:\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case STRING:\n      return parseTypeName(token);\n    case LC:\n      return parseFunctionType(token);\n    case LS:\n      return parseUnionType(token);\n    case LB:\n      return parseRecordType(token);\n    case LBRACKET:\n      return parseArrayType(token);\n    default:\n      return reportTypeSyntaxWarning(\"msg.jsdoc.unexpected.token\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / delimLen + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                lastWasGap = true;\n                break;\n            }\n        }\n        if (lastWasGap) {\n            if (ch >= 'A' && ch <= 'Z') {\n                buf[count++] = ch;\n                lastWasGap = false;\n            } else if (ch >= 'a' && ch <= 'z') {\n                buf[count++] = (char) (ch - 32);\n                lastWasGap = false;\n            }\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buf = new char[strLen / delimLen + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    final List<E> setOrder = new ArrayList<E>(list);\n    setOrder.retainAll(set);\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    final List<E> setOrder = new ArrayList<E>(set);\n    return new ListOrderedSet<E>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) {\n                if (result == null) {\n                    result = more;\n                }\n                else {\n                    result = result.add(more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = result.add(more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) {\n                if (result == null) {\n                    result = more;\n                }\n                else {\n                    result.add(more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) {\n                if (result == null) {\n                    result = more;\n                }\n                else {\n                    result = result.add(more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (more != null) \n            {\n                if (result == null) \n                {\n                    result = more;\n                } \n                else \n                {\n                    result = result.add(more);\n                }\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (val / 9.0);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0;\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0;\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - (10.0 - val);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0; //invert adjustPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0;\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (10.0 * (1.0 - val));\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    if (entry == null) {\n      return false;\n    }\n    return cfg.getImplicitReturn().getInEdges().size() == 1;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Computes the control flow graph.\n  ControlFlowAnalysis cfa =\n      new ControlFlowAnalysis(compiler, false, false);\n  cfa.process(null, root);\n  ControlFlowGraph<Node> cfg = cfa.getCfg();\n  new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n      .compute(cfg.getEntry().getValue());\n  if (root.isFunction()) {\n    root = root.getLastChild();\n  }\n  do {\n    codeChanged = false;\n    NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n  } while (codeChanged);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  return new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n      cfg,\n      cfg.getEntry(),\n      cfg.getImplicitReturn(),\n      IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE)\n      .allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): Implement this.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(cfg.getEntry().getParent()) &&\n        cfg.getEntry().getNext() != cfg.getImplicitReturn()) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(cfg.getEntry()),\n                 cfg.getDirectedGraphNode(cfg.getImplicitReturn()),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg,\n            cfg.getEntry(),\n            cfg.getImplicitReturn(),\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n    return test.allPathsSatisfyPredicate();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO(user): Implement this.\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n      new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n          cfg,\n          cfg.getEntry(),\n          cfg.getImplicitReturn(),\n          IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n  return test.allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n        cfg,\n        cfg.getEntry(),\n        cfg.getImplicitReturn(),\n        IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE).allPathsSatisfyPredicate();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the entry node has no successors, then all paths return.\n  if (cfg.getEntry().getSuccessors().isEmpty()) {\n    return true;\n  }\n\n  // If the entry node has a successor that is the implicit return, then all\n  // paths return.\n  if (cfg.getEntry().getSuccessors().contains(cfg.getImplicitReturn())) {\n    return true;\n  }\n\n  // If the entry node has a successor that is a function, then all paths return.\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n      cfg.getEntry().getSuccessors()) {\n    if (edge.getDestination().getValue().isFunction()) {\n      return true;\n    }\n  }\n\n  // Otherwise, there is no guarantee that all paths return.\n  return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp z = x.divide(y);\n\n        Dfp[] r = new Dfp[2];\n        r[0] = z;\n        r[1] = z;\n\n        return r;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp c = x.divide(y);\n        Dfp r = c;\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(y);\n            x = x.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return new Dfp[] { x, y };\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(y);\n            x = x.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return new Dfp[] { y, x };\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] y = new Dfp[2];\n        Dfp[] x = new Dfp[2];\n        Dfp[] py = new Dfp[2];\n\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[1];\n        resplit(x);\n\n        y[0] = a[0].add(a[1]);\n        y[1] = a[1];\n\n        for (int i = 3; i < 90; i += 2) {\n            x[0] = x[0].multiply(y[0]);\n            x[1] = x[1].multiply(y[0]);\n            x[0] = x[0].negate();\n            y[0] = y[0].add(x[0].divide(i));\n            if (y[0].equals(py[0])) {\n                break;\n            }\n            py[0] = new Dfp(y[0]);\n        }\n\n        y[0] = y[0].multiply(a[0].getTwo());\n        y[1] = y[1].multiply(a[0].getTwo());\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(y);\n            x = x.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return new Dfp[] { y, y };\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(y);\n            x = x.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return new Dfp[] { x, y };\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp c = x.divide(y);\n        Dfp z = y.divide(x);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.multiply(z);\n            fact = fact.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return new Dfp[] {y, y.multiply(a[0].getTwo())};\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n        Dfp c = y.divide(x);\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] r = new Dfp[2];\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n\n        Dfp fact = a[0].getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(y);\n            x = x.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        r[0] = y;\n        r[1] = y;\n\n        return r;\n    }"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        boolean result = false;\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            result = coll.remove(value);\n            if (coll.isEmpty()) {\n                decorated().remove(key);\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            result = coll.remove(value);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = justTransform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING_KEY);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = justTransform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setType(Token.STRING_KEY);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING_KEY);\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(dataset.getRowKey(r), category);\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    // create a new list...\n    List result = new ArrayList();\n    // calculate the total for the current item...\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    // calculate the positive and negative bases...\n    double posBase = base;\n    double negBase = base;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            posBase = posBase + v;\n            result.add(new Double(posBase));\n        }\n        else if (v < 0.0) {\n            negBase = negBase + v;\n            result.add(0, new Double(negBase));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(dataset.getRowKey(r), category);\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    // create the list...\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node: childNodes) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Element> childElements = new ArrayList<>();\n            for (Node child: childNodes) {\n                if (child instanceof Element)\n                    childElements.add((Element) child);\n            }\n            shadowChildrenRef = childElements;\n        }\n        return shadowChildrenRef;\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Element> childElements = new ArrayList<>();\n            for (Node child: childNodes) {\n                if (child instanceof Element)\n                    childElements.add((Element) child);\n            }\n            shadowChildrenRef = childElements;\n        }\n        return shadowChildrenRef;\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                children.add((Element) child);\n            }\n        }\n        shadowChildrenRef = children;\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node child : childNodes) {\n                if (child instanceof Element) {\n                    elements.add((Element) child);\n                }\n            }\n            shadowChildrenRef = elements;\n        }\n        return shadowChildrenRef;\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node child : childNodes)\n        {\n            if (child instanceof Element)\n            {\n                shadowChildrenRef.add((Element) child);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            shadowChildrenRef = new ArrayList<>();\n            for (Node child : childNodes) {\n                if (child instanceof Element)\n                    shadowChildrenRef.add((Element) child);\n            }\n        }\n        return shadowChildrenRef;\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node child: childNodes)\n        {\n            if (child instanceof Element)\n            {\n                shadowChildrenRef.add((Element) child);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            shadowChildrenRef = new ArrayList<>();\n            for (Element child: childElements())\n                shadowChildrenRef.add(child);\n        }\n        return shadowChildrenRef;\n    }",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = new ArrayList<Element>();\n    for (Node node : childNodes) {\n        if (node instanceof Element) {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return hash % decorated().data.length;\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return hash & (data.length - 1);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % this.buckets.length);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return hash & (data.length - 1);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  hash >>> 14;\n    hash +=  hash << 4;\n    hash ^=  hash >>> 10;\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash % data.length;\n}",
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    h += ~(h << 9);\n    h ^=  h >>> 14;\n    h +=  h << 4;\n    h ^=  h >>> 10;\n    return h;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  hash >>> 14;\n    hash +=  hash << 4;\n    hash ^=  hash >>> 10;\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  hash >>> 14;\n    hash +=  hash << 4;\n    hash ^=  hash >>> 10;\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return hash & (data.length - 1);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r > c + k) {\n                    d[r][c] = 0;\n                } else {\n                    d[r][c] = m.getEntry(r, c);\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rowCount    = m.getRowDimension();\n    final int columnCount = m.getColumnDimension();\n    final RealMatrix out = createMatrix(rowCount, columnCount);\n    for (int row = 0; row < rowCount; ++row) {\n        for (int col = 0; col < columnCount; ++col) {\n            if (row + k >= col) {\n                out.setEntry(row, col, m.getEntry(row, col));\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r + k <= c) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r + k <= c) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r > c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r + k <= c) {\n                    d[r][c] = m.getEntry(r, c);\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c > k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r + k < c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n        }\n    }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        if (left.skew == Skew.LEFT_HIGH) {\n            rotateCW();\n            skew       = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        } else {\n            final Skew s = left.right.skew;\n            left.rotateCCW();\n            rotateCW();\n            switch(s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return false;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n        }\n    }",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // find the first small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * epsilon) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // find the first small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * epsilon) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) < norm * EPS) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1) {\n        if (FastMath.abs(matrixT[idx][idx]) <= norm * epsilon) {\n            return idx;\n        }\n        idx++;\n    }\n    return matrixT.length - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length && FastMath.abs(matrixT[idx][idx]) > SMALL_SUB_DIAGONAL_ELEMENT_FACTOR * norm) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // find the first small sub-diagonal element\n    int idx = startIdx;\n    while (idx < matrixT.length && FastMath.abs(matrixT[idx][idx]) >= norm * EPS) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * epsilon) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * epsilon) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * epsilon) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n      JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n      if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n      JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n      if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n      JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n      if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n      JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n      if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return SetUniqueList.setUniqueList(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return SetUniqueList.setUniqueList(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return SetUniqueList.setUniqueList(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return SetUniqueList.setUniqueList(new HashSet<E>(list), list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    if (token == JsDocToken.RC) {\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpression));\n  } else {\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(typeExpression);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return arrayType;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n\n    while (true) {\n      if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        if (token == JsDocToken.RC) {\n          return wrapNode(Token.ELLIPSIS, IR.empty());\n        }\n\n        Node typeExpression = parseTypeExpression(token);\n        if (typeExpression == null) {\n          return null;\n        }\n\n        arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpression));\n      } else {\n        Node typeExpression = parseTypeExpression(token);\n        if (typeExpression == null) {\n          return null;\n        }\n\n        arrayType.addChildToBack(typeExpression);\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    }\n  }\n\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      skipEOLs();\n      Node typeExpression = parseTypeExpression(next());\n      if (typeExpression == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpression));\n    } else {\n      Node typeExpression = parseTypeExpression(token);\n      if (typeExpression == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(typeExpression);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) {\n    restoreLookAhead(token);\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n\n  Node arrayType = newNode(Token.LB);\n  skipEOLs();\n  if (match(JsDocToken.RB)) {\n    next();\n    return arrayType;\n  }\n\n  Node elementTypeList = parseElementTypeList(next());\n  if (elementTypeList == null) {\n    return null;\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  if (token == JsDocToken.RB) {\n    return arrayType;\n  }\n\n  boolean restArg = false;\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    restArg = true;\n  }\n\n  Node elementType = parseTypeExpression(token);\n  if (elementType == null) {\n    return null;\n  }\n\n  arrayType.addChildToBack(elementType);\n\n  skipEOLs();\n  if (match(JsDocToken.COMMA)) {\n    next();\n    skipEOLs();\n    token = next();\n  } else {\n    if (restArg) {\n      arrayType = wrapNode(Token.ELLIPSIS, arrayType);\n    }\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }\n\n  if (restArg) {\n    arrayType = wrapNode(Token.ELLIPSIS, arrayType);\n  }\n  arrayType.addChildToBack(parseElementTypeList(token));\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) {\n    restoreLookAhead(token);\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n\n  Node arrayType = newNode(Token.LB);\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    token = next();\n\n    boolean restArg = false;\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RB) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, IR.empty());\n      }\n      restArg = true;\n    }\n\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (restArg) {\n      arrayType = wrapNode(Token.ELLIPSIS, arrayType);\n    } else if (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      arrayType.addChildToBack(parseElementTypeList(next()));\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n  }\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  do {\n    if (token == JsDocToken.ELLIPSIS) {\n      next();\n      skipEOLs();\n      Node typeExpression = parseTypeExpression(next());\n      if (typeExpression == null) {\n        return null;\n      }\n      arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpression));\n    } else {\n      Node typeExpression = parseTypeExpression(token);\n      if (typeExpression == null) {\n        return null;\n      }\n      arrayType.addChildToBack(typeExpression);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n    next();\n    skipEOLs();\n    token = next();\n  } while (true);\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    Node elementType = null;\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      elementType = wrapNode(Token.ELLIPSIS, parseTypeExpression(token));\n    } else {\n      elementType = parseTypeExpression(token);\n    }\n\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token == JsDocToken.RC) {\n    next();\n    return arrayType;\n  }\n\n  do {\n    if (token == JsDocToken.ELLIPSIS) {\n      next();\n      skipEOLs();\n      Node typeExpression = parseTypeExpression(next());\n      if (typeExpression == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpression));\n    } else {\n      Node typeExpression = parseTypeExpression(token);\n      if (typeExpression == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(typeExpression);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RC)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n  }\n\n  next();\n\n  arrayType.addChildToBack(arrayType);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    if (token == JsDocToken.RC) {\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression == null) {\n      return null;\n    }\n    return wrapNode(Token.ELLIPSIS, typeExpression);\n  }\n\n  Node typeExpression = parseTypeExpression(token);\n  if (typeExpression == null) {\n    return null;\n  }\n\n  arrayType.addChildToBack(typeExpression);\n\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return arrayType;\n  }\n\n  // Move to the comma token.\n  next();\n\n  // Move to the token passed the comma.\n  skipEOLs();\n  token = next();\n\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    if (token == JsDocToken.RC) {\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression == null) {\n      return null;\n    }\n    return wrapNode(Token.ELLIPSIS, typeExpression);\n  }\n\n  do {\n    typeExpression = parseTypeExpression(token);\n    if (typeExpression == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(typeExpression);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n  double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  if (norm == 0) {\n    return new Vector3D(1, 0, 0);\n  } else {\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }\n}",
      "public Vector3D getAxis()  {\n  double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  if (norm == 0) {\n    return Vector3D.PLUS_I;\n  } else {\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }\n}",
      "public Vector3D getAxis()  {\n    // compute the axis\n    double coeff = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (coeff < Precision.SAFE_MIN) {\n        return Vector3D.PLUS_I;\n    } else {\n        return new Vector3D(q1 / coeff, q2 / coeff, q3 / coeff);\n    }\n}",
      "public Vector3D getAxis()  {\n  return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    double n = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (n < Precision.SAFE_MIN) {\n        return Vector3D.PLUS_I;\n    }\n    return new Vector3D(q1 / n, q2 / n, q3 / n);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      return new Vector3D(1, 0, 0);\n    } else {\n      return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n  }",
      "public Vector3D getAxis()  {\n  // return the normalized axis of the rotation\n  return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n  }",
      "public Vector3D getAxis()  {\n  double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 * inv, q2 * inv, q3 * inv);\n}",
      "public Vector3D getAxis()  {\n    double n = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (n == 0) {\n      return Vector3D.PLUS_I;\n    } else {\n      return new Vector3D(q1 / n, q2 / n, q3 / n);\n    }\n  }"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding\", e);\n                }\n            } else if (b != PLUS) {\n                buffer.write(b);\n            } else {\n                buffer.write(SPACE);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        int b = bytes[i];\n        if (b < 0) \n        {\n            b = 256 + b;\n        }\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationField lastUnitField = null;\n    DurationField lastRangeField = null;\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType loopType = partial.getFieldType(i);\n        DurationField loopUnitField = loopType.getDurationType().getField(partial.getChronology());\n        DurationField loopRangeField = loopUnitField.getRangeDurationField();\n        if (i > 0) {\n            if (loopUnitField.isSupported() == false) {\n                if (lastUnitField.isSupported()) {\n                    return false;\n                }\n            } else if (lastRangeField.equals(loopUnitField) == false) {\n                return false;\n            }\n        }\n        lastUnitField = loopUnitField;\n        lastRangeField = loopRangeField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DurationField lastUnitField = null;\n    for (int i = 0; i < partial.size(); i++) {\n        DurationField unitField = partial.getFieldType(i).getDurationType().getField(partial.getChronology());\n        if (i > 0) {\n            if (unitField.isSupported() == false) {\n                if (lastUnitField.isSupported()) {\n                    return false;\n                }\n            } else {\n                if (lastUnitField.getUnitMillis() != unitField.getUnitMillis()) {\n                    return false;\n                }\n            }\n        }\n        lastUnitField = unitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationFieldType lastType = partial.getFieldType(size - 1);\n    DurationFieldType thisType = partial.getFieldType(size - 2);\n    DurationFieldType nextType = partial.getFieldType(size - 3);\n    DurationField lastUnitField = lastType.getDurationType().getField(partial.getChronology());\n    DurationField thisUnitField = thisType.getDurationType().getField(partial.getChronology());\n    DurationField nextUnitField = nextType.getDurationType().getField(partial.getChronology());\n    return lastUnitField.equals(thisUnitField) && thisUnitField.equals(nextUnitField);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(0);\n    DurationField lastUnitField = lastType.getDurationType().getField(partial.getChronology());\n    for (int i = 1; i < partial.size(); i++) {\n        DateTimeFieldType loopType = partial.getFieldType(i);\n        DurationField loopUnitField = loopType.getDurationType().getField(partial.getChronology());\n        if (loopUnitField.isSupported() == false) {\n            return false;\n        }\n        if (lastUnitField.equals(loopUnitField) == false) {\n            return false;\n        }\n        lastType = loopType;\n        lastUnitField = loopUnitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationField lastUnitField = null;\n    DurationField unitField = null;\n    for (int i = 0; i < size; i++) {\n        unitField = partial.getFieldType(i).getDurationType().getField(partial.getChronology());\n        if (i > 0) {\n            if (unitField.isSupported() == false) {\n                if (lastUnitField.isSupported()) {\n                    return false;\n                }\n            } else {\n                if (lastUnitField.getRangeDurationField().equals(unitField) == false) {\n                    return false;\n                }\n            }\n        }\n        lastUnitField = unitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    DurationField lastUnitField = lastType.getDurationType().getField(partial.getChronology());\n    for (int i = size - 2; i >= 0; i--) {\n        DateTimeFieldType loopType = partial.getFieldType(i);\n        DurationField loopUnitField = loopType.getDurationType().getField(partial.getChronology());\n        if (loopUnitField.isSupported() == false) {\n            return false;\n        }\n        if (loopUnitField.getUnitMillis() != lastUnitField.getUnitMillis()) {\n            return false;\n        }\n        lastType = loopType;\n        lastUnitField = loopUnitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationField lastUnitField = null;\n    DurationField lastRangeField = null;\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType loopType = partial.getFieldType(i);\n        DurationField loopUnitField = loopType.getDurationType().getField(partial.getChronology());\n        DurationField loopRangeField = loopUnitField.getRangeDurationField();\n        if (i > 0) {\n            if (loopUnitField.isSupported() == false) {\n                if (lastUnitField.isSupported()) {\n                    return false;\n                }\n            } else if (lastRangeField.equals(loopUnitField) == false) {\n                return false;\n            }\n        }\n        lastUnitField = loopUnitField;\n        lastRangeField = loopRangeField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DurationField lastUnitField = null;\n    DurationField lastRangeField = null;\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType type = partial.getFieldType(i);\n        DurationField unitField = type.getDurationType().getField(partial.getChronology());\n        if (i > 0) {\n            if (unitField.isSupported() == false) {\n                return false;\n            }\n            if (lastUnitField.isSupported() == false) {\n                return false;\n            }\n            DurationField rangeField = lastUnitField.getRangeDurationField();\n            if (rangeField == null) {\n                return false;\n            }\n            if (lastRangeField == null) {\n                lastRangeField = rangeField;\n            } else {\n                if (rangeField != lastRangeField) {\n                    return false;\n                }\n            }\n        }\n        lastUnitField = unitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return true;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    if (lastType == null) {\n        return false;\n    }\n    DurationField lastUnitField = lastType.getDurationType().getField(partial.getChronology());\n    if (lastUnitField == null) {\n        return false;\n    }\n    for (int i = size - 2; i >= 0; i--) {\n        DateTimeFieldType type = partial.getFieldType(i);\n        if (type == null) {\n            return false;\n        }\n        DurationField unitField = type.getDurationType().getField(partial.getChronology());\n        if (unitField == null) {\n            return false;\n        }\n        if (unitField.isSupported() == false) {\n            return false;\n        }\n        if (lastUnitField.equals(unitField) == false) {\n            return false;\n        }\n        lastUnitField = unitField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    DurationField lastUnitField = null;\n    for (int i = 0; i < partial.size(); i++) {\n        DurationField unitField = partial.getFieldType(i).getDurationType().getField(partial.getChronology());\n        if (i > 0) {\n            if (unitField.isSupported() == false) {\n                if (lastUnitField.isSupported()) {\n                    return false;\n                }\n            } else if (lastUnitField.isSupported() == false) {\n                return false;\n            } else if (lastUnitField.getRangeDurationField() != unitField) {\n                return false;\n            }\n        }\n        lastUnitField = unitField;\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    strings.add(newStringNode(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      strings.add(newStringNode(param.getString()));\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    strings.add(newStringNode(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<Node>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext()) \n    {\n        Node string = IR.string(param.getString());\n        string.useSourceInfoIfMissingFromForTree(param);\n        strings.add(string);\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = Lists.newArrayList();\n    for (Node param : params.children()) {\n      strings.add(newStringNode(param.getString()));\n    }\n    return strings;\n  }",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      strings.add(newStringNode(param.getString()));\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild();\n       param != null; param = param.getNext()) {\n    strings.add(newStringNode(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param = params.getFirstChild();\n       param != null; param = param.getNext()) {\n    strings.add(newStringNode(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = Lists.newArrayList();\n    for (Node param = params.getFirstChild();\n         param != null;\n         param = param.getNext()) {\n        if (param.isName()) {\n            strings.add(newString(param.getString()));\n        } else {\n            strings.add(param.detachFromParent());\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) {\n        strings.add(newNode(Token.STRING, param.getString()));\n    }\n    return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = WordUtils.capitalize(str, delimiters);\n    return WordUtils.uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = WordUtils.capitalize(str, delimiters);\n    return WordUtils.uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    return uncapitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = WordUtils.capitalize(str, delimiters);\n    return WordUtils.uncapitalize(str, delimiters);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (cConvertedIds == null) \n    {\n        cConvertedIds = new HashMap<String, String>();\n        cConvertedIds.put(\"GMT-0\", \"GMT\");\n        cConvertedIds.put(\"GMT+0\", \"GMT\");\n        cConvertedIds.put(\"GMT0\", \"GMT\");\n        cConvertedIds.put(\"UTC\", \"UTC\");\n        cConvertedIds.put(\"UTC+0\", \"UTC\");\n        cConvertedIds.put(\"UTC-0\", \"UTC\");\n        cConvertedIds.put(\"WET\", \"WET\");\n        cConvertedIds.put(\"WET+0\", \"WET\");\n        cConvertedIds.put(\"WET-0\", \"WET\");\n        cConvertedIds.put(\"CET\", \"CET\");\n        cConvertedIds.put(\"CET+0\", \"CET\");\n        cConvertedIds.put(\"CET-0\", \"CET\");\n        cConvertedIds.put(\"MET\", \"MET\");\n        cConvertedIds.put(\"MET+0\", \"MET\");\n        cConvertedIds.put(\"MET-0\", \"MET\");\n        cConvertedIds.put(\"MEST\", \"MEST\");\n        cConvertedIds.put(\"MEST+0\", \"MEST\");\n        cConvertedIds.put(\"MEST-0\", \"MEST\");\n        cConvertedIds.put(\"MESZ\", \"MESZ\");\n        cConvertedIds.put(\"MESZ+0\", \"MESZ\");\n        cConvertedIds.put(\"MESZ-0\", \"MESZ\");\n        cConvertedIds.put(\"CEST\", \"CEST\");\n        cConvertedIds.put(\"CEST+0\", \"CEST\");\n        cConvertedIds.put(\"CEST-0\", \"CEST\");\n        cConvertedIds.put(\"EET\", \"EET\");\n        cConvertedIds.put(\"EET+0\", \"EET\");\n        cConvertedIds.put(\"EET-0\", \"EET\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n        // standard format offset [+-]hh:mm\n        // our ID is without any prefix, so we need to add the GMT back\n        return \"GMT\" + id;\n    }\n    // unusual offset, so setup a SimpleTimeZone as best we can\n    return new java.util.SimpleTimeZone(iWallOffset, getID()).getID();\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cConvertedIds == null) \n    {\n        cConvertedIds = new HashMap<String, String>();\n        cConvertedIds.put(\"GMT-0\", \"GMT+0\");\n        cConvertedIds.put(\"GMT-1\", \"GMT+1\");\n        cConvertedIds.put(\"GMT-2\", \"GMT+2\");\n        cConvertedIds.put(\"GMT-3\", \"GMT+3\");\n        cConvertedIds.put(\"GMT-4\", \"GMT+4\");\n        cConvertedIds.put(\"GMT-5\", \"GMT+5\");\n        cConvertedIds.put(\"GMT-6\", \"GMT+6\");\n        cConvertedIds.put(\"GMT-7\", \"GMT+7\");\n        cConvertedIds.put(\"GMT-8\", \"GMT+8\");\n        cConvertedIds.put(\"GMT-9\", \"GMT+9\");\n        cConvertedIds.put(\"GMT-10\", \"GMT+10\");\n        cConvertedIds.put(\"GMT-11\", \"GMT+11\");\n        cConvertedIds.put(\"GMT-12\", \"GMT+12\");\n    }\n    return cConvertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNewIds == null) \n    {\n        cOldToNewIds = new HashMap<String, String>();\n        cOldToNewIds.put(\"EST\", \"America/New_York\");\n        cOldToNewIds.put(\"MST\", \"America/Denver\");\n        cOldToNewIds.put(\"HST\", \"Pacific/Honolulu\");\n        cOldToNewIds.put(\"ACT\", \"Australia/Darwin\");\n        cOldToNewIds.put(\"AET\", \"Australia/Sydney\");\n        cOldToNewIds.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cOldToNewIds.put(\"ART\", \"Africa/Cairo\");\n        cOldToNewIds.put(\"AST\", \"America/Halifax\");\n        cOldToNewIds.put(\"BET\", \"America/Sao_Paulo\");\n        cOldToNewIds.put(\"BST\", \"Asia/Dhaka\");\n        cOldToNewIds.put(\"CAT\", \"Africa/Harare\");\n        cOldToNewIds.put(\"CNT\", \"America/St_Johns\");\n        cOldToNewIds.put(\"CST\", \"America/Chicago\");\n        cOldToNewIds.put(\"CTT\", \"Asia/Shanghai\");\n        cOldToNewIds.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cOldToNewIds.put(\"ECT\", \"America/Guayaquil\");\n        cOldToNewIds.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cOldToNewIds.put(\"IST\", \"Asia/Kolkata\");\n        cOldToNewIds.put(\"JST\", \"Asia/Tokyo\");\n        cOldToNewIds.put(\"MIT\", \"Pacific/Apia\");\n        cOldToNewIds.put(\"NET\", \"Asia/Yerevan\");\n        cOldToNewIds.put(\"NST\", \"Pacific/Auckland\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = cOldToNew.get(id);\n    if (newId == null) {\n        newId = convertOldId(id);\n        cOldToNew.put(id, newId);\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNewIds == null) {\n        cOldToNewIds = new HashMap<String, String>();\n        cOldToNewIds.put(\"GMT-0\", \"GMT\");\n        cOldToNewIds.put(\"GMT+0\", \"GMT\");\n        cOldToNewIds.put(\"GMT0\", \"GMT\");\n        cOldToNewIds.put(\"GMT-00\", \"GMT\");\n        cOldToNewIds.put(\"GMT+00\", \"GMT\");\n        cOldToNewIds.put(\"GMT00\", \"GMT\");\n        cOldToNewIds.put(\"GMT-0000\", \"GMT\");\n        cOldToNewIds.put(\"GMT+0000\", \"GMT\");\n        cOldToNewIds.put(\"GMT0000\", \"GMT\");\n        cOldToNewIds.put(\"GMT-00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT+00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT-000000\", \"GMT\");\n        cOldToNewIds.put(\"GMT+000000\", \"GMT\");\n        cOldToNewIds.put(\"GMT000000\", \"GMT\");\n        cOldToNewIds.put(\"GMT-00:00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT+00:00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT00:00:00\", \"GMT\");\n        cOldToNewIds.put(\"GMT-00000000\", \"GMT\");\n        cOldToNewIds.put(\"GMT+00000000\", \"GMT\");\n        cOldToNewIds.put(\"GMT00000000\", \"GMT\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldToNewIds == null) \n    {\n        cOldToNewIds = new HashMap<String, String>();\n        cOldToNewIds.put(\"ACT\", \"Australia/Darwin\");\n        cOldToNewIds.put(\"AET\", \"Australia/Sydney\");\n        cOldToNewIds.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cOldToNewIds.put(\"ART\", \"Africa/Cairo\");\n        cOldToNewIds.put(\"AST\", \"America/Anchorage\");\n        cOldToNewIds.put(\"BET\", \"America/Sao_Paulo\");\n        cOldToNewIds.put(\"BST\", \"Asia/Dhaka\");\n        cOldToNewIds.put(\"CAT\", \"Africa/Harare\");\n        cOldToNewIds.put(\"CNT\", \"America/St_Johns\");\n        cOldToNewIds.put(\"CST\", \"America/Chicago\");\n        cOldToNewIds.put(\"CTT\", \"Asia/Shanghai\");\n        cOldToNewIds.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cOldToNewIds.put(\"ECT\", \"America/Guayaquil\");\n        cOldToNewIds.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cOldToNewIds.put(\"IST\", \"Asia/Kolkata\");\n        cOldToNewIds.put(\"JST\", \"Asia/Tokyo\");\n        cOldToNewIds.put(\"MIT\", \"Pacific/Apia\");\n        cOldToNewIds.put(\"NET\", \"Asia/Yerevan\");\n        cOldToNewIds.put(\"NST\", \"Pacific/Auckland\");\n        cOldToNewIds.put(\"PLT\", \"Asia/Karachi\");\n        cOldToNewIds.put(\"PNT\", \"America/Phoenix\");\n        cOldToNewIds.put(\"PRT\", \"America/Puerto_Rico\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cConvertedIds == null) \n    {\n        cConvertedIds = new HashMap<String, String>();\n        cConvertedIds.put(\"EST\", \"America/New_York\");\n        cConvertedIds.put(\"MST\", \"America/Denver\");\n        cConvertedIds.put(\"HST\", \"Pacific/Honolulu\");\n        cConvertedIds.put(\"ACT\", \"Australia/Darwin\");\n        cConvertedIds.put(\"AET\", \"Australia/Sydney\");\n        cConvertedIds.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cConvertedIds.put(\"ART\", \"Africa/Cairo\");\n        cConvertedIds.put(\"AST\", \"America/Halifax\");\n        cConvertedIds.put(\"BET\", \"America/Sao_Paulo\");\n        cConvertedIds.put(\"BST\", \"Asia/Dhaka\");\n        cConvertedIds.put(\"CAT\", \"Africa/Harare\");\n        cConvertedIds.put(\"CNT\", \"America/St_Johns\");\n        cConvertedIds.put(\"CST\", \"America/Chicago\");\n        cConvertedIds.put(\"CTT\", \"Asia/Shanghai\");\n        cConvertedIds.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cConvertedIds.put(\"ECT\", \"America/Guayaquil\");\n        cConvertedIds.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cConvertedIds.put(\"IST\", \"Asia/Kolkata\");\n        cConvertedIds.put(\"JST\", \"Asia/Tokyo\");\n        cConvertedIds.put(\"MIT\", \"Pacific/Apia\");\n        cConvertedIds.put(\"NET\", \"Asia/Yerevan\");\n        cConvertedIds.put(\"NST\", \"Pacific/Auckland\");\n        cConvertedIds.put(\"PLT\", \"Asia/Karachi\");\n        cConvertedIds.put(\"PNT\", \"America/Phoenix\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = cConvertedIds.get(id);\n    if (newId == null) {\n        newId = convertId(id);\n        cConvertedIds.put(id, newId);\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String newId = null;\n    if (cConvertedIds == null) \n    {\n        cConvertedIds = new HashMap<String, String>();\n        newId = cConvertedIds.get(id);\n        if (newId == null) \n        {\n            if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) \n            {\n                // standard format offset [+-]hh:mm\n                // our ID is without any prefix, so we need to add the GMT back\n                newId = \"GMT\" + id;\n            } \n            else \n            {\n                // unusual offset, so setup a SimpleTimeZone as best we can\n                newId = new java.util.SimpleTimeZone(Integer.parseInt(id), id).getID();\n            }\n            cConvertedIds.put(id, newId);\n        }\n    } \n    else \n    {\n        newId = cConvertedIds.get(id);\n    }\n    return newId;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = getWeightSquareRoot().multiply(getJacobian(params));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Set up the Jacobian.\n        final RealMatrix j = computeJacobian(params);\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightMatrix = getWeight();\n        final RealMatrix weightedJacobian = weightMatrix.multiply(j);\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final RealMatrix j = computeJacobian(params);\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = j.scalarMultiply(getWeightSquareRoot());\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Set up the Jacobian.\n    final RealMatrix j = new Array2DRowRealMatrix(nR, nC);\n\n    // Compute transpose(J)J.\n    final RealMatrix jTj = j.transpose().multiply(j);\n\n    // Compute the covariances matrix.\n    final DecompositionSolver solver\n        = new QRDecomposition(jTj, threshold).getSolver();\n    return solver.getInverse().getData();\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    return weightedJacobian.scalarMultiply(-1).getData();\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian.\n    final RealMatrix j = computeJacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    final RealMatrix weightSqrt = getWeightSquareRoot();\n\n    // Compute the weighted Jacobian.\n    return weightSqrt.multiply(j);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final RealMatrix j = computeJacobian(params);\n\n    // Compute the weight matrix.\n    final RealMatrix weightMatrix = getWeight();\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = weightMatrix.multiply(j);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian.\n    final RealMatrix j = computeJacobian(params);\n\n    // Compute the weight matrix.\n    final RealMatrix weightMatrix = getWeight();\n\n    // Compute the weighted Jacobian.\n    return weightMatrix.multiply(j);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Implement the method here\n}"
    ],
    [
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n\n        int least = -1;\n        for (int i = 0; i < iterators.size(); i++) {\n            if (set(i)) {\n                if (least == -1) {\n                    least = i;\n                } else {\n                    final int comparison = comparator.compare(values.get(i), values.get(least));\n                    if (comparison < 0) {\n                        least = i;\n                    }\n                }\n            }\n        }\n\n        return least;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            set(i);\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        int least = -1;\n        for (int i = 0; i < iterators.size(); i++) {\n            if (!valueSet.get(i)) {\n                if (set(i)) {\n                    least = i;\n                }\n            } else if (least == -1) {\n                least = i;\n            } else if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                least = i;\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator must not be null\");\n        }\n        for (int i = 0; i < iterators.size(); i++) {\n            if (!valueSet.get(i)) {\n                set(i);\n            }\n        }\n        int least = 0;\n        for (int i = 1; i < iterators.size(); i++) {\n            if (comparator.compare(values.get(least), values.get(i)) > 0) {\n                least = i;\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            set(i);\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"Comparator must not be null\");\n        }\n\n        int least = -1;\n        for (int i = 0; i < iterators.size(); i++) {\n            if (!valueSet.get(i)) {\n                if (!set(i)) {\n                    return -1;\n                }\n            }\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n\n        int least = -1;\n        for (int i = 0; i < iterators.size(); i++) {\n            if (set(i)) {\n                if (least == -1) {\n                    least = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                        least = i;\n                    }\n                }\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (set(i)) {\n                least = i;\n            }\n        } else if (least == -1) {\n            least = i;\n        } else {\n            final int compare = comparator.compare(values.get(i), values.get(least));\n            if (compare < 0) {\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException();\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    if (values == null) {\n        values = new ArrayList<E>(iterators.size());\n        valueSet = new BitSet(iterators.size());\n        for (int i = 0; i < iterators.size(); i++) {\n            set(i);\n        }\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i) && (least < 0 || comparator.compare(values.get(i), values.get(least)) < 0)) {\n            least = i;\n        }\n    }\n    if (least < 0) {\n        throw new NoSuchElementException();\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        if (values == null) {\n            values = new ArrayList<E>(iterators.size());\n            valueSet = new BitSet(iterators.size());\n            for (int i = 0; i < iterators.size(); i++) {\n                set(i);\n            }\n        }\n        int least = -1;\n        for (int i = 0; i < values.size(); i++) {\n            if (!valueSet.get(i)) {\n                continue;\n            }\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n        if (least == -1) {\n            throw new NoSuchElementException();\n        }\n        return least;\n    }"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) nodeTest;\n        QName name = nameTest.getNodeName();\n        return parentPointer.getPropertyPointer(name.toString());\n    }\n    else if (nodeTest instanceof NodeTypeTest) {\n        NodeTypeTest typeTest = (NodeTypeTest) nodeTest;\n        int type = typeTest.getNodeType();\n        if (type == Compiler.NODE_TYPE_NODE) {\n            return parentPointer.getNodePointer();\n        }\n        else if (type == Compiler.NODE_TYPE_TEXT) {\n            return parentPointer.getTextPointer();\n        }\n        else if (type == Compiler.NODE_TYPE_COMMENT) {\n            return parentPointer.getCommentPointer();\n        }\n        else if (type == Compiler.NODE_TYPE_PROCESSING_INSTRUCTION) {\n            return parentPointer.getProcessingInstructionPointer();\n        }\n    }\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nnt = (NodeNameTest) nodeTest;\n        return parentPointer.getChildPointer(nnt.getNodeName());\n    }\n    else {\n        return parentPointer.getChildPointer();\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nnt = (NodeNameTest) nodeTest;\n        QName name = nnt.getNodeName();\n        return parentPointer.getPropertyPointer(name.toString());\n    }\n    else {\n        return parentPointer.getPropertyPointer(\"\");\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        QName name = nodeTest.getNodeName();\n        return parentPointer.getChildPointer(name.toString());\n    }\n    else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        QName name = nodeTest.getNodeName();\n        return parentPointer.getAttributePointer(name.toString());\n    }\n    else if (axis == Compiler.AXIS_SELF\n            && step.getNodeTest() instanceof NodeTypeTest\n            && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        return parentPointer;\n    }\n    else if (axis == Compiler.AXIS_PARENT\n            && step.getNodeTest() instanceof NodeTypeTest\n            && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        return parentPointer.getParentPointer();\n    }\n    else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n            && step.getNodeTest() instanceof NodeTypeTest\n            && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                == Compiler.NODE_TYPE_NODE\n            && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n        return parentPointer;\n    }\n    else {\n        return parentPointer.getChildPointer(\n            axisToString(axis) + \"::\" + step.getNodeTest());\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) nodeTest;\n        QName name = nameTest.getNodeName();\n        return parentPointer.getPropertyPointer(name.toString());\n    }\n    return parentPointer.getPropertyPointer(null);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        childPointer = parentPointer.getChildPointer(nodeTest.getNodeName());\n    }\n    else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        childPointer = parentPointer.getAttributePointer(nodeTest.getNodeName());\n    }\n    else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n        childPointer = parentPointer;\n    }\n    else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n        childPointer = parentPointer.getParentPointer();\n    }\n    else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new PropertyPointer(\n                parentPointer,\n                ((NodeNameTest) step.getNodeTest()).getNodeName(),\n                false);\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new PropertyPointer(\n                parentPointer,\n                ((NodeNameTest) step.getNodeTest()).getNodeName(),\n                true);\n        }\n        else if (axis == Compiler.AXIS_SELF) {\n            return parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT) {\n            return parentPointer.getParentPointer();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF) {\n            return parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\n                \"Unknown axis: \" + axisToString(axis));\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        String propertyName = nodeTest.getNodeName().toString();\n        return new PropertyPointer(parentPointer, propertyName);\n    }\n    else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        NodeNameTest nodeTest = (NodeNameTest) step.getNodeTest();\n        String propertyName = nodeTest.getNodeName().toString();\n        return new PropertyPointer(parentPointer, propertyName, true);\n    }\n    else {\n        return new PropertyPointer(parentPointer);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            childPointer = parentPointer.getFirstChildPointer();\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            childPointer = parentPointer.getFirstAttributePointer();\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            childPointer = parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            childPointer = parentPointer.getParentPointer();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            childPointer = parentPointer;\n        }\n        else {\n            throw new RuntimeException(\n                \"Unsupported axis: \" + axisToString(axis));\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) nodeTest;\n        QName name = nameTest.getNodeName();\n        if (nameTest.isWildcard()) {\n            return parentPointer.getFirstChildPointer(name.getNamespaceURI(),\n                name.getLocalPart());\n        }\n        else {\n            return parentPointer.getFirstChildPointer(name);\n        }\n    }\n    else if (nodeTest instanceof NodeTypeTest) {\n        NodeTypeTest typeTest = (NodeTypeTest) nodeTest;\n        switch (typeTest.getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return parentPointer.getFirstChildPointer();\n            case Compiler.NODE_TYPE_TEXT:\n                return parentPointer.getFirstChildPointer(\n                    Compiler.NODE_TYPE_TEXT);\n            case Compiler.NODE_TYPE_COMMENT:\n                return parentPointer.getFirstChildPointer(\n                    Compiler.NODE_TYPE_COMMENT);\n            case Compiler.NODE_TYPE_PI:\n                return parentPointer.getFirstChildPointer(\n                    Compiler.NODE_TYPE_PI);\n            default:\n                throw new IllegalStateException(\n                    \"Unknown node type: \" + typeTest.getNodeType());\n        }\n    }\n    else {\n        throw new IllegalStateException(\n            \"Unknown node test type: \" + nodeTest.getClass().getName());\n    }\n}"
    ],
    [
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    // get the locale-specific data for the field\n    final Locale locale= definingCalendar.getLocale();\n    final String[] localeData= DateFormatSymbols.getInstance(locale).getShortMonths();\n    final Map<String, Integer> keyValues= new HashMap<String, Integer>(localeData.length);\n    for(int i=0; i<localeData.length; i++) {\n        keyValues.put(localeData[i], Integer.valueOf(i));\n    }\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    // The cache may already contain the values for the locale\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        // The cache does not contain the values for the locale, create them\n        switch(field) {\n            case Calendar.ERA:\n                strategy= new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.MONTH:\n                strategy= new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.ZONE_OFFSET: //$NON-NLS-1$\n            case Calendar.DST_OFFSET:\n                strategy= new TimeZoneStrategy(field);\n                break;\n            default:\n                throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n        // Put the values into the cache for the Locale\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            // Another thread must have put the values into the cache\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        switch (field) {\n            case Calendar.ERA:\n                strategy = new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.MONTH:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.AM_PM:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.HOUR:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.HOUR_OF_DAY:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.MINUTE:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.SECOND:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.MILLISECOND:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.ZONE_OFFSET:\n                strategy = new TimeZoneStrategy();\n                break;\n            case Calendar.DST_OFFSET:\n                strategy = new TimeZoneStrategy();\n                break;\n            default:\n                throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    // get the locale specific data\n    final Locale locale = definingCalendar.getLocale();\n    final String[] eras = DateFormatSymbols.getInstance(locale).getEras();\n    final String[] months = DateFormatSymbols.getInstance(locale).getMonths();\n    final String[] shortMonths = DateFormatSymbols.getInstance(locale).getShortMonths();\n    final String[] weekdays = DateFormatSymbols.getInstance(locale).getWeekdays();\n    final String[] shortWeekdays = DateFormatSymbols.getInstance(locale).getShortWeekdays();\n    final String[] AmPmStrings = DateFormatSymbols.getInstance(locale).getAmPmStrings();\n\n    // construct the locale specific format field\n    final String formatField;\n    switch(field) {\n        case Calendar.ERA:\n            formatField = eras[0];\n            break;\n        case Calendar.MONTH:\n            formatField = months[0];\n            break;\n        case Calendar.SHORT_MONTH:\n            formatField = shortMonths[0];\n            break;\n        case Calendar.WEEK_OF_YEAR:\n        case Calendar.WEEK_OF_MONTH:\n        case Calendar.DAY_OF_WEEK_IN_MONTH:\n        case Calendar.DAY_OF_WEEK:\n        case Calendar.AM_PM:\n            formatField = weekdays[0];\n            break;\n        case Calendar.HOUR:\n        case Calendar.HOUR_OF_DAY:\n        case Calendar.MINUTE:\n        case Calendar.SECOND:\n        case Calendar.MILLISECOND:\n            formatField = \"00\";\n            break;\n        case Calendar.ZONE_OFFSET:\n        case Calendar.DST_OFFSET:\n            formatField = \"+0000\";\n            break;\n        default:\n            throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n\n    // construct the Strategy\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        if(field==Calendar.DAY_OF_WEEK) {\n            strategy= new TextStrategy(field, definingCalendar, locale);\n        } else {\n            strategy= new LocaleSpecificStrategy(field, definingCalendar, locale);\n        }\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        if(field == Calendar.MONTH) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n        } else if(field == Calendar.AM_PM) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n        } else if(field == Calendar.ERA) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n        } else if(field == Calendar.ZONE_OFFSET) {\n            strategy = new TimeZoneStrategy(field);\n        } else if(field == Calendar.DST_OFFSET) {\n            strategy = new TimeZoneStrategy(field);\n        } else {\n            strategy = new NumberStrategy(field);\n        }\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if(inCache != null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        switch(field) {\n            case Calendar.ERA:\n                strategy = new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.MONTH:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.AM_PM:\n                strategy = new CaseInsensitiveTextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.HOUR:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.HOUR_OF_DAY:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.MINUTE:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.SECOND:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.MILLISECOND:\n                strategy = new NumberStrategy(field);\n                break;\n            case Calendar.ZONE_OFFSET:\n                strategy = new TimeZoneStrategy();\n                break;\n            case Calendar.DST_OFFSET:\n                strategy = new TimeZoneStrategy();\n                break;\n            default:\n                throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    // The cache uses static final keys and values, so we can use identity here.\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        switch(field) {\n            case Calendar.MONTH:\n                strategy= new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                strategy= new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.AM_PM:\n                strategy= new TextStrategy(field, definingCalendar, locale);\n                break;\n            case Calendar.HOUR:\n                strategy= new NumberStrategy(field);\n                break;\n            case Calendar.HOUR_OF_DAY:\n                strategy= new NumberStrategy(field);\n                break;\n            case Calendar.MINUTE:\n                strategy= new NumberStrategy(field);\n                break;\n            case Calendar.SECOND:\n                strategy= new NumberStrategy(field);\n                break;\n            case Calendar.MILLISECOND:\n                strategy= new NumberStrategy(field);\n                break;\n            case Calendar.ZONE_OFFSET:\n                strategy= new TimeZoneStrategy();\n                break;\n            case Calendar.DST_OFFSET:\n                strategy= new TimeZoneStrategy();\n                break;\n            default:\n                throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n        strategy= cache.putIfAbsent(locale, strategy);\n        if(strategy==null) {\n            strategy= cache.get(locale);\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            return true;\n        }\n    }\n    nextObject = null;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        final E current = iterator.next();\n        if (predicate.evaluate(current)) {\n            nextObject = current;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}\n\n//-----------------------------------------------------------------------",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            return true;\n        }\n    }\n    nextObject = null;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (iterator.hasNext()) {\n        nextObject = iterator.next();\n        nextObjectSet = true;\n        return true;\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            return true;\n        }\n    }\n    nextObject = null;\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    x[i] = lB[i];\n                }\n                if (x[i] > uB[i]) {\n                    x[i] = uB[i];\n                }\n            }\n            return x;\n        }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            final double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            final double[] repaired = new double[x.length];\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            final double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = x[i] < lB[i] ? lB[i] : x[i];\n        repaired[i] = repaired[i] > uB[i] ? uB[i] : repaired[i];\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        final double[][] matrixT = schur.getT().getData();\n        final double[][] matrixP = schur.getP().getData();\n\n        final int n = matrixT.length;\n\n        // compute matrix norm\n        double norm = 0.0;\n        for (int i = 0; i < n; i++) {\n           for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n              norm = norm + FastMath.abs(matrixT[i][j]);\n           }\n        }\n\n        // we can not handle a matrix with zero norm\n        if (Precision.equals(norm, 0.0, EPSILON)) {\n           throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        // Backsubstitute to find vectors of upper triangular form\n\n        double r = 0.0;\n        double s = 0.0;\n        double z = 0.0;\n\n        for (int idx = n - 1; idx >= 0; idx--) {\n            double p = realEigenvalues[idx];\n            double q = imagEigenvalues[idx];\n\n            // look for small sub-diagonal element\n            int m = idx - 1;\n            while (m >= 0) {\n                double tst1 = FastMath.abs(matrixT[m][m]) + FastMath.abs(matrixT[m][idx]);\n                if (FastMath.abs(matrixT[m][m]) <= EPSILON * tst1) {\n                    break;\n                }\n                m--;\n            }\n\n            // Check for convergence\n            if (m == idx - 1) {\n                // One root found\n                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n                idx--;\n            } else if (m == idx - 2) {\n                // Two roots found\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer transformer = new SchurTransformer(matrix);\n        final RealMatrix t = transformer.getT();\n        final RealMatrix p = transformer.getP();\n        final RealMatrix pt = transformer.getPT();\n        final double[] realEigenvalues = new double[t.getRowDimension()];\n        final double[] imagEigenvalues = new double[t.getRowDimension()];\n        final RealMatrix z = MatrixUtils.createRealMatrix(t.getColumnDimension(), t.getColumnDimension());\n        for (int i = 0; i < t.getColumnDimension(); i++) {\n            for (int j = 0; j < t.getColumnDimension(); j++) {\n                z.setEntry(i, j, p.getEntry(i, j));\n            }\n        }\n        // Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < t.getColumnDimension(); i++) {\n            int k = i;\n            double p = t.getEntry(i, i);\n            for (int j = i + 1; j < t.getColumnDimension(); j++) {\n                if (t.getEntry(j, j) > p) {\n                    k = j;\n                    p = t.getEntry(j, j);\n                }\n            }\n            if (k != i) {\n                t.setEntry(k, k, t.getEntry(i, i));\n                t.setEntry(i, i, p);\n                for (int j = 0; j < t.getColumnDimension(); j++) {\n                    p = z.getEntry(j, i);\n                    z.setEntry(j, i, z.getEntry(j, k));\n                    z.setEntry(j, k, p);\n                }\n            }\n        }\n        // Determine the largest eigen value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < t.getColumnDimension(); i++) {\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        final double[][] matrixT = schur.getT().getData();\n        final double[][] matrixP = schur.getP().getData();\n\n        final int n = matrixT.length;\n\n        // compute matrix norm\n        double norm = 0.0;\n        for (int i = 0; i < n; i++) {\n           for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n              norm = norm + FastMath.abs(matrixT[i][j]);\n           }\n        }\n\n        // we can not handle a matrix with zero norm\n        if (Precision.equals(norm, 0.0, EPSILON)) {\n           throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        // Backsubstitute to find vectors of upper triangular form\n\n        double r = 0.0;\n        double s = 0.0;\n        double z = 0.0;\n\n        for (int idx = n - 1; idx >= 0; idx--) {\n            double p = realEigenvalues[idx];\n            double q = imagEigenvalues[idx];\n\n            // Check for convergence\n            if (q <= epsilon * norm) {\n                // one root found\n                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n                iu--;\n                iteration = 0;\n            } else if (iteration == MAX_ITERATIONS) {\n                // too many iterations\n                throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                     MAX_ITERATIONS);\n            } else {\n                // form shift\n                double shift = matrixT[idx][idx] - p;\n                double x = matrixT[idx][idx + 1];\n                double y = matrixT[idx + 1][idx];\n                double w = x * x + y * y;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    final double norm = getNorm();\n\n    // shift information\n    final ShiftInfo shift = new ShiftInfo();\n\n    // Outer loop over eigenvalue index\n    int iteration = 0;\n    int iu = n - 1;\n    while (iu >= 0) {\n\n        // Look for single small sub-diagonal element\n        final int il = findSmallSubDiagonalElement(iu, norm);\n\n        // Check for convergence\n        if (il == iu) {\n            // One root found\n            matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n            iu--;\n            iteration = 0;\n        } else if (il == iu - 1) {\n            // Two roots found\n            double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n            double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n            matrixT[iu][iu] += shift.exShift;\n            matrixT[iu - 1][iu - 1] += shift.exShift;\n\n            // Compute the eigenvector\n            final Complex eigenValue = new Complex(matrixT[iu][iu], p);\n            final Complex[] eigenVector = new Complex[n];\n            eigenVector[iu] = new Complex(1.0, 0.0);\n            eigenVector[iu - 1] = new Complex(0.0, 0.0);\n            for (int i = iu - 2; i >= 0; i--) {\n                eigenVector[i] = cdiv(eigenVector[i + 1].getReal(), eigenVector[i + 1].getImaginary(),\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // Look for small super-diagonal element\n        int l = idx + 1;\n        while (l < n) {\n            if (FastMath.abs(matrixT[l][l - 1]) <= EPSILON * (FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]))) {\n                break;\n            }\n            l++;\n        }\n\n        // Check for convergence\n        if (l == idx) {\n            // One root found\n            matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n            idx--;\n            iteration = 0;\n        } else if (l == idx + 1) {\n            // Two roots found\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform matrix to Schur form\n    final SchurTransformer schur = new SchurTransformer(matrix);\n\n    // calculate eigenvalues\n    final double[] realEigenvalues = new double[matrix.getColumnDimension()];\n    final double[] imagEigenvalues = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        realEigenvalues[i] = schur.getT().getEntry(i, i);\n        imagEigenvalues[i] = 0;\n    }\n\n    // return the Schur transform\n    return schur;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        long current = values[i];\n        while (current != 0) {\n            final int index = numberOfTrailingZeros(current);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n            current &= ~(1L << index);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final int enumSize = enumClass.getEnumConstants().length;\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[enumSize - (i * Long.SIZE + j) - 1]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int bit = constant.ordinal() % Long.SIZE;\n        final int element = constant.ordinal() / Long.SIZE;\n        if ((values[element] & (1L << bit)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final int enumSize = enumClass.getEnumConstants().length;\n        for (int i = 0; i < values.length; i++) {\n            for (int j = 0; j < Long.SIZE; j++) {\n                if ((values[i] & (1L << j)) != 0) {\n                    result.add(enumClass.getEnumConstants()[j + i * Long.SIZE]);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (int i = 0; i < values.length; i++) {\n            final long bitVector = values[i];\n            final int end = (int) Math.min(enumClass.getEnumConstants().length, (i + 1) * Long.SIZE);\n            for (int j = i * Long.SIZE; j < end; j++) {\n                if ((bitVector & (1L << (j % Long.SIZE))) != 0) {\n                    result.add(enumClass.getEnumConstants()[j]);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        for (int i = 0; i < constants.length; i++) {\n            final E constant = constants[i];\n            final int ordinal = constant.ordinal();\n            if (ordinal < Long.SIZE) {\n                if ((values[0] & (1L << ordinal)) != 0) {\n                    result.add(constant);\n                }\n            } else {\n                final int arrayIndex = ordinal / Long.SIZE;\n                final int bitIndex = ordinal % Long.SIZE;\n                if (arrayIndex >= values.length) {\n                    break;\n                }\n                if ((values[arrayIndex] & (1L << bitIndex)) != 0) {\n                    result.add(constant);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        final E constant = constants[i];\n        final int index = constant.ordinal() / Long.SIZE;\n        final int bit = constant.ordinal() % Long.SIZE;\n        if (values[index] == 0) {\n            continue;\n        }\n        if ((values[index] & (1L << bit)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        final long mask = 1L << i;\n        for (final long value : values) {\n            if ((value & mask) != 0) {\n                result.add(constants[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        if ((values[constant.ordinal() / Long.SIZE] & (1L << (constant.ordinal() % Long.SIZE))) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final int enumSize = enumClass.getEnumConstants().length;\n    for (int i = 0; i < values.length; i++) {\n        long current = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((current & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[j + (i * Long.SIZE)]);\n            }\n            current >>>= 1;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant + offset;\n    int newOffset = newZone.getOffset(localInstant);\n    long newInstant = localInstant - newOffset;\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long localInstant = iZone.convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == this) {\n        return oldInstant;\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long localInstant = iZone.convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    DateTickUnitType t = unit.getUnitType();\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int milliseconds = calendar.get(Calendar.MILLISECOND);\n        int count = unit.getMultiple();\n        int current = calendar.get(Calendar.MILLISECOND);\n        int value = count * (current / count);\n        if (value == current) \n        {\n            value = value + count;\n        }\n        calendar.set(Calendar.MILLISECOND, value);\n        result = calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int seconds = calendar.get(Calendar.SECOND);\n        int count = unit.getMultiple();\n        int current = calendar.get(Calendar.SECOND);\n        int value = count * (current / count);\n        if (value == current) \n        {\n            value = value + count;\n        }\n        calendar.set(Calendar.SECOND, value);\n        result = calendar.getTime();\n    } \n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int minutes = calendar.get(Calendar.MINUTE);\n        int count = unit.getMultiple();\n        int current = calendar.get(Calendar.MINUTE);\n        int value = count * (current / count);\n        if (value == current) \n        {\n            value = value + count;\n        }\n        calendar.set(Calendar.MINUTE, value);\n        result = calendar.getTime();\n    } \n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        milliseconds = calendar.get(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) \n        {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() <= date.getTime()) \n        {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        milliseconds = calendar.get(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.MILLISECOND, value - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.SECOND, value);\n        Date dd = calendar.getTime();\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int milliseconds = calendar.get(Calendar.MILLISECOND);\n        int count = unit.getMultiple();\n        int value = count * (milliseconds / count);\n        calendar.set(Calendar.MILLISECOND, value + count);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int seconds = calendar.get(Calendar.SECOND);\n        int count = unit.getMultiple();\n        int value = count * (seconds / count);\n        calendar.set(Calendar.SECOND, value + count);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int minutes = calendar.get(Calendar.MINUTE);\n        int count = unit.getMultiple();\n        int value = count * (minutes / count);\n        calendar.set(Calendar.MINUTE, value + count);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        int count = unit.getMultiple();\n        int value = count * (hours / count);\n        calendar.set(Calendar.HOUR_OF_DAY, value + count);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.DAY)) \n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        milliseconds = calendar.get(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.MILLISECOND, value - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() >= date.getTime()) \n        {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        milliseconds = calendar.get(Calendar.MILLISECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) \n        {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) \n    {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) \n        {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) \n        {\n            milliseconds = 500;\n        }\n        else \n        {\n            milliseconds = 999;\n}\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (isEnableSubstitutionInVariables()) {\n        final StrBuilder buf2 = new StrBuilder(value);\n        substitute(buf2, 0, buf2.length());\n        return buf2.toString();\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null) {\n        return null;\n    }\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String resolved = null;\n    if (getEnableSubstitutionInVariables()) {\n        final StrBuilder buf2 = new StrBuilder(buf.substring(startPos, endPos));\n        if (substitute(buf2, 0, buf2.length()) > 0) {\n            resolved = buf2.toString();\n        }\n    }\n    if (resolved == null) {\n        resolved = getVariableResolver().lookup(variableName);\n    }\n    return resolved;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (isEnableSubstitutionInVariables() == false) {\n        return value;\n    }\n    final StrBuilder bufValue = new StrBuilder(value);\n    substitute(bufValue, 0, value.length(), new ArrayList<String>());\n    return bufValue.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getEnableSubstitutionInVariables()) {\n        // substitutor is set to perform variable substitution,\n        // so do that before querying the resolver\n        final StrBuilder buf2 = new StrBuilder(buf);\n        substitute(buf2, startPos, endPos);\n        return getVariableResolver().lookup(buf2.toString());\n    } else {\n        return getVariableResolver().lookup(variableName);\n    }\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String varValue = null;\n    if (getVariableResolver() != null) {\n        varValue = getVariableResolver().lookup(variableName);\n    }\n    if (varValue == null && isEnableSubstitutionInVariables()) {\n        varValue = substitute(variableName, startPos, endPos);\n    }\n    return varValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    String resolved = resolver.lookup(variableName);\n    if (resolved == null) {\n        return null;\n    }\n    if (resolved.indexOf(getEscapeChar()) >= 0) {\n        resolved = escape(resolved);\n    }\n    return resolved;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (isEnableSubstitutionInVariables() && buf.indexOf(value, startPos, endPos) >= 0) {\n        return value;\n    }\n    return substitute(value, buf, startPos, endPos);\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = new char[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n        chars[i] = str.charAt(i);\n    }\n    final StringBuilder key = new StringBuilder();\n    key.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        final char next = i < chars.length - 1 ? chars[i + 1] : SPACE;\n        final char aNext = i < chars.length - 2 ? chars[i + 2] : SPACE;\n        final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n        System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n        if (chars[i] != chars[i - 1]) {\n            key.append(chars[i]);\n        }\n    }\n    if (key.length() > 1) {\n        char lastChar = key.charAt(key.length() - 1);\n        if (lastChar == 'S') {\n            key.deleteCharAt(key.length() - 1);\n            lastChar = key.charAt(key.length() - 1);\n        }\n        if (key.length() > 2) {\n            final char last2Char = key.charAt(key.length() - 2);\n            if (last2Char == 'A' && lastChar == 'Y') {\n                key.deleteCharAt(key.length() - 2);\n            }\n        }\n        if (lastChar == 'A') {\n            key.deleteCharAt(key.length() - 1);\n        }\n    }\n    final String string = key.toString();\n    return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final int len = str.length();\n        final char[] chars = new char[len];\n        int count = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isLetter(str.charAt(i))) {\n                chars[count++] = str.charAt(i);\n            }\n        }\n        if (count == len) {\n            return str.toUpperCase(java.util.Locale.ENGLISH);\n        }\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final int len = str.length();\n    final char[] chars = new char[len];\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isLetter(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == len) {\n        return str.toUpperCase(java.util.Locale.ENGLISH);\n    }\n    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final int len = str.length();\n    final char[] chars = new char[len];\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isLetter(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == len) {\n        return str.toUpperCase(java.util.Locale.ENGLISH);\n    }\n    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder soundex = new StringBuilder(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        final char c = chars[i];\n        final char previous = chars[i - 1];\n        final char next = i < chars.length - 1 ? chars[i + 1] : ' ';\n        final char[] transcoded = transcode(previous, c, next);\n        if (transcoded != null) {\n            soundex.append(transcoded);\n        }\n    }\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toCharArray();\n        final StringBuilder sb = new StringBuilder();\n        sb.append(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            if (sb.length() < TRUE_LENGTH) {\n                final char mapped = map(c);\n                if (mapped != 0) {\n                    sb.append(mapped);\n                }\n            }\n        }\n        while (sb.length() < TRUE_LENGTH) {\n            sb.append('0');\n        }\n        return sb.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = new char[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n        chars[i] = this.mapping[str.charAt(i) - 'A'];\n    }\n    final StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        if (chars[i] != 0) {\n            sb.append(chars[i]);\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toCharArray();\n        final StringBuilder soundex = new StringBuilder(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            if (c != chars[i - 1]) {\n                final int code = getCode(c);\n                if (code > 0) {\n                    soundex.append(code);\n                }\n            }\n        }\n        return soundex.toString();\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toCharArray();\n        final StringBuilder soundex = new StringBuilder(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char last = soundex.charAt(soundex.length() - 1);\n            if (last != '0' && c != last) {\n                soundex.append(this.getMappingCode(c));\n            }\n        }\n        return soundex.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final int len = str.length();\n    final char[] chars = new char[len];\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isLetter(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == len) {\n        return str.toUpperCase(java.util.Locale.ENGLISH);\n    }\n    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING) {\n        return TypeFactory.stringType();\n    }\n    if (clz == CLASS_ITERABLE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_ENUM) {\n        return TypeFactory.unknownType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First: JDK types\n    if (clz.getName().startsWith(\"java.\")) {\n        if (clz == String.class) {\n            return TypeFactory.stringType();\n        }\n        if (clz == Integer.class) {\n            return TypeFactory.intType();\n        }\n        if (clz == Boolean.class) {\n            return TypeFactory.booleanType();\n        }\n        if (clz == Long.class) {\n            return TypeFactory.longType();\n        }\n        if (clz == Double.class) {\n            return TypeFactory.doubleType();\n        }\n        if (clz == Character.class) {\n            return TypeFactory.charType();\n        }\n        if (clz == Byte.class) {\n            return TypeFactory.byteType();\n        }\n        if (clz == Short.class) {\n            return TypeFactory.shortType();\n        }\n        if (clz == Float.class) {\n            return TypeFactory.floatType();\n        }\n        if (clz == Void.class) {\n            return TypeFactory.voidType();\n        }\n    }\n    // and then Jackson types\n    if (clz.getName().startsWith(\"com.fasterxml.jackson\")) {\n        if (clz == JsonNode.class) {\n            return TypeFactory.unknownType();\n        }\n        if (clz == JsonParser.class) {\n            return TypeFactory.unknownType();\n        }\n        if (clz == JsonGenerator.class) {\n            return TypeFactory.unknownType();\n        }\n        if (clz == JsonLocation.class) {\n            return TypeFactory.unknownType();\n        }\n        if (clz == JsonProcessingException.class) {\n            return TypeFactory.unknownType();\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 07-Mar-2017, tatu: As per [databind#1551], need to handle `Optional`\n    //    separately, since it is not considered a \"well-known\" type.\n    if (clz == Optional.class) {\n        return null;\n    }\n    // 10-Mar-2017, tatu: And `OptionalInt`, `OptionalLong`, `OptionalDouble`\n    if (clz == OptionalInt.class || clz == OptionalLong.class\n            || clz == OptionalDouble.class) {\n        return null;\n    }\n    // 16-Mar-2017, tatu: Also `java.util.Optional`\n    if (clz == java.util.Optional.class) {\n        return null;\n    }\n    // 10-Mar-2017, tatu: And `java.util.OptionalInt`, `java.util.OptionalLong`, `java.util.OptionalDouble`\n    if (clz == java.util.OptionalInt.class || clz == java.util.OptionalLong.class\n            || clz == java.util.OptionalDouble.class) {\n        return null;\n    }\n    // 03-Apr-2017, tatu: And `java.util.stream.Stream`\n    if (clz == java.util.stream.Stream.class) {\n        return null;\n    }\n    // 03-Apr-2017, tatu: And `java.util.stream.IntStream`\n    if (clz == java.util.stream.IntStream.class) {\n        return null;\n    }\n    // 03-Apr-2017, tatu: And `java.util.stream.LongStream`\n    if (clz == java.util.stream.LongStream.class) {\n        return null;\n    }\n    // 03-Apr-2017, tatu: And `java.util.stream.DoubleStream`\n    if (clz == java.util.stream.DoubleStream.class) {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Character.class) {\n        return CharType.instance;\n    }\n    if (clz == Byte.class) {\n        return ByteType.instance;\n    }\n    if (clz == Short.class) {\n        return ShortType.instance;\n    }\n    if (clz == Float.class) {\n        return FloatType.instance;\n    }\n    if (clz == Void.class) {\n        return VoidType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First, common JDK types\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING) {\n        return TypeFactory.stringType();\n    }\n    if (clz == CLASS_ITERABLE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return TypeFactory.unknownType();\n    }\n    // Then Jackson types\n    if (clz == CLASS_JACKSON_BINARY) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_DATE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TREE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER_ITERATOR) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER_ITERATOR_1) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER_ITERATOR_2) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER_ITERATOR_3) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_JACKSON_NODE_TRAVERSER_ITERATOR_4) {\n        return TypeFactory.unknownType();\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING || clz == CLASS_CHAR_SEQUENCE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_ITERABLE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return TypeFactory.unknownType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    if (clz == Byte.class) {\n        return ByteType.instance;\n    }\n    if (clz == Short.class) {\n        return ShortType.instance;\n    }\n    if (clz == Float.class) {\n        return FloatType.instance;\n    }\n    if (clz == Character.class) {\n        return CharType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntegerType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Float.class) {\n        return FloatType.instance;\n    }\n    if (clz == Short.class) {\n        return ShortType.instance;\n    }\n    if (clz == Byte.class) {\n        return ByteType.instance;\n    }\n    if (clz == Character.class) {\n        return CharacterType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // first, common types\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_ITERABLE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_NUMBER) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_INTEGER) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_LONG) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_DOUBLE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_CHARACTER) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_BYTE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_SHORT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_FLOAT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_BIG_INTEGER) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_BIG_DECIMAL) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_CALENDAR) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_DATE) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_OBJECT_STREAM_CONSTANT) {\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First, JDK types\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Integer.class);\n        }\n        if (clz == Boolean.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Boolean.class);\n        }\n        if (clz == Long.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Long.class);\n        }\n        if (clz == Double.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Double.class);\n        }\n        if (clz == Character.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Character.class);\n        }\n        if (clz == Byte.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Byte.class);\n        }\n        if (clz == Short.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Short.class);\n        }\n        if (clz == Float.TYPE) {\n            return TypeFactory.defaultInstance().constructType(Float.class);\n        }\n    } else if (clz.isArray()) {\n        return TypeFactory.defaultInstance().constructArrayType(clz);\n    } else if (clz == String.class) {\n        return TypeFactory.defaultInstance().constructType(String.class);\n    } else if (clz == Object.class) {\n        return TypeFactory.defaultInstance().constructType(Object.class);\n    } else if (clz == java.util.Map.class) {\n        return TypeFactory.defaultInstance().constructType(java.util.Map.class);\n    } else if (clz == java.util.List.class) {\n        return TypeFactory.defaultInstance().constructType(java.util.List.class);\n    } else if (clz == java.util.Collection.class) {\n        return TypeFactory.defaultInstance().constructType(java.util.Collection.class);\n    } else if (clz == java.util.Iterator.class) {\n        return TypeFactory.defaultInstance().constructType(java.util.Iterator.class);\n}\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isExprResult()) {\n      return null;\n    }\n\n    Node expr = n.getFirstChild();\n    if (!expr.isAssign()) {\n      return null;\n    }\n\n    Node lhs = expr.getFirstChild();\n    if (!lhs.isGetProp()) {\n      return null;\n    }\n\n    Node className = lhs.getFirstChild();\n    if (!className.isName() || !\"prototype\".equals(lhs.getLastChild().getString())) {\n      return null;\n    }\n\n    Node rhs = expr.getLastChild();\n    if (!rhs.isFunction()) {\n      return null;\n    }\n\n    return new PrototypeMemberDeclaration(className.getString(), rhs);\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isExprResult()) {\n      return null;\n    }\n\n    Node assign = n.getFirstChild();\n    if (!assign.isAssign()) {\n      return null;\n    }\n\n    Node lhs = assign.getFirstChild();\n    if (!lhs.isGetProp()) {\n      return null;\n    }\n\n    Node obj = lhs.getFirstChild();\n    if (!obj.isName() || !obj.getString().equals(\"prototype\")) {\n      return null;\n    }\n\n    Node name = lhs.getLastChild();\n    if (!name.isName()) {\n      return null;\n    }\n\n    Node rhs = assign.getLastChild();\n    if (!rhs.isFunction()) {\n      return null;\n    }\n\n    return new PrototypeMemberDeclaration(name.getString(), rhs);\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n          return new PrototypeMemberDeclaration(lhs.getLastChild(), rhs);\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp()) {\n      Node lhs = n.getFirstChild();\n      if (lhs.getFirstChild().isThis()) {\n        return new PrototypeMemberDeclaration(lhs.getLastChild(), n);\n      }\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult()) {\n        Node expr = n.getFirstChild();\n        if (expr.isAssign()) {\n          Node lhs = expr.getFirstChild();\n          if (lhs.isGetProp()) {\n            Node obj = lhs.getFirstChild();\n            if (obj.isName() && obj.getString().equals(\"prototype\")) {\n              return new PrototypeMemberDeclaration(lhs.getLastChild(),\n                                                     expr.getLastChild());\n            }\n          }\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign() && n.getFirstChild().isGetProp()) {\n    Node lhs = n.getFirstChild();\n    if (lhs.getFirstChild().isThis()) {\n      return new PrototypeMemberDeclaration(lhs.getLastChild().getString(), n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.isExprResult()) {\n        return null;\n      }\n\n      Node expr = n.getFirstChild();\n      if (!expr.isAssign()) {\n        return null;\n      }\n\n      Node lhs = expr.getFirstChild();\n      if (!lhs.isGetProp()) {\n        return null;\n      }\n\n      Node obj = lhs.getFirstChild();\n      if (!obj.isName() || !obj.getString().equals(\"prototype\")) {\n        return null;\n      }\n\n      Node rhs = expr.getLastChild();\n      if (!rhs.isFunction()) {\n        return null;\n      }\n\n      Node name = lhs.getLastChild();\n      return new PrototypeMemberDeclaration(name.getString(), rhs);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign()) {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n      Node rhs = lhs.getNext();\n      if (rhs.isFunction()) {\n        return new PrototypeMemberDeclaration(lhs.getLastChild(), rhs);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult()) {\n    Node expr = n.getFirstChild();\n    if (expr.isAssign()) {\n      Node lhs = expr.getFirstChild();\n      if (lhs.isGetProp()) {\n        Node recv = lhs.getFirstChild();\n        if (recv.isName() && recv.getString().equals(\"prototype\")) {\n          return new PrototypeMemberDeclaration(lhs, expr.getLastChild());\n        }\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult()) {\n        Node expr = n.getFirstChild();\n        if (expr.isAssign()) {\n          Node lhs = expr.getFirstChild();\n          if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n            return new PrototypeMemberDeclaration(lhs.getLastChild().getString(), expr.getLastChild());\n          }\n        }\n      }\n      return null;\n    }"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(nRows * n, nCols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat.getData(), i * nRows, j * nCols);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double entry = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i + k * nRows][j + l * nCols] = entry;\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double entry = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i + k * nRows][j + l * nCols] = entry;\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat.getData(), i * rows, j * cols);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\");\n        }\n        if (m < 0) {\n            throw new IllegalArgumentException(\"m must be non-negative\");\n        }\n        final int nRows = mat.getRowDimension();\n        final int nCols = mat.getColumnDimension();\n        final RealMatrix out = MatrixUtils.createRealMatrix(nRows * n, nCols * m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                out.setSubMatrix(mat.getData(), i * nRows, (i + 1) * nRows - 1, j * nCols, (j + 1) * nCols - 1);\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double value = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = value;\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            for (int k = 0; k < n; ++k) {\n                for (int l = 0; l < m; ++l) {\n                    data[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(nRows * n, nCols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat.getData(), i * nRows, j * nCols);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double entry = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i + k * nRows][j + l * nCols] = entry;\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double val = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = val;\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) > 0)\n        {\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else\n        {\n            candidate = node;\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = bytesRead;\n    if (inf.getBytesWritten() < bytesRead) {\n        bytesInflated = inf.getBytesWritten();\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesRead();\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = getBytesRead();\n    if (bytesInflated < bytesRead) {\n        bytesInflated += 0x100000000L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = bytesRead;\n    long bytesConsumed = inf.getBytesWritten();\n    if (bytesConsumed > bytesInflated) {\n        bytesInflated = bytesConsumed;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = getBytesRead();\n    final long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < bytesRead) {\n        return bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesInflated = inf.getBytesWritten();\n    final long bytesRead = getBytesRead();\n    if (bytesInflated < bytesRead) {\n        return bytesInflated;\n    }\n    return bytesRead;\n}",
      "private long getBytesInflated()  {\n    final long bytesInflated = inf.getBytesWritten();\n    final long bytesRead = inf.getBytesRead();\n    if (bytesInflated < bytesRead) {\n        return bytesInflated;\n    }\n    final long diff = bytesInflated - bytesRead;\n    if (diff > Integer.MAX_VALUE) {\n        return bytesRead;\n    }\n    return bytesRead + diff;\n}",
      "private long getBytesInflated()  {\n    final long bytesInflated = inf.getBytesWritten();\n    final long bytesRead = bytesReadForThisEntry;\n    if (bytesInflated > bytesRead) {\n        return bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = getBytesRead();\n    final long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        throw new IllegalStateException(\"inflated bytes cannot be greater than read bytes\");\n    }\n    if (bytesInflated < bytesRead) {\n        return bytesRead - bytesInflated;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    }\n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"[a-zA-Z_$][a-zA-Z_$0-9]*\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    for (String part : name.split(\"\\\\.\")) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"[a-zA-Z_$][a-zA-Z_$0-9]*\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    for (String part : name.split(\"\\\\.\")) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.length() > 0 && name.indexOf('.') == -1;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*$\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*$\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    for (String part : name.split(\"\\\\.\")) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.length() > 0;\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n        final int n = matrixT.length;\n        int im = iu - 1;\n        double eps = Precision.EPSILON;\n        double eps3 = eps * 3.0;\n        double f = 0.0;\n        double tst1 = 0.0;\n        double tst2 = 0.0;\n        double p = 0.0;\n        double q = 0.0;\n        double r = 0.0;\n        double s = 0.0;\n        double z = 0.0;\n        int j;\n        int k;\n        int iteration = 0;\n        int maxIter = 30;\n\n        for (k = iu; k >= il; k--) {\n            iteration = 0;\n            do {\n                for (j = k; j < n - 1; j++) {\n                    tst1 = FastMath.abs(matrixT[j][j]) + FastMath.abs(matrixT[j + 1][j]);\n                    tst2 = tst1 + FastMath.abs(matrixT[j + 1][j + 1]);\n                    if (tst1 <= eps3 * tst2) {\n                        break;\n                    }\n                }\n                if (j != k) {\n                    if (iteration == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    iteration++;\n                    f = (matrixT[k][k] - matrixT[k + 1][k + 1]) / (2 * matrixT[k][k + 1]);\n                    s = FastMath.sqrt(1 + f * f);\n                    if (f < 0.0) {\n                        s = -s;\n                    }\n                    f = (matrixT[k][k] - matrixT[k + 1][k + 1]) / (matrixT[k][k] - matrixT[k + 1][k + 1] + s * f);\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    int im = iu - 1;\n    int iteration = 0;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = iu - 1; k >= il; k--) {\n        boolean notlast = k != (il - 1);\n        if (k != iu - 1) {\n            p = matrixT[k][k + 1];\n            q = matrixT[k + 1][k + 1];\n            r = notlast ? matrixT[k + 2][k + 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != iu - 1) {\n                matrixT[k + 1][k] = -s * shift.x;\n            } else if (il != iu - 1) {\n                matrixT[k + 1][k] = -matrixT[k + 1][k];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n        int im = iu;\n\n        for (int k = iu - 1; k >= il; k--) {\n            boolean notlast = k != (il - 1);\n            if (k != iu - 1) {\n                p = matrixT[k][k + 1];\n                q = matrixT[k + 1][k + 1];\n                r = notlast ? matrixT[k + 2][k + 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != iu - 1) {\n                    matrixT[k + 1][k] = -s * shift.x;\n                } else if (il != iu - 1) {\n                    matrixT[k + 1][k] = -matrixT[k + 1][k];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    int im = iu - 1;\n    for (int k = iu - 2; k >= il; k--) {\n        boolean notlast = k != (il - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu - 1;\n    int iteration = 0;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n        final int n = matrixT.length;\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n        int im = iu - 1;\n        int iteration = 0;\n        for (int k = iu - 2; k >= il; k--) {\n            boolean notlast = k != (il - 1);\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\n                    matrixT[k][k - 1] = -matrixT[k][k - 1];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0;\n    double q = 0;\n    double r = 0;\n    int im = iu - 1;\n    if (il != iu - 1) {\n        hVec[0] = matrixT[il][il];\n        hVec[1] = matrixT[il + 1][il];\n        hVec[2] = matrixT[il + 2][il];\n        im = il;\n    } else {\n        hVec[0] = 0;\n        hVec[1] = 0;\n        hVec[2] = 0;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu - 1;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != iu) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu - 1;\n    hVec[0] = matrixT[im][im];\n    hVec[1] = matrixT[im + 1][im];\n    hVec[2] = 0.0;\n    return im;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child: childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            TextNode textNode = (TextNode) node;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child: childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n            for (Segment segment = getSegment(this.segmentStart);\n                segment.getSegmentStart() < this.segmentEnd;\n                segment.inc()) {\n                if (!segment.inIncludeSegments()) {\n                    return (false);\n                }\n            }\n            return true;\n        }",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n            for (Segment segment = getSegment(this.segmentStart);\n                segment.getSegmentStart() < this.segmentEnd;\n                segment.inc()) {\n                if (!segment.inIncludeSegments()) {\n                    return (false);\n                }\n            }\n            return true;\n        }",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return days / DateTimeConstants.MILLIS_PER_DAY;\n        }\n        int amount = zeroInstance.get(start.getChronology().days());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[startValues.length];\n    for (int i = 0; i < startValues.length; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < startValues.length; i++) {\n        if (diff[i] != 0) {\n            amount = diff[i];\n            break;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"Zero instance must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        chrono = DateTimeUtils.getChronology(chrono);\n        int[] values1 = chrono.get(zeroInstance, start);\n        int[] values2 = chrono.get(zeroInstance, end);\n        int amount = 0;\n        for (int i = 0, isize = values1.length; i < isize; i++) {\n            amount = FieldUtils.safeSubtract(values2[i], values1[i]);\n        }\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int units = chrono.hours().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return units;\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        values[i] = end.get(i) - start.get(i);\n    }\n    return zeroInstance.getPeriodType().getPeriodType().getDifference(values, start.getValues());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return days / DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int millis = chrono.millis().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return millis / DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (start instanceof LocalDateTime && end instanceof LocalDateTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int millis = chrono.millis().getDifference(\n                ((LocalDateTime) end).getLocalMillis(), ((LocalDateTime) start).getLocalMillis());\n        return millis / DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n        Chronology chrono = start.getChronology();\n        chrono = DateTimeUtils.getChronology(chrono);\n        long startMillis = ((BaseLocal) start).getLocalMillis();\n        long endMillis = ((BaseLocal) end).getLocalMillis();\n        return chrono.days().getDifference(endMillis, startMillis);\n    }\n    int amount = 0;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int hours = chrono.hours().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return hours;\n        }\n        int amount = zeroInstance.get(start.getChronology().hours());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] resultValues = new int[startValues.length];\n    for (int i = 0, isize = startValues.length; i < isize; i++) {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (startValue == endValue) {\n            resultValues[i] = 0;\n        } else if (startValue < endValue) {\n            resultValues[i] = endValue - startValue;\n        } else {\n            resultValues[i] = endValue + (zeroValue - startValue);\n        }\n    }\n    return zeroInstance.getPeriodType().getPeriodType().getDifference(resultValues, zeroValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int units = chrono.hours().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return units;\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        int[] startValues = new int[start.size()];\n        int[] endValues = new int[end.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            startValues[i] = start.get(i);\n            endValues[i] = end.get(i);\n        }\n        return zeroInstance.getPeriodType().getPeriodType().getDifference(startValues, endValues);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return days / DateTimeConstants.MILLIS_PER_DAY;\n        }\n        if (start instanceof LocalTime && end instanceof LocalTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int millis = chrono.millis().getDifference(\n                    ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n            return millis / DateTimeConstants.MILLIS_PER_HOUR;\n        }\n        if (start instanceof LocalDateTime && end instanceof LocalDateTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int millis = chrono.millis().getDifference(\n                    ((LocalDateTime) end).getLocalMillis(), ((LocalDateTime) start).getLocalMillis());\n            return millis / DateTimeConstants.MILLIS_PER_HOUR;\n        }\n        if (start instanceof LocalDate && end instanceof LocalDateTime)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDateTime) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return days / DateTimeConstants.MILLIS_PER_DAY;\n        }\n        if (start instanceof LocalDateTime && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDateTime) start).getLocalMillis());\n}\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    chrono = DateTimeUtils.getChronology(chrono);\n    int[] values = chrono.get(zeroInstance, start, end);\n    int amount = 0;\n    for (int i = 0, isize = values.length; i < isize; i++) {\n        amount = Math.addExact(amount, values[i]);\n    }\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) {\n        throw new IllegalArgumentException(\"Index \" + index\n                + \" out of bounds.\");\n    }\n    LegendTitle legend = null;\n    List legendIndices = (List) this.datasetToLegendMap.get(\n            new Integer(index));\n    if (legendIndices != null) {\n        // the first axis in the list is used for data <--> Java2D\n        Integer axisIndex = (Integer) legendIndices.get(0);\n        legend = getLegend(axisIndex.intValue());\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) \n    {\n        throw new IllegalArgumentException(\"Index \" + index + \" out of bounds.\");\n    }\n    LegendTitle result = null;\n    List axisIndices = (List) this.datasetToRangeAxesMap.get(new Integer(index));\n    if (axisIndices != null) \n    {\n        // the first axis in the list is used for data <--> Java2D\n        Integer axisIndex = (Integer) axisIndices.get(0);\n        result = getLegend(axisIndex.intValue());\n    }\n    else \n    {\n        result = getLegend(0);\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (index < 0 || index >= getLegendCount()) {\n        throw new IllegalArgumentException(\"Index \" + index\n                + \" out of bounds.\");\n    }\n    result = (LegendTitle) this.legends.get(index);\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Enumeration<ZipArchiveEntry> enumeration = getEntries();\n    final List<ZipArchiveEntry> entries = new ArrayList<>();\n    while (enumeration.hasMoreElements()) {\n        entries.add(enumeration.nextElement());\n    }\n    Collections.sort(entries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseOptionalParameterType(token);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node paramType = null;\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        next();\n        paramType = parseTopLevelTypeExpression(next());\n        if (paramType != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      } else {\n        paramType = parseTopLevelTypeExpression(token);\n        if (paramType != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n      if (paramType != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    }\n    return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n                next();\n            }\n        }\n\n        return typeNode;\n    } else {\n        return parseOptionalParameterType(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n        if (str == null || size <= 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int pads = size - strLen;\n        if (pads <= 0) {\n            return str;\n        }\n        str = leftPad(str, strLen + pads / 2, padChar);\n        str = rightPad(str, size, padChar);\n        return str;\n    }",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n         child != null; child = child.getNext()) {\n      if (mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n         child != null; child = child.getNext()) {\n      if (mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Preconditions.checkState(call.isCall());\n    for (Node arg = call.getFirstChild().getNext();\n         arg != null; arg = arg.getNext()) {\n      if (mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext(); child != null;\n         child = child.getNext()) {\n      if (mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node child = call.getFirstChild().getNext();\n       child != null; child = child.getNext()) {\n    if (mayHaveSideEffects(child)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext(); child != null;\n         child = child.getNext()) {\n      if (mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node child = call.getFirstChild().getNext();\n       child != null; child = child.getNext()) {\n    if (mayHaveSideEffects(child)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Preconditions.checkArgument(call.isCall());\n  for (Node child = call.getFirstChild().getNext();\n       child != null; child = child.getNext()) {\n    if (mayHaveSideEffects(child)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Preconditions.checkArgument(call.isCall());\n  for (Node child = call.getFirstChild().getNext();\n       child != null; child = child.getNext()) {\n    if (mayHaveSideEffects(child)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n         child != null; child = child.getNext()) {\n      if (mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    //TODO: Implement this method\n    return null;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isEscape(ch)) \n        {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) \n            { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } \n            else \n            {\n                token.content.append((char) unescaped);\n            }\n        } \n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } \n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        } \n        else \n        {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        if (isEscape(c)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) c).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else if (isDelimiter(c)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(c)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(c)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            // error condition (end of file before end of token)\n            throw new IOException(\"(startline \" + startLineNumber +\n                    \") EOF reached before simple token finished\");\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        if (isEscape(c)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) c).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else if (isDelimiter(c)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(c)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(c)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) c);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    final int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        final int[] c = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            c[i] = index / uniCounterOffset[i];\n            index -= c[i] * uniCounterOffset[i];\n        }\n        c[last] = index;\n        return c;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        final int[] counts = new int[dimension];\n        int count = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = count / uniCounterOffset[i];\n            count = count % uniCounterOffset[i];\n        }\n        counts[last] = count;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    int i = 0;\n    while (index >= uniCounterOffset[i]) {\n        index -= uniCounterOffset[i];\n        i++;\n    }\n    c[i] = index;\n    for (int j = 0; j < i; j++) {\n        c[j] = (index - uniCounterOffset[j]) / size[j];\n        index -= c[j] * size[j];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        final int[] counts = new int[dimension];\n        int m = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = m / uniCounterOffset[i];\n            m = m % uniCounterOffset[i];\n        }\n        counts[last] = m;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        final int[] counts = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = index / uniCounterOffset[i];\n            index %= uniCounterOffset[i];\n        }\n        counts[last] = index;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    final int[] c = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        c[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    c[last] = index;\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        final int[] c = new int[dimension];\n        int remaining = index;\n        for (int i = 0; i < dimension; i++) {\n            c[i] = remaining / uniCounterOffset[i];\n            remaining = remaining % uniCounterOffset[i];\n        }\n        c[last] = remaining;\n        return c;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    final int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n        JsonPointer last = this;\n        JsonPointer next = _nextSegment;\n        while (next != null) {\n            last = next;\n            next = next._nextSegment;\n        }\n        return last;\n    }",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n        JsonPointer ptr = this;\n        while (ptr._nextSegment != null) {\n            ptr = ptr._nextSegment;\n        }\n        return ptr;\n    }",
      "public JsonPointer last()  {\n        JsonPointer last = this;\n        while (last._nextSegment != null) {\n            last = last._nextSegment;\n        }\n        return last;\n    }",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is of type T\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                @SuppressWarnings(\"unchecked\") // OK because obj is of type T\n                final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of type cls\n                final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                @SuppressWarnings(\"unchecked\") // OK because input is of type T\n                final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n            }\n        }\n        return null;\n    }\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be of type Cloneable\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of type cls\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                @SuppressWarnings(\"unchecked\") // OK because obj is of type T\n                final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is verified to be of type cls\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                @SuppressWarnings(\"unchecked\") // OK because obj is checked to be of type Cloneable\n                final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n            }\n        }\n        return null;\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n\n    for (ObjectType objType : type.getExtendedInterfaces()) {\n      if (objType.isNativeObjectType()) {\n        JSTypeRegistry registry = objType.getNativeType();\n        SymbolScope scope = registry.getScope();\n        if (scope != null) {\n          Symbol param = scope.getQualifiedSlot(paramName);\n          if (param != null) {\n            return param;\n          }\n        }\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (ObjectType objType : type.getExtendedInterfaces()) {\n    Symbol param = objType.getPropertyScope().getSlot(paramName);\n    if (param != null) {\n      return param;\n    }\n  }\n\n  ObjectType objType = type.getInstanceType();\n  if (objType != null) {\n    Symbol param = objType.getPropertyScope().getSlot(paramName);\n    if (param != null) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n\n    for (ObjectType.Entry<String, Symbol> entry : type.getParameters()) {\n      if (entry.getKey().equals(paramName)) {\n        return entry.getValue();\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType objType : type.getExtendedInterfaces()) {\n    for (String propName : objType.getOwnPropertyNames()) {\n      if (propName.equals(paramName)) {\n        return objType.getPropertyScope().getQualifiedSlot(paramName);\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n\n    for (ObjectType objType : type.getExtendedInterfaces()) {\n      if (objType.getConstructor() != null) {\n        Symbol param = getParameterInFunction(objType.getConstructor(), paramName);\n        if (param != null) {\n          return param;\n        }\n      }\n    }\n\n    if (type.getPrototype() != null) {\n      Symbol param = getParameterInFunction(type.getPrototype(), paramName);\n      if (param != null) {\n        return param;\n      }\n    }\n\n    for (Symbol param : type.getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getProperties().values()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  // Check the parameters of the function\n  for (Symbol param : type.getParameters()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  // Check the var_args parameter of the function\n  if (type.isVarArgs()) {\n    Symbol varArgs = type.getVarArgsParameter();\n    if (varArgs != null && varArgs.getName().equals(paramName)) {\n      return varArgs;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (ObjectType objType : type.getExtendedInterfaces()) {\n    Symbol param = objType.getPropertyScope().getSlot(paramName);\n    if (param != null) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (ObjectType objType : type.getExtendedInterfaces()) {\n    if (objType.getReferenceName().equals(\"Function\")) {\n      for (Symbol param : objType.getProperties()) {\n        if (param.getName().equals(paramName)) {\n          return param;\n        }\n      }\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property p : type.getProperties()) {\n    if (p.getName().equals(paramName)) {\n      return p.getSymbol();\n    }\n  }\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            double sigma = FastMath.sqrt(matrix.getColumnVariance(i));\n            outMatrix.setEntry(i, i, sigma * sigma);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getCovariance(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getColumnVariance(j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = 0; j < i; j++) {\n                double cov = computeCovariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                outMatrix.setEntry(i, j, cov);\n                outMatrix.setEntry(j, i, cov);\n            }\n            outMatrix.setEntry(i, i, computeVariance(matrix.getColumn(i), biasCorrected));\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            double sigma = FastMath.sqrt(matrix.getColumnVariance(i));\n            outMatrix.setEntry(i, i, sigma * sigma);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getCovariance(i, j) / sigma;\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getColumn(i).dotProduct(matrix.getColumn(j)) / (nObs - (biasCorrected ? 1 : 0));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getColumn(i).dotProduct(matrix.getColumn(j));\n                entry = biasCorrected ? entry / (n - 1) : entry / n;\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n            outMatrix.setEntry(i, i, matrix.getColumn(i).dotProduct(matrix.getColumn(i)));\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, sigma * sigma);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) / sigma;\n                outMatrix.setEntry(i, j, entry * entry);\n                outMatrix.setEntry(j, i, entry * entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j);\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n                double entry = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    double x = matrix.getEntry(k, i);\n                    double y = matrix.getEntry(k, j);\n                    entry += (x - mean[i]) * (y - mean[j]);\n                }\n                if (biasCorrected) {\n                    entry /= (matrix.getRowDimension() - 1);\n                } else {\n                    entry /= matrix.getRowDimension();\n                }\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n            outMatrix.setEntry(i, i, 0);\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n                double cov = matrix.getCovariance(i, j, biasCorrected);\n                outMatrix.setEntry(i, j, cov);\n                outMatrix.setEntry(j, i, cov);\n            }\n            outMatrix.setEntry(i, i, matrix.getVariance(i, biasCorrected));\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = 0; j < i; j++) {\n                double entry = 0;\n                for (int k = 0; k < nObs; k++) {\n                    double x = matrix.getEntry(k, i);\n                    double y = matrix.getEntry(k, j);\n                    entry += (x - mean[i]) * (y - mean[j]);\n                }\n                if (biasCorrected) {\n                    entry /= nObs - 1;\n                } else {\n                    entry /= nObs;\n                }\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n            outMatrix.setEntry(i, i, 0);\n        }\n        return outMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63, got \" + count);\n    }\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be a positive number not bigger than 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize >= 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (count > 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63, but is \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize >= 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63, but was \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63, but is \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize >= 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached = 0;\n    bitsCachedSize = 0;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63.\");\n    }\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    return bitsCached & MASKS[count];\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize >= 57) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    if (labelNode.isString()) {\n      return label.equals(labelNode.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    return labelNode != null && labelNode.getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  return labelNode != null && labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null) {\n    return false;\n  }\n  if (labelNode.getType() != Token.LABEL) {\n    return false;\n  }\n  return labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null || !labelNode.isLabel()) {\n    return false;\n  }\n  return labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null) {\n    return false;\n  }\n  return labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getString().equals(label);\n    }\n    return false;\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null) \n        {\n            if (item < urls.size()) \n            {\n                result = (String) urls.get(item);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c == '\\\\') {\n            i++;\n            if (i >= str.length()) {\n                throw new IllegalArgumentException(\"Invalid index value: \"+str);\n            }\n            c = str.charAt(i);\n        }\n        index = (index * 31) + c;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n        int i = str.indexOf(':');\n        if (i < 1) {\n            throw new IllegalArgumentException(\"Invalid index: \"+str);\n        }\n        String num = str.substring(0, i);\n        try {\n            return Integer.parseInt(num);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Invalid index: \"+str, e);\n        }\n    }",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    if (str.length() > 0) {\n        char c = str.charAt(0);\n        if (c >= '0' && c <= '9') {\n            index = c - '0';\n        } else if (c >= 'A' && c <= 'F') {\n            index = c - 'A' + 10;\n        } else if (c >= 'a' && c <= 'f') {\n            index = c - 'a' + 10;\n        } else {\n            throw new IllegalArgumentException(\"Invalid hex character: \"+c);\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n        if (str == null) {\n            return -1;\n        }\n        int i = str.indexOf('[');\n        if (i < 0) {\n            return -1;\n        }\n        return Integer.parseInt(str.substring(i+1, str.length()-1));\n    }",
      "private final static int _parseIndex(String str)  {\n    int index = str.indexOf(':');\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Expected a ':' in the index, got \" + str);\n    }\n    return Integer.parseInt(str.substring(0, index));\n}",
      "private final static int _parseIndex(String str)  {\n    int i = str.length();\n    if (i > 1) {\n        throw new IllegalArgumentException(\"Index value '\"+str+\"' can not be used as an index\");\n    }\n    if (i == 0) {\n        return -1;\n    }\n    return str.charAt(0) - '0';\n}",
      "private final static int _parseIndex(String str)  {\n        int len = str.length();\n        if (len == 0) {\n            return -1;\n        }\n        int ch = str.charAt(0);\n        if (ch >= '0' && ch <= '9') {\n            return ch - '0';\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return ch - 'a' + 10;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            return ch - 'A' + 36;\n        }\n        return -1;\n    }",
      "private final static int _parseIndex(String str)  {\n        int i = str.length();\n        if (i > 2) {\n            return -1;\n        }\n        int index = 0;\n        for (int j = 0; j < i; j++) {\n            char c = str.charAt(j);\n            if (c < '0' || c > '9') {\n                return -1;\n            }\n            index = index * 10 + (c - '0');\n        }\n        return index;\n    }",
      "private final static int _parseIndex(String str)  {\n        int len = str.length();\n        if (len == 0) {\n            return -1;\n        }\n        int ch = str.charAt(0);\n        if (ch >= '0' && ch <= '9') {\n            return ch - '0';\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            return ch - 'A' + 10;\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return ch - 'a' + 10;\n        }\n        return -1;\n    }",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c == '\\\\') {\n            index++;\n        }\n        index++;\n    }\n    return index;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        int[] index = nextPermutation(c.size(), k);\n        Object[] result = new Object[k];\n        int i = 0;\n        for (Object o : c) {\n            result[i] = o;\n            i++;\n        }\n        return result;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] result = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        result[i++] = o;\n    }\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (i == k) {\n            break;\n        }\n        sample[i++] = o;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] sample = new Object[k];\n    int[] index = nextPermutation(c.size(), k);\n    int i = 0;\n    for (Object o : c) {\n        if (i == k) {\n            break;\n        }\n        sample[index[i]] = o;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        sample[i] = o;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    Iterator<?> iter = c.iterator();\n    for (int i = 0; i < k; i++) {\n        sample[i] = iter.next();\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        sample[i] = o;\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        sample[i++] = o;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] index = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (i == k) {\n            break;\n        }\n        sample[i++] = o;\n    }\n    return sample;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.getprop(IR.name(\"goog\"),\n                                       IR.string(methodName)));\n    callNode.putBooleanProp(Node.FREE_CALL, true);\n    callNode.addChildToBack(argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodNode = NodeUtil.newQName(compiler, methodName);\n      Node callNode = IR.call(methodNode, argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.getprop(IR.name(\"goog\"),\n                                       IR.string(methodName)));\n    callNode.putBooleanProp(Node.FREE_CALL, true);\n    callNode.addChildToBack(argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL, new Node(Token.GETPROP,\n                                                    new Node(Token.NAME, \"goog\"),\n                                                    new Node(Token.STRING, methodName)));\n      callNode.addChildToBack(argumentNode);\n      callNode.setSourceFileName(srcref.getSourceFileName());\n      callNode.setSourcePosition(srcref.getSourcePosition());\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL, new Node(Token.GETPROP,\n                                                    new Node(Token.NAME, \"goog\"),\n                                                    new Node(Token.STRING, methodName)));\n      callNode.addChildToBack(argumentNode);\n      callNode.setSourceFileForNode(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL, new Node(Token.GETPROP,\n          new Node(Token.NAME, \"goog\"),\n          new Node(Token.STRING, methodName)));\n      callNode.addChildToBack(argumentNode);\n      callNode.setSourceFileForNode(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodNode = NodeUtil.newQName(compiler, methodName);\n      Node callNode = IR.call(methodNode, argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(IR.getprop(IR.name(\"goog\"),\n                                             IR.string(methodName)));\n      callNode.putBooleanProp(Node.FREE_CALL, true);\n      callNode.addChildToBack(argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               new Node(Token.GETPROP,\n                                        new Node(Token.NAME, \"goog\"),\n                                        new Node(Token.STRING, methodName)),\n                               argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = IR.call(IR.getprop(IR.name(\"goog\"),\n                                       IR.string(methodName)));\n    callNode.srcrefTreeIfMissing(srcref);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp =\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        // Create a list of pairs (value, index).\n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>();\n        for (int i = 0; i < doubles.length; i++) {\n            list.add(new Pair<Double, Integer>(doubles[i], i));\n        }\n\n        // Create comparators for increasing and decreasing orders.\n        final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int len = doubles.length;\n        final List<Pair<Double, Integer>> list = new ArrayList<>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<>(doubles[i], i));\n        }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs of the form (value, index).\n    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp =\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        // Create a list of Pair<Double, Integer>\n        final int len = doubles.length;\n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<Double, Integer>(doubles[i], i));\n        }\n\n        // Create comparators for increasing and decreasing orders.\n        final Comparator<Pair<Double, Integer>> comp\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = qrt.length;\n        final int m = qrt[0].length;\n        double[][] qa = new double[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                qa[i][j] = qrt[i][j] / -rDiag[j];\n            }\n            qa[i][i] = 1;\n            for (int j = i + 1; j < m; ++j) {\n                qa[i][j] = qrt[i][j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n        if (cachedQT == null) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\n            double[][] qa = new double[n][m];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < i + 1; ++j) {\n                    qa[i][j] = qrt[i][j];\n                }\n            }\n            cachedQT = MatrixUtils.createRealMatrix(qa);\n        }\n        return cachedQT;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = qrt.length;\n        final int m = qrt[0].length;\n        double[][] qa = new double[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < FastMath.min(i + 1, m); ++j) {\n                qa[i][j] = qrt[j][i] / -rDiag[j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int m = qrt.length;\n        final int n = qrt[0].length;\n        double[][] qt = new double[n][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < FastMath.min(i + 1, n); ++j) \n            {\n                qt[j][i] = qrt[j][i];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = qrt.length;\n        final int m = qrt[0].length;\n        double[][] qt = new double[m][n];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < FastMath.min(i + 1, n); ++j) \n            {\n                qt[i][j] = qrt[j][i] / -rDiag[j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int m = qrt.length;\n        final int n = qrt[0].length;\n        double[][] qa = new double[n][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n                qa[j][i] = qrt[j][i];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = qrt.length;\n        final int m = qrt[0].length;\n        double[][] qt = new double[n][m];\n        for (int i = 0; i < n; ++i) \n        {\n            for (int j = 0; j < FastMath.min(i + 1, m); ++j) \n            {\n                qt[i][j] = qrt[j][i] / -rDiag[j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int m = qrt.length;\n        final int n = qrt[0].length;\n        double[][] qt = new double[n][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < FastMath.min(i + 1, n); ++j) \n            {\n                qt[j][i] = qrt[i][j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n        if (cachedQT == null) {\n            final int n = qrt.length;\n            final int m = qrt[0].length;\n            double[][] qt = new double[m][n];\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n                    qt[i][j] = qrt[j][i] / -rDiag[j];\n                }\n            }\n            cachedQT = MatrixUtils.createRealMatrix(qt);\n        }\n\n        // return the cached matrix\n        return cachedQT;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = qrt.length;\n        final int m = qrt[0].length;\n        double[][] qa = new double[n][m];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                qa[i][j] = qrt[j][i];\n            }\n            qa[i][i] = 1;\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n    return cachedQT;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable result = this.keyToGroupMap.get(key);\n        if (result == null) {\n            result = this.defaultGroup;\n        }\n        return result;\n    }",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable result = this.keyToGroupMap.get(key);\n        if (result == null) {\n            result = this.defaultGroup;\n        }\n        return result;\n    }",
      "public Comparable getGroup(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable group = this.keyToGroupMap.get(key);\n        if (group == null) {\n            group = this.defaultGroup;\n        }\n        return group;\n    }",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity < 0) {\n        throw new StringIndexOutOfBoundsException(capacity);\n    }\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) \n    {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) \n    {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) \n    {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeRangeInfo) {\n        CumulativeRangeInfo info = (CumulativeRangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for negative hours: \" + minutesOffset);\n    }\n    return forOffsetMillis(hoursOffset * 3600000 + minutesOffset * 60000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes may not be negative when hours are positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes may not be positive when hours are negative\");\n    }\n    String id = printOffset(hoursOffset, minutesOffset);\n    return fixedOffsetZone(id, hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    int millisOffset = FieldUtils.safeMultiply(hoursOffset, DateTimeConstants.MILLIS_PER_HOUR);\n    millisOffset = FieldUtils.safeAdd(millisOffset, FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE));\n    return DateTimeZone.forOffsetMillis(millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    int millisOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return forOffsetMillis(millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Convert from old alias before consulting provider since they may differ.\n    String id = printOffset(hoursOffset, minutesOffset);\n    DateTimeZone dtz = cProvider.getZone(id);\n    if (dtz != null) {\n        return dtz;\n    }\n\n    // Check the offset is valid.\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for negative hours: \" + minutesOffset);\n    }\n\n    // Check the offset is valid.\n    long offset = (long) hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + (long) minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset < -MAX_MILLIS || offset > MAX_MILLIS) {\n        throw new IllegalArgumentException(\"Offset out of range: \" + offset);\n    }\n\n    // Create the zone.\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for negative hours: \" + minutesOffset);\n    }\n    int millisOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    String id = printOffset(millisOffset);\n    return fixedOffsetZone(id, millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // check range of hours\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    // check range of minutes\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    // check for valid sign combination\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    // calculate millis from hours and minutes\n    int millisOffset = (hoursOffset * DateTimeConstants.MILLIS_PER_HOUR) + (minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n    // check range of millis\n    if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n        throw new IllegalArgumentException(\"Offset out of range: \" + millisOffset);\n    }\n    // create and return zone\n    String id = printOffset(millisOffset);\n    return fixedOffsetZone(id, millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes out of range for negative hours: \" + minutesOffset);\n    }\n    String id = printOffset(hoursOffset, minutesOffset);\n    return fixedOffsetZone(id, hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Check arguments\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n\n    // Calculate the millisecond offset\n    int millisOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return forOffsetMillis(millisOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    //int pos = bufPos;\n    //int end = bufLength;\n    //StringBuilder builder = new StringBuilder();\n    //boolean inQuote = false;\n    //char last = 0;\n    //while (pos < end) {\n    //    char c = charBuf[pos];\n    //    if (c == open && !inQuote) {\n    //        int count = 1;\n    //        int start = pos;\n    //        pos++;\n    //        while (pos < end) {\n    //            c = charBuf[pos];\n    //            if (c == close) {\n    //                count--;\n    //                if (count == 0) {\n    //                    builder.append(charBuf, start, pos - start + 1);\n    //                    pos++;\n    //                    break;\n    //                }\n    //            } else if (c == open) {\n    //                count++;\n    //            }\n    //            pos++;\n    //        }\n    //    } else if (c == '\"' || c == '\\'') {\n    //        if (last != '\\\\') {\n    //            inQuote = !inQuote;\n    //        }\n    //    }\n    //    pos++;\n    //}\n    //bufPos = pos;\n    //return builder.toString();\n    return \"\";\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n\n    int start = bufPos;\n    int depth = 0;\n    char last = 0;\n\n    // in java, we can't iterate over the codepoints in a string (there is no codepoint iterator), so we have to\n    // fall back to oldskool array access.\n    final char[] val = charBuf;\n    final int length = bufLength;\n\n    boolean inQuote = false;\n    boolean inEscape = false;\n\n    for (int pos = start; pos < length; pos++) {\n        char c = val[pos];\n\n        if (c == close && !inQuote && !inEscape) {\n            depth--;\n            if (depth <= 0) {\n                bufPos = pos + 1;\n                return cacheString(val, stringCache, start, pos - start);\n            }\n        }\n        else if (c == open && !inQuote && !inEscape) {\n            depth++;\n        }\n        else if (c == '\\\\' && !inEscape) {\n            inEscape = true;\n        }\n        else if (c == '\\'' || c == '\"') {\n            if (inEscape) {\n                inEscape = false;\n            } else if (!inQuote) {\n                inQuote = true;\n            } else {\n                inQuote = false;\n            }\n        }\n        else {\n            inEscape = false;\n        }\n\n        last = c;\n    }\n\n    return cacheString(val, stringCache, start, length - start);\n}",
      "public String chompBalanced(char open, char close)  {\n    //start by finding the next instance of the open\n    int start = nextIndexOf(open);\n    if (start == -1)\n        return \"\";\n    int end = start + 1;\n    int depth = 0;\n    while (end < length())\n    {\n        char c = charAt(end);\n        if (c == close)\n        {\n            depth--;\n            if (depth < 0)\n                break;\n        }\n        else if (c == open)\n            depth++;\n        else if (c == '\\\\')\n        {\n            //escape; skip next char\n            end++;\n        }\n        end++;\n    }\n    if (end >= length())\n        return \"\";\n    return substring(start, end+1);\n}",
      "public String chompBalanced(char open, char close)  {\n    //TODO: implement this method\n    return null;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = bufPos;\n    int end = bufLength;\n    int depth = 0;\n\n    boolean inQuote = false;\n    boolean escaped = false;\n\n    //Pattern pattern = Pattern.compile(\"\\\\\\\\([\\\\\\\\\\\\\\\"'])\");\n    //Matcher matcher = pattern.matcher(buf);\n\n    for (int i = bufPos; i < bufLength; i++) \n    {\n        char c = charBuf[i];\n\n        if (escaped) \n        {\n            escaped = false;\n        } \n        else \n        {\n            if (c == '\\\\') \n            {\n                escaped = true;\n            } \n            else if (c == '\\'' || c == '\"') \n            {\n                inQuote = !inQuote;\n            } \n            else if (c == close && !inQuote) \n            {\n                depth--;\n                if (depth <= 0) \n                {\n                    end = i;\n                    bufPos = i + 1;\n                    break;\n                }\n            } \n            else if (c == open && !inQuote) \n            {\n                depth++;\n            }\n        }\n    }\n\n    return cacheString(charBuf, stringCache, start, end - start);\n}",
      "public String chompBalanced(char open, char close)  {\n    // start from the current position\n    int start = bufPos;\n    // count of openers\n    int count = 0;\n    // look through the rest of the buffer\n    while (bufPos < bufLength) \n    {\n        // get the current character\n        char c = charBuf[bufPos];\n        // if it's the closer, and we've had enough openers...\n        if (c == close && --count < 0)\n        {\n            // ... we've found the end of the matched string\n            break;\n        }\n        // if it's an opener, and it's not quoted or escaped...\n        else if (c == open)\n        {\n            // ... increment the opener count\n            count++;\n        }\n        // advance to the next character\n        bufPos++;\n    }\n    // return the matched string\n    return cacheString(charBuf, stringCache, start, bufPos - start);\n}",
      "public String chompBalanced(char open, char close)  {\n    // start:\n    int start = bufPos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        switch (c) {\n            case '\\\\':\n                if (isEmpty()) break; // hit end\n                consume(); // skip next\n                break;\n            case '\\'':\n                while (!isEmpty() && consume() != '\\'') ;\n                break;\n            case '\"':\n                while (!isEmpty() && consume() != '\"') ;\n                break;\n            case open:\n                depth++;\n                break;\n            case close:\n                if (depth-- == 0) {\n                    String matched = cacheString(charBuf, stringCache, start, bufPos - start);\n                    return matched;\n                }\n                break;\n        }\n    }\n    return cacheString(charBuf, stringCache, start, bufPos - start);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = bufPos;\n    int end = bufLength;\n    int depth = 0;\n\n    boolean inQuote = false;\n    char last = 0;\n    char quote = 0;\n\n    for (int pos = bufPos; pos < bufLength; pos++) {\n        char c = charBuf[pos];\n        if (c == quote && last != '\\\\') {\n            inQuote = !inQuote;\n        }\n        if (!inQuote && c == open) {\n            depth++;\n        }\n        if (!inQuote && c == close) {\n            depth--;\n            if (depth <= 0) {\n                end = pos;\n                break;\n            }\n        }\n        last = c;\n    }\n\n    bufPos = end;\n    return cacheString(charBuf, stringCache, start, end - start);\n}",
      "public String chompBalanced(char open, char close)  {\n    //start by finding the next instance of the open\n    String startSeq = consumeTo(open);\n    int startPos = bufPos;\n    //if it's not found, return the start string\n    if (startPos == 0)\n        return startSeq;\n    //now find the close, starting from that position\n    String endSeq = consumeTo(close);\n    //if not found, return the start string\n    if (bufPos == 0)\n        return startSeq;\n    //otherwise, return the string between them\n    return startSeq + endSeq;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n\n    int start = bufPos;\n    int end = start;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    char quote = 0;\n\n    final char[] val = charBuf;\n    final int length = bufLength;\n\n    while (true) {\n        if (end == length) break;\n        char c = val[end];\n        if (c == close && !inQuote) {\n            if (depth == 0) break;\n            depth--;\n        } else if (c == open && !inQuote) {\n            depth++;\n        } else if (c == quote && last != '\\\\') {\n            inQuote = !inQuote;\n        }\n        last = c;\n        end++;\n    }\n\n    bufPos = end;\n    return cacheString(charBuf, stringCache, start, end - start);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTx = getX().transpose().multiply(getX());\n        final RealMatrix xTxInv = new SingularValueDecomposition(xTx).getSolver().getInverse();\n        final RealMatrix rT = getQR().getR().getSubMatrix(0, getBeta().getDimension() - 1, 0, getBeta().getDimension() - 1);\n        return rT.transpose().multiply(rT).multiply(xTxInv);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // X'X\n        RealMatrix xTx = getX().transpose().multiply(getX());\n        // X'X^-1\n        RealMatrix xTxInverse = new SingularValueDecomposition(xTx).getSolver().getInverse();\n        // R'R\n        RealMatrix rTR = getQR().getR().transpose().multiply(getQR().getR());\n        // R'R^-1\n        RealMatrix rTRInverse = new SingularValueDecomposition(rTR).getSolver().getInverse();\n        // R'R^-1 * X'X^-1\n        RealMatrix betaVariance = rTRInverse.multiply(xTxInverse);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Compute the variance-covariance matrix of the regression parameters\n        // Var(b) = (X^T X)^-1\n        //\n        // Use QR decomposition to reduce (X^T X)^-1 to (R^T R)^-1,\n        // with only the top p rows of R included, where p = the length of\n        // the beta vector.\n        //\n        // Data for the model must have been successfully loaded using one of\n        // the newSampleData methods before invoking this method; otherwise\n        // a NullPointerException will be thrown.\n        //\n        // The QR decomposition is computed using the Householder algorithm.\n        //\n        // The algorithm is as follows:\n        //\n        // 1. Compute the QR decomposition of X^T X.\n        // 2. Compute the inverse of R.\n        // 3. Compute the inverse of (R^T R)^-1.\n        // 4. Compute the inverse of (X^T X)^-1.\n        // 5. Return the inverse of (X^T X)^-1.\n        //\n        // Note that the inverse of a triangular matrix is simply the\n        // transpose of the matrix.\n        //\n        // The QR decomposition is computed using the Householder algorithm.\n        //\n        // The algorithm is as follows:\n        //\n        // 1. Compute the QR decomposition of X^T X.\n        // 2. Compute the inverse of R.\n        // 3. Compute the inverse of (R^T R)^-1.\n        // 4. Compute the inverse of (X^T X)^-1.\n        // 5. Return the inverse of (X^T X)^-1.\n        //\n        // Note that the inverse of a triangular matrix is simply the\n        // transpose of the matrix.\n        //\n        // The QR decomposition is computed using the Householder algorithm.\n        //\n        // The algorithm is as follows:\n        //\n        // 1. Compute the QR decomposition of X^T X.\n        // 2. Compute the inverse of R.\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // get the number of regression parameters\n        final int p = getBeta().getColumnDimension();\n\n        // get the transpose of the matrix X\n        final RealMatrix xt = getX().transpose();\n\n        // get the QR decomposition of X\n        final QRDecomposition qr = new QRDecomposition(getX());\n\n        // get the upper triangular matrix R\n        final RealMatrix r = qr.getR();\n\n        // get the transpose of the upper triangular matrix R\n        final RealMatrix rt = r.transpose();\n\n        // get the inverse of the matrix R\n        final RealMatrix rInv = r.solve(MatrixUtils.createRealIdentityMatrix(p));\n\n        // get the inverse of the matrix Rt\n        final RealMatrix rtInv = rt.solve(MatrixUtils.createRealIdentityMatrix(p));\n\n        // calculate the variance-covariance matrix\n        final RealMatrix var = rInv.multiply(xt).multiply(rInv.transpose());\n\n        // return the variance-covariance matrix\n        return var;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix x = getX();\n        final int n = x.getRowDimension();\n        final int p = x.getColumnDimension();\n        final RealMatrix xtx = x.transpose().multiply(x);\n        final RealMatrix xtxInv = new SingularValueDecomposition(xtx).getSolver().getInverse();\n        final RealMatrix r = new QRDecomposition(xtxInv).getR();\n        final RealMatrix rt = r.transpose();\n        final RealMatrix rtR = rt.multiply(r);\n        final RealMatrix rtRInv = new CholeskyDecomposition(rtR).getSolver().getInverse();\n        return rtRInv.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix covariance = null;\n        RealMatrix qr = getQR();\n        RealMatrix rt = qr.transpose();\n        RealMatrix rtR = rt.multiply(qr);\n        RealMatrix rtRInverse = new SingularValueDecomposition(rtR).getSolver().getInverse();\n        covariance = rtRInverse.multiply(rt);\n        return covariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // get the number of regression parameters\n        final int p = beta.getDimension();\n\n        // get the QR decomposition of X\n        final QRDecomposition qr = new QRDecomposition(getX());\n\n        // get the top p rows of R\n        final RealMatrix r = qr.getR();\n        final RealMatrix rTop = r.getSubMatrix(0, p - 1, 0, r.getColumnDimension() - 1);\n\n        // get the inverse of R\n        final RealMatrix rInv = new LUDecomposition(rTop).getSolver().getInverse();\n\n        // return the inverse of R multiplied by the transpose of R\n        return rInv.multiply(rInv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the X matrix from the super class\n        RealMatrix x = getX();\n\n        // Get the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(x);\n\n        // Get the R matrix from the QR decomposition\n        RealMatrix r = qr.getR();\n\n        // Get the top p rows of R\n        int p = getBeta().getDimension();\n        RealMatrix rTop = r.getSubMatrix(0, p - 1, 0, r.getColumnDimension() - 1);\n\n        // Calculate the inverse of R\n        RealMatrix rInv = new LUDecomposition(rTop).getSolver().getInverse();\n\n        // Calculate the variance-covariance matrix of the beta vector\n        RealMatrix betaVar = rInv.multiply(rInv.transpose());\n\n        return betaVar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = getX().transpose().multiply(getX());\n        QRDecomposition qr = new QRDecomposition(XtX);\n        RealMatrix R = qr.getR();\n        int p = getBeta().getColumnDimension();\n        return R.getSubMatrix(0, p - 1, 0, p - 1).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate the inverse of the X matrix\n        final RealMatrix invX = qr.getQ().transpose().multiply(qr.getR().inverse());\n        // Calculate the inverse of the X transpose matrix\n        final RealMatrix invXT = invX.transpose();\n        // Calculate the variance-covariance matrix\n        return invXT.multiply(invX);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print((long)offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    // delegate to the underlying dataset\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        if (!result.containsKey(currentSlot.getName())) {\n          result.put(currentSlot.getName(), currentSlot);\n        }\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        result.put(currentSlot.getName(), currentSlot);\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        if (!result.containsKey(currentSlot.getName())) {\n          result.put(currentSlot.getName(), currentSlot);\n        }\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        result.put(currentSlot.getName(), currentSlot);\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n  for (LinkedFlowScope currentScope = this;\n       currentScope != blindScope;\n       currentScope = currentScope.parent) {\n    for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n         currentSlot != null &&\n             (currentScope.parent == null ||\n              currentScope.parent.lastSlot != currentSlot);\n         currentSlot = currentSlot.parent) {\n      if (result.containsKey(currentSlot.getName())) {\n        continue;\n      }\n      result.put(currentSlot.getName(), currentSlot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        slots.put(currentSlot.getName(), currentSlot);\n      }\n    }\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n  for (LinkedFlowScope currentScope = this;\n       currentScope != blindScope;\n       currentScope = currentScope.parent) {\n    for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n         currentSlot != null &&\n             (currentScope.parent == null ||\n              currentScope.parent.lastSlot != currentSlot);\n         currentSlot = currentSlot.parent) {\n      result.put(currentSlot.getName(), currentSlot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        if (result.containsKey(currentSlot.getName())) {\n          result.remove(currentSlot.getName());\n        }\n      }\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n  for (LinkedFlowScope currentScope = this;\n       currentScope != blindScope;\n       currentScope = currentScope.parent) {\n    for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n         currentSlot != null &&\n             (currentScope.parent == null ||\n              currentScope.parent.lastSlot != currentSlot);\n         currentSlot = currentSlot.parent) {\n      result.put(currentSlot.getName(), currentSlot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (LinkedFlowScope currentScope = this;\n         currentScope != blindScope;\n         currentScope = currentScope.parent) {\n      for (LinkedFlowSlot currentSlot = currentScope.lastSlot;\n           currentSlot != null &&\n           (currentScope.parent == null ||\n            currentScope.parent.lastSlot != currentSlot);\n           currentSlot = currentSlot.parent) {\n        result.put(currentSlot.getName(), currentSlot);\n      }\n    }\n    return result;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0.0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n}\n}\n}",
      "public static double atanh(double a)  {\n        return 0.5 * FastMath.log((1 + a) / (1 - a));\n    }",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0.0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (Double.isNaN(a)) {\n        return a;\n    }\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n        return FastMath.log( (1 + a) / (1 - a) ) / 2;\n    }",
      "public static double atanh(double a)  {\n        return FastMath.log( (1.0 + a) / (1.0 - a) ) / 2.0;\n    }",
      "public static double atanh(double a)  {\n        if (Double.isNaN(a)) {\n            return a;\n        }\n        if (a < -1.0 || a > 1.0) {\n            return Double.NaN;\n        }\n        if (a == 0) {\n            return a;\n        }\n        if (a < 0) {\n            return -FastMath.log((1 + a) / (1 - a)) / 2;\n        }\n        return FastMath.log((1 + a) / (1 - a)) / 2;\n    }",
      "public static double atanh(double a)  {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    double absAsinh;\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n        if (Double.isNaN(a)) {\n            return a;\n        }\n        if (a < -1.0 || a > 1.0) {\n            return Double.NaN;\n        }\n        if (a == 0.0) {\n            return a;\n        }\n        if (a < 0.0) {\n            return -FastMath.log((1.0 - a) / (1.0 + a)) / 2.0;\n        }\n        return FastMath.log((1.0 + a) / (1.0 - a)) / 2.0;\n    }"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = Sum.of(values).getResult();\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_EQUALS_ZERO);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_FINITE_NUMBER,\n                                               normalizedSum);\n    }\n\n    double factor = normalizedSum / sum;\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * factor;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = Sum.of(values);\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_IS_ZERO);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM,\n                                               normalizedSum);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (double v : values) {\n            if (Double.isInfinite(v)) {\n                throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n            }\n            sum += v;\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_IS_ZERO);\n        }\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_SUM);\n        }\n\n        double[] out = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                out[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return out;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (double v : values) {\n        if (!Double.isNaN(v)) {\n            sum += v;\n        }\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_NORMALIZED_SUM);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    }\n\n    double factor = normalizedSum / sum;\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        double v = values[i];\n        if (!Double.isNaN(v)) {\n            out[i] = v * factor;\n        } else {\n            out[i] = v;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        sum += values[i];\n    }\n\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NAN);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_ZERO);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        sum += values[i];\n    }\n\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NAN);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_ZERO);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_FOR_SUM,\n                                                   normalizedSum);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_OF_INPUT_VALUES_IS_ZERO);\n        }\n\n        double[] out = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                out[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return out;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n            }\n        }\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_FOR_SUM,\n                                                   normalizedSum);\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_EQUAL_TO_ZERO);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = Sum.of(values).getResult();\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_OR_NAN_ARRAY);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_AS_TARGET_SUM);\n    }\n\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = values[i];\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        sum += values[i];\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM, sum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_AROUND_ZERO);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealMatrix beta = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return new ArrayRealVector(beta.getColumn(0));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealMatrix beta = new LUDecomposition(XTOIX).getSolver().getInverse().multiply(XTOIY);\n        return beta.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() == 0 ? null : elements.get(0);\n}",
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n        if (id == null) {\n            return null;\n        }\n        if (id.equals(id())) {\n            return this;\n        }\n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        return elements.isEmpty() ? null : elements.first();\n    }",
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.first();\n}",
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.get(0);\n}",
      "public Element getElementById(String id)  {\n        for (Element e : this) {\n            if (e.id().equals(id))\n                return e;\n            Elements els = e.getElementsByAttributeValue(\"id\", id);\n            if (!els.isEmpty())\n                return els.first();\n        }\n        return null;\n    }",
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() == 0 ? null : els.get(0);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    for (int i = 0; i < c.length; i++) {\n        switch (c[i]) {\n        case START_FE:\n            fmtCount++;\n            result.append(START_FE).append(readArgumentIndex(pattern, next(i)));\n            break;\n        case START_FMT:\n            result.append(START_FMT).append(customPatterns.get(fmtCount - 1));\n            break;\n        case END_FE:\n            result.append(END_FE);\n            break;\n        default:\n            result.append(c[i]);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern);\n    for (int i = 0; i < customPatterns.size(); i++) \n    {\n        result.insert(result.indexOf(START_FE + i + END_FE), START_FMT + customPatterns.get(i) + END_FMT);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    int last = 0;\n    for (int i = 0; i < customPatterns.size(); i++) {\n        final int start = pattern.indexOf(START_FE, last);\n        result.append(pattern, last, start);\n        result.append(START_FE);\n        result.append(customPatterns.get(i));\n        result.append(END_FE);\n        last = pattern.indexOf(END_FE, start) + 1;\n    }\n    result.append(pattern, last, pattern.length());\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int fmtCount = 0;\n    for (int i = 0; i < pattern.length(); i++) \n    {\n        char c = pattern.charAt(i);\n        if (c == START_FE) \n        {\n            fmtCount++;\n            seekNonWs(pattern, i);\n            final int start = i;\n            final int index = readArgumentIndex(pattern, next(i));\n            result.append(START_FE).append(index);\n            seekNonWs(pattern, i);\n            if (c[i] == START_FMT) \n            {\n                result.append(START_FMT).append(customPatterns.get(fmtCount - 1));\n            }\n            if (c[i] != END_FE) \n            {\n                throw new IllegalArgumentException(\n                        \"Unreadable format element at position \" + start);\n            }\n            //$FALL-THROUGH$\n        } \n        else \n        {\n            result.append(c);\n            next(i);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        switch (c[i]) {\n        case START_FE:\n            fmtCount++;\n            result.append(START_FE).append(readArgumentIndex(pattern, i + 1));\n            seekNonWs(pattern, i);\n            i = pos.getIndex();\n            break;\n        case END_FE:\n            fmtCount--;\n            result.append(END_FE);\n            break;\n        case START_FMT:\n            result.append(START_FMT).append(customPatterns.get(fmtCount));\n            break;\n        default:\n            result.append(c[i]);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) \n    {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    int last = 0;\n    for (int i = 0; i < customPatterns.size(); i++) \n    {\n        final String custom = customPatterns.get(i);\n        final int start = pattern.indexOf(custom, last);\n        result.append(pattern, last, start);\n        result.append(START_FMT).append(custom).append(END_FMT);\n        last = start + custom.length();\n    }\n    result.append(pattern, last, pattern.length());\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    for (int i = 0; i < c.length; i++) {\n        if (c[i] == START_FE) {\n            fmtCount++;\n        }\n        result.append(c[i]);\n        if (c[i] == END_FE && fmtCount < customPatterns.size()) {\n            result.append(START_FMT).append(customPatterns.get(fmtCount)).append(END_FMT);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    for (int i = 0; i < c.length; i++) {\n        switch (c[i]) {\n        case START_FE:\n            fmtCount++;\n            seekNonWs(pattern, new ParsePosition(i));\n            final int start = i;\n            final int index = readArgumentIndex(pattern, next(new ParsePosition(i)));\n            result.append(START_FE).append(index);\n            seekNonWs(pattern, new ParsePosition(i));\n            if (c[i] == START_FMT) {\n                result.append(START_FMT).append(customPatterns.get(fmtCount - 1));\n            }\n            break;\n        default:\n            result.append(c[i]);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    for (int i = 0; i < c.length; i++) {\n        switch (c[i]) {\n        case START_FE:\n            fmtCount++;\n            result.append(START_FE).append(readArgumentIndex(pattern, i + 1));\n            i = seekNonWs(pattern, i + 1);\n            if (c[i] == START_FMT) {\n                result.append(START_FMT).append(customPatterns.get(fmtCount - 1));\n            }\n            break;\n        case END_FE:\n            result.append(END_FE);\n            break;\n        case QUOTE:\n            result.append(appendQuotedString(pattern, i, null, true));\n            break;\n        default:\n            result.append(c[i]);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int fmtCount = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        if (pattern.charAt(i) == START_FE) {\n            fmtCount++;\n            seekNonWs(pattern, new ParsePosition(i));\n            final int start = i;\n            final int index = readArgumentIndex(pattern, next(new ParsePosition(i)));\n            result.append(START_FE).append(index);\n            seekNonWs(pattern, new ParsePosition(i));\n            if (pattern.charAt(i) == START_FMT) {\n                result.append(START_FMT).append(customPatterns.get(fmtCount - 1));\n            }\n            if (pattern.charAt(i) != END_FE) {\n                throw new IllegalArgumentException(\n                        \"Unreadable format element at position \" + start);\n            }\n            i = next(new ParsePosition(i)).getIndex();\n        } else {\n            result.append(pattern.charAt(i));\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!typeVarMap.containsKey(fromArg)) {\n        typeVarMap.put((String) fromArg, toArg);\n      }\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!typeVarMap.containsKey(fromArg)) {\n        typeVarMap.put((String) fromArg, toArg);\n      }\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!typeVarMap.containsKey(fromArg)) {\n        typeVarMap.put((String) fromArg, toArg);\n      }\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!typeVarMap.containsKey(fromArg)) {\n        typeVarMap.put((String) fromArg, toArg);\n      }\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!typeVarMap.containsKey(fromArg)) {\n        typeVarMap.put((String) fromArg, toArg);\n      }\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n}\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n  if (typeVarMap.get(from.getRawType().toString()) == to.getRawType()) {\n    return true;\n  }\n\n  // check if they are equivalent under our current mapping.\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (typeEquals(ptype, to, typeVarMap)) {\n      return true;\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (typeVarMap.containsKey(from.getRawType().toString()) && typeVarMap.get(from.getRawType().toString()).equals(to.getRawType())) {\n      return true;\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to)) {\n    return true;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    while (fromArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) fromArg;\n      fromArg = typeVarMap.get(v.getName());\n    }\n    while (toArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) toArg;\n      toArg = typeVarMap.get(v.getName());\n    }\n    if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (typeVarMap.get(to.getRawType().getName()) != null) {\n      return typeVarMap.get(to.getRawType().getName()).equals(from.getRawType());\n    }\n    return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  return $Gson$Types.equals(from.getRawType(), to.getRawType())\n      && Arrays.equals(from.getActualTypeArguments(), to.getActualTypeArguments());\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  return from.equals(to);\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to)) {\n    return true;\n  }\n  if (from.getRawType().equals(to.getRawType())) {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(v.getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(v.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // if they can't be resolved to classes, they're not equal\n  Class<?> fromRaw = $Gson$Types.getRawType(from);\n  Class<?> toRaw = $Gson$Types.getRawType(to);\n  if (fromRaw == null || toRaw == null) {\n    return false;\n  }\n\n  // check if they're equal under our current mapping\n  if (fromRaw.equals(toRaw)) {\n    return true;\n  }\n\n  // check if one is a subtype of the other\n  if (isAssignableFrom(from, to, typeVarMap)) {\n    return true;\n  }\n\n  // if the raw types are different, the types aren't equal\n  return false;\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Iterator<E> tmp = (Iterator<E>) iterator;\n            return tmp;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Iterator<E> tmp = (Iterator<E>) iterator;\n            return tmp;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  if (node == null) {\n    return null;\n  }\n  N superNode = null;\n  N partition = getColor(node);\n  if (partition != null) {\n    superNode = partition;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N partition = coloring.get(node);\n    N superNode = partitionToSuperNode.get(partition);\n    if (superNode == null) {\n        superNode = node;\n        partitionToSuperNode.put(partition, superNode);\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  // TODO: Implement this method\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  int partition = getColor(node);\n  for (N neighbor : getNeighborNodes(node)) {\n    if (getColor(neighbor) == partition) {\n      return neighbor;\n    }\n  }\n  return node;\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (getColor(node) == null) \n  {\n    return node;\n  }\n  else \n  {\n    return getPartitionSuperNode(getColor(node));\n  }\n}",
      "public N getPartitionSuperNode(N node)  {\n  N partitionSuperNode = null;\n  int partition = coloring.get(node);\n  for (N n : getNeighborNodes(node))\n  {\n    if (coloring.get(n) == partition)\n    {\n      if (partitionSuperNode == null)\n      {\n        partitionSuperNode = n;\n      }\n      else\n      {\n        partitionSuperNode = null;\n        break;\n      }\n    }\n  }\n  return partitionSuperNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  N superNode = null;\n  if (node != null) {\n    int partition = coloring.get(node);\n    for (N n : getNeighborNodes(node)) {\n      if (coloring.get(n) == partition) {\n        superNode = getPartitionSuperNode(n);\n        break;\n      }\n    }\n    if (superNode == null) {\n      superNode = node;\n    }\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    int partition = getColoring(node);\n    for (N neighbor : getNeighborNodes(node)) \n    {\n        if (getColoring(neighbor) == partition) \n        {\n            superNode = neighbor;\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  N superNode = null;\n  int partition = coloring.get(node);\n  for (N n : getNeighborNodes(node))\n  {\n    if (coloring.get(n) == partition)\n    {\n      if (superNode == null)\n      {\n        superNode = n;\n      }\n      else\n      {\n        superNode = getPartitionSuperNode(superNode);\n      }\n    }\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  // TODO(user): Implement this method.\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += f.value(points[i]) * weights[i];\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += f.value(points[i]) * weights[i];\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Only process expressions that are not part of an assignment operation\n  // or the LHS of an assignment operation.\n  if (NodeUtil.isExpressionNode(expr) && !NodeUtil.isAssignmentOp(parent) &&\n      !(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == expr)) {\n    // If the expression is a string literal, replace it with a short encoded\n    // string expression.\n    if (expr.isString()) {\n      String originalString = expr.getString();\n      String encodedString = encodeString(originalString);\n      Node replacementNode = NodeUtil.newString(encodedString);\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String shortString = shortenString(expr.getString());\n    if (shortString != null) {\n      Node replacement = NodeUtil.newString(t.getSourceName(), shortString);\n      replacement.copyInformationFrom(expr);\n      parent.replaceChild(expr, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String string = expr.getString();\n    if (string.length() > 2) {\n      String encoded = encodeString(string);\n      if (encoded != null) {\n        Node replacement = NodeUtil.newString(encoded).srcref(expr);\n        parent.replaceChild(expr, replacement);\n        t.reportCodeChange();\n        return replacement;\n      }\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String originalString = expr.getString();\n    String shortenedString = shortenString(originalString);\n    if (shortenedString != null) {\n      Node replacementNode = IR.string(shortenedString);\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String encodedString = encodeString(expr.getString());\n    Node replacementNode = IR.string(encodedString).srcref(expr);\n    parent.replaceChild(expr, replacementNode);\n    t.reportCodeChange();\n    return replacementNode;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String originalString = expr.getString();\n    String encodedString = encodeString(originalString);\n    if (encodedString.length() < originalString.length()) {\n      Node replacementNode = IR.string(encodedString).srcref(expr);\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Only process string expressions\n  if (expr.getType() != Token.STRING)\n    return expr;\n\n  // Get the string value\n  String value = expr.getString();\n\n  // If the string is short enough, leave it alone\n  if (value.length() <= 5)\n    return expr;\n\n  // Encode the string\n  String encoded = encodeString(value);\n\n  // If the encoded string is longer than the original, leave it alone\n  if (encoded.length() > value.length())\n    return expr;\n\n  // Replace the expression with the encoded string\n  Node replacement = Node.newString(Token.STRING, encoded);\n  parent.replaceChild(expr, replacement);\n  t.reportCodeChange();\n  return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Check if the expression is a string literal\n  if (expr.isString())\n  {\n    // Check if the string is a valid base64 encoded string\n    if (isBase64Encoded(expr.getString()))\n    {\n      // Create a new string literal node with the encoded string\n      Node newExpr = IR.string(encodeBase64(expr.getString()));\n      newExpr.useSourceInfoIfMissingFromForTree(expr);\n\n      // Replace the original expression with the new expression\n      parent.replaceChild(expr, newExpr);\n\n      // Return the new expression\n      return newExpr;\n    }\n  }\n\n  // Return the original expression if no replacement was made\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String shortString = shortenString(expr.getString());\n        Node replacementNode = NodeUtil.newString(t.getSourceFile(), shortString);\n        parent.replaceChild(expr, replacementNode);\n        t.reportCodeChange();\n        return replacementNode;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String originalString = expr.getString();\n    String encodedString = encodeString(originalString);\n    if (encodedString.length() < originalString.length()) \n    {\n      Node replacementNode = IR.string(encodedString);\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n      return replacementNode;\n    }\n  }\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.getDescription() != null) {\n      builder.setDescription(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n        String desc = info.getDescription();\n        if (desc != null) {\n            builder.setDescription(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      builder.setDescription(desc);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      builder.setDescription(desc);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n        String desc = info.getDescription();\n        if (desc != null) {\n            builder.setDescription(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n        String desc = info.getDescription();\n        if (desc != null) {\n            builder.setDescription(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      builder.setDescription(desc);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc != null) {\n        String desc = jsDoc.getDescription();\n        if (desc != null) {\n            builder.setDescription(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.isDeprecated()) {\n      builder.setDeprecated(info.getDeprecationReason());\n    }\n    if (info.isConstant()) {\n      builder.setConstant(true);\n    }\n    if (info.isOverride()) {\n      builder.setOverride(true);\n    }\n    if (info.isHidden()) {\n      builder.setHidden(true);\n    }\n    if (info.isTransient()) {\n      builder.setTransient(true);\n    }\n    if (info.isNoCompile()) {\n      builder.setNoCompile(true);\n    }\n    if (info.isExport()) {\n      builder.setExport(true);\n    }\n    if (info.isAbstract()) {\n      builder.setAbstract(true);\n    }\n    if (info.isFinal()) {\n      builder.setFinal(true);\n    }\n    if (info.isStatic()) {\n      builder.setStatic(true);\n    }\n    if (info.isConstructor()) {\n      builder.setConstructor(true);\n    }\n    if (info.isOverride()) {\n      builder.setOverride(true);\n    }\n    if (info.isImplemented()) {\n      builder.setImplemented(true);\n    }\n    if (info.isSuppressed()) {\n      builder.setSuppressed(true);\n    }\n    if (info.isImplements()) {\n      builder.setImplements(true);\n    }\n    if (info.isInterface()) {\n      builder.setInterface(true);\n    }\n    if (info.isEnum()) {\n      builder.setEnum(true);\n    }\n    if (info.isTypedef()) {\n      builder.setTypedef(true);\n    }\n    if (info.isExport()) {\n      builder.setExport(true);\n    }\n    if (info.isPrivate()) {\n      builder.setPrivate(true);\n    }\n}\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo jsDoc = node.getJSDocInfo();\n  if (jsDoc != null) {\n    String desc = jsDoc.getDescription();\n    if (desc != null) {\n      builder.setDescription(desc);\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double meanX = sumX / xArray.length;\n        double meanY = sumY / yArray.length;\n        double covariance = sumXY / xArray.length - meanX * meanY;\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sumX = 0d;\n    double sumY = 0d;\n    double sumXX = 0d;\n    double sumYY = 0d;\n    double sumXY = 0d;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double covariance = (sumXY - (sumX * sumY) / xArray.length) / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance *= (xArray.length / (xArray.length - 1d));\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - (sumX * sumY / xArray.length)) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= (xArray.length / (xArray.length - 1));\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance = covariance * xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance = covariance * xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXX = 0d;\n        double sumYY = 0d;\n        double sumXY = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - (sumX * sumY) / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= (xArray.length / (xArray.length - 1));\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double cov = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            cov = cov * xArray.length / (xArray.length - 1);\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0d;\n        double sumY = 0d;\n        double sumXY = 0d;\n        double sumX2 = 0d;\n        double sumY2 = 0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance = covariance * xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(in, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(is, value);\n    count(skipped);\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: implement this method\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String content = sb.toString();\n    long fp = FP.fingerprint(content);\n    return Long.toString(fp, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: implement this method\n    return \"\";\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement the fingerprinting algorithm\n    return \"\";\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String tcValue = sb.toString();\n    return Long.toString(FP.fingerprint(tcValue), Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement the fingerprinting algorithm\n    return null;\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    return Long.toString(FP.fingerprint(sb.toString()), Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      sb.append(part);\n    }\n    String tcValue = sb.toString();\n    return Long.toString(FP.fingerprint(tcValue), Character.MAX_RADIX);\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    //\n    // The expected format looks like this:\n    //\n    // [generatorName]\n    // someId:someFile:theLine:theColumn\n    //\n    //\n\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    String tcValue = sb.toString();\n\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n  }"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long offset = maxDistanceFromEnd;\n        while (offset >= minDistanceFromEnd) {\n            raf.seek(offset);\n            raf.read(buf);\n            for (int i = 0; i < sig.length; i++) {\n                if (buf[i] != sig[i]) {\n                    offset--;\n                    break;\n                }\n            }\n            if (offset == minDistanceFromEnd) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        if (minDistanceFromEnd < 0 || maxDistanceFromEnd < minDistanceFromEnd) {\n            throw new IllegalArgumentException(\"Invalid distance\");\n        }\n        if (sig.length > maxDistanceFromEnd) {\n            throw new IllegalArgumentException(\"Signature too long\");\n        }\n\n        final long pos = raf.length() - maxDistanceFromEnd;\n        raf.seek(pos);\n        final byte[] buf = new byte[sig.length];\n        raf.readFully(buf);\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n\n        final long step = Math.max(1, (maxDistanceFromEnd - minDistanceFromEnd) / 100);\n        for (long i = pos + step; i >= pos + minDistanceFromEnd; i -= step) {\n            raf.seek(i);\n            raf.readFully(buf);\n            if (Arrays.equals(buf, sig)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = raf.length() - minDistanceFromEnd;\n        while (pos >= raf.length() - maxDistanceFromEnd) {\n            raf.seek(pos);\n            if (raf.read() == sig[0]) {\n                int i;\n                for (i = 1; i < sig.length; i++) {\n                    if (raf.read() != sig[i]) {\n                        break;\n                    }\n                }\n                if (i == sig.length) {\n                    return true;\n                }\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = maxDistanceFromEnd;\n        while (pos >= minDistanceFromEnd) {\n            raf.seek(pos);\n            pos--;\n            raf.read(buf, 0, 1);\n            if (buf[0] == sig[0]) {\n                raf.seek(pos);\n                raf.read(buf, 0, sig.length);\n                if (Arrays.equals(buf, sig)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        if (minDistanceFromEnd > maxDistanceFromEnd) {\n            return false;\n        }\n        final long pos = raf.length() - minDistanceFromEnd;\n        raf.seek(pos);\n        final byte[] buf = new byte[sig.length];\n        raf.readFully(buf);\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n        return tryToLocateSignature(minDistanceFromEnd + 1,\n                                    maxDistanceFromEnd, sig);\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long maxOffset = Math.min(maxDistanceFromEnd, fileLength - sig.length);\n        final long minOffset = Math.max(0, fileLength - maxDistanceFromEnd);\n        long offset = minOffset;\n        int sigOffset = 0;\n        int readOffset = 0;\n        int readLength = 0;\n        byte[] readBuffer = null;\n        boolean found = false;\n        while (offset >= minOffset && !found) {\n            readOffset = (int) (offset - minOffset);\n            readLength = (int) Math.min(sig.length - sigOffset, maxOffset - offset);\n            if (readBuffer == null || readBuffer.length < readLength) {\n                readBuffer = new byte[readLength];\n            }\n            file.seek(offset);\n            file.readFully(readBuffer, 0, readLength);\n            while (sigOffset < sig.length && sigOffset + readOffset < readBuffer.length\n                    && sig[sigOffset] == readBuffer[sigOffset + readOffset]) {\n                sigOffset++;\n            }\n            if (sigOffset == sig.length) {\n                found = true;\n            } else {\n                offset--;\n                sigOffset = 0;\n            }\n        }\n        if (found) {\n            file.seek(offset + sigOffset);\n        }\n        return found;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long end = file.length();\n        long pos = end - minDistanceFromEnd;\n        while (pos >= end - maxDistanceFromEnd) {\n            file.seek(pos);\n            if (file.read(sig) == sig.length) {\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = minDistanceFromEnd;\n        while (distance <= maxDistanceFromEnd) {\n            final long pos = file.length() - distance;\n            file.seek(pos);\n            final int read = file.read(buf.array(), 0, sig.length);\n            if (read == sig.length) {\n                for (int i = 0; i < sig.length; i++) {\n                    if (buf.get(i) != sig[i]) {\n                        break;\n                    }\n                    if (i == sig.length - 1) {\n                        return true;\n                    }\n                }\n            }\n            distance++;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = minDistanceFromEnd;\n        while (distance <= maxDistanceFromEnd) {\n            long offset = raf.length() - distance;\n            raf.seek(offset);\n            boolean found = true;\n            for (int i = 0; i < sig.length; i++) {\n                if (sig[i] != raf.readByte()) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) {\n                return true;\n            }\n            distance++;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = minDistanceFromEnd;\n        while (distance <= maxDistanceFromEnd) {\n            final long pos = file.length() - distance;\n            file.seek(pos);\n            if (file.read() == sig[0]) {\n                if (file.read() == sig[1]) {\n                    if (file.read() == sig[2]) {\n                        if (file.read() == sig[3]) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            distance++;\n        }\n        return false;\n    }"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_b != null) {\n        return new ByteArrayInputStream(_b, _ptr, _end - _ptr);\n    }\n    return _in;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_ctxt, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_ctxt, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    if (_b == null) {\n        return _in;\n    }\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_ctxt, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < this.sectionKeys.length) {\n        result = this.sectionKeys[section];\n    }\n    else {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < this.sectionKeys.length) {\n        result = this.sectionKeys[section];\n    }\n    else {\n        result = createSectionKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) \n    {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) \n    {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < getItemCount()) \n    {\n        result = getKey(section);\n    }\n    else \n    {\n        result = \"SECTION_\" + section;\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) \n    {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) \n    {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) \n    {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) \n    {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT &&\n                    _numberType == NumberType.NaN);\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_INT || _currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonStreamContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            if (ctxt instanceof TokenBufferReadContext) {\n                try {\n                    return ((TokenBufferReadContext) ctxt).isNaN();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Integer) {\n                    return false;\n                }\n                if (ob instanceof Double) {\n                    return Double.isNaN((Double) ob);\n                }\n                return false;\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            return super.isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN(getDoubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // 25-Jun-2015, tatu: as per [databind#838], needs to be same as ParserBase\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN(_numberValue);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT && _currentFloat == Float.NaN);\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            Object ob = _currentObject();\n            if (ob instanceof Double) {\n                return ((Double) ob).isNaN();\n            }\n            if (ob instanceof Float) {\n                return ((Float) ob).isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT) && (_numberType == NumberType.NaN);\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n        final String abrevMarker = \"...\";\n        if (offset <= 4) {\n            return str.substring(0, maxWidth - 3) + abrevMarker;\n        }\n        if (maxWidth < 7) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n        }\n        if (offset + maxWidth - 3 < str.length()) {\n            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n        }\n        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n    }"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbol) \n    {\n        lastSymbol = symbolName;\n        Integer index = symbolMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolIndex = index;\n        } \n        else \n        {\n            lastSymbolIndex = symbolMap.size();\n            symbolMap.put(symbolName, lastSymbolIndex);\n        }\n    }\n    return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbol) \n    {\n        lastSymbol = symbolName;\n        Integer index = symbolMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolIndex = index;\n        } \n        else \n        {\n            lastSymbolIndex = symbolMap.size();\n            symbolMap.put(symbolName, lastSymbolIndex);\n        }\n    }\n    return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = nameMap.size();\n  nameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n    Integer index = nameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = nameMap.size();\n    nameMap.put(symbolName, index);\n    return index;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName)\n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null)\n        {\n            lastSymbolNameIndex = index;\n        }\n        else\n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = nameMap.size();\n  nameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbol) {\n    lastSymbol = symbolName;\n    Integer index = symbolMap.get(symbolName);\n    if (index != null) {\n      lastSymbolIndex = index;\n    } else {\n      lastSymbolIndex = symbolMap.size();\n      symbolMap.put(symbolName, lastSymbolIndex);\n    }\n  }\n  return lastSymbolIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  double result;\n  if (p == PEEKED_LONG) {\n    result = (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    result = Double.parseDouble(peekedString);\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString); // don't catch this NumberFormatException.\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString); // don't catch this NumberFormatException.\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString); // don't catch this NumberFormatException.\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString);\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString); // don't catch this NumberFormatException.\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    long asLong = Long.parseLong(peekedString); // don't catch this NumberFormatException.\n    result = (double) asLong;\n    if (result != asLong) { // Make sure no precision was lost casting to 'int'.\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  double result;\n  if (p == PEEKED_LONG) {\n    result = (double) peekedLong;\n    if (peekedLong != result) { // Make sure no precision was lost casting to 'double'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedLong + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  long asLong = Long.parseLong(peekedString);\n  result = (double) asLong;\n  if (result != asLong) { // Make sure no precision was lost casting to 'double'.\n}\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  double result;\n  if (p == PEEKED_LONG) {\n    result = (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    result = Double.parseDouble(peekedString);\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      result = Double.parseDouble(nextUnquotedValue());\n    } else {\n      result = Double.parseDouble(nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'));\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) \n        {\n            return null;\n        }\n        if (repeat <= 0) \n        {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if(str == null) \n        {\n            return null;\n        }\n        if(repeat <= 0) \n        {\n            return \"\";\n        }\n        final int inputLength = str.length();\n        if(repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if(inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}\n//-----------------------------------------------------------------------\n// Padding\n//-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}\n//-----------------------------------------------------------------------\n// Padding\n//-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return \"\";\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n// StringUtils.java\nfinal int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if(str == null) {\n            return null;\n        }\n        if(repeat <= 0) {\n            return \"\";\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}\n// StringUtils.java\nfinal int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if(str == null) {\n            return null;\n        }\n        if(repeat <= 0) {\n            return \"\";\n        }\n        final int inputLength = str.length();\n        if(repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if(inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n// text/translate/NumericEntityUnescaper.java\nfinal char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n                if(start == seqEnd) {\n                    return 0;\n                }\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(end < seqEnd && ( input.charAt(end) >= '0' && input.charAt(end) <= '9' ||\n                                    input.charAt(end) >= 'a' && input.charAt(end) <= 'f' ||"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = headerId;\n    ZipExtraField ze = null;\n    if (type.equals(UnparseableExtraFieldData.HEADER)) {\n        ze = new UnparseableExtraFieldData();\n    } else {\n        final Class<?>[] cArg = new Class[1];\n        cArg[0] = ZipShort.class;\n        final Object[] arg = new Object[1];\n        arg[0] = type;\n        ze = (ZipExtraField) ExtraFieldUtils.getExtraFieldClasses()\n                .get(type).getDeclaredConstructor(cArg).newInstance(arg);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = headerId;\n    ZipExtraField ze = null;\n    try {\n        ze = (ZipExtraField) ExtraFieldUtils.getExtraFieldClasses(type).newInstance();\n        ze.setHeaderId(type);\n    } catch (final ClassCastException cce) {\n        ze = new UnrecognizedExtraField();\n        ze.setHeaderId(type);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    if (headerId != null) {\n        final ZipShort type = headerId;\n        final ZipShort creator = null;\n        final String className = ExtraFieldUtils.getExtraFieldClassName(type, creator);\n        if (className != null) {\n            ze = (ZipExtraField) Class.forName(className).newInstance();\n        }\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n    }\n    ze.setHeaderId(headerId);\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = ZipShort.get(headerId.getValue() & 0xffff);\n    ZipExtraField ze = null;\n    try {\n        ze = (ZipExtraField) ExtraFieldUtils.getExtraFieldClasses()[type.getValue()].newInstance();\n    } catch (final ArrayIndexOutOfBoundsException aioobe) {\n        // fall back to UnrecognizedExtraField\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n        ze.setHeaderId(type);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = EXTRA_FIELD_MAP.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = headerId;\n    final ZipShort subtype = null;\n    return createExtraField(type, subtype);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    try {\n        final Class<?> c = ExtraFieldUtils.getExtraFieldImpl(headerId);\n        if (c != null) {\n            ze = (ZipExtraField) c.newInstance();\n        }\n    } catch (final ClassNotFoundException cnfe) {\n        // ignore\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n        ze.setHeaderId(headerId);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = headerId;\n    final String className = ZIP_EXTRA_FIELD_CLASSES.get(type);\n    if (className != null) {\n        return (ZipExtraField) Class.forName(className).newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    if (headerId != null) {\n        final ZipShort type = ZipShort.get(headerId.getValue() & 0x0000ffff);\n        final String className = EXTRA_FIELD_CLASSES.get(type);\n        if (className != null) {\n            try {\n                ze = (ZipExtraField) Class.forName(className).newInstance();\n            } catch (final ClassNotFoundException cnfe) {\n                throw new InstantiationException(cnfe.getMessage());\n            }\n        }\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n    }\n    ze.setHeaderId(headerId);\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    try {\n        final Class<?> c = Class.forName(\n                \"org.apache.commons.compress.archivers.zip.\"\n                + ExtraFieldUtils.getExtraFieldClassName(headerId));\n        ze = (ZipExtraField) c.newInstance();\n    } catch (final ClassNotFoundException e) {\n        ze = new UnrecognizedExtraField();\n    }\n    ze.setHeaderId(headerId);\n    return ze;\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n        Map clone = (Map) map.clone();\n        for (Iterator i = clone.keySet().iterator(); i.hasNext();) {\n            Comparable key = (Comparable) i.next();\n            clone.put(key, cloneMarker((Marker) map.get(key)));\n        }\n        return clone;\n    }",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Iterator i = clone.entrySet().iterator(); i.hasNext();) {\n        Map.Entry entry = (Map.Entry) i.next();\n        entry.setValue(entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Iterator i = clone.entrySet().iterator(); i.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) i.next();\n        entry.setValue((Object) entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Iterator i = clone.keySet().iterator(); i.hasNext();) {\n        Object key = i.next();\n        clone.put(key, cloneMarker((Marker) map.get(key)));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue((Object) entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        clone.put(entry.getKey(), entry.getValue());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {\n        Object key = iterator.next();\n        clone.put(key, ObjectUtilities.clone(map.get(key)));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n        Map clone = (Map) map.clone();\n        clone.putAll(map);\n        return clone;\n    }",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Iterator iterator = clone.keySet().iterator(); iterator.hasNext();) {\n        Object key = iterator.next();\n        Object value = clone.get(key);\n        if (value instanceof Shape) {\n            clone.put(key, ShapeUtilities.clone((Shape) value));\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        Comparable key = (Comparable) i.next();\n        clone.put(key, map.get(key));\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = element.getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = element.getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getCentralDirectoryData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        parent.addAll(offset + index, coll);\n        expectedModCount = parent.modCount;\n        size += cSize;\n        LinkedSubList.this.modCount++;\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        parent.addAll(offset + index, coll);\n        expectedModCount = parent.modCount;\n        size += cSize;\n        LinkedSubList.this.modCount++;\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        parent.addAll(offset + index, coll);\n        expectedModCount = parent.modCount;\n        size += cSize;\n        LinkedSubList.this.modCount++;\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (contains(obj)) {\n                continue;\n            }\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            LinkedSubList.this.modCount++;\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        parent.addAll(offset + index, coll);\n        expectedModCount = parent.modCount;\n        size += cSize;\n        LinkedSubList.this.modCount++;\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (contains(obj)) {\n                continue;\n            }\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            LinkedSubList.this.modCount++;\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        parent.addAll(offset + index, coll);\n        expectedModCount = parent.modCount;\n        size += cSize;\n        LinkedSubList.this.modCount++;\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (contains(obj)) {\n                continue;\n            }\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            LinkedSubList.this.modCount++;\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        //----------------------------------------------------------------------\n        // TODO: Implement this method\n        //----------------------------------------------------------------------\n        return false;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        final int cSize = coll.size();\n        if (cSize == 0) {\n            return false;\n        }\n\n        checkModCount();\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (contains(obj)) {\n                continue;\n            }\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            LinkedSubList.this.modCount++;\n        }\n        return true;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalizedConstraints.add(normalize(constraint));\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalizedConstraints.add(normalize(constraint));\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound)\n    {\n        return true;\n    }\n    if (this.lowerBound < bin.lowerBound && this.upperBound > bin.upperBound)\n    {\n        return true;\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound > bin.upperBound)\n    {\n        return true;\n    }\n    if (this.lowerBound < bin.lowerBound && this.upperBound == bin.upperBound)\n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.getLowerBound() && this.upperBound > bin.getUpperBound()) \n    {\n        return true;\n    }\n    else \n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound) \n    {\n        return true;\n    }\n    else if (this.lowerBound == bin.lowerBound) \n    {\n        return this.upperBound < bin.upperBound;\n    }\n    else if (this.upperBound == bin.upperBound) \n    {\n        return this.lowerBound > bin.lowerBound;\n    }\n    else \n    {\n        return this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    // TODO: implement this method\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound) \n    {\n        return true;\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound) {\n        return true;\n    }\n    if (this.lowerBound == bin.upperBound && this.upperBound == bin.lowerBound) {\n        return true;\n    }\n    if (this.lowerBound < bin.lowerBound && this.upperBound > bin.lowerBound) {\n        return true;\n    }\n    if (this.lowerBound < bin.upperBound && this.upperBound > bin.upperBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound) \n    {\n        return true;\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound < bin.upperBound) \n    {\n        return true;\n    }\n    if (this.lowerBound > bin.lowerBound && this.lowerBound < bin.upperBound) \n    {\n        return true;\n    }\n    if (this.upperBound > bin.lowerBound && this.upperBound < bin.upperBound) \n    {\n        return true;\n    }\n    if (this.lowerBound < bin.lowerBound && this.upperBound > bin.upperBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.getLowerBound() && this.upperBound >= bin.getLowerBound()) \n    {\n        return true;\n    }\n    else if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getUpperBound()) \n    {\n        return true;\n    }\n    else if (this.lowerBound >= bin.getLowerBound() && this.lowerBound <= bin.getUpperBound()) \n    {\n        return true;\n    }\n    else if (this.upperBound >= bin.getLowerBound() && this.upperBound <= bin.getUpperBound()) \n    {\n        return true;\n    }\n    else \n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) \n    {\n        return true;\n    }\n    if (this.lowerBound >= bin.lowerBound && this.lowerBound <= bin.upperBound) \n    {\n        return true;\n    }\n    if (this.upperBound >= bin.lowerBound && this.upperBound <= bin.upperBound) \n    {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] chars = str.toCharArray();\n        final List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(chars[tokenStart]);\n        for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n            final int type = Character.getType(chars[pos]);\n            if (type != currentType) {\n                if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                    final int newTokenStart = pos - 1;\n                    if (newTokenStart != tokenStart) {\n                        list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                        tokenStart = newTokenStart;\n                    }\n                } else {\n                    list.add(new String(chars, tokenStart, pos - tokenStart));\n                    tokenStart = pos;\n                }\n                currentType = type;\n            }\n        }\n        list.add(new String(chars, tokenStart, chars.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.isEmpty()) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        final char[] chars = str.toCharArray();\n        final List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(chars[tokenStart]);\n        for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n            final int type = Character.getType(chars[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(chars, tokenStart, chars.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                final int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] chars = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        final int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    // Parse the datetime text using the ISO parser.\n    // This will return a Partial that contains the date and time fields.\n    Partial partial = ISODateTimeFormat.dateTimeParser().parse(text);\n\n    // Get the chronology from the partial.\n    Chronology chrono = partial.getChronology();\n\n    // Get the time zone from the partial.\n    DateTimeZone zone = partial.getZone();\n\n    // Get the millisecond instant from the partial.\n    long millis = chrono.set(partial, 0);\n\n    // If the partial has a time zone, then convert the millisecond instant to\n    // the time zone of the partial.\n    if (zone != null) {\n        millis = zone.convertUTCToLocal(millis);\n    }\n\n    return millis;\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return new Instant(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return new Instant(text, ISOChronology.getInstance()).getMillis();\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n      case Token.NOT: {\n        MinimizedCondition subtree =\n            unoptimized(n.getFirstChild().detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.NOT, subtree.positive.cloneTree()).srcref(n),\n            subtree.negative);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.NOT, subtree.negative.cloneTree()).srcref(n),\n            subtree.positive);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      case Token.AND:\n      case Token.OR: {\n        int opType = n.getType();\n        int complementType = opType == Token.AND ? Token.OR : Token.AND;\n        MinimizedCondition leftSubtree =\n            unoptimized(n.getFirstChild().detachFromParent());\n        MinimizedCondition rightSubtree =\n            unoptimized(n.getLastChild().detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(opType, leftSubtree.positive.cloneTree(),\n                rightSubtree.positive.cloneTree()).srcref(n),\n            leftSubtree.negative,\n            rightSubtree.negative);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(complementType, leftSubtree.negative.cloneTree(),\n                rightSubtree.negative.cloneTree()).srcref(n),\n            leftSubtree.positive,\n            rightSubtree.positive);\n        return new MinimizedCondition(posTree, negTree);\n      }\n      case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        Node thenNode = cond.getNext();\n        Node elseNode = thenNode.getNext();\n        MinimizedCondition thenSubtree =\n            unoptimized(thenNode.detachFromParent());\n        MinimizedCondition elseSubtree =\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), 1000, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(new MeasuredNode(n, 0, false),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    int length = estimateCostOneLevel(n);\n    MeasuredNode positive = new MeasuredNode(n, length, false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  int length = estimateCostOneLevel(n);\n  return new MinimizedCondition(\n      new MeasuredNode(n, length, false),\n      new MeasuredNode(new Node(Token.SCRIPT).srcref(n), length * 1000, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    int length = estimateCost(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, length, false),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n), length + 1000, false));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(new MeasuredNode(n, 0, false),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n            Integer.MAX_VALUE, false));\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return getLexicalScopeDepth(scope.getParentScope()) + scope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return getLexicalScopeDepth(scope.getParentScope()) + scope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return ((LexicalScope) scope).getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return getLexicalScopeDepth(((PropertyScope) scope).getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return ((LexicalScope) scope).getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return scope.getDepth() + getLexicalScopeDepth(scope.getParentScope());\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return ((LexicalScope) scope).getDepth();\n  } else if (scope instanceof PropertyScope) {\n    PropertyScope propertyScope = (PropertyScope) scope;\n    int lexicalDepth = getLexicalScopeDepth(propertyScope.getParentScope());\n    return lexicalDepth + propertyScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    LexicalScope lexicalScope = scope.getParent();\n    return lexicalScope.getDepth() + getLexicalScopeDepth(lexicalScope);\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return ((LexicalScope) scope).getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return getLexicalScopeDepth(((PropertyScope) scope).getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    LexicalScope lexicalScope = ((PropertyScope) scope).getLexicalScope();\n    return lexicalScope.getDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    LexicalScope parentScope = scope.getParent();\n    return parentScope.getDepth() + 1;\n  } else {\n    return 0;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values)[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(values);\n    Validate.isTrue(enumClass.isEnum(), \"The class %s is not an enum\", enumClass);\n    Validate.isTrue(enumClass.getEnumConstants().length <= Long.SIZE, \"The class %s has more than 64 values\", enumClass);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = a;\n        Dfp x = a;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp x = a;\n    Dfp y = a.getOne();\n    Dfp c = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        c = c.divide(i);\n        y = y.add(x.multiply(c));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp x = a;\n        Dfp y = x;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = new Dfp(a);\n        Dfp x = new Dfp(y);\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = a.getOne();\n        Dfp x = a;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp y = a.getOne();\n    Dfp x = a;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.divide(i);\n        y = y.add(x);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a.multiply(a);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.divide(fact);\n\n        y = y.add(x);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n\n        fact = fact.multiply(i);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = new Dfp(a);\n        Dfp x = new Dfp(y);\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.divide(i);\n        y = y.add(x);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = a.getOne();\n        Dfp x = a;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        T threshold = getNorm().multiply(0.6);\n        if (threshold.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n            T inverse  = x.getField().getOne().divide(y.multiply(y).add(z.multiply(z)));\n            return new FieldVector3D<T>(x.getField().getZero(), z.multiply(inverse), x.getField().getZero().subtract(y.multiply(inverse)));\n        } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n            T inverse  = x.getField().getOne().divide(x.multiply(x).add(z.multiply(z)));\n            return new FieldVector3D<T>(z.multiply(inverse), x.getField().getZero(), x.getField().getZero().subtract(x.multiply(inverse)));\n        }\n        T inverse  = x.getField().getOne().divide(x.multiply(x).add(y.multiply(y)));\n        return new FieldVector3D<T>(y.multiply(inverse), x.getField().getZero().subtract(x.multiply(inverse)), x.getField().getZero());\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        T inverse  = x.getField().getZero().add(1).divide(getNorm());\n        return new FieldVector3D<T>(getField(),\n                                    getField().getZero(),\n                                    inverse.multiply(z),\n                                    inverse.multiply(x.negate()));\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        T inverse  = x.getField().getZero().add(1).divide(getNorm());\n        return new FieldVector3D<T>(getField(),\n                                    inverse.multiply(z),\n                                    getField().getZero(),\n                                    inverse.multiply(y.negate()));\n    }\n    T inverse  = x.getField().getZero().add(1).divide(getNorm());\n    return new FieldVector3D<T>(getField(),\n                                inverse.multiply(y),\n                                inverse.multiply(x.negate()),\n                                getField().getZero());\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(getField().getZero(), inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(getField().getZero(), -inverse * z, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, getField().getZero());\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        T inverse  = y.multiply(z).multiply(0.5).reciprocal();\n        return new FieldVector3D<T>(x.getField().getZero(), inverse.multiply(z), inverse.multiply(y).negate());\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        T inverse  = x.multiply(z).multiply(0.5).reciprocal();\n        return new FieldVector3D<T>(inverse.multiply(z).negate(), x.getField().getZero(), inverse.multiply(x));\n    }\n    T inverse  = x.multiply(y).multiply(0.5).reciprocal();\n    return new FieldVector3D<T>(inverse.multiply(y).negate(), inverse.multiply(x).negate(), x.getField().getZero());\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        T inverse  = x.multiply(0).subtract(z).divide(y.multiply(y).add(z.multiply(z)));\n        return new FieldVector3D<T>(x.getField().getZero(), inverse, z.negate());\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        T inverse  = x.multiply(0).subtract(z).divide(x.multiply(x).add(z.multiply(z)));\n        return new FieldVector3D<T>(z.negate(), x.getField().getZero(), inverse);\n    }\n    T inverse  = y.multiply(0).subtract(x).divide(x.multiply(x).add(y.multiply(y)));\n    return new FieldVector3D<T>(y.negate(), inverse, x.getField().getZero());\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(field.getZero(), inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(field.getZero(), -inverse * z, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, field.getZero());\n\n    }"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlapsRange(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T lower = (compareTo(other.getMinimum()) < 0) ? other.getMinimum() : getMinimum();\n    final T upper = (compareTo(other.getMaximum()) > 0) ? other.getMaximum() : getMaximum();\n    return new Range<T>(lower, upper);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T lower = (compareTo(other) <= 0 ? getLower() : other.getLower());\n    final T upper = (compareTo(other) <= 0 ? other.getUpper() : getUpper());\n    return new Range<T>(lower, upper);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlapsWith(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n    }\n    return new Range<>(\n            getMinimum().compareTo(other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum(),\n            getMaximum().compareTo(other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.getMinimum().compareTo(getMinimum()) < 0) {\n        throw new IllegalArgumentException(\"Range must be at least [\" + getMinimum() + \", \" + getMaximum() + \"] but was [\" + other.getMinimum() + \", \" + other.getMaximum() + \"]\");\n    }\n    if (other.getMaximum().compareTo(getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"Range must be no more than [\" + getMinimum() + \", \" + getMaximum() + \"] but was [\" + other.getMinimum() + \", \" + other.getMaximum() + \"]\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    return new Range<T>(other.getMinimum(), other.getMaximum());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlapsRange(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n    }\n    final T lower = (compareTo(other.getMinimum()) < 0) ? other.getMinimum() : getMinimum();\n    final T upper = (compareTo(other.getMaximum()) > 0) ? other.getMaximum() : getMaximum();\n    return between(lower, upper, getMinimumInclusive(), getMaximumInclusive());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.isAfterRange(this)) {\n        throw new IllegalArgumentException(\"Range must be after this range\");\n    }\n    if (other.isBeforeRange(this)) {\n        throw new IllegalArgumentException(\"Range must be before this range\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    final T lower = other.getMinimumNumber().compareTo(getMinimumNumber()) < 0 ? other.getMinimumNumber() : getMinimumNumber();\n    final T upper = other.getMaximumNumber().compareTo(getMaximumNumber()) > 0 ? other.getMaximumNumber() : getMaximumNumber();\n    return new Range<T>(lower, upper);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new NullPointerException(\"Range must not be null\");\n    }\n    if (other.getMaximum().compareTo(this.getMinimum()) < 0 || other.getMinimum().compareTo(this.getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T max = this.getMaximum().compareTo(other.getMaximum()) > 0 ? this.getMaximum() : other.getMaximum();\n    final T min = this.getMinimum().compareTo(other.getMinimum()) < 0 ? this.getMinimum() : other.getMinimum();\n    return Range.between(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new NullPointerException(\"Range must not be null\");\n    }\n    if (other.getMinimumNumber().compareTo(getMaximumNumber()) > 0 || other.getMaximumNumber().compareTo(getMinimumNumber()) < 0) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    return new Range<T>(\n            (other.getMinimumNumber().compareTo(getMinimumNumber()) > 0 ? other.getMinimumNumber() : getMinimumNumber()),\n            (other.getMaximumNumber().compareTo(getMaximumNumber()) < 0 ? other.getMaximumNumber() : getMaximumNumber()));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.isAfter(this)) {\n        throw new IllegalArgumentException(\"Cannot calculate intersection with a range after this range\");\n    }\n    if (other.isBefore(this)) {\n        throw new IllegalArgumentException(\"Cannot calculate intersection with a range before this range\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    return new Range<T>(other.getMinimum(), other.getMaximum());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other.getMaximum().compareTo(this.getMinimum()) < 0 || other.getMinimum().compareTo(this.getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n    }\n    return new Range<T>(\n            other.getMinimum().compareTo(this.getMinimum()) > 0 ? other.getMinimum() : this.getMinimum(),\n            other.getMaximum().compareTo(this.getMaximum()) < 0 ? other.getMaximum() : this.getMaximum());\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // note: this should not get called any more (caller checks, dispatches)\n    if (enc == JsonEncoding.UTF8) { // We have optimized writer for UTF-8\n        return new UTF8Generator(ctxt, out);\n    }\n    // not optimal, but should do unless we really care about UTF-16/32 encoding speed\n    return new OutputStreamWriter(out, enc.getJavaName());\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // note: this should not get called any more (caller checks, dispatches)\n    return new UTF8Generator(this, out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // note: this should not get called any more (caller checks, dispatches)\n    return new JsonGenerator(this, out, ctxt, true);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _getBufferRecycler());\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, ctxt, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _getBufferRecycler());\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    else if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    else if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    else \n    {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(String.class)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Class.class)) {\n        return ((Class<?>) o1).getName().equals(((Class<?>) o2).getName());\n    }\n    if (type.equals(Byte.TYPE) || type.equals(Short.TYPE) || type.equals(Integer.TYPE)\n            || type.equals(Character.TYPE) || type.equals(Long.TYPE) || type.equals(Float.TYPE)\n            || type.equals(Double.TYPE) || type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Enum.class)) {\n        return o1.equals(o2);\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    } \n    else if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } \n    else if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    } \n    else \n    {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> alternates = ImmutableList.builder();\n      for (JSType alternate : unionType.getAlternates()) {\n        alternates.add(filterNoResolvedType(alternate));\n      }\n      return registry.createUnionType(alternates.build());\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n\n    if (type.isUnionType()) {\n        UnionType unionType = type.toMaybeUnionType();\n        if (unionType.isUnknownType()) {\n            return type;\n        }\n\n        for (JSType alternate : unionType.getAlternates()) {\n            if (!alternate.isNoResolvedType()) {\n                return type;\n            }\n        }\n\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      for (JSType alternate : unionType.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          return alternate;\n        }\n      }\n    }\n\n    return null;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      for (JSType alternate : unionType.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          return alternate;\n        }\n      }\n    }\n    return null;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          return alt;\n        }\n      }\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> alternates = ImmutableList.builder();\n      for (JSType alternate : unionType.getAlternates()) {\n        if (!alternate.isNoResolvedType()) {\n          alternates.add(alternate);\n        }\n      }\n      if (alternates.build().size() == 1) {\n        return alternates.build().get(0);\n      }\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      for (JSType alternate : unionType.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          return alternate;\n        }\n      }\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      List<JSType> alternates = Lists.newArrayList();\n      for (JSType alternate : unionType.getAlternates()) {\n        alternates.add(filterNoResolvedType(alternate));\n      }\n      return JSType.join(alternates);\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.getAlternates().size() == 2) {\n      JSType first = unionType.getAlternates().get(0);\n      JSType second = unionType.getAlternates().get(1);\n      if (first.isNoResolvedType() && second.isNoResolvedType()) {\n        return first;\n      }\n    }\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.getAlternates().stream().allMatch(JSType::isNoResolvedType)) {\n      return type;\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParams = parseTypeParameters(token);\n    if (typeParams != null) {\n      functionType.addChildToBack(typeParams);\n    }\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node contextType = null;\n    if (match(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      contextType = wrapNode(Token.THIS, parseTypeName(next()));\n      if (contextType == null) {\n        return null;\n      }\n    }\n    Node parameters = parseParametersType(next());\n    if (parameters == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parameters);\n    if (contextType != null) {\n      functionType.addChildToFront(contextType);\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (peek(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      Node contextType = parseTypeExpression(next());\n      if (contextType == null) {\n        return null;\n      }\n      functionType.addChildToFront(contextType);\n    }\n    Node parameters = parseParametersType(next());\n    if (parameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(parameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(typeParameters);\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node contextType = parseTypeName(next());\n    if (contextType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(contextType);\n  }\n  skipEOLs();\n  Node parameters = parseParametersType(next());\n  if (parameters == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(parameters);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParams = parseTypeParameters(token);\n  if (typeParams != null) {\n    functionType.addChildToBack(typeParams);\n  }\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  Node contextType = null;\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    contextType = wrapNode(Token.THIS, parseTypeName(next()));\n    if (contextType == null) {\n      return null;\n    }\n    functionType.addChildToFront(contextType);\n  }\n  Node parameters = parseParametersType(next());\n  if (parameters == null) {\n    return null;\n  }\n  functionType.addChildToBack(parameters);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  } else {\n    functionType.addChildToBack(resultType);\n  }\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node parameters = parseParametersType(token);\n  if (parameters == null) {\n    return null;\n  }\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parameters);\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    Node resultType = null;\n    boolean hasVarArgs = false;\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.STRING) {\n      String tokenStr = stream.getString();\n      boolean isThis = \"this\".equals(tokenStr);\n      boolean isNew = \"new\".equals(tokenStr);\n      if (isThis || isNew) {\n        if (match(JsDocToken.COLON)) {\n          next();\n          skipEOLs();\n          Node contextType = wrapNode(\n              isThis ? Token.THIS : Token.NEW,\n              parseContextTypeExpression(next()));\n          if (contextType == null) {\n            return null;\n          }\n\n          functionType.addChildToFront(contextType);\n        } else {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        if (match(JsDocToken.COMMA)) {\n          next();\n          skipEOLs();\n          token = next();\n        } else {\n          hasVarArgs = false;\n        }\n      }\n    }\n\n    if (hasParams) {\n      parameters = parseParametersType(token);\n      if (parameters == null) {\n        return null;\n      }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParams = parseTypeParameters(token);\n    if (typeParams == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParams);\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node parameters = parseParametersType(next());\n    if (parameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(parameters);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    Node resultType = null;\n    Node thisType = null;\n\n    if (token == JsDocToken.FUNCTION) {\n      next();\n      skipEOLs();\n      token = next();\n    }\n\n    if (token == JsDocToken.LP) {\n      next();\n      skipEOLs();\n      token = next();\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    if (token == JsDocToken.THIS) {\n      next();\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.COLON) {\n        next();\n        skipEOLs();\n        token = next();\n        thisType = parseTypeExpression(token);\n        if (thisType == null) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n        }\n        skipEOLs();\n        token = next();\n      } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n    }\n\n    if (token == JsDocToken.COMMA) {\n      next();\n      skipEOLs();\n      token = next();\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    if (token == JsDocToken.RP) {\n      next();\n      skipEOLs();\n      token = next();\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    if (token == JsDocToken.COLON) {\n      next();\n      skipEOLs();\n      token = next();\n      resultType = parseTypeExpression(token);\n      if (resultType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n      }\n      skipEOLs();\n      token = next();\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParams = parseTypeParameters(token);\n  if (typeParams != null) {\n    functionType.addChildToBack(typeParams);\n  }\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  Node contextType = null;\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    contextType = parseTypeName(next());\n    if (contextType == null) {\n      return null;\n    }\n    functionType.addChildToBack(contextType);\n  }\n  Node parameters = parseParametersType(next());\n  if (parameters == null) {\n    return null;\n  }\n  functionType.addChildToBack(parameters);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  } else {\n    functionType.addChildToBack(resultType);\n  }\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node thisType = null;\n    Node parameters = null;\n    Node resultType = null;\n\n    skipEOLs();\n    if (match(JsDocToken.THIS)) {\n      thisType = wrapNode(Token.THIS, parseTypeName(next()));\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n    }\n\n    parameters = parseParametersType(next());\n    if (parameters == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(parameters);\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n//-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }\n//-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // create a new SummaryStatistics to hold the aggregate values\n    SummaryStatistics aggregate = new SummaryStatistics();\n\n    // loop through the input statistics and add their values to the aggregate\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat.getMin());\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getMean());\n        aggregate.addValue(stat.getStandardDeviation());\n    }\n\n    // return the aggregate statistics\n    return new StatisticalSummaryValues(aggregate.getMin(),\n                                        aggregate.getMax(),\n                                        aggregate.getMean(),\n                                        aggregate.getStandardDeviation());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        // compute aggregate statistics\n        SummaryStatistics aggregate = new SummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            aggregate.addValue(stat.getMean());\n            aggregate.addValue(stat.getStandardDeviation());\n            aggregate.addValue(stat.getVariance());\n            aggregate.addValue(stat.getN());\n            aggregate.addValue(stat.getSum());\n            aggregate.addValue(stat.getSumsq());\n        }\n        // return aggregate statistics\n        return new StatisticalSummaryValues(aggregate.getMean(),\n                aggregate.getStandardDeviation(),\n                aggregate.getVariance(),\n                aggregate.getN(),\n                aggregate.getSum(),\n                aggregate.getSumsq());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Initialize the aggregated statistics\n    StatisticalSummaryValues aggregatedStatistics = new StatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            aggregatedStatistics.incrementN(stat.getN());\n            aggregatedStatistics.incrementSum(stat.getSum());\n            aggregatedStatistics.incrementSumsq(stat.getSumsq());\n            aggregatedStatistics.incrementMin(stat.getMin());\n            aggregatedStatistics.incrementMax(stat.getMax());\n        }\n    }\n\n    // Compute the aggregated mean and variance\n    double aggregatedMean = aggregatedStatistics.getSum() / aggregatedStatistics.getN();\n    double aggregatedVariance = aggregatedStatistics.getSumsq() / aggregatedStatistics.getN();\n    aggregatedVariance -= aggregatedMean * aggregatedMean;\n\n    // Return the aggregated statistics\n    return new StatisticalSummaryValues(aggregatedStatistics.getN(), aggregatedMean, aggregatedVariance,\n            aggregatedStatistics.getMin(), aggregatedStatistics.getMax());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    long n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    return new StatisticalSummaryValues(n, sum, sumsq, min, max);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.addValue(stat.getMean());\n        aggregatedStatistics.addValue(stat.getStandardDeviation());\n        aggregatedStatistics.addValue(stat.getVariance());\n        aggregatedStatistics.addValue(stat.getMax());\n        aggregatedStatistics.addValue(stat.getMin());\n        aggregatedStatistics.addValue(stat.getN());\n        aggregatedStatistics.addValue(stat.getSum());\n        aggregatedStatistics.addValue(stat.getSumsq());\n    }\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(),\n            aggregatedStatistics.getStandardDeviation(),\n            aggregatedStatistics.getVariance(),\n            aggregatedStatistics.getMax(),\n            aggregatedStatistics.getMin(),\n            aggregatedStatistics.getN(),\n            aggregatedStatistics.getSum(),\n            aggregatedStatistics.getSumsq());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n        }\n        return new StatisticalSummaryValues(n, sum, sumsq, min, max);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // Check for empty or null collection\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Initialize aggregate statistics\n    StatisticalSummaryValues aggregate = new StatisticalSummaryValues();\n\n    // Iterate over collection and aggregate statistics\n    for (SummaryStatistics stat : statistics) {\n        aggregate.incrementN(stat.getN());\n        aggregate.incrementSum(stat.getSum());\n        aggregate.incrementSumsq(stat.getSumsq());\n        aggregate.incrementMin(stat.getMin());\n        aggregate.incrementMax(stat.getMax());\n    }\n\n    // Return aggregate statistics\n    return aggregate;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        SummaryStatistics first = statistics.iterator().next();\n        StatisticalSummaryValues values = first.getSummary();\n        values.setN(0);\n        values.setSum(0);\n        values.setSumsq(0);\n        values.setMin(Double.POSITIVE_INFINITY);\n        values.setMax(Double.NEGATIVE_INFINITY);\n\n        for (SummaryStatistics stat : statistics) {\n            values.setN(values.getN() + stat.getN());\n            values.setSum(values.getSum() + stat.getSum());\n            values.setSumsq(values.getSumsq() + stat.getSumsq());\n            values.setMin(Math.min(values.getMin(), stat.getMin()));\n            values.setMax(Math.max(values.getMax(), stat.getMax()));\n        }\n\n        return values;\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n    if (statistics.isEmpty()) {\n        return null;\n    }\n    Iterator<SummaryStatistics> iter = statistics.iterator();\n    SummaryStatistics first = iter.next();\n    SummaryStatistics result = new SummaryStatistics();\n    while (iter.hasNext()) {\n        SummaryStatistics next = iter.next();\n        result.addValue(next.getMin());\n        result.addValue(next.getMax());\n        result.addValue(next.getSum());\n        result.addValue(next.getSumsq());\n        result.addValue(next.getN());\n        result.addValue(next.getGeometricMean());\n    }\n    return new StatisticalSummaryValues(result.getMin(), result.getMax(), result.getSum(),\n            result.getSumsq(), result.getN(), result.getGeometricMean());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null) {\n            return null;\n        }\n        if (statistics.isEmpty()) {\n            return null;\n        }\n        Iterator<SummaryStatistics> iter = statistics.iterator();\n        SummaryStatistics first = iter.next();\n        while (iter.hasNext()) {\n            first.combine(iter.next());\n        }\n        return first.getSummary();\n    }"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                                                sample1.length, 2, true);\n        }\n        double sumSq = 0.0d;\n        for (int i = 0; i < sample1.length; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev / (sample1[i] - meanDifference);\n        }\n        return sumSq;\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                    n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                    sample1.length, 2, true);\n        }\n        double sumSq = 0.0d;\n        for (int i = 0; i < sample1.length; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev;\n        }\n        return sumSq / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                    n, 2, true);\n        }\n        double sumSq = 0.0d;\n        for (int i = 0; i < n; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev / (n - 1);\n        }\n        return sumSq;\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                                                n, 2, true);\n        }\n        double sumSq = 0;\n        for (int i = 0; i < n; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev;\n        }\n        return sumSq / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                                                sample1.length, 2, true);\n        }\n        double sumSq = 0.0d;\n        for (int i = 0; i < sample1.length; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev;\n        }\n        return sumSq / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double sumSq = 0.0d;\n        for (int i = 0; i < n; i++) {\n            final double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev / (sample1[i] - meanDifference);\n        }\n        return sumSq / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                                                sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_POINTS,\n                                                sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1] = 0;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (bytesRemaining == 0) {\n        return -1;\n    }\n    int bytesToRead = len;\n    if (bytesToRead > bytesRemaining) {\n        bytesToRead = (int) bytesRemaining;\n    }\n    int bytesRead;\n    ByteBuffer buf;\n    if (bytesToRead <= buffer.capacity()) {\n        buf = buffer;\n        bytesRead = read(bytesToRead);\n    } else {\n        buf = ByteBuffer.allocate(bytesToRead);\n        bytesRead = channel.read(buf);\n        buf.flip();\n    }\n    if (bytesRead >= 0) {\n        buf.get(b, off, bytesRead);\n        bytesRemaining -= bytesRead;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (current == null) {\n        return -1;\n    }\n    final int bytesRead = current.read(b, off, len);\n    if (bytesRead == -1) {\n        current = null;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesToRead = Math.min(len, currentChunk.length - readOffset);\n    System.arraycopy(currentChunk, readOffset, b, off, bytesToRead);\n    readOffset += bytesToRead;\n    if (readOffset == currentChunk.length) {\n        readOffset = 0;\n        currentChunk = null;\n    }\n    return bytesToRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (bytesRemaining == 0) {\n        return -1;\n    }\n    int bytesToRead = len;\n    if (bytesToRead > bytesRemaining) {\n        bytesToRead = (int) bytesRemaining;\n    }\n    int bytesRead;\n    ByteBuffer buf;\n    if (bytesToRead <= buffer.capacity()) {\n        buf = buffer;\n        bytesRead = read(bytesToRead);\n    } else {\n        buf = ByteBuffer.allocate(bytesToRead);\n        bytesRead = channel.read(buf);\n        buf.flip();\n    }\n    if (bytesRead >= 0) {\n        buf.get(b, off, bytesRead);\n        bytesRemaining -= bytesRead;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (bytesRemaining == 0) {\n        return -1;\n    }\n    int bytesToRead = len;\n    if (bytesToRead > bytesRemaining) {\n        bytesToRead = (int) bytesRemaining;\n    }\n    int bytesRead;\n    ByteBuffer buf;\n    if (bytesToRead <= buffer.capacity()) {\n        buf = buffer;\n        bytesRead = read(bytesToRead);\n    } else {\n        buf = ByteBuffer.allocate(bytesToRead);\n        bytesRead = channel.read(buf);\n        buf.flip();\n    }\n    if (bytesRead >= 0) {\n        buf.get(b, off, bytesRead);\n        bytesRemaining -= bytesRead;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesToRead = Math.min(len, currentChunk.length - readOffset);\n    System.arraycopy(currentChunk, readOffset, b, off, bytesToRead);\n    readOffset += bytesToRead;\n    if (readOffset == currentChunk.length) {\n        currentChunk = null;\n        readOffset = 0;\n        return -1;\n    }\n    return bytesToRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesToRead = Math.min(len, currentChunk.length - readOffset);\n    System.arraycopy(currentChunk, readOffset, b, off, bytesToRead);\n    readOffset += bytesToRead;\n    if (readOffset == currentChunk.length) {\n        readOffset = 0;\n        currentChunk = null;\n    }\n    return bytesToRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n    return bytesRead;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (NodeUtil.isCallOrNew(callNode)) {\n        return NodeUtil.getArgumentForCallOrNew(callNode, argIndex);\n      } else {\n        Preconditions.checkState(callNode.isGetProp());\n        Preconditions.checkState(callNode.getLastChild().getString().equals(\"call\"));\n        return NodeUtil.getArgumentForCallOrNew(callNode, argIndex);\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (callNode.isCall() || callNode.isNew()) {\n        return callNode.getFirstChild().getNext().getChildAtIndex(argIndex);\n      } else if (callNode.isGetProp() && callNode.getLastChild().getString().equals(\"call\")) {\n        return callNode.getFirstChild().getNext().getChildAtIndex(argIndex);\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callOrNew = site.node;\n      Node arg = null;\n      if (callOrNew.isCall() || callOrNew.isNew()) {\n        arg = callOrNew.getChildAtIndex(argIndex + 1);\n      } else if (callOrNew.isGetProp()) {\n        Node callNode = callOrNew.getFirstChild();\n        if (callNode.isCall() || callNode.isNew()) {\n          arg = callNode.getChildAtIndex(argIndex + 1);\n        }\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      Node call = site.node;\n      if (call.isCall()) {\n        arg = NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (call.isGetProp()) {\n        arg = NodeUtil.getArgumentForCallOrNew(call.getLastChild(), argIndex);\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callOrNew = site.node;\n      Node arg = null;\n      if (callOrNew.isCall()) {\n        arg = callOrNew.getFirstChild().getNext();\n      } else if (callOrNew.isNew()) {\n        arg = callOrNew.getFirstChild();\n      } else if (callOrNew.isGetProp()) {\n        Node call = callOrNew.getFirstChild();\n        if (call.isCall()) {\n          arg = call.getFirstChild().getNext();\n        }\n      }\n\n      for (int i = 0; i < argIndex && arg != null; i++) {\n        arg = arg.getNext();\n      }\n\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callOrNewOrDotCall = site.node;\n      if (callOrNewOrDotCall.isCall() || callOrNewOrDotCall.isNew()) {\n        return callOrNewOrDotCall.getChildAtIndex(argIndex + 1);\n      } else if (callOrNewOrDotCall.isGetProp()\n          && callOrNewOrDotCall.getLastChild().getString().equals(\"call\")) {\n        return callOrNewOrDotCall.getFirstChild().getNext().getChildAtIndex(\n            argIndex);\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      if (site.isCall()) {\n        arg = site.getNode().getChildAtIndex(argIndex + 1);\n      } else if (site.isNew()) {\n        arg = site.getNode().getChildAtIndex(argIndex);\n      } else if (site.isDotCall()) {\n        arg = site.getNode().getChildAtIndex(argIndex + 1);\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callNode = site.node;\n      if (callNode.isCall()) {\n        return NodeUtil.getArgumentForCallOrNew(callNode, argIndex);\n      } else if (callNode.isGetProp()) {\n        return NodeUtil.getArgumentForCallOrNew(callNode, argIndex);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected node type: \" + callNode.getToken());\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node callOrNew = site.node;\n      if (callOrNew.isCall() || callOrNew.isNew()) {\n        return NodeUtil.getArgumentForCallOrNew(callOrNew, argIndex);\n      } else {\n        Preconditions.checkState(callOrNew.isGetProp());\n        return NodeUtil.getArgumentForCallOrNew(callOrNew.getLastChild(), argIndex);\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isFunctionObjectCall(call)) {\n        return call.getSecondChild().getNext().getChildAtIndex(argIndex);\n      } else if (call.isCall()) {\n        return call.getChildAtIndex(argIndex + 1);\n      } else {\n        return null;\n      }\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n      if (type.getDeprecationReason() != null) {\n        return type.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) {\n      JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n        return \"\";\n      }\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n      if (type.getDeprecationReason() != null) {\n        return type.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // The JDK caches names, but does not support custom locales or daylight savings\n    // This code mimics the JDK code, but allows for a locale and daylight flag\n    // This code is a copy of the JDK code from OpenJDK 7u60, with minor modifications\n    // The original code can be found at http://hg.openjdk.java.net/jdk7u/jdk7u60/jdk/file/tip/src/share/classes/java/util/TimeZone.java\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        if (locale.equals(Locale.ENGLISH) && !daylight) {\n            value = tz.getDisplayName(daylight, style, Locale.ENGLISH);\n        } else {\n            final String[] names = new String[4];\n            names[0] = tz.getDisplayName(false, TimeZone.LONG, locale);\n            names[1] = tz.getDisplayName(false, TimeZone.SHORT, locale);\n            names[2] = tz.getDisplayName(true, TimeZone.LONG, locale);\n            names[3] = tz.getDisplayName(true, TimeZone.SHORT, locale);\n            final StringBuilder sb = new StringBuilder();\n            final int offset = tz.getRawOffset();\n            final int hour = Math.abs((offset / (60 * 1000)) / 60);\n            final int minute = Math.abs((offset / (60 * 1000)) % 60);\n            sb.append(names[2 * (daylight ? 1 : 0)]);\n            if (hour != 0 || minute != 0) {\n                sb.append(' ');\n                if (hour < 10) {\n                    sb.append('0');\n                }\n                sb.append(hour);\n                if (minute < 10) {\n                    sb.append('0');\n                }\n}\n}\n}\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            value = tz.getDisplayName(daylight, style, locale);\n            final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (previous != null) {\n                // even though it doesn't matter if another thread put the value\n                // it's still good practice to return the String instance that is\n                // actually in the ConcurrentMap\n                value = previous;\n            }\n        }\n        return value;\n    }",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            value = tz.getDisplayName(daylight, style, locale);\n            final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (previous != null) {\n                // even though it doesn't matter if another thread put the pattern\n                // it's still good practice to return the String instance that is\n                // actually in the ConcurrentMap\n                value= previous;\n            }\n        }\n        return value;\n    }",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // TimeZone.getDisplayName() results are not thread-safe\n    // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228305\n    synchronized (cTimeZoneDisplayCache) {\n        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cTimeZoneDisplayCache.get(key);\n        if (value == null) {\n            value = tz.getDisplayName(daylight, style, locale);\n            final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n            if (previous != null) {\n                // even though it doesn't matter if another thread put the value\n                // it's still good practice to return the String instance that is\n                // actually in the ConcurrentMap\n                value = previous;\n            }\n        }\n        return value;\n    }\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    if (this.source != null) {\n        if (this.extract == TableOrder.BY_ROW) {\n            result = this.source.getRowIndex(key);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) {\n            result = this.source.getColumnIndex(key);\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.columnKeys != null) \n    {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.columnKeys != null) \n    {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowIndex(key);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnIndex(key);\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowIndex(key);\n        } \n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnIndex(key);\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.columnKeys.contains(key)) {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point - getMin() <= tolerance) {\n        return Location.BOUNDARY;\n    } else if (getMax() - point <= tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getInf()) {\n        return Location.OUTSIDE;\n    }\n    if (point > getSup()) {\n        return Location.OUTSIDE;\n    }\n    if (FastMath.abs(point - getInf()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (FastMath.abs(point - getSup()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getMin() - tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point > getMax() + tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getMin()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getMax()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getMin() - tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point > getMax() + tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point < getMin() + tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (point > getMax() - tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getInf()) {\n        return Location.OUTSIDE;\n    } else if (point > getSup()) {\n        return Location.OUTSIDE;\n    } else if (FastMath.abs(point - getInf()) <= tolerance) {\n        return Location.BOUNDARY;\n    } else if (FastMath.abs(point - getSup()) <= tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getInf()) {\n        return Location.OUTSIDE;\n    } else if (point > getSup()) {\n        return Location.OUTSIDE;\n    } else if (point - getInf() < tolerance) {\n        return Location.BOUNDARY;\n    } else if (getSup() - point < tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getMin() - tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point > getMax() + tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getMin()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getMax()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    Integer pivotColumn = null;\n    double minValue = Double.MAX_VALUE;\n    final int varStart = tableau.getNumObjectiveFunctions();\n    final int varEnd = tableau.getWidth() - 1;\n    for (int i = varStart; i < varEnd; i++) {\n        double value = tableau.getEntry(0, i);\n        if (value < minValue) {\n            minValue = value;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int colIndex = 0;\n    double minValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(0, i) < minValue) {\n            minValue = tableau.getEntry(0, i);\n            colIndex = i;\n        }\n    }\n    return colIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        Integer minRow = null;\n        int minIndex = tableau.getWidth();\n        final int varStart = tableau.getNumObjectiveFunctions();\n        final int varEnd = tableau.getWidth() - 1;\n        for (Integer row : minRatioPositions) {\n            for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {\n                final Integer basicRow = tableau.getBasicRow(i);\n                if (basicRow != null && basicRow.equals(row) && i < minIndex) {\n                    minIndex = i;\n                    minRow = row;\n                }\n            }\n        }\n        return minRow;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // Find the column with the most negative coefficient in the objective function row\n        Integer pivotColumn = null;\n        double minValue = Double.POSITIVE_INFINITY;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n            double value = tableau.getEntry(0, i);\n            if (value < minValue) {\n                minValue = value;\n                pivotColumn = i;\n            }\n        }\n        return pivotColumn;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // Find the column with the most negative coefficient in the objective function row.\n        Integer pivotColumn = null;\n        double minCoefficient = Double.POSITIVE_INFINITY;\n        for (int j = tableau.getNumObjectiveFunctions(); j < tableau.getWidth(); j++) {\n            double coefficient = tableau.getEntry(0, j);\n            if (coefficient < minCoefficient) {\n                minCoefficient = coefficient;\n                pivotColumn = j;\n            }\n        }\n        return pivotColumn;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        Integer minRow = null;\n        int minIndex = tableau.getWidth();\n        final int varStart = tableau.getNumObjectiveFunctions();\n        final int varEnd = tableau.getWidth() - 1;\n        for (Integer row : minRatioPositions) {\n            for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {\n                final Integer basicRow = tableau.getBasicRow(i);\n                if (basicRow != null && basicRow.equals(row) && i < minIndex) {\n                    minIndex = i;\n                    minRow = row;\n                }\n            }\n        }\n        return minRow;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int mostNegative = 0;\n    int mostNegativeColumn = 0;\n    for (int j = 0; j < tableau.getWidth(); j++) {\n        double entry = tableau.getEntry(0, j);\n        if (entry < mostNegative) {\n            mostNegative = (int) entry;\n            mostNegativeColumn = j;\n        }\n    }\n    return mostNegativeColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // optimization/linear/SimplexSolver.java\n    // 2. apply Bland's rule to prevent cycling:\n    //    take the row for which the corresponding basic variable has the smallest index\n    //\n    // see http://www.stanford.edu/class/msande310/blandrule.pdf\n    // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n    //\n    // Additional heuristic: if we did not get a solution after half of maxIterations\n    //                       revert to the simple case of just returning the top-most row\n    // This heuristic is based on empirical data gathered while investigating MATH-828.\n    if (getIterations() < getMaxIterations() / 2) {\n        Integer minRow = null;\n        int minIndex = tableau.getWidth();\n        final int varStart = tableau.getNumObjectiveFunctions();\n        final int varEnd = tableau.getWidth() - 1;\n        for (Integer row : minRatioPositions) {\n            for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {\n                final Integer basicRow = tableau.getBasicRow(i);\n                if (basicRow != null && basicRow.equals(row) && i < minIndex) {\n                    minIndex = i;\n                    minRow = row;\n                }\n            }\n        }\n        return minRow;\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int mostNegativeColumn = -1;\n        double mostNegativeValue = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < tableau.getWidth(); i++) {\n            double value = tableau.getEntry(0, i);\n            if (value < mostNegativeValue) {\n                mostNegativeValue = value;\n                mostNegativeColumn = i;\n            }\n        }\n        return mostNegativeColumn;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int colIndex = 0;\n        double minValue = Double.MAX_VALUE;\n        for (int i = 0; i < tableau.getWidth(); i++) {\n            if (tableau.getEntry(0, i) < minValue) {\n                minValue = tableau.getEntry(0, i);\n                colIndex = i;\n            }\n        }\n        return colIndex;\n    }"
    ]
  ]
}