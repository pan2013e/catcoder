{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.49095477386934677,
    "pass@1": 0.30201005025125627,
    "compile@3": 0.6172110552763814,
    "pass@3": 0.3911641541038525,
    "compile@5": 0.6640543989790221,
    "pass@5": 0.42914971683815895
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(rowKey,\n            columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(rowKey, columnKey);\n    if (item != null) \n    {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(rowKey,\n            columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n            rowKey, columnKey);\n    if (item != null) {\n        result = item.getPercentComplete();\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}\n\nclass IteratorIterable<E> implements Iterable<E>",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}\n\nclass IteratorIterable<E> implements Iterable<E>",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}\n\nclass IteratorIterable<E> implements Iterable<E>\n{\n    final Iterator<? extends E> iterator;\n    final boolean multipleUse;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1)\n    {\n        RealMatrix diagMatrix = new Array2DRowRealMatrix(m.getRowDimension(), m.getColumnDimension());\n        for(int r = 0; r < diagMatrix.getRowDimension(); r++)\n        {\n            diagMatrix.setEntry(r, r, m.getEntry(r, 0));\n        }\n        return diagMatrix;\n    }\n    else\n    {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = (r == c) ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                if(r==c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0.0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final int nCols = m.getColumnDimension();\n        final RealMatrix out = new Array2DRowRealMatrix(nCols, nCols);\n        for (int r = 0; r < nCols; ++r) {\n            for (int c = 0; c < nCols; ++c) {\n                out.setEntry(r, c, m.getEntry(r, c));\n            }\n        }\n        return out;\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for(int r = 0; r < m.getRowDimension(); r++)\n        {\n            for(int c = 0; c < m.getRowDimension(); c++)\n            {\n                if(r == c)\n                {\n                    d[r][c] = m.getEntry(r, c);\n                }\n                else\n                {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if(m.getColumnDimension() == m.getRowDimension())\n    {\n        double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for(int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for(int c = 0; c < m.getColumnDimension(); c++)\n            {\n                if(r == c)\n                {\n                    d[r][c] = m.getEntry(r, c);\n                }\n                else\n                {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        throw new RuntimeException(\"Matrix is not a column vector nor a square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                if(r==c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0.0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final int nCols = m.getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nCols);\n        for (int r = 0; r < nCols; ++r) {\n            for (int c = 0; c < nCols; ++c) {\n                if(r==c) {\n                    out.setEntry(r, c, m.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int nRows = m.getRowDimension();\n        final double[] d = new double[nRows];\n        for (int r = 0; r < nRows; r++) {\n            d[r] = m.getEntry(r, 0);\n        }\n        return new Array1DRowRealMatrix(d);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int nCols = m.getColumnDimension();\n        final double[][] d = new double[nCols][nCols];\n        for (int r = 0; r < nCols; r++) {\n            d[r][r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new RuntimeException(\"Invalid matrix dimensions.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                d[r][c] = (r == c) ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = (r == c) ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][r] = m.getEntry(r,0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if(m.getColumnDimension() == m.getRowDimension())\n    {\n        double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) \n        {\n            for(int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = (r == c) ? m.getEntry(r,c) : 0.0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        throw new RuntimeException(\"m is not a column matrix or a square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int nRows = m.getRowDimension();\n        final double[] d = new double[nRows];\n        for (int r = 0; r < nRows; r++) {\n            d[r] = m.getEntry(r, 0);\n        }\n        return new Array1DRowRealMatrix(d);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int nCols = m.getColumnDimension();\n        final double[][] d = new double[nCols][nCols];\n        for (int r = 0; r < nCols; r++) {\n            for (int c = 0; c < nCols; c++) {\n                if (r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Invalid matrix dimensions.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                if(r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if(r == c) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), m.getRowDimension(), m.getRowDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if(m.getColumnDimension() == 1)\n    {\n        return m;\n    }\n    else\n    {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r == c)\n                {\n                    d[r][c] = m.getEntry(r, c);\n                }\n                else\n                {\n                    d[r][c] = 0.0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows, columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows, columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = MathArrays.buildArray(rows * columns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            double[] block = MathArrays.buildArray(iHeight * jWidth);\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return FieldUtils.readStaticField(field, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return FieldUtils.readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return FieldUtils.readStaticField(field, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Check if id is a standard timezone id (e.g. \"America/Toronto\")\n        if (id.length() > 6) {\n            return DateTimeZone.forTimeZone(java.util.TimeZone.getTimeZone(id));\n        }\n\n        // Check if id is a fixed offset (e.g. \"+05:00\")\n        if (id.matches(\"^[+-]\\\\d\\\\d(:\\\\d\\\\d(:\\\\d\\\\d)?)?$\")) {\n            int hours = Integer.parseInt(id.substring(1, 3));\n            int minutes = id.length() >= 5 ? Integer.parseInt(id.substring(4, 6)) : 0;\n            int seconds = id.length() >= 8 ? Integer.parseInt(id.substring(7, 9)) : 0;\n            return forOffsetHoursMinutesSeconds(hours, minutes, seconds);\n        }\n\n        // If this point is reached, id must be a DateTimeZone.\n        return cProvider.getZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // First try as a standard zone id.\n        DateTimeZone tz = cProvider.getZone(id);\n        if (tz != null) {\n            return tz;\n        }\n\n        // Then try as a fixed offset zone.\n        return new FixedDateTimeZone(id, id, parseZone(id).getOffset(0), parseZone(id).getOffset(0));\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Check if it is a fixed offset, if not throw an exception\n        if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n            // standard format offset [+-]hh:mm\n            int hourOffset = Integer.parseInt(id.substring(1, 3));\n            int minuteOffset = Integer.parseInt(id.substring(4, 6));\n            return new FixedDateTimeZone(id, id, hourOffset * 3600000 + minuteOffset * 60000, hourOffset * 3600000 + minuteOffset * 60000);\n        }\n\n        throw new IllegalArgumentException(\"Unrecognised zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            // standard format offset [+-]hh:mm\n            int len = id.length();\n            if (len >= 6 && len <= 6 && Character.isDigit(id.charAt(1)) && Character.isDigit(id.charAt(2))) {\n                int offsetHours = Integer.parseInt(id.substring(1, 3));\n                int offsetMinutes = Integer.parseInt(id.substring(4, 6));\n                return forOffsetHoursMinutes(offsetHours, offsetMinutes);\n            }\n        }\n        // Try and find the zone using the built-in provider.\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Unknown time zone id: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            return cProvider.getZone(convId);\n        }\n\n        // Try parsing the id as a fixed offset zone.\n        if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n            // standard format offset [+-]hh:mm\n            int offset;\n            if (id.charAt(0) == '+') {\n                offset = Integer.parseInt(id.substring(1, 3)) * 60 * 60 * 1000 +\n                         Integer.parseInt(id.substring(4, 6)) * 60 * 1000;\n            } else {\n                offset = -Integer.parseInt(id.substring(1, 3)) * 60 * 60 * 1000 -\n                         Integer.parseInt(id.substring(4, 6)) * 60 * 1000;\n            }\n            return forOffsetMillis(offset);\n        }\n\n        throw new IllegalArgumentException(\"Unrecognised ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        try {\n            return forTimeZone(java.util.TimeZone.getTimeZone(id));\n        }\n        catch (IllegalArgumentException ex) {\n            // try parsing as a fixed offset zone\n            try {\n                int offset = parseOffset(id);\n                return forOffsetMillis(offset);\n            }\n            catch (IllegalArgumentException ex2) {\n                // try parsing as a locale independent fixed offset zone\n                int offset = parseFixedOffset(id);\n                return new FixedDateTimeZone(\"Z\" + id, id, offset, offset);\n            }\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // First check the cache.\n        DateTimeZone tz = getCache().get(id);\n        if (tz != null) {\n            return tz;\n        }\n\n        if (id.equals(\"UTC\")) {\n            tz = UTC;\n        } else {\n            tz = cProvider.getZone(id);\n        }\n\n        if (tz == null) {\n            // Not found in cache or standard locations, check for fixed offset format.\n            if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n                tz = forOffsetString(id.substring(1));\n            } else {\n                // Last attempt: try converting the ID to a TimeZone and then back to a DateTimeZone.\n                try {\n                    TimeZone timeZone = TimeZone.getTimeZone(id);\n                    tz = forTimeZone(timeZone);\n                } catch (IllegalArgumentException iae) {\n                    // Ignore and return null.\n                }\n            }\n        }\n\n        if (tz == null) {\n            throw new IllegalArgumentException(\n                \"Unknown time zone ID: \" + id);\n        }\n\n        // Cache the zone.\n        getCache().put(id, tz);\n        return tz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.matches(\"^-?(\\\\d{1,2}:\\\\d{2})$\")) {\n            // Fixed offset datetime zone\n            return forOffsetHoursMinutes(id);\n        }\n        if (id.equals(\"system\")) {\n            // Use the system time zone provider.\n            return cProvider.getZone(id);\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        throw new IllegalArgumentException(\"Unknown timezone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        try {\n            return forTimeZone(TimeZone.getTimeZone(id));\n        } catch (IllegalArgumentException iae) {\n            // Ignore exception and continue with parsing.\n        }\n\n        int sign = 1;\n        int hour = 0;\n        int minute = 0;\n        int pos = 0;\n\n        if (id.charAt(0) == '+') {\n            pos++;\n        } else if (id.charAt(0) == '-') {\n            pos++;\n            sign = -1;\n        }\n\n        while (pos < id.length()) {\n            char c = id.charAt(pos);\n            if (c >= '0' && c <= '9') {\n                if (minute > 59) {\n                    throw new IllegalArgumentException(id);\n                }\n                if (hour > 23) {\n                    throw new IllegalArgumentException(id);\n                }\n                if (pos == 0 && c == '0' && id.length() > 1) {\n                    pos++;\n                    continue;\n                }\n\n                int digit = c - '0';\n                if (pos == 1) {\n                    minute = minute * 10 + digit;\n                } else {\n                    hour = hour * 10 + digit;\n                }\n                pos++;\n            } else if (c == ':') {\n                if (minute > 59) {\n                    throw new IllegalArgumentException(id);\n                }\n                if (hour > 23) {\n                    throw new IllegalArgumentException(id);\n                }\n                if (pos == 0) {\n                    throw new IllegalArgumentException(id);\n                }\n                minute *= 60;\n                pos++;\n            } else {\n                throw new IllegalArgumentException(id);\n            }\n        }\n\n        if (minute > 59) {\n            throw new IllegalArgumentException(id);\n        }\n        if (hour > 23) {\n            throw new IllegalArgumentException(id);\n        }\n\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        try {\n            return forTimeZone(TimeZone.getTimeZone(id));\n        } catch (IllegalArgumentException ex) {\n            if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n                // standard format offset [+-]hh:mm\n                try {\n                    int offset = Integer.parseInt(id.substring(1, 3)) * 60 * 60 * 1000;\n                    offset += Integer.parseInt(id.substring(4, 6)) * 60 * 1000;\n                    return forOffsetMillis(offset);\n                } catch (RuntimeException ex2) {\n                    // Ignore and fall through to exception\n                }\n            }\n            throw new IllegalArgumentException(\"Unrecognised time zone id: \" + id);\n        }\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x.mant[j];    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + x.exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    if (x == 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, getZero(), result);\n        return result;\n    }\n\n    if (x == 1) {\n        return result;\n    }\n\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = sign;\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    if (x == 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n        Dfp result = newInstance(getZero());\n        result.sign = sign;\n        result.nans = INFINITE;\n        result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n        return result;\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        return result;\n    }\n\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x.mant[j];    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n}",
      "private Dfp multiplyFast(final int x)  {\n    final int shift = x >> 3;\n    int extra = x & 0x07;\n\n    for (int i = 0; i < mant.length; i++) {\n        final int r = mant[i] * x + result.mant[i+shift] + extra;\n        extra = r >> RADIX;\n        result.mant[i+shift] = r - (extra << RADIX);\n    }\n\n    extra = RADIX-extra;\n    for (int i = 0; i < mant.length; i++) {\n        final int r = mant[i] + rh + extra;\n        rh = r >> RADIX;\n        mant[i] = r - rh * RADIX;\n    }\n\n    return extra;\n}",
      "private Dfp multiplyFast(final int x)  {\n    /* handle special cases */\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE && mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n    }\n\n    if (x == 0) {\n        Dfp result = newInstance(getZero());\n        result.sign = sign;\n        result.nans = FINITE;\n        return result;\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    int extra = 0;\n\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = mant[i] * x + extra;\n        mant[i] = r % RADIX;\n        extra = r / RADIX;\n    }\n\n    extra = RADIX-extra;\n    for (int i = 0; i < mant.length; i++) {\n        mant[i] = RADIX-mant[i]-1;\n    }\n\n    int rh = extra / RADIX;\n    extra = extra - rh * RADIX;\n    for (int i = 0; i < mant.length; i++) {\n        final int r = mant[i] + rh;\n        rh = r / RADIX;\n        mant[i] = r - rh * RADIX;\n    }\n\n    a.exp += log2(x);\n\n    if (extra != 0) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    final int shift = RADIX-x;\n    final int extra = multiplyAdd(x);\n\n    /* shift the product to the right place */\n    if (shift>0) {\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = mant[i] >> shift;\n        }\n    } else {\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] << -shift;\n            mant[i] = r + rh;\n            rh = r>>RADIX;\n        }\n    }\n\n    /* fixup the exponent */\n    exp = exp + shift;\n\n    return extra;\n}",
      "private Dfp multiplyFast(final int x)  {\n    /* handle special cases */\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE && x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    Dfp b = newInstance(x);\n\n    /* initialize the result object */\n    Dfp result = newInstance(getZero());\n\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * b.mant[j];    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + b.exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == b.sign)?1:-1);\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = (byte)sign;\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, result, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    /* handle special cases */\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE && x <= RADIX) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n    }\n\n    /* initialize the result object */\n    Dfp result = newInstance(this);\n\n    if (x == 0) {\n        // initialize the result object with the product\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = 0;\n        }\n\n        // Fixup the exponent.\n        exp = 0;\n        sign = 1;\n        return result;\n    }\n\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i] * x;\n        final int rh = r / RADIX;\n        rl = r - rh * RADIX;\n        result.mant[i] = rh;\n    }\n\n    // Handle the case where the product is zero\n    if (result.mant[mant.length-1] == 0) {\n        result.exp = 0;\n    }\n\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K transformedKey = keyTransformer.transform(entry.getKey());\n            final V transformedValue = valueTransformer.transform(entry.getValue());\n            result.put(transformedKey,transformedValue);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  throws IllegalArgumentException {\n        if (map == null) {\n            throw new IllegalArgumentException(\"map is null\");\n        }\n        \n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), entry.getValue());\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) \n    {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n    {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  throws UnsupportedOperationException {\n        if (map instanceof UnmodifiableMap) {\n            throw new UnsupportedOperationException(\"Transforming an UnmodifiableMap is not supported\");\n        }\n        if (map instanceof ListOrderedMap) {\n            ListOrderedMap<K, V> orderedMap = (ListOrderedMap<K, V>) map;\n            Map<K, V> result = new LinkedHashMap<>(orderedMap.size());\n            for (Map.Entry<K, V> entry : orderedMap.entrySet()) {\n                result.put(entry.getKey(), entry.getValue());\n            }\n            return result;\n        }\n        if (map instanceof TransformedSplitMap) {\n            TransformedSplitMap<K, V, ?, ?> splitMap = (TransformedSplitMap<K, V, ?, ?>) map;\n            return splitMap.transformMap(splitMap.decorated());\n        }\n        if (map instanceof TransformedMultiValuedMap) {\n            TransformedMultiValuedMap<K, V, ?, ?> multiValuedMap = (TransformedMultiValuedMap<K, V, ?, ?>) map;\n            return multiValuedMap.transformMap(multiValuedMap.decorated());\n        }\n        \n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), entry.getValue());\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n        result.put(entry.getKey(), entry.getValue());\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) \n    {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n    {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  throws IllegalArgumentException {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            if (!entry.getValue().getClass().isAssignableFrom(V.class)) {\n                throw new IllegalArgumentException(\"Invalid type for value: \" + entry.getValue().getClass().getName());\n            }\n            result.put(transformKey(entry.getKey()), (V) entry.getValue());\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n        \n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            if(entry.getKey().getClass().isAssignableFrom(ListOrderedMap.class))\n            {\n                ListOrderedMap<K,V> temp = new ListOrderedMap<>(entry.getKey());\n                result.put(temp.previousKey(temp.getKey()), entry.getValue());\n            }\n            else\n            {\n                result.put(transformKey(entry.getKey()), entry.getValue());\n            }\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(!late);\n    Node block = IR.block();\n    Node result = IR.exprResult(block);\n    Node func = IR.getprop(\n        IR.name(\"Function\"),\n        IR.string(\"prototype\").srcref(exportedFunction));\n    Node newFunction = IR.invoke(func,\n        IR.string(\"bind\").srcref(exportedFunction),\n        IR.name(exportedFunction.getString()).srcref(exportedFunction));\n    block.addChild(newFunction);\n\n    if (!exportedFunction.isVarArgs()) {\n        List<Node> params = exportedFunction.getParametersList().getStatementsList();\n        for (Node param : params) {\n            if (param.isVarArgs()) {\n                param.putBooleanProp(Node.VARARGS, false);\n                param.replaceChild(param.getFirstChild(),\n                    IR.ellipsis().srcref(param));\n                reportCodeChange();\n            }\n        }\n    }\n\n    Node paramList = exportedFunction.getParametersList();\n    Node firstParameter = paramList.getFirstChild();\n    if (firstParameter != null && !firstParameter.isVarArgs()) {\n        addParameterAfter(paramList, IR.name(\"undefined\"));\n    }\n\n    Node paramListCopy = paramList.cloneTree();\n    paramListCopy.putBooleanProp(Node.FREE_CALL, false);\n\n    Node newExport = IR.exprResult(IR.new_(\n        IR.getprop(IR.name(\"Function\"),\n            IR.string(\"prototype\").srcref(exportedFunction)),\n        IR.string(\"bind\").srcref(exportedFunction),\n        IR.invoke(newFunction,\n            IR.string(\"bind\").srcref(exportedFunction),\n            IR.apply(IR.name(\"Function\").getFunctionNode(),\n                IR.array(IR.name(exportedFunction.getString()),\n                    paramListCopy)))));\n    newExport.copyInformationFrom(exportedFunction);\n    return newExport;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Handle the case where there are no parameters.\n    if (exportedFunction.getFirstChild().getType() == Token.EMPTY) \n    {\n        Node newFunction = NodeUtil.makeEmptyFunctionBody(IR.name(exportedFunction.getLastChild().getString()));\n        reportMissingReturnTypeWarning(exportedFunction);\n        return newFunction;\n    }\n    else {\n        Node newFunction = NodeUtil.makeEmptyFunctionBody(IR.name(exportedFunction.getFirstChild().getString()));\n        reportMissingParameterTypeWarning(exportedFunction);\n        return newFunction;\n    }\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node newFunction = IR.function(exportedFunction.getString());\n  newFunction.copyInformationFrom(exportedFunction);\n  NodeUtil.redeclareVarsInside(newFunction);\n  Node paramList = IR.paramList();\n  Node returnType = exportedFunction.getLastChild();\n  if (returnType == null || returnType.getType() != Token.TYPE) {\n    newFunction.addChild(IR.keyword(\"void\"));\n  } else {\n    newFunction.addChild(returnType.cloneTree());\n  }\n  Node param = exportedFunction.getFirstChild();\n  while (param != null) {\n    Node paramName = param.getFirstChild();\n    paramList.addChild(IR.param(paramName.cloneTree()));\n    param = param.getNext();\n  }\n  newFunction.addChild(paramList);\n  newFunction.addChild(IR.block());\n  return newFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create an empty block for the function body\n    Node block = IR.block();\n\n    // Create the params list for the extern function\n    Node params = exportedFunction.getFirstChild().getNext();\n    Node paramList = IR.paramList();\n    for (Node param : NodeUtil.getFunctionParameters(params)) {\n        paramList.addChild(param.cloneTree());\n    }\n\n    // Create the extern function node\n    Node externFunction = IR.function(\n        IR.name(\"$$Extern_\" + exportedFunction.getSourceInfo().getLine()),\n        paramList,\n        block);\n\n    // Copy the return type from the original function\n    Node returnType = exportedFunction.getSecondChild();\n    if (returnType != null) {\n        externFunction.addChild(returnType.cloneTree());\n    }\n\n    // Copy the parameter name from the original function\n    paramList.forEachChild((param) -> {\n        param.addChild(param.cloneTree());\n    });\n\n    // Add the extern function to the original function's scope\n    externFunction.getParent().replaceChild(externFunction, exportedFunction);\n\n    // Report code change\n    reportCodeChange();\n\n    // Return the extern function node\n    return externFunction;\n}\n\n// javascript/jscomp/PeepholeRemoveDeadCode.java\nclass PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {\n\n  // TODO(dcc): Some (all) of these can probably be better achieved\n  // using the control flow graph (like CheckUnreachableCode).\n  // There is an existing CFG pass (UnreachableCodeElimination) that\n  // could be changed to use code from CheckUnreachableCode to do this.\n\n  @Override\n  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.ASSIGN:\n        return tryFoldAssignment(subtree);\n      case Token.COMMA:\n        return tryFoldComma(subtree);\n      case Token.SCRIPT:\n      case Token.BLOCK:\n        return tryOptimizeBlock(subtree);\n      case Token.EXPR_RESULT:\n        subtree = tryFoldExpr(subtree);\n        return subtree;\n      case Token.HOOK:\n        return tryFoldHook(subtree);\n      case Token.SWITCH:\n        return tryOptimizeSwitch(subtree);\n}\n}\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(!late);\n    NodeFunction fn = new NodeFunction(exportedFunction);\n    Node returnType = exportedFunction.getSecondChild();\n    if (returnType == null || !returnType.isString()) {\n      reportMissingReturnTypeError(fn);\n    }\n    Node paramList = exportedFunction.getLastChild();\n    if (paramList == null || paramList.getType() != Token.PARAM_LIST) {\n      reportMissingParamTypeError(fn);\n    }\n\n    // add the this value before the parameters if necessary\n    if (fn.thisValue != null && !NodeUtil.isUndefined(fn.thisValue)) {\n      // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n      Node newCallTarget = IR.getprop(\n          fn.callTarget.cloneTree(),\n          IR.string(\"call\").srcref(fn.callTarget));\n      fn.n.replaceChild(fn.callTarget, newCallTarget);\n      fn.n.addChildAfter(fn.thisValue.cloneTree(), newCallTarget);\n      fn.n.putBooleanProp(Node.FREE_CALL, false);\n    } else {\n      fn.n.putBooleanProp(Node.FREE_CALL, true);\n    }\n\n    // add the parameters to the call target\n    Node paramListCopy = paramList.cloneTree();\n    addParameterAfter(paramListCopy, fn.callTarget);\n\n    return createExternFunction(fn);\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Get the name of the exported function\n    String name = exportedFunction.getFirstChild().getString();\n    \n    // Get the original function node\n    Node originalFunction = exportedFunction.getLastChild().getLastChild();\n    \n    // Get the original parameters of the function\n    List<Node> originalParameters = originalFunction.getChild(1).getChildren();\n    \n    // Create a new list of parameters for the extern function\n    List<Node> externParameters = new ArrayList<>();\n    \n    // Add a param for the fakeName\n    externParameters.add(IR.name(fakeName));\n    \n    // Add the original parameters\n    externParameters.addAll(originalParameters);\n    \n    // Create the extern function\n    Node externFunction = IR.function(null, IR.name(name), externParameters, null);\n    \n    // Add the fake return value\n    externFunction.addChild(IR.returnStatement(IR.name(fakeName)));\n    \n    // Report a warning if the original function is missing a parameter or return type\n    if (originalFunction.getChild(2) == null) {\n        compiler.report(JSError.MISSING_PARAMETER_TYPE, originalFunction);\n    }\n    if (originalFunction.getChild(3) == null) {\n        compiler.report(JSError.MISSING_RETURN_TYPE, originalFunction);\n    }\n    \n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node newFunction = IR.getdecl(IR.identifier(exportedFunction.getName()));\n  Node newBody = IR.block();\n  newFunction.addChild(newBody);\n\n  // add all the parameters from the original function to the new function\n  Node originalParameters = exportedFunction.getChild(1);\n  Node newParameters = originalParameters.cloneTree();\n  newFunction.addChild(newParameters);\n\n  // create a new statement to return undefined\n  Node newReturn = IR.return_(IR.undefinedExpr());\n  newBody.addChild(newReturn);\n\n  // add the warning here\n  if (originalParameters.getChildCount() == 0) {\n    compiler.report(JSError.MISSING_PARAM_TYPES);\n  } else if (!NodeUtil.getReturnType(exportedFunction).isPresent()) {\n    compiler.report(JSError.MISSING_RETURN_TYPES);\n  }\n  \n  reportCodeChange();\n  return newFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(exportedFunction.isFunction());\n    Node externFunction = IR.fun(\n        IR.name(\"extern \" + exportedFunction.getName()),\n        IR.paramList(),\n        IR.block());\n    if (exportedFunction.getSecondChild() == null) {\n      compiler.reportWarning(\n          exportedFunction,\n          \"missing return type in function declaration\");\n    }\n    if (exportedFunction.getLastChild() == null) {\n      compiler.reportWarning(\n          exportedFunction,\n          \"missing parameter types in function declaration\");\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Get the function name\n    String name = exportedFunction.getFirstChild().getString();\n\n    // Get the function node\n    Node fnNode = exportedFunction.getFirstChild().getFirstChild();\n\n    // Check if the function has a return type\n    String returnType = null;\n    if (fnNode.getLastChild().getType() == Token.TYPE) {\n        returnType = fnNode.getLastChild().getLastChild().getString();\n    } else {\n        // No return type found, create a warning\n        compiler.reportWarning(\n            fnNode.getLastChild().getLastChild(),\n            \"Missing return type\");\n    }\n\n    // Check if the function has parameter types\n    List<String> paramTypes = new ArrayList<>();\n    for (Node param : fnNode.getFirstChild().getLastChild().getChildren()) {\n        if (param.getType() == Token.TYPE) {\n            paramTypes.add(param.getLastChild().getString());\n        } else {\n            // No parameter type found, create a warning\n            compiler.reportWarning(\n                param.getLastChild().getLastChild(),\n                \"Missing parameter type\");\n        }\n    }\n\n    // Create the extern function node\n    Node externFunction = IR.function(name, paramTypes, returnType);\n    externFunction.copyInformationFrom(fnNode);\n\n    // Add the extern function to the extern scope\n    externScope.addChild(externFunction);\n\n    // Report code change\n    reportCodeChange();\n\n    // Return the extern function node\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node newFunction = IR.function(exportedFunction.getLastChild());\n    if (exportedFunction.getChildCount() <= 2 || exportedFunction.getChild(2).getType() != Token.PARAM_LIST) {\n        System.err.println(\"Warning: Missing parameter type for function '\" + exportedFunction.getFirstChild().getString() + \"'\");\n    } else {\n        newFunction.addChildAfter(IR.paramList(NodeUtil.getTypes(exportedFunction.getChild(2))), newFunction.getFirstChild());\n    }\n    if (exportedFunction.getChildCount() <= 3 || exportedFunction.getChild(3).getType() != Token.BLOCK) {\n        System.err.println(\"Warning: Missing return type for function '\" + exportedFunction.getFirstChild().getString() + \"'\");\n    } else {\n        newFunction.addChildAfter(IR.block(), newFunction.getFirstChild());\n    }\n    newFunction.copyInformationFrom(exportedFunction);\n    return newFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n\n    if (n == 0) {\n        Arrays.fill(sigma, Double.NaN);\n    } else {\n        RealMatrix covariance = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covariance.getEntry(i, i));\n        }\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    computeCovariances(params, covarianceSingularityThreshold);\n\n    // Get the diagonal elements of the covariance matrix.\n    double[][] covMatrix = covarianceImpl.getResult().getData();\n\n    // Estimate the standard deviation of the parameters.\n    double[] sigma = new double[covMatrix.length];\n    for (int i = 0; i < covMatrix.length; i++) {\n        sigma[i] = Math.sqrt(covMatrix[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements of the covariance matrix.\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements of the covariance matrix.\n    double[] sigma = new double[covarianceMatrix.getRowDimension()];\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = covarianceMatrix.getEntry(i, i);\n    }\n\n    // Take the square root of the diagonal elements.\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = FastMath.sqrt(sigma[i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    RealMatrix covariance = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Get the diagonal elements of the covariance matrix.\n    double[] sigma = new double[covariance.getRowDimension()];\n    for (int i = 0; i < covariance.getRowDimension(); i++) {\n        sigma[i] = FastMath.sqrt(covariance.getEntry(i, i));\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    RealMatrix covariance = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements (i.e. variances).\n    double[] variances = covariance.getColumnVector(0).toArray();\n\n    // Compute the square root of the variances.\n    double[] sigma = new double[variances.length];\n    for (int i = 0; i < variances.length; i++) {\n        sigma[i] = FastMath.sqrt(variances[i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    computeCovariances(params, covarianceSingularityThreshold);\n\n    // Compute the standard deviations from the diagonal of the covariance matrix.\n    double[] sigma = new double[params.length];\n    double[][] cov = covarianceMatrix.getData();\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(cov[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n\n    // Compute the covariance matrix.\n    computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements of the covariance matrix.\n    double[] sigma = new double[covariance.getColumnDimension()];\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = covariance.getEntry(i, i);\n    }\n\n    // Return the square root of the diagonal elements.\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = Math.sqrt(sigma[i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        // cyclic substitution detected\n        throw new IllegalArgumentException(\"Cyclic substitution detected in variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    // Check if the variable is already in the list of prior variables\n    for (String priorVar : priorVariables)\n    {\n        if (priorVar.equals(varName)) {\n            throw new IllegalArgumentException(\n                    \"Cyclic substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVar : priorVariables) {\n        if (varName.equals(priorVar)) {\n            throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    // Check if the variable is already in the list\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVar : priorVariables) \n    {\n        if (priorVar.equals(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        // Cyclic substitution detected. Throw an exception.\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        // cyclic substitution detected\n        throw new RuntimeException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        String cycle = varName;\n        int index = priorVariables.indexOf(varName);\n        while (index >= 0)\n        {\n            cycle = priorVariables.get(index) + \" -> \" + cycle;\n            index = priorVariables.lastIndexOf(priorVariables.get(index), index - 1);\n        }\n        throw new IllegalArgumentException(\"Cyclic reference detected: \" + cycle);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    // Check if the variable is already in the list\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        // Cyclic substitution detected!\n        // Handle this exception or throw an exception\n        System.out.println(\"Cyclic substitution detected: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  List<INPUT> result = Lists.newArrayList();\n\n  // Collect all symbols provided in these files.\n  for (INPUT input : roots) {\n    for (String provide : input.getProvides()) {\n      provideMap.put(provide, input);\n    }\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : roots) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(roots, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n  // to the reader.\n  if (sortedList.size() < roots.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(roots);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  if (sorted) {\n    result.addAll(sortedList);\n  } else {\n    result.addAll(roots);\n  }\n\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  List<INPUT> result = Lists.newArrayList();\n\n  // Collect all the dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : roots) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(roots, deps);\n\n  if (!sorted) {\n    // If the user asked for the original order, we need to re-order the\n    // results to match the original order.\n    Map<INPUT, Integer> originalOrder = new HashMap<>();\n    for (int i = 0; i < roots.size(); i++) {\n      originalOrder.put(roots.get(i), i);\n    }\n\n    sortedList = sortedList.stream()\n        .sorted(Comparator.comparingInt(o -> originalOrder.get(o)))\n        .collect(Collectors.toList());\n  }\n\n  for (INPUT input : sortedList) {\n    result.add(input);\n    result.addAll(getDependenciesOf(input, deps));\n  }\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this\n  // as an exercise to the reader.\n  if (result.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(result);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  List<INPUT> inputs = Lists.newArrayList(roots);\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  if (sorted) {\n    return topologicalStableSort(inputs, deps);\n  } else {\n    // Return the inputs in the original order.\n    return inputs;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  List<INPUT> inputs = Lists.newArrayList(roots);\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n  if (sorted) {\n    return topologicalStableSort(inputs, deps);\n  } else {\n    return inputs;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  // Build a map of all the dependencies between inputs.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Topologically sort the inputs.\n  List<INPUT> sortedList = topologicalStableSort(roots, deps);\n\n  // Throw an exception if there is a cycle.\n  if (sortedList.size() < roots.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(roots);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  // Return the sorted list of dependencies.\n  return sorted ? sortedList : roots;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  // This is the list of all the nodes that are reachable from the roots.\n  final Set<INPUT> reachable = Sets.newHashSet();\n\n  // Add the roots to the reachable set.\n  reachable.addAll(roots);\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : roots) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(roots, deps);\n\n  // If sorted is true, return the sorted list. Otherwise, return the original\n  // list of roots.\n  if (sorted) {\n    return sortedList;\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n    List<INPUT> inputs = Lists.newArrayList(roots);\n    noProvides = Lists.newArrayList();\n\n    // Collect all symbols provided in these files.\n    for (INPUT input : inputs) {\n      Collection<String> currentProvides = input.getProvides();\n      if (currentProvides.isEmpty()) {\n        noProvides.add(input);\n      }\n\n      for (String provide : currentProvides) {\n        provideMap.put(provide, input);\n      }\n    }\n\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n\n    if (sorted) {\n      return sortedList;\n    } else {\n      return roots;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  List<INPUT> allInputs = Lists.newArrayList(roots);\n  for (INPUT input : inputs) {\n    if (!roots.contains(input)) {\n      allInputs.add(input);\n    }\n  }\n\n  // A topologically sorted list of the inputs.\n  List<INPUT> sortedList = topologicalStableSort(allInputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n  // to the reader.\n  if (sortedList.size() < allInputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(allInputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  return sorted ? sortedList : roots;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n  List<INPUT> inputs = Lists.newArrayList(roots);\n\n  // A topologically sorted list of the inputs.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // Throw an exception if the sortedList is a subset of inputs.\n  if (sorted && sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  return sorted ? sortedList : inputs;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n\n    // The roots are already sorted, so we just return them if we're sorted.\n    if (sorted) {\n      return roots;\n    }\n\n    List<INPUT> result = Lists.newArrayList();\n    List<INPUT> worklist = Lists.newArrayList();\n\n    // Add all the roots to the worklist.\n    for (INPUT root : roots) {\n      worklist.add(root);\n    }\n\n    // Keep processing the worklist until it's empty.\n    while (!worklist.isEmpty()) {\n      INPUT input = worklist.remove(worklist.size() - 1);\n\n      // Add the input to the result.\n      result.add(input);\n\n      // Get the dependencies of the input.\n      List<INPUT> deps = getDependencies(input);\n\n      // Remove any dependencies that are already in the result.\n      deps.removeAll(result);\n\n      // Add any new dependencies to the worklist.\n      worklist.addAll(deps);\n    }\n\n    // The dependency graph of roots has a cycle iff result is a proper subset of\n    // roots.\n    if (result.size() < roots.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(roots);\n      subGraph.removeAll(result);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n\n    return result;\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            if (Character.isUpperCase(ch)) {\n                buf[count++] = Character.toLowerCase(ch);\n            } else {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            if (Character.isUpperCase(ch)) {\n                buf[count++] = Character.toLowerCase(ch);\n            } else {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final StringBuilder buf = new StringBuilder(strLen);\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf.append(Character.toLowerCase(ch));\n            lastWasGap = false;\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final StringBuilder buf = new StringBuilder(strLen);\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf.append(Character.toLowerCase(ch));\n            lastWasGap = false;\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final StringBuilder buf = new StringBuilder(strLen);\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf.append(Character.toLowerCase(ch));\n            lastWasGap = false;\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n    Dfp result[] = new Dfp[2];\n\n    if (a.getField().getRadixDigits() != ln5Split[0].length) {\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result2 = newInstance(a.getZero());\n        result2.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, trapName, a, result2);\n    }\n\n    if (a.equals(getZero())) {\n        result[0] = newInstance(a);\n        result[1] = newInstance(a);\n        return result;\n    }\n\n    final Dfp[] x = split(a.getField(), a.toString());\n\n    result[0] = x[0];\n    if (x[0].equals(getZero())) {\n        result[0] = newInstance(a);\n    }\n\n    result[1] = x[1];\n    if (x[1].equals(getZero())) {\n        result[1] = newInstance(a);\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n    Dfp result[] = new Dfp[2];\n\n    if (a.getField().getRadixDigits() != ln5Split[0].length) {\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        result[0] = a.newInstance(a.getZero());\n        result[0].nans = QNAN;\n        return result.clone();\n    }\n\n    if (a.isZero()) {\n        result[0] = a.newInstance(a.getZero());\n        result[0].nans = QNAN;\n        result[1] = a.newInstance(a.getZero());\n        result[1].nans = QNAN;\n        return result.clone();\n    }\n\n    if (a.isInf()) {\n        result[0] = a.newInstance(a.getZero());\n        result[0].nans = QNAN;\n        result[1] = a.newInstance(a.getZero());\n        result[1].nans = QNAN;\n        return result.clone();\n    }\n\n    if (a.isNan()) {\n        result[0] = a.newInstance(a.getZero());\n        result[0].nans = QNAN;\n        result[1] = a.newInstance(a.getZero());\n        result[1].nans = QNAN;\n        return result.clone();\n    }\n\n    Dfp[] tmp = a.getField().split(a.toString());\n\n    result[0] = tmp[0];\n    result[1] = tmp[1];\n\n    return result.clone();\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n    DfpField field = a.getField();\n\n    if (field.getRadixDigits() != 400) {\n        Dfp result = field.newInstance(a);\n        result.nans = QNAN;\n        return new Dfp[] {result, result};\n    }\n\n    final DfpField.Dfp[] split = field.getSplit(a.toString());\n    final Dfp result[] = new Dfp[2];\n\n    for (int i=0; i<2; i++) {\n        result[i] = field.newInstance(split[i]);\n        result[i].sign = a.sign;\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = a.newInstance(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.newInstance(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n    final DfpField field = a.getField();\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.newInstance(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.newInstance(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n    final DfpField field = a.getField();\n    if (field.getRadixDigits() != 2) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result[] = new Dfp[2];\n        result[0] = field.newInstance(field.getZero());\n        result[0].nans = QNAN;\n        result[1] = field.newInstance(field.getZero());\n        result[1].nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, trapName, a, result);\n    }\n\n    if (a.lessThan(field.getZero())) {\n        return new Dfp[] {a, field.getZero()};\n    }\n\n    if (a.equals(field.getZero())) {\n        final Dfp result[] = new Dfp[2];\n        result[0] = field.newInstance(field.getZero());\n        result[0].nans = QNAN;\n        result[1] = field.newInstance(field.getZero());\n        result[1].nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, trapName, a, result);\n    }\n\n    final DfpField.DfpSplit result = field.split(a);\n\n    final Dfp r0 = field.newInstance(result.get0());\n    final Dfp r1 = field.newInstance(result.get1());\n    r0.nans = result.get0Nans();\n    r1.nans = result.get1Nans();\n    return new Dfp[] {r0, r1};\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n\n    if (!a.isFinite()) {\n        getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = a.nans;\n        return dotrap(DfpField.FLAG_INVALID, trapName, a, result);\n    }\n\n    final char[] s = new char[a.length()];\n    a.getChars(s, 0);\n    final Dfp[] result = split(a.getField(), new String(s));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final DfpField field = a.getField();\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9')\n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.')\n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp)\n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final String trapName = \"split\";\n\n    if (a.getField().getRadixDigits() != DfpField.BIG_RADIX_DIGITS) {\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result[] = new Dfp[2];\n        result[0] = dotrap(DfpField.FLAG_INVALID, trapName, a, a);\n        result[1] = dotrap(DfpField.FLAG_INVALID, trapName, a, a);\n        return result;\n    }\n\n    final Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.length()];\n    a.getChars(0, buf, 0);\n\n    for (int i = 0; i < buf.length; i++) {\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (DfpField.BIG_RADIX_DIGITS / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = new Dfp(DfpField.BIG_DECIMAL_FIELD, new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = new Dfp(DfpField.BIG_DECIMAL_FIELD, new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final DfpField field = a.getField();\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = field.newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    Element parent = parent();\n    if (parent != null)\n    {\n        accum.append(parent.cssSelector());\n        accum.append('>');\n    }\n    if (id() != null)\n    {\n        accum.append('#').append(id());\n    }\n    else\n    {\n        if (parent == null)\n            accum.append('/');\n        accum.append(tagName());\n        for (String c : classNames())\n            accum.append(\".\").append(c);\n        accum.append(':nth-child(').append(index()).append(')');\n    }\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    boolean first = true;\n    Element parent = this.parent;\n    while (parent != null)\n    {\n        String ptag = parent.tag().name();\n        if (first)\n        {\n            accum.append(ptag);\n            first = false;\n        }\n        else\n        {\n            accum.insert(0, ptag + \" > \");\n        }\n        parent = parent.parent;\n    }\n\n    String tag = this.tag().name();\n    String id = this.id();\n    List<String> classes = this.classNames();\n\n    if (id != null) \n    {\n        accum.append(\"#\").append(id);\n        return StringUtil.releaseBuilder(accum);\n    }\n\n    StringBuilder unique = StringUtil.borrowBuilder();\n    if (!classes.isEmpty()) \n    {\n        classes.sort(String::compareTo);\n        for (String c : classes)\n        {\n            unique.append(\".\").append(c);\n        }\n    }\n    else \n    {\n        unique.append(tag);\n    }\n    String unique_str = StringUtil.releaseBuilder(unique);\n\n    int idx = 0;\n    for (Element sib : this.siblings()) \n    {\n        if (sib.tag().name().equals(tag) && sib.equals(this))\n        {\n            accum.append(\":nth-child(\").append(++idx).append(\")\");\n            break;\n        }\n    }\n\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    boolean first = true;\n    for (Element ancestor : this.parents) \n    {\n        if (first) \n        {\n            accum.append(ancestor.cssSelector());\n            first = false;\n        }\n        else \n        {\n            accum.append(\" > \");\n            accum.append(ancestor.cssSelector());\n        }\n    }\n    if (id != null) \n    {\n        accum.append(\"#\").append(id);\n        return StringUtil.releaseBuilder(accum);\n    }\n    accum.append(\">\");\n    accum.append(this.uniqueSelector());\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    Element parent = this.parent;\n    while (parent != null) {\n        accum.insert(0, parent.cssSelector() + \" > \");\n        parent = parent.parent;\n    }\n    if (id != null) {\n        accum.append(id);\n        return StringUtil.releaseBuilder(accum);\n    }\n    accum.append(tag).append('.');\n    for (String c : classNames) {\n        accum.append(c).append('.');\n    }\n    accum.deleteCharAt(accum.length() - 1); // remove the trailing '.'\n    accum.append(':');\n    accum.append(\"nth-child(\").append(this.getIndex()).append(\")\");\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String cssSelector()  {\n    String id = getAttributeValue(\"id\");\n    if (id != null && !id.isEmpty())\n        return \"#\" + id;\n    return parentSelector() + \" > \" + uniqueSelector();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    if (id != null) {\n        accum.append('#').append(id);\n        return StringUtil.releaseBuilder(accum);\n    }\n    String parentSelector = parent != null ? parent.cssSelector() : \"*\";\n    accum.append(parentSelector).append('>').append(uniqueSelector());\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    List<String> classes = getClasses();\n    if (classes.isEmpty()) {\n        return parent().cssSelector() + \" > \" + tagName + \":nth-child(\" + (getIndex() + 1) + \")\";\n    } else {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < classes.size(); i++) {\n            if (i > 0) {\n                sb.append(\".\");\n            }\n            sb.append(classes.get(i));\n        }\n        return parent().cssSelector() + \" > \" + tagName + \".\" + sb.toString() + \":nth-child(\" + (getIndex() + 1) + \")\";\n    }\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    if (getParent() != null) {\n        return getParent().cssSelector() + \"> \" + getUniqueSelector();\n    }\n    return getUniqueSelector();\n}",
      "public String cssSelector()  {\n    if (id != null) {\n        return \"#\" + id;\n    } else {\n        StringBuilder accum = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) {\n            accum.append(parent.cssSelector());\n            accum.append(\">\");\n        }\n        accum.append(uniqueSelector());\n        return accum.toString();\n    }\n}",
      "public String cssSelector()  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    boolean first = true;\n    for (Element ancestor : this.ancestors)\n    {\n        accum.append(ancestor.cssSelector(first));\n        first = false;\n    }\n    String elementSelector = \"\";\n    if (this.hasId())\n    {\n        elementSelector = \"#\" + this.getId();\n    }\n    else\n    {\n        String tagName = this.getTag().toLowerCase();\n        String classSelector = \"\";\n        if (this.hasClass())\n        {\n            classSelector = \".\" + String.join(\".\", this.getClasses());\n        }\n        elementSelector = tagName + classSelector;\n        if (this.hasAttribute(\"data-unique-id\"))\n        {\n            elementSelector += \"[\" + this.getAttribute(\"data-unique-id\") + \"]\";\n        }\n        else\n        {\n            elementSelector += \":nth-child(\" + this.getIndexOfNthChild() + \")\";\n        }\n    }\n    accum.append(elementSelector);\n    return StringUtil.releaseBuilder(accum);\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n\tint cost = 0;\n\tswitch (n.getType())\n\t{\n\t\tcase Token.NOT:\n\t\t\tcost = 1;\n\t\t\tbreak;\n\t\tcase Token.LBRACE:\n\t\tcase Token.RBRACE:\n\t\tcase Token.LBRACK:\n\t\tcase Token.RBRACK:\n\t\tcase Token.LPAREN:\n\t\tcase Token.RPAREN:\n\t\t\tcost = 1;\n\t\t\tbreak;\n\t\tcase Token.WHILE:\n\t\tcase Token.FOR:\n\t\tcase Token.DO:\n\t\tcase Token.IF:\n\t\tcase Token.SWITCH:\n\t\tcase Token.CASE:\n\t\tcase Token.DEFAULT_CASE:\n\t\t\tcost = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT)\n    {\n        cost = 1;\n    }\n    else if (n.getType() == Token.LBRACE || n.getType() == Token.RBRACE ||\n             n.getType() == Token.LBRACK || n.getType() == Token.RBRACK ||\n             n.getType() == Token.LPAREN || n.getType() == Token.RPAREN)\n    {\n        cost = 1;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) {\n        cost += 1;\n    } else if (n.getType() == Token.MUL || n.getType() == Token.AND ||\n               n.getType() == Token.OR || n.getType() == Token.BITOR ||\n               n.getType() == Token.BITXOR || n.getType() == Token.BITAND) {\n        cost += 2;\n    }\n    if (n.getType() == Token.LBRACE || n.getType() == Token.LBRACK) {\n        cost += 1;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.isNOT()) {\n    cost++;\n  }\n  if (n.isParenthesized()) {\n    cost++;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.isNOT()) {\n    cost++;\n  } else if (NodeUtil.isLoopStructure(n)) {\n    return Integer.MAX_VALUE; // Don't bother optimizing loops\n  } else if (n.getType() == Token.IF) {\n    return estimateCostOneLevel(n.getFirstChild()) + estimateCostOneLevel(n.getLastChild());\n  } else if (n.getType() == Token.ARRAYLIT || n.getType() == Token.OBJECTLIT) {\n    return estimateCostOneLevel(n.getFirstChild()) + estimateCostOneLevel(n.getLastChild());\n  } else if (n.getType() == Token.CALL && n.getFirstChild().isName() &&\n             NodeUtil.isSafeToInlineCall(n)) {\n    return estimateCostOneLevel(n.getFirstChild()) + estimateCostOneLevel(n.getLastChild());\n  } else if (n.isParenthesized()) {\n    cost++;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n\t int totalCost = 0;\n\t int type = n.getType();\n\t switch (type) \n\t {\n\t case Token.NOT:\n\t\t totalCost += 1;\n\t\t break;\n\t case Token.LBRACE:\n\t case Token.RBRACE:\n\t case Token.LBRACK:\n\t case Token.RBRACK:\n\t case Token.LParen:\n\t case Token.RParen:\n\t\t totalCost += 1;\n\t\t break;\n\t case Token.FOR:\n\t case Token.WHILE:\n\t case Token.DO:\n\t case Token.IF:\n\t case Token.SWITCH:\n\t case Token.WITH:\n\t\t totalCost += 3;\n\t\t break;\n\t case Token.FUNCTION:\n\t\t totalCost += 5;\n\t\t break;\n\t case Token.ADD:\n\t case Token.MUL:\n\t case Token.EQ:\n\t case Token.NE:\n\t case Token.GT:\n\t case Token.LT:\n\t case Token.GE:\n\t case Token.LE:\n\t\t totalCost += 2;\n\t\t break;\n\t }\n\t return totalCost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  if (n.getType() == Token.NOT) \n  {\n    return 1 + estimateCostOneLevel(n.getFirstChild());\n  } else \n  {\n    int cost = 0;\n    for (Node child : n) \n    {\n      cost += estimateCostOneLevel(child);\n    }\n    return cost;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n\t int cost=0;\n\t int type=n.getType();\n\t if(type==Token.NOT) \n\t {\n\t\t cost=1;\n\t }\n\t else if(type==Token.AND||type==Token.OR)\n\t {\n\t\t cost=estimateCostOneLevel(n.getFirstChild())+estimateCostOneLevel(n.getLastChild())+1;\n\t }\n\t else if(type==Token.MUL)\n\t {\n\t\t cost=estimateCostOneLevel(n.getFirstChild())+estimateCostOneLevel(n.getLastChild())+1;\n\t }\n\t else if(type==Token.LBRACE)\n\t {\n\t\t cost=estimateCostOneLevel(n.getFirstChild())+estimateCostOneLevel(n.getLastChild())+1;\n\t }\n\t return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n\t int numNegations = 0;\n\t int numParentheses = 0;\n\t if (n.getType() == Token.NOT) \n\t {\n\t\t numNegations++;\n\t\t numParentheses += estimateCostOneLevel(n.getFirstChild());\n\t }\n\t else if (NodeUtil.isControlStructure(n)) \n\t {\n\t\t numParentheses++;\n\t\t numParentheses += estimateCostOneLevel(NodeUtil.getLoopCodeBlock(n));\n\t }\n\t else if (n.getType() == Token.IF) \n\t {\n\t\t numParentheses += estimateCostOneLevel(n.getFirstChild()); // test\n\t\t numParentheses += estimateCostOneLevel(n.getSecondChild()); // then\n\t\t numParentheses += estimateCostOneLevel(n.getLastChild());  // else\n\t }\n\t else if (n.getType() == Token.TRY)\n\t {\n\t\t numParentheses++;\n\t\t for (Node child : n.getChildren()) \n\t\t {\n\t\t\t numParentheses += estimateCostOneLevel(child);\n\t\t }\n\t }\n\t else if (n.getType() == Token.ARRAYLIT) \n\t {\n\t\t for (Node child : n.getChildren()) \n\t\t {\n\t\t\t numParentheses += estimateCostOneLevel(child);\n\t\t }\n\t }\n\t else if (n.getType() == Token.CALL) \n\t {\n\t\t for (Node arg : n.getChildren()) \n\t\t {\n\t\t\t numParentheses += estimateCostOneLevel(arg);\n\t\t }\n\t }\n\t else if (n.getType() == Token.NEW) \n\t {\n\t\t for (Node arg : n.getChildren()) \n\t\t {\n\t\t\t numParentheses += estimateCostOneLevel(arg);\n\t\t }\n\t }\n\t return numNegations + numParentheses;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) \n  {\n    cost = 1;\n  }\n  else if (n.getType() == Token.ARRAYLIT) \n  {\n    cost = 2;\n  }\n  else if (n.getType() == Token.MUL || n.getType() == Token.AND || n.getType() == Token.OR || n.getType() == Token.BITOR || n.getType() == Token.BITXOR || n.getType() == Token.BITAND)\n  {\n    cost = 1;\n  }\n  else if (n.getType() == Token.NAME) \n  {\n    cost = 0;\n  }\n  else if (n.getType() == Token.CALL) \n  {\n    cost = 2;\n  }\n  else if (n.getType() == Token.COND) \n  {\n    cost = 3;\n  }\n  else if (n.getType() == Token.WHILE || n.getType() == Token.DO || n.getType() == Token.FOR) \n  {\n    cost = 4;\n  }\n  else if (n.getType() == Token.ASSIGN) \n  {\n    cost = 5;\n  }\n  else if (n.getType() == Token.RETURN) \n  {\n    cost = 6;\n  }\n  else if (n.getType() == Token.BLOCK) \n  {\n    cost = 7;\n  }\n  else if (n.getType() == Token.IF) \n  {\n    cost = 8;\n  }\n  else if (n.getType() == Token.SWITCH) \n  {\n    cost = 9;\n  }\n  else if (n.getType() == Token.REGEXP) \n  {\n    cost = 10;\n  }\n  else if (n.getType() == Token.VAR) \n  {\n    cost = 11;\n  }\n  else if (n.getType() == Token.WITH) \n  {\n    cost = 12;\n  }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if(size == 0) {\n        return this;\n    }\n    int start = 0;\n    int end = size - 1;\n    while(start <= end) {\n        int temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    for (int i = 0; i < size / 2; i++) \n    {\n        final char tmp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start <= end) \n    {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) {\n        final char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start <= end) \n    {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) \n    {\n        final char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        final char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start < end) \n    {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    while (start < end)\n    {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == y) {\n        return true;\n    }\n    if ((x == null) || (y == null)) {\n        return false;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (MathUtils.equalsIncludingNaN(x, y)) {\n        return true;\n    }\n\n    if (x.length != y.length) {\n        return false;\n    }\n\n    for (int i = 0; i < x.length; ++i) {\n        if (!MathUtils.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) \n    {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) \n    {\n        return x == y;\n    }\n    if (x.length != y.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (MathArrays.equalsIncludingNaN(x, y)) {\n        return true;\n    }\n    if (Dfp.equalsIncludingNaN(x, y)) {\n        return true;\n    }\n    if (SimpleRegression.equalsIncludingNaN(x, y)) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > coreValue().length()) \n        throw new IllegalArgumentException(\"offset must be between 0 and \" + coreValue().length());\n\n    String leftText = coreValue().substring(0, offset);\n    String rightText = coreValue().substring(offset);\n\n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n\n    parentNode().insertBefore(rightNode, this.nextSibling());\n    parentNode().removeChild(this);\n\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = text();\n    if (offset > text.length())\n        throw new IndexOutOfBoundsException(\"Offset (\" + offset + \") must be less than or equal to text length (\" + text.length() + \")\");\n\n    TextNode before = new TextNode(text.substring(0, offset));\n    TextNode after = new TextNode(text.substring(offset));\n\n    parentNode().insertBefore(after, this.nextSibling());\n    parentNode().removeChild(this);\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n\tTextNode nextNode = new TextNode(coreValue().substring(offset));\n\tcoreValue(coreValue().substring(0, offset));\n\tparentNode().insertBefore(nextNode, this.nextSibling());\n\treturn nextNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String prefix = text.substring(0, offset);\n    String suffix = text.substring(offset);\n    TextNode prefixNode = new TextNode(prefix);\n    TextNode suffixNode = new TextNode(suffix);\n    insertBefore(suffixNode, getSiblingIndex());\n    return suffixNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > coreValue().length()) \n        throw new IllegalArgumentException(\"Offset must be between 0 and the length of the text\");\n    \n    String leftText = coreValue().substring(0, offset);\n    String rightText = coreValue().substring(offset);\n    \n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n    \n    parentNode().insertBefore(rightNode, nextSibling());\n    \n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > coreValue().length()) {\n        throw new IllegalArgumentException(\"Offset must be between 0 and \" + coreValue().length());\n    }\n\n    String text = coreValue();\n    String beforeText = text.substring(0, offset);\n    String afterText = text.substring(offset);\n\n    TextNode beforeNode = new TextNode(beforeText);\n    TextNode afterNode = new TextNode(afterText);\n\n    insertBefore(afterNode); // Insert the new text node after this one\n\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n\tString textBefore = getWholeText().substring(0, offset);\n\tString textAfter = getWholeText().substring(offset);\n\tTextNode newTextNode = new TextNode(textAfter);\n    parentNode.insertBefore(newTextNode, getNextSibling());\n\ttext(textBefore);\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n\tString text = coreValue();\n\t\n\tif (offset > 0 && offset < text.length())\n\t{\n\t\tString part1 = text.substring(0, offset);\n\t\tString part2 = text.substring(offset);\n\t\t\n\t\tTextNode newTextNode = new TextNode(part2);\n\t\tparentNode().insertBefore(newTextNode, this.nextSibling());\n\t\t\n\t\tcoreValue(part1);\n\t\t\n\t\treturn newTextNode;\n\t}\n\telse\n\t{\n\t\treturn this;\n\t}\n}",
      "public TextNode splitText(int offset)  {\n\tif(offset > coreValue().length())\n\t{\n\t\tthrow new IndexOutOfBoundsException(\"offset must be smaller or equal to the length of the text.\");\n\t}\n\tString text = coreValue();\n    TextNode newTextNode = new TextNode(text.substring(offset));\n    text(text.substring(0, offset));\n    parent().insertChild(nextSibling(), newTextNode);\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n\tTextNode textNode = new TextNode(getWholeText().substring(offset));\n    coreValue(getWholeText().substring(0, offset));\n    insertAfter(siblingIndex(), textNode);\n    return textNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int minFreq = helper.min(obj);\n        int maxFreq = helper.max(obj);\n        int newFreq = maxFreq - minFreq;\n        helper.setCardinality(obj, newFreq);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int max = helper.max(obj);\n        final int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int max = helper.max(obj);\n        int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int max = helper.max(obj);\n        int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int max = helper.max(obj);\n        int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int count = helper.max(obj) - helper.min(obj);\n        for (int i = 0; i < count; i++) {\n            helper.newList.add(obj);\n        }\n    }\n    return helper.newList;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        int minCardinality = helper.min(obj);\n        int maxCardinality = helper.max(obj);\n        for (int i = 0; i < maxCardinality - minCardinality; i++) {\n            helper.newList.add(obj);\n        }\n    }\n    return helper.newList;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int max = helper.max(obj);\n        final int min = helper.min(obj);\n        final int newCardinality = max - min;\n        helper.setCardinality(obj, newCardinality);\n        if (newCardinality > 0) {\n            helper.newList.add(obj);\n        }\n    }\n    return helper.newList;\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n        final byte[] result = new byte[16];\n        ByteUtils.toLittleEndian(result, value.longValue(), 0, 8);\n        ByteUtils.toLittleEndian(result, value.shiftRight(64).longValue(), 8, 8);\n        return result;\n    } else {\n        return getBytes(value.longValue());\n    }\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value == null) \n    {\n        return getBytes(0);\n    }\n    \n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value.longValue(), 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return ZipLong.getBytes(value.longValue());\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n        final byte[] result = new byte[16];\n        ByteUtils.toLittleEndian(result, value.longValue(), 0, 8);\n        ByteUtils.toLittleEndian(result, value.shiftRight(64).longValue(), 8, 8);\n        return result;\n    } else {\n        return getBytes((long)value);\n    }\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (final char c : chrs) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    // Use the delete() method to keep the characters present in the set\n    return delete(str, set, false);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    // Keep any of the characters present in the specified string\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    // Create a new StringBuilder to hold the modified string.\n    final StringBuilder buffer = new StringBuilder(str.length());\n    // Create a new char array to hold the characters of the string.\n    final char[] chrs = str.toCharArray();\n    // Iterate through the characters in the string.\n    for (int i = 0; i < chrs.length; i++) {\n        // Get the character at the current index.\n        final char ch = chrs[i];\n        // Create a new CharSet instance with the set of characters to keep.\n        final CharSet chars = CharSet.getInstance(set);\n        // Check if the character is in the set of characters to keep.\n        if (chars.contains(ch)) {\n            // If it is, append it to the new StringBuilder.\n            buffer.append(ch);\n        }\n    }\n    // Return the modified string.\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix with the square root of the covariance matrix\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Iterate over the rows and columns of the square root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            // Get the diagonal element of the covariance matrix\n            double covariance = getRootMatrix().getEntry(i, i);\n\n            // Calculate the square root of the diagonal element\n            double squareRootValue = FastMath.sqrt(covariance);\n\n            // Set the square root value in the square root matrix\n            squareRoot.setEntry(i, j, squareRootValue);\n\n            // If the row and column are different, set the corresponding element to 0\n            if (i != j) {\n                squareRoot.setEntry(j, i, 0.0);\n            }\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix for the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from RectangularCholeskyDecomposition\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Copy the upper triangle of the root matrix to the square root matrix\n    for (int i = 0; i < rank; i++)\n    {\n        for (int j = 0; j <= i; j++)\n        {\n            squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n        }\n    }\n\n    // Set the diagonal elements of the square root matrix to 1\n    for (int i = 0; i < rank; i++)\n    {\n        squareRoot.setEntry(i, i, 1.0);\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix for the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from RectangularCholeskyDecomposition\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Extract the square root from the root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (i == j) {\n                squareRoot.setEntry(i, j, FastMath.sqrt(rootMatrix.getEntry(i, i)));\n            } else {\n                squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n            }\n        }\n    }\n\n    // Transpose the square root matrix since it's currently in upper triangular form\n    return squareRoot.transpose();\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix with the square root of the covariance matrix\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from the RectangularCholeskyDecomposition class\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Iterate over the columns of the root matrix and set the corresponding elements in the square root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n        }\n    }\n\n    // Set the diagonal elements to 1\n    for (int i = 0; i < rank; i++) {\n        squareRoot.setEntry(i, i, 1.0);\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(root.getRowDimension(), rank);\n\n    // Iterate over the rows and columns of the root matrix\n    for (int i = 0; i < root.getRowDimension(); ++i) \n    {\n        for (int j = 0; j < rank; ++j) \n        {\n            // Set the entry in the square root matrix to the square root of the corresponding entry in the root matrix\n            squareRoot.setEntry(i, j, FastMath.sqrt(root.getEntry(i, j)));\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix for the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from RectangularCholeskyDecomposition\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Extract the upper triangular part of the root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n        }\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix with the same dimensions as the covariance matrix\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from the RectangularCholeskyDecomposition object\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Set the entries of the square root matrix to the corresponding entries of the root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix with the same dimensions as the covariance matrix\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from the RectangularCholeskyDecomposition class\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Iterate over the rows and columns of the square root matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            // Get the entry from the root matrix\n            double entry = rootMatrix.getEntry(i, j);\n\n            // Set the entry in the square root matrix\n            squareRoot.setEntry(i, j, entry);\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from the RectangularCholeskyDecomposition\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Compute the square root of the covariance matrix\n    for (int i = 0; i < rank; i++) {\n        for (int j = 0; j <= i; j++) {\n            squareRoot.setEntry(i, j, Math.sqrt(rootMatrix.getEntry(i, j)));\n        }\n    }\n\n    // Set the remaining entries to zero\n    for (int i = rank; i < getRootMatrix().getColumnDimension(); i++) {\n        for (int j = 0; j < getRootMatrix().getRowDimension(); j++) {\n            squareRoot.setEntry(i, j, 0);\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Get the rank of the covariance matrix\n    int rank = getRank();\n\n    // Create a new matrix with the same dimensions as the covariance matrix\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(rank, rank);\n\n    // Get the root matrix from the RectangularCholeskyDecomposition\n    RealMatrix rootMatrix = getRootMatrix();\n\n    // Copy the elements from the root matrix to the square root matrix\n    for (int i = 0; i < rank; i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            squareRoot.setEntry(i, j, rootMatrix.getEntry(i, j));\n        }\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != null) {\n            switch (t) {\n            case START_OBJECT:\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            case START_ARRAY:\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            case FIELD_NAME:\n            case END_OBJECT:\n                if (_vanillaProcessing) {\n                    throw ctxt.endOfInputException(handledType());\n                }\n                if (_objectIdReader != null) {\n                    return deserializeWithObjectId(p, ctxt);\n                }\n                return deserializeFromObject(p, ctxt);\n            default:\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        ObjectNode node = ctxt.getNodeFactory().objectNode();\n        String key = p.nextFieldName();\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken token = p.nextToken();\n            if (token == null) { // can this ever occur?\n                token = JsonToken.NOT_AVAILABLE; // can this ever occur?\n            }\n            switch (token.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_STRING:\n                value = ctxt.getNodeFactory().textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = ctxt.getNodeFactory().booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = ctxt.getNodeFactory().booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = ctxt.getNodeFactory().nullNode();\n                break;\n            default:\n                value = deserializeAny(p, ctxt, ctxt.getNodeFactory());\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, ctxt.getNodeFactory(),\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object value;\n        switch (t.id()) {\n            case JsonTokenId.ID_STRING:\n                value = ctxt.getNodeFactory().textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = ctxt.getNodeFactory().numberNode(p.getLongValue());\n                break;\n            case JsonTokenId.ID_NUMBER_FLOAT:\n                value = ctxt.getNodeFactory().numberNode(p.getDoubleValue());\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = ctxt.getNodeFactory().booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = ctxt.getNodeFactory().booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = ctxt.getNodeFactory().nullNode();\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case JsonTokenId.ID_END_OBJECT:\n                p.skipChildren();\n                value = null;\n                break;\n            case JsonTokenId.ID_FIELD_NAME:\n                value = deserializeAny(p, ctxt, ctxt.getNodeFactory());\n                break;\n            default:\n                throw ctxt.handleUnexpectedToken(handledType(), t);\n        }\n        return value;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        ObjectNode node = ctxt.getNodeFactory().objectNode();\n        String key = p.nextFieldName();\n        for (; key != null; key = p.nextFieldName()) {\n            JsonNode value;\n            JsonToken tt = p.nextToken();\n            switch (tt) {\n            case VALUE_STRING:\n                value = ctxt.getNodeFactory().textNode(p.getText());\n                break;\n            case VALUE_NUMBER_INT:\n                value = ctxt.getNodeFactory().numberNode(p.getLongValue());\n                break;\n            case VALUE_NUMBER_FLOAT:\n                value = ctxt.getNodeFactory().numberNode(p.getDoubleValue());\n                break;\n            case VALUE_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, ctxt.getNodeFactory());\n                break;\n            case VALUE_TRUE:\n                value = ctxt.getNodeFactory().booleanNode(true);\n                break;\n            case VALUE_FALSE:\n                value = ctxt.getNodeFactory().booleanNode(false);\n                break;\n            case VALUE_NULL:\n                value = ctxt.getNodeFactory().nullNode();\n                break;\n            default:\n                throw ctxt.handleUnexpectedToken(handledType(), p);\n            }\n            node.set(key, value);\n        }\n        return node;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object result = _deserializeOther(p, ctxt, t);\n        if (result == ctxt.getMissingTokenHandler().handleMissingToken(ctxt, handledType())) {\n            t = p.nextToken();\n            if (t == JsonToken.END_OBJECT) {\n                return ctxt.getMissingTokenHandler().handleUnexpectedToken(ctxt, handledType(), p);\n            } else {\n                throw new JsonParseException(\"Unexpected token after \"\n                    + ctxt.getParser().getParserFeatures() + \": \"\n                    + t + \" (\" + t.id() + \")\");\n            }\n        }\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != null) {\n            switch (t) {\n            case START_OBJECT:\n                return deserializeObject(p, ctxt,\n                        ctxt.getNodeFactory());\n            case START_ARRAY:\n                return deserializeArray(p, ctxt,\n                        ctxt.getNodeFactory());\n            case VALUE_STRING:\n                return ctxt.getNodeFactory().textNode(p.getText());\n            case VALUE_NUMBER_INT:\n                return _fromInt(p, ctxt, ctxt.getNodeFactory());\n            case VALUE_NUMBER_FLOAT:\n                return ctxt.getNodeFactory().numberNode(p.getDoubleValue());\n            case VALUE_EMBEDDED_OBJECT:\n                return _fromEmbedded(p, ctxt, ctxt.getNodeFactory());\n            case VALUE_TRUE:\n                return ctxt.getNodeFactory().booleanNode(true);\n            case VALUE_FALSE:\n                return ctxt.getNodeFactory().booleanNode(false);\n            case VALUE_NULL:\n                return ctxt.getNodeFactory().nullNode();\n            default:\n                break;\n            }\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object value;\n        switch (t.id()) {\n        case JsonTokenId.ID_STRING:\n            value = p.getText();\n            break;\n        case JsonTokenId.ID_NUMBER_INT:\n            value = p.getLongValue();\n            break;\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            value = p.getDoubleValue();\n            break;\n        case JsonTokenId.ID_TRUE:\n            value = Boolean.TRUE;\n            break;\n        case JsonTokenId.ID_FALSE:\n            value = Boolean.FALSE;\n            break;\n        case JsonTokenId.ID_NULL:\n            value = null;\n            break;\n        default:\n            throw new IOException(\"Unexpected token: \" + t);\n        }\n        return value;\n    }\n\n    protected final ObjectNode deserializeObject(JsonParser p, DeserializationContext ctxt,\n            final JsonNodeFactory nodeFactory) throws IOException\n    {\n        final ObjectNode node = nodeFactory.objectNode();\n        JsonToken t = p.nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            return deserializeObjectAtName(p, ctxt, nodeFactory);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            String key;\n            while ((key = p.nextFieldName()) != null) {\n                JsonNode value;\n                t = p.nextToken();\n                switch (t.id()) {\n                case JsonTokenId.ID_START_OBJECT:\n                    value = deserializeObject(p, ctxt, nodeFactory);\n                    break;\n                case JsonTokenId.ID_START_ARRAY:\n                    value = deserializeArray(p, ctxt, nodeFactory);\n                    break;\n                case JsonTokenId.ID_EMBEDDED_OBJECT:\n                    value = _fromEmbedded(p, ctxt, nodeFactory);\n                    break;\n                case JsonTokenId.ID_STRING:\n                    value = nodeFactory.textNode(p.getText());\n                    break;\n                case JsonTokenId.ID_NUMBER_INT:\n                    value = _fromInt(p, ctxt, nodeFactory);\n                    break;\n                case JsonTokenId.ID_TRUE:\n}\n}\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != null) {\n            switch (t) {\n            case START_OBJECT:\n                return deserializeObject(p, ctxt, (JsonNodeFactory)ctxt.getNodeFactory());\n            case START_ARRAY:\n                return deserializeArray(p, ctxt, (JsonNodeFactory)ctxt.getNodeFactory());\n            case VALUE_STRING:\n                return ctxt.getNodeFactory().textNode(p.getText());\n            case VALUE_NUMBER_INT:\n                return _fromInt(p, ctxt, (JsonNodeFactory)ctxt.getNodeFactory());\n            case VALUE_NUMBER_FLOAT:\n                return _fromDouble(p, ctxt, (JsonNodeFactory)ctxt.getNodeFactory());\n            case VALUE_TRUE:\n                return ctxt.getNodeFactory().booleanNode(true);\n            case VALUE_FALSE:\n                return ctxt.getNodeFactory().booleanNode(false);\n            case VALUE_NULL:\n                return ctxt.getNodeFactory().nullNode();\n            default:\n                return ctxt.handleUnexpectedToken(handledType(), p);\n            }\n        } else {\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == null) {\n            t = JsonToken.NOT_AVAILABLE;\n        }\n        Object value;\n        switch (t.id()) {\n            case JsonTokenId.ID_START_OBJECT:\n                value = deserializeObject(p, ctxt, _nodeFactory);\n                break;\n            case JsonTokenId.ID_START_ARRAY:\n                value = deserializeArray(p, ctxt, _nodeFactory);\n                break;\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _fromEmbedded(p, ctxt, _nodeFactory);\n                break;\n            case JsonTokenId.ID_STRING:\n                value = _nodeFactory.textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = _fromInt(p, ctxt, _nodeFactory);\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = _nodeFactory.booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = _nodeFactory.booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = _nodeFactory.nullNode();\n                break;\n            default:\n                value = _missingToken(p, ctxt);\n        }\n        return value;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        ObjectNode node = ctxt.getNodeFactory().objectNode();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String key = p.getCurrentName();\n            t = p.nextToken();\n            JsonNode value;\n            switch (t.id()) {\n            case JsonTokenId.ID_STRING:\n                value = ctxt.getNodeFactory().textNode(p.getText());\n                break;\n            case JsonTokenId.ID_NUMBER_INT:\n                value = ctxt.getNodeFactory().numberNode(p.getLongValue());\n                break;\n            case JsonTokenId.ID_TRUE:\n                value = ctxt.getNodeFactory().booleanNode(true);\n                break;\n            case JsonTokenId.ID_FALSE:\n                value = ctxt.getNodeFactory().booleanNode(false);\n                break;\n            case JsonTokenId.ID_NULL:\n                value = ctxt.getNodeFactory().nullNode();\n                break;\n            case JsonTokenId.ID_START_OBJECT:\n            case JsonTokenId.ID_START_ARRAY:\n            case JsonTokenId.ID_EMBEDDED_OBJECT:\n                value = _deserializeOther(p, ctxt, t);\n                break;\n            default:\n                value = deserializeAny(p, ctxt, node);\n            }\n            JsonNode old = node.replace(key, value);\n            if (old != null) {\n                _handleDuplicateField(p, ctxt, ctxt.getNodeFactory(),\n                        key, node, old, value);\n            }\n        }\n        return node;\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(\"Cannot calculate sum of differences because no data exists\");\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty\");\n    }\n\n    double sumDifference = 0.0;\n\n    for (int i = 0; i < sample1.length; i++) {\n        sumDifference += sample1[i] - sample2[i];\n    }\n\n    return sumDifference;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(\"sample1 must contain at least one value\");\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        Object[] result = _freeBuffer;\n        if (result == null) {\n            result = new Object[Math.max(12, fullChunk.length)];\n        } else if (result.length < fullChunk.length) {\n            result = new Object[Math.max(fullChunk.length, doubleSize(result.length))];\n        }\n        System.arraycopy(fullChunk, 0, result, 0, fullChunk.length);\n        _freeBuffer = result;\n        _size += fullChunk.length;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _size += fullChunk.length;\n        if ((_freeBuffer == null) || (_freeBuffer.length < fullChunk.length)) {\n            _freeBuffer = new Object[Math.max(12, fullChunk.length)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        Object[] oldFreeBuffer = _freeBuffer;\n        Object[] newFreeBuffer = new Object[_freeBuffer.length + len];\n        System.arraycopy(oldFreeBuffer, 0, newFreeBuffer, 0, _freeBuffer.length);\n        System.arraycopy(fullChunk, 0, newFreeBuffer, _freeBuffer.length, len);\n        _freeBuffer = newFreeBuffer;\n        return newFreeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        Object[] newChunk = null;\n        if (_freeBuffer != null) {\n            int len = Math.min(fullChunk.length, _freeBuffer.length);\n            System.arraycopy(fullChunk, 0, _freeBuffer, 0, len);\n            newChunk = _freeBuffer;\n            _freeBuffer = null;\n        } else {\n            newChunk = fullChunk;\n        }\n        _size += fullChunk.length;\n        return newChunk;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _copyTo(_freeBuffer, _freeBuffer.length, fullChunk, fullChunk.length);\n        Object[] result = _freeBuffer;\n        _freeBuffer = null;\n        _size += fullChunk.length;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = fullChunk.length + _size;\n        Object[] newFreeBuffer = new Object[Math.max(12, newSize)];\n        if (_freeBuffer != null) {\n            System.arraycopy(_freeBuffer, 0, newFreeBuffer, 0, _freeBuffer.length);\n        }\n        System.arraycopy(fullChunk, 0, newFreeBuffer, _size, fullChunk.length);\n        Object[] result = _freeBuffer;\n        _freeBuffer = newFreeBuffer;\n        _size = newSize;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        final int len = fullChunk.length;\n        final int oldSize = _size;\n        final int newSize = oldSize + len;\n        final Object[] newBuffer = new Object[newSize];\n\n        if (oldSize > 0) {\n            System.arraycopy(_freeBuffer, 0, newBuffer, 0, oldSize);\n        }\n        System.arraycopy(fullChunk, 0, newBuffer, oldSize, len);\n\n        _freeBuffer = newBuffer;\n        _size = newSize;\n\n        return newBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        Object[] result = _freeBuffer;\n        if (result == null) {\n            result = new Object[Math.max(12, fullChunk.length)];\n        }\n        int len = Math.min(result.length, fullChunk.length);\n        System.arraycopy(fullChunk, 0, result, 0, len);\n        for (int i = len; i < fullChunk.length; i++) {\n            result[i] = fullChunk[i];\n        }\n        _freeBuffer = null;\n        _size += fullChunk.length;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        final int len = fullChunk.length;\n        final Object[] buffer = resetAndStart(_freeBuffer, len);\n        System.arraycopy(fullChunk, 0, buffer, 0, len);\n        return buffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        Object[] newChunk;\n        if (_freeBuffer == null) {\n            newChunk = new Object[Math.max(12, fullChunk.length)];\n        } else if (_freeBuffer.length < fullChunk.length) {\n            newChunk = new Object[Math.max(12, fullChunk.length)];\n        } else {\n            newChunk = _freeBuffer;\n            _freeBuffer = null;\n        }\n        _copyIn(fullChunk, newChunk, 0);\n        _size += fullChunk.length;\n        return newChunk;\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n\tif (token == JsDocToken.ASTERISK) {\n\t\treturn newNode(Token.ASTERISK);\n\t} else if (token == JsDocToken.NULL) {\n\t\treturn newNode(Token.NULL);\n\t} else if (token == JsDocToken.UNDEFINED) {\n\t\treturn newNode(Token.UNDEFINED);\n\t} else {\n\t\treturn parseTypeName(token);\n\t}\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case STRING:\n      return parseTypeName(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case UNION:\n      return parseUnionType(token);\n    case RECORD:\n      return parseRecordType(token);\n    case ARRAY:\n      return parseArrayType(token);\n    default:\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.basic.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token)\n    {\n        case Token.STAR:\n            return newNode(Token.STAR);\n        case Token.NULL:\n            return newNode(Token.NULL);\n        case Token.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        default:\n            return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n\tif (token == JsDocToken.STAR) \n\t{\n\t\treturn newNode(Token.STAR);\n\t}\n\telse if (token == JsDocToken.NULL)\n\t{\n\t\treturn newNode(Token.NULL);\n\t}\n\telse if (token == JsDocToken.UNDEFINED)\n\t{\n\t\treturn newNode(Token.UNDEFINED);\n\t}\n\telse \n\t{\n\t\treturn parseTypeName(token);\n\t}\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n\tif (token == JsDocToken.ASTERISK) {\n\t\treturn newNode(Token.ASTERISK);\n\t} else if (token == JsDocToken.NULL) {\n\t\treturn newNode(Token.NULL);\n\t} else if (token == JsDocToken.UNDEFINED) {\n\t\treturn newNode(Token.UNDEFINED);\n\t} else {\n\t\treturn parseTypeName(token);\n\t}\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else {\n        return parseTypeName(token);\n    }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (deferredName == null)\n    {\n        throw new NullPointerException(\"Deferred name is null\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n      throw new IllegalArgumentException(\"name == null\");\n    }\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    if (deferredName == null) {\n      deferredName = name;\n      return this;\n    }\n    else {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n                else if (value < 0.0) {\n                    total = total - value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n                if (value < 0.0) {\n                    total = total + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n        //maximum = Math.max(maximum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n        if (array == null)\n        {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0)\n        {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try\n        {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (final NullPointerException ex)\n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null)\n        {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0)\n        {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try\n        {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        }\n        catch (final NullPointerException ex)\n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) \n        {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) \n        {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try \n        {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.isEmpty()) {\n        return str;\n    }\n\n    final int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return \"\";\n    }\n\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder(buffer.length);\n    boolean capitalizeNext = true;\n\n    for (final char ch : buffer) {\n        if (Character.isWhitespace(ch)) {\n            capitalizeNext = true;\n        } else if (delimLen > 0 && isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            initials.append(ch);\n            capitalizeNext = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimeters == null) {\n        delimeters = new char[] {' '};\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder buf = new StringBuilder(buffer.length);\n    boolean wordStart = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            wordStart = true;\n        } else if (wordStart) {\n            buf.append(ch);\n            wordStart = false;\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (isDelimiter(ch, delimiters) && !firstWord) {\n            initials.append(ch);\n        }\n        if (!Character.isWhitespace(ch)) {\n            initials.append(ch);\n            firstWord = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder(str.length());\n    boolean newWord = true;\n    final char[] wordChars = str.toCharArray();\n    for (final char c : wordChars) {\n        if (newWord) {\n            initials.append(c);\n            newWord = false;\n        } else if (isDelimiter(c, delimiters)) {\n            newWord = true;\n        } else {\n            newWord = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (isDelimiter(ch, delimiters) || firstWord) {\n            firstWord = false;\n            if (i < buffer.length - 1 && Character.isLowerCase(buffer[i + 1])) {\n                initials.append(ch);\n            } else {\n                initials.append(Character.toUpperCase(ch));\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (isDelimiter(ch, delimiters)) {\n            firstWord = true;\n        } else {\n            if (firstWord) {\n                initials.append(ch);\n                firstWord = false;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder buf = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buf.append(ch);\n            capitalizeNext = false;\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            firstWord = true;\n        } else {\n            if (firstWord) {\n                initials.append(Character.toUpperCase(ch));\n                firstWord = false;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return \"\";\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = false;\n    final StringBuilder buf = new StringBuilder();\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buf.append(ch);\n            capitalizeNext = false;\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder(str.length());\n    boolean wordStart = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters) || !Character.isLetter(ch)) {\n            wordStart = true;\n        } else if (wordStart) {\n            initials.append(ch);\n            wordStart = false;\n        }\n    }\n    return initials.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int row = 0; row < rowCount; row++) {\n\t\tNumber n = data.getValue(row, column);\n\t\tif (n != null) {\n\t\t\ttotal += n.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int r = 0; r < rowCount; r++) {\n\t\tNumber n = data.getValue(r, column);\n\t\tif (n != null) {\n\t\t\ttotal += n.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t    throw new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int row = 0; row < rowCount; row++) {\n\t    Number n = data.getValue(row, column);\n\t    if (n != null) {\n\t        total += n.doubleValue();\n\t    }\n\t}\n\treturn total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t    throw new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int row = 0; row < rowCount; row++) {\n\t    Number n = data.getValue(row, column);\n\t    if (n != null) {\n\t        total += n.doubleValue();\n\t    }\n\t}\n\treturn total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int r = 0; r < rowCount; r++) {\n\t\tNumber n = data.getValue(r, column);\n\t\tif (n != null) {\n\t\t\ttotal += n.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) \n    {\n        Number n = data.getValue(row, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int v = 0; v < rowCount; v++) {\n        Number n = data.getValue(v, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int v = 0; v < rowCount; v++) {\n        Number n = data.getValue(v, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n\tif (data == null) {\n\t    throw new IllegalArgumentException(\"Null 'data' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint rowCount = data.getRowCount();\n\tfor (int row = 0; row < rowCount; row++) {\n\t\tNumber n = data.getValue(row, column);\n\t\tif (n != null) {\n\t\t\ttotal += n.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    final ParsePosition parsePosition = new ParsePosition(0);\n    final BigFraction result = parse(source, parsePosition);\n    if (parsePosition.getIndex() == 0) {\n        throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n    }\n    return result;\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    // TODO Auto-generated method stub\n    return null;\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(),\n                BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(),\n                BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        // Create an empty set and list to decorate\n        final Set<E> set = new HashSet<E>();\n        final List<E> decoratedList = new ArrayList<E>();\n        return new ListOrderedSet<E>(set, decoratedList);\n    }\n    // Create a new set and list to decorate\n    final Set<E> set = new HashSet<E>();\n    final List<E> decoratedList = new ArrayList<E>();\n\n    // Iterate over the list and add elements to the set and list\n    for (final E element : list) {\n        if (!set.contains(element)) {\n            set.add(element);\n            decoratedList.add(element);\n        }\n    }\n    return new ListOrderedSet<E>(set, decoratedList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list); // create a new set from the list\n    return new ListOrderedSet<>(set, list); // pass set and list to the constructor\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list); // HashSet to remove duplicates\n    list.clear(); // Clear the list to avoid duplicates\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    List<E> temp = new ArrayList<>(list);\n    list.clear();\n    ListOrderedSet<E> sl = new ListOrderedSet<>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        // Create an empty ordered set.\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    // Remove duplicates and preserve order.\n    final Set<E> set = new HashSet<>(list);\n    final List<E> uniqueList = new ArrayList<>(set);\n    uniqueList.sort(Comparator.naturalOrder()); // Assuming natural ordering is desired.\n    return new ListOrderedSet<>(set, uniqueList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list); // remove duplicates\n    list.clear(); // clear the original list\n    list.addAll(set); // add unique elements back\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        // Create an empty ordered set.\n        return new ListOrderedSet<E>(new HashSet<>(), new ArrayList<>());\n    }\n    // Remove duplicates from the list and create a new ordered set.\n    final List<E> tempList = new ArrayList<>(new HashSet<>(list));\n    list.clear();\n    final ListOrderedSet<E> orderedSet = new ListOrderedSet<>(new HashSet<>(), new ArrayList<>());\n    orderedSet.addAll(tempList);\n    return orderedSet;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Plot plot = getPlot();\n    if (plot == null) {\n        return null;\n    }\n    if (plot instanceof ValueAxisPlot) {\n        return ((ValueAxisPlot) plot).getDataRange(axis);\n    }\n    else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.NaN;\n    double max = Double.NaN;\n    for (Subplot subplot : getSubplots()) {\n        min = Math.min(min, subplot.getDataRange(axis).getLowerBound());\n        max = Math.max(max, subplot.getDataRange(axis).getUpperBound());\n    }\n    if (Double.isNaN(min) || Double.isNaN(max)) {\n        return getDefaultAutoRange();\n    }\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = Double.NaN;\n    Range range = null;\n    NumberAxis na = null;\n    DateAxis da = null;\n    LogAxis la = null;\n    PeriodAxis pa = null;\n    Plot plot = getPlot();\n    if (plot instanceof ValueAxisPlot) {\n        ValueAxisPlot vap = (ValueAxisPlot) plot;\n        if (axis == getRangeAxis()) {\n            range = vap.getDataRange(this);\n        }\n        else {\n            range = vap.getDataRange(axis);\n        }\n    }\n    if (range == null) {\n        return getDefaultAutoRange();\n    }\n    if (axis instanceof NumberAxis) {\n        na = (NumberAxis) axis;\n    }\n    else if (axis instanceof DateAxis) {\n        da = (DateAxis) axis;\n    }\n    else if (axis instanceof LogAxis) {\n        la = (LogAxis) axis;\n    }\n    else if (axis instanceof PeriodAxis) {\n        pa = (PeriodAxis) axis;\n    }\n    if (na != null) {\n        double max = range.getUpperBound();\n        double min = range.getLowerBound();\n        if (na.getRangeType() == RangeType.POSITIVE) {\n            min = Math.max(0.0, min);\n            max = Math.max(0.0, max);\n        }\n        else if (na.getRangeType() == RangeType.NEGATIVE) {\n            min = Math.min(0.0, min);\n            max = Math.min(0.0, max);\n        }\n        if (na.getAutoRangeIncludesZero()) {\n            min = Math.min(min, 0.0);\n            max = Math.max(max, 0.0);\n        }\n        result = new Range(min, max);\n    }\n    else if (da != null) {\n        long upper = da.getTimeline().toTimelineValue(\n                (long) range.getUpperBound());\n        long lower;\n        long fixedAutoRange = (long) da.getFixedAutoRange();\n        if (fixedAutoRange > 0.0) {\n            lower = upper - fixedAutoRange;\n}\n}\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null || getPlot() == null) {\n        return getDefaultAutoRange();\n    }\n\n    Plot plot = getPlot();\n    if (plot instanceof ValueAxisPlot) {\n        ValueAxisPlot vap = (ValueAxisPlot) plot;\n\n        Range r = vap.getDataRange(axis);\n        if (r == null) {\n            r = getDefaultAutoRange();\n        }\n\n        if (axis.getRangeType() == RangeType.POSITIVE) {\n            r = new Range(Math.max(r.getLowerBound(), 0.0), r.getUpperBound());\n        }\n        else if (axis.getRangeType() == RangeType.NEGATIVE) {\n            r = new Range(r.getLowerBound(), Math.min(r.getUpperBound(), 0.0));\n        }\n\n        if (axis.getAutoRangeIncludesZero()) {\n            r = new Range(Math.min(r.getLowerBound(), 0.0), Math.max(r.getUpperBound(), 0.0));\n        }\n        return r;\n    }\n\n    return getDefaultAutoRange();\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.NaN;\n    double max = Double.NaN;\n    for (Plot subplot : getSubplots()) {\n        if (subplot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap = (ValueAxisPlot) subplot;\n            Range r = vap.getDataRange(axis);\n            if (r != null) {\n                double submin = r.getLowerBound();\n                double submax = r.getUpperBound();\n                if (axis.isInverted()) {\n                    if (min == Double.NaN || submin > min) {\n                        min = submin;\n                    }\n                    if (max == Double.NaN || submax < max) {\n                        max = submax;\n                    }\n                }\n                else {\n                    if (min == Double.NaN || submin < min) {\n                        min = submin;\n                    }\n                    if (max == Double.NaN || submax > max) {\n                        max = submax;\n                    }\n                }\n            }\n        }\n    }\n    if (!Double.isNaN(min) && !Double.isNaN(max)) {\n        return new Range(min, max);\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Plot plot = getPlot();\n    if (plot == null) {\n        return null;\n    }\n    if (axis != getRangeAxis()) {\n        return null;\n    }\n\n    Range r = plot.getDataRange(this);\n    if (r == null) {\n        r = getDefaultAutoRange();\n    }\n\n    double lower = r.getLowerBound();\n    double upper = r.getUpperBound();\n\n    if (lower == Double.NEGATIVE_INFINITY) {\n        lower = getRange().getLowerBound();\n    }\n    if (upper == Double.POSITIVE_INFINITY) {\n        upper = getRange().getUpperBound();\n    }\n\n    double range = upper - lower;\n\n    if (range <= getAutoRangeMinimumSize()) {\n        double expand = Math.max(getAutoRangeMinimumSize() - range, 0.0) / 2;\n        lower = lower - expand;\n        upper = upper + expand;\n    }\n\n    if (Double.isNaN(lower) || lower < getLowerBound()) {\n        lower = getLowerBound();\n    }\n    if (Double.isNaN(upper) || upper > getUpperBound()) {\n        upper = getUpperBound();\n    }\n\n    if (upper < lower) {\n        lower = upper;\n    }\n\n    return new Range(lower, upper);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Plot plot = getPlot();\n    if (plot == null) {\n        return getDefaultAutoRange();\n    }\n\n    if (axis == this) {\n        if (plot instanceof ValueAxisPlot) {\n            return ((ValueAxisPlot) plot).getDataRange(this);\n        }\n        else {\n            return getDefaultAutoRange();\n        }\n    }\n    else {\n        return plot.getRangeAxis(axis.getPlotIndex()).getDataRange(axis);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Plot plot = getPlot();\n    if (plot == null) {\n        return null;  // no plot, no data\n    }\n    if (plot instanceof ValueAxisPlot) {\n        ValueAxisPlot vap = (ValueAxisPlot) plot;\n        Range r = vap.getDataRange(axis);\n        if (r == null) {\n            r = getDefaultAutoRange();\n        }\n        return r;\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = Double.NaN;\n    if (axis instanceof DateAxis)\n    {\n        result = ((DateAxis) axis).getDataRange();\n    }\n    else if (axis instanceof PeriodAxis)\n    {\n        result = ((PeriodAxis) axis).getDataRange();\n    }\n    else if (axis instanceof LogAxis)\n    {\n        result = ((LogAxis) axis).getDataRange();\n    }\n    else if (axis instanceof NumberAxis)\n    {\n        result = ((NumberAxis) axis).getDataRange();\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null || getPlot() == null) {\n        return getDefaultAutoRange();\n    }\n\n    if (axis instanceof CategoryAxis) {\n        CategoryAxis ca = (CategoryAxis) axis;\n        if (ca.getAutoRangeCategorySize() != -1) {\n            return ca.getDataRange();\n        }\n        else {\n            return getDefaultAutoRange();\n        }\n    }\n    else if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        if (na.isAutoRange()) {\n            if (na.getRangeType() == RangeType.POSITIVE) {\n                return new Range(Math.max(0.0, na.getLowerBound()), na.getUpperBound());\n            }\n            else if (na.getRangeType() == RangeType.NEGATIVE) {\n                return new Range(na.getLowerBound(), Math.min(0.0, na.getUpperBound()));\n            }\n            else {\n                return new Range(na.getLowerBound(), na.getUpperBound());\n            }\n        }\n        else {\n            return na.getRange();\n        }\n    }\n    else if (axis instanceof DateAxis) {\n        DateAxis da = (DateAxis) axis;\n        if (da.getTimeline() instanceof SegmentedTimeline) {\n            return new DateRange(((SegmentedTimeline) da.getTimeline()).getStartTime(),\n                    ((SegmentedTimeline) da.getTimeline()).getStartTime() + 1);\n        }\n        else {\n            return getDefaultAutoRange();\n        }\n    }\n    else if (axis instanceof LogAxis) {\n        LogAxis la = (LogAxis) axis;\n        Range r = getDefaultAutoRange();\n        if (r.getLowerBound() != r.getUpperBound()) {\n            double lower = r.getLowerBound();\n            double upper = r.getUpperBound();\n            lower = Math.max(lower, la.getSmallestValue());\n            upper = Math.min(upper, la.getBiggestValue());\n            r = new Range(lower, upper);\n        }\n        return r;\n    }\n    else {\n        return getDefaultAutoRange();\n    }\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log10(val + 1.0); //invert adjustPow10\n        if (res < 0) {\n            res = res - 1;\n        }\n        else {\n            res = res + 1;\n        }\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = val < 0.0;\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val >= 10.0) \n    {\n        res = Math.log10(val); // use standard log10 function\n    }\n    else if (val < 1.0) \n    {\n        res = (Math.log10(Math.pow(10, val + 1.0)) - 10.0) / 9.0; // invert adjustedPow10\n    }\n    else \n    {\n        res = Math.log10(val) + ((int) val - 1) / 9.0; // adjust for 0 to 1 scaling\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log10(val) + (1.0 - val) / val; // invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = val < 0.0;\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    if (val < 10.0) \n    {\n        return Math.log10(val + Math.pow(10.0, -val + 1.0));\n    }\n    else \n    {\n        return Math.log10(val);\n    }\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = val < 0.0;\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val >= 10.0) \n    {\n        res = Math.log10(val);\n    }\n    else \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val >= 10.0) \n    {\n        res = Math.log10(val);\n    }\n    else if (val > 0.0) \n    {\n        res = val - Math.floor(val);\n    }\n    else \n    {\n        res = Math.log10(Math.abs(val)) - 1.0;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log10(val + Math.pow(10, -((int)val))) + ((int)val)*(-1); //invert adjustedPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = val < 0.0;\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log10(val) + val / 9.0; // adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (BasicBlock block : cfg.getBlocks()) {\n    if (block.getSuccessors().size() == 1) {\n      Node last = block.getLast();\n      if (last.isReturn() || (last.isThrow() && last.getNext() == null)) {\n        continue;\n      }\n    }\n    return false;\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    List<Node> exitNodes = cfg.getExitNodes();\n    Set<Node> returnNodes = new HashSet<>();\n    for (Node exitNode : exitNodes) {\n        for (Node predecessor : exitNode.getPredecessors()) {\n            if (predecessor.isReturn()) {\n                returnNodes.add(predecessor);\n            }\n        }\n    }\n\n    for (Node node : cfg.getGraphviz().keySet()) {\n        if (!cfg.getGraphviz().get(node).isEmpty() && !returnNodes.contains(node)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    List<Node> nodes = cfg.getNodes();\n    for(Node node : nodes) {\n        if(node.getType() == Token.FUNCTION) {\n            if (!cfg.mayReturn(node)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): This is not a correct way to check if all paths return.\n  // We should use something like a reachability analysis instead.\n  for (Node node : cfg.getNodes()) {\n    if (cfg.isEntryPoint(node)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  List<Node> reachableNodes = cfg.getReachableNodes();\n  for (Node node : reachableNodes)\n  {\n    if (!cfg.mayHaveReturnValue(node))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO: This function is not yet implemented.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isEmpty()) {\n        return false;\n    }\n    Set<Node> allNodes = cfg.getAllNodes();\n    Set<Node> reachableNodes = cfg.getReachableNodes();\n    for (Node reachableNode : reachableNodes) {\n        if (reachableNode.isReturn() || reachableNode.isThrow()) {\n            for (Node unreachableNode : allNodes) {\n                if (!reachableNode.equals(unreachableNode) && !reachableNode.isReturn() && !reachableNode.isThrow()) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node startNode : cfg.getStarts())\n    {\n        if (!cfg.getSuccessors(startNode).isEmpty())\n        {\n            if (!containsReturn(cfg.getSuccessors(startNode)))\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.root == null || !cfg.root.isBlock()) {\n      return false;\n    }\n    if (cfg.root.getSuccessors().isEmpty()) {\n      return false;\n    }\n    if (!cfg.root.getSuccessors().get(0).isReturn()) {\n      return false;\n    }\n    List<Node> successors = cfg.root.getSuccessors().get(0).getSuccessors();\n    for(Node successor : successors) {\n        if (!successor.isReturn()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (ControlFlowGraph.BasicBlock block : cfg.getBasicBlocks()) \n  {\n    if (block.getSuccessors().size() == 0) \n    {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = a.clone();\n\n    /* First compute x = (a-1)/(a+1) */\n    x[0] = x[0].subtract(a[0]);\n    x[1] = x[1].subtract(a[1]);\n    resplit(x);\n    Dfp[] tmp = addOneSplit(x);\n    x[0] = tmp[0];\n    x[1] = tmp[1];\n    resplit(x);\n    x[0] = x[0].divide(a[0]);\n    x[1] = x[1].divide(a[1]);\n\n    /* Then compute ln(x+1) - ln(x-1) */\n    tmp = fastLog(x);\n    x[0] = tmp[0];\n    x[1] = tmp[1];\n    resplit(x);\n    x[0] = x[0].multiply(a[0]);\n    x[1] = x[1].multiply(a[1]);\n    resplit(x);\n    tmp = addOneSplit(x);\n    x[0] = tmp[0];\n    x[1] = tmp[1];\n    resplit(x);\n    x[0] = x[0].subtract(a[0]);\n    x[1] = x[1].subtract(a[1]);\n    resplit(x);\n\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n\n    Dfp[] y = new Dfp[2];\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, a, x);\n        y[0] = x[0];\n        y[1] = x[1];\n        splitAdd(y, LN_SPLIT_COEF[i], x);\n        y[0] = x[0];\n        y[1] = x[1];\n    }\n\n    splitMult(y, a, x);\n    y[0] = x[0];\n    y[1] = x[1];\n\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int ix;\n    Dfp x[] = new Dfp[2];\n\n    x[0] = a[0];\n    x[1] = a[1];\n    x[0] = x[0].add(x[1]);\n    x[1] = x[0].subtract(x[1]);\n    x[0].subtract(x[1]);\n    ix = x[0].classify();\n\n    if (ix >= Dfp.LN_TABLE_LENGTH) {\n        Dfp[] y = new Dfp[2];\n\n        y[0] = x[0].divide(x[0].newInstance(\"1.2\"));\n        y[1] = x[1].divide(x[0].newInstance(\"1.2\"));\n        y[0] = logInternal(y);\n        y[0] = y[0].multiply(x[0].newInstance(\"1.2\"));\n        y[1] = y[0].subtract(y[1]);\n\n        return y;\n    }\n\n    if (ix >= 0) {\n        return slowLog(a);\n    }\n\n    x[0] = x[0].negate();\n    x[1] = x[1].negate();\n    x = slowLog(x);\n    x[0] = x[0].negate();\n    x[1] = x[1].negate();\n\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    y[0] = a[0].multiply(a[0]);\n    y[1] = a[0].multiply(a[1]).add(a[1]);\n\n    Dfp[] z = slowLog(a[0]);\n    y[0] = y[0].multiply(z[0]);\n    y[1] = y[1].multiply(z[0]).add(z[1]);\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n    final Dfp tmp[] = new Dfp[2];\n    final Dfp tmp2[] = new Dfp[2];\n\n    split(a[0], x);\n    split(a[1], y);\n    tmp[0] = x[0].add(y[0]);\n    tmp[1] = x[1].add(y[1]);\n    resplit(tmp);\n\n    final Dfp t[] = new Dfp[2];\n    t[0] = tmp[0].subtract(tmp[1]);\n    t[1] = tmp[1].negate();\n    resplit(t);\n\n    tmp2[0] = x[0].multiply(t[0]);\n    tmp2[1] = x[1].multiply(t[1]);\n    resplit(tmp2);\n\n    y[0] = tmp2[0].add(tmp2[1]);\n    y[1] = tmp2[1];\n    resplit(y);\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n    final Dfp a0, a1;\n    final Dfp t[] = new Dfp[2];\n\n    a0 = a[0];\n    a1 = a[1];\n\n    x[0] = a0.subtract(a1);\n    x[1] = a0.add(a1);\n\n    /* Now x = (a-1)/(a+1) */\n\n    /* Now, we can apply the series for ln(x+1) - ln(x-1) */\n    t[0] = x[0].multiply(2);\n    t[1] = x[1].multiply(2);\n    y[0] = t[0];\n    y[1] = t[1];\n\n    for (int i = 2; i <= 8; i += 2) {\n        t[0] = t[0].multiply(x[0]);\n        t[1] = t[1].multiply(x[0]);\n        y[0] = y[0].subtract(t[0]);\n        y[1] = y[1].subtract(t[1]);\n\n        t[0] = t[0].multiply(x[0]);\n        t[1] = t[1].multiply(x[0]);\n        y[0] = y[0].add(t[0]);\n        y[1] = y[1].add(t[1]);\n    }\n\n    x[0] = y[0].divide(2);\n    x[1] = y[1].divide(2);\n\n    /* Now multiply x by 2 to get ln(a) */\n    t[0] = x[0].multiply(2);\n    t[1] = x[1].multiply(2);\n    x[0] = t[0];\n    x[1] = t[1];\n\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] x = split(a[0]);\n    final Dfp[] one = new Dfp[2];\n    final Dfp[] two = new Dfp[2];\n\n    one[0] = new Dfp(1);\n    two[0] = new Dfp(2);\n\n    final Dfp x0 = x[0];\n    final Dfp x1 = x[1];\n    final Dfp x0sq = x0.multiply(x0);\n    final Dfp x1sq = x1.multiply(x1);\n\n    y[0] = x0sq.multiply(x0sq).multiply(x0).subtract(one[0]);\n    y[1] = x0sq.multiply(x0sq).multiply(x0).subtract(x1sq.multiply(x1).multiply(x1));\n\n    for (int i = 3; i < 90; i++) {\n        final Dfp xi = x0sq.multiply(x0sq).multiply(x0).subtract(y[0]).divide(i);\n        final Dfp xii = x1sq.multiply(x1sq).multiply(x1).subtract(y[1]).divide(i);\n        final Dfp zi = xi.add(xii).add(xi.multiply(xii));\n        final Dfp zi2 = zi.multiply(zi);\n        final Dfp zi3 = zi2.multiply(zi);\n        final Dfp zi4 = zi3.multiply(zi);\n\n        y[0] = zi4.multiply(xi).subtract(y[0]);\n        y[1] = zi4.multiply(xi).subtract(zi3.multiply(xii).subtract(y[1]));\n    }\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    y[0] = a[0];\n    y[1] = a[1];\n\n    if (y[0].equals(a.getZero()) || y[0].lessThan(a.getZero()) || y[0].isNaN()) {\n        a[0].getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return a.dotrap(DfpField.FLAG_INVALID, \"logInternal\", a, a.newInstance((byte)1, Dfp.QNAN));\n    }\n\n    if (y[0].classify() == Dfp.INFINITE) {\n        return a;\n    }\n\n    final Dfp[] x = split((a[0].add(a[1])).divide(a[0].subtract(a[1])));\n\n    /* x = (a-1)/(a+1) */\n\n    y[0] = x[0].subtract(a.getTwo());\n    y[1] = x[1].subtract(a.getTwo());\n\n    /* Now compute ln(x+1) - ln(x-1) */\n\n    final Dfp fact = a.newInstance(1);\n\n    for (int i = 1; i < 90; i++) {\n        x[0] = x[0].multiply(y[0]);\n        x[1] = x[1].multiply(y[1]);\n        fact = fact.multiply(a.newInstance(i));\n        y[0] = y[0].add(x[0].divide(fact));\n        if (y[0].equals(y[1])) {\n            break;\n        }\n        y[1] = new Dfp(y[0]);\n    }\n\n    /* y[0] is ln((x+1)/(x-1)) */\n\n    y[0] = y[0].multiply(a.newInstance(2)).add(y[1]);\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int ix;\n    Dfp x[] = a.clone();\n\n    if (x[0].greaterThan(x[1])) {\n        ix = x[0].intValue();\n    } else {\n        ix = x[1].intValue();\n    }\n\n    x[0] = x[0].subtract(x[1]);\n    x[1] = x[0].multiply(x[0]).divide(x[1]);\n    x[0] = x[0].subtract(x[1]);\n    x[1] = x[0].multiply(x[0]).divide(x[1]);\n    x[0] = x[0].subtract(x[1]);\n    x[1] = x[0].multiply(x[0]).divide(x[1]);\n\n    x[0] = x[0].divide(2);\n    x[1] = x[1].divide(2);\n\n    x[0] = x[0].add(x[1]);\n    x[1] = x[1].negate();\n\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = a;\n    Dfp y[] = new Dfp[2];\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    return y;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean result = coll.remove((V) value);\n        if (result && coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean result = coll.remove((V) value);\n        if (coll.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        final boolean result = coll.remove((V) value);\n        if (result) {\n            if (coll.isEmpty()) {\n                // last value removed, remove key\n                decorated().remove(key);\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            return false;\n        }\n\n        final K k = castKey(key);\n        final Collection<V> coll = getCollection(k);\n        if (coll != null && coll.remove((V) value)) \n        {\n            if (coll.isEmpty()) \n            {\n                decorated().remove(k);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean removed = coll.remove((V) value);\n        if (removed && coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n\n        final K typedKey = castKey(key);\n        final Collection<V> coll = getCollection(typedKey);\n        if (coll == null) {\n            return false;\n        }\n\n        final Iterator<V> it = coll.iterator();\n        boolean removed = false;\n        while (it.hasNext()) {\n            final V next = it.next();\n            if (compareValues(next, value)) {\n                it.remove();\n                removed = true;\n            }\n        }\n\n        // remove key if it has no more values\n        if (coll.isEmpty()) {\n            decorated().remove(typedKey);\n        }\n\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean removed = coll.remove((V) value);\n        if (removed && coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        final boolean result = coll.remove((V) value);\n        if (result) {\n            if (coll.isEmpty()) {\n                decorated().remove(key);\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean removed = coll.remove((V) value);\n        if (removed && coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n\n        final K k = castKey(key);\n        final Collection<V> coll = getCollection(k);\n        boolean result = false;\n        if (coll != null) {\n            result = coll.remove((V) value);\n            if (coll.isEmpty()) {\n                decorated().remove(k);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n  Node transformed = transform(n);\n  if (transformed.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, transformed.getString());\n  } else if (transformed.getType() == Token.STRING) {\n    return newStringNode(\n        Token.STRING, '\"' + transformed.getString() + '\"');\n  } else {\n    return transformed;\n  }\n}",
      "private Node transformAsString(AstNode n)  {\n  n = transform(n);\n  if (n.getType() == Token.NAME) {\n    n = newStringNode(Token.STRING, n.getString());\n  } else if (n.getType() == Token.STRING) {\n    String identifier = n.getString();\n    if (!isAllowedProp(identifier)) {\n      errorReporter.error(\n        \"invalid property identifier\",\n        sourceName,\n        n.getLineno(), \"\", 0);\n    }\n  }\n  return n;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, n.getString());\n  } else {\n    return newStringNode(Token.NAME, \"\\\"\" + n.getString() + \"\\\"\");\n  }\n}\n\n@Override\nNode processObjectLiteralElement(ObjectLiteralElement elementNode) {\n  Node node = newNode(Token.PROP);\n  Node nameNode = elementNode.getPropName();\n\n  if (nameNode.getType() == Token.NAME) {\n    Node transformedName = transform(nameNode);\n\n    if (elementNode.getPropInit() == null) {\n      if (config.languageMode == LanguageMode.ECMASCRIPT3) {\n        if (!isAllowedProp(nameNode.getString())) {\n          errorReporter.error(\n            \"property name is not allowed in strict mode\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n      } else {\n        validateObjectLiteralKeyName(transformedName);\n      }\n    } else {\n      validateObjectLiteralKeyName(transformedName);\n    }\n\n    node.addChildToBack(transformedName);\n  } else {\n    node.addChildToBack(transformAsString(nameNode));\n  }\n  \n  Node initNode = elementNode.getPropInit();\n  if (initNode != null) {\n    node.addChildToBack(transform(initNode));\n  }\n\n  node.setLineno(elementNode.getLineno());\n  node.setCharno(position2charno(elementNode.getAbsolutePosition()));\n  maybeSetLengthFrom(node, elementNode);\n\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, n.getString());\n  } else if (n.getType() == Token.STRING) {\n    return newStringNode(Token.STRING, \"\\\"\" + n.getString() + \"\\\"\");\n  } else {\n    return null;\n  }\n}",
      "private Node transformAsString(AstNode n)  {\n  n = transform(n);\n  if (n.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, n.getString());\n  } else if (n.getType() == Token.STRING) {\n    return newStringNode(Token.STRING, \"\\\"\" + n.getString() + \"\\\"\");\n  }\n  return n;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node transformed = transform(n);\n  if (transformed.getType() == Token.NAME) {\n    String identifier = transformed.getString();\n    if (!isAllowedProp(identifier)) {\n      errorReporter.error(\n        \"identifier is reserved\",\n        sourceName,\n        transformed.getLineno(), \"\", 0);\n    }\n    transformed = newStringNode(Token.STRING, identifier);\n  } else if (transformed.getType() == Token.STRING) {\n    transformed = newStringNode(Token.STRING, \"\\\"\" + transformed.getString() + \"\\\"\");\n  }\n  return transformed;\n}",
      "private Node transformAsString(AstNode n)  {\n  n = transform(n);\n  if (n.getType() == Token.NAME) {\n    n = newStringNode(Token.STRING, n.getString());\n  } else if (n.getType() == Token.STRING) {\n    n = newStringNode(Token.STRING, \"\\\"\" + n.getString() + \"\\\"\");\n  }\n  return n;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node result = transform(n);\n  if (result.getType() == Token.NAME) {\n    Name name = (Name) result;\n    String identifier = name.getIdentifier();\n    if (isAllowedProp(identifier)) {\n      result = new StringLiteral(identifier);\n      result.setLineno(name.getLineno());\n      result.setCharno(name.getCharno());\n      maybeSetLengthFrom(result, name);\n    }\n  } else if (result.getType() == Token.STRING) {\n    StringLiteral string = (StringLiteral) result;\n    if (string.getIdentifier().indexOf(\".\") > -1) {\n      errorReporter.error(\"invalid character '.' in property name\",\n        sourceName, string.getLineno(), \"\", 0);\n    }\n  }\n  return result;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, node.getString());\n  } else if (node.getType() == Token.STRING) {\n    return newStringNode(Token.STRING, \"\\\"\" + node.getString() + \"\\\"\");\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME) {\n    return newStringNode(Token.STRING, n.getString());\n  } else {\n    return n;\n  }\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(dataset.getRowKey(r), category);\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(r, dataset.getColumnIndex(category));\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(dataset.getRowKey(r), category);\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category), includedRows);\n        }\n\n        int baseIndex = -1;\n        int rowCount = includedRows.length;\n        for (int i = 0; i < rowCount; i++) {\n            int r = includedRows[i];\n            Number n = dataset.getValue(r, dataset.getColumnIndex(category));\n            if (n == null) {\n                continue;\n            }\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                posBase = posBase + v;\n                result.add(new Object[] {new Integer(r), new Double(posBase)});\n            }\n            else if (v < 0.0) {\n                if (baseIndex < 0) {\n                    result.add(new Object[] {null, new Double(base)});\n                    baseIndex = 0;\n                }\n                negBase = negBase + v; // '+' because v is negative\n                result.add(0, new Object[] {new Integer(-r - 1),\n                        new Double(negBase)});\n                baseIndex++;\n            }\n        }\n        return result;\n\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childNodesCache == null)\n    {\n        childNodesCache = new ArrayList<>(childNodes.size());\n        for (Node node : childNodes)\n            if (node instanceof Element)\n                childNodesCache.add((Element)node);\n    }\n    return childNodesCache;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> copy = new ArrayList<>(childNodes.size());\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            copy.add((Element) node);\n        }\n    }\n    return copy;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> cachedChildren = childElements;\n    if (cachedChildren == null || childNodes.size() != cachedChildren.size()) \n    {\n        cachedChildren = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element)\n                cachedChildren.add((Element) node);\n        }\n        childElements = cachedChildren;\n    }\n    return cachedChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null) {\n        childNodesList = new ArrayList<>();\n        for (Node child : childNodes)\n            if (child instanceof Element)\n                childNodesList.add((Element) child);\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                childElements.add((Element) child);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> copy = new ArrayList<>();\n    for (Node node : childNodes)\n        if (node instanceof Element)\n            copy.add((Element) node);\n    return copy;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesShadow == null) \n    {\n        childNodesShadow = new ArrayList<>(childNodes);\n    }\n    return childNodesShadow;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n        childElements = new ArrayList<>(childNodes);\n    else if (childElements.size() != childNodes.size())\n        childElements = new ArrayList<>(childNodes);\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> list = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof Element) {\n            list.add((Element) child);\n        }\n    }\n    return list;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null) {\n        childNodesList = new ArrayList<>();\n        for (Node child : childNodes) \n        {\n            if (child instanceof Element) \n            {\n                childNodesList.add((Element) child);\n            }\n        }\n    }\n    return childNodesList;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    if (key == null) \n    {\n        return 0;\n    }\n    if (key == key1)\n    {\n        return 0;\n    }\n    if (key == key2)\n    {\n        return 1;\n    }\n    if (key == key3)\n    {\n        return 2;\n    }\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    if (key == null) {\n        return 0;\n    }\n\n    return Math.abs(key.hashCode()) % data.length;\n}",
      "private int getHash(final Object key)  {\n    if (key == null) {\n        return 0;\n    }\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    if (key == null) \n    {\n        return 0;\n    }\n\n    return Math.abs(key.hashCode() % data.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % data.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, m.getColumnDimension() - k)];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = Math.max(0, r - k); c < m.getColumnDimension(); c++) \n        {\n            d[r][c - Math.max(0, r - k)] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = r; c < m.getColumnDimension(); c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, Math.min(m.getColumnDimension() - k, m.getRowDimension()))];\n    for (int r = 0; r < d.length; r++) {\n        for (int c = 0; c < d[0].length; c++) {\n            d[r][c] = m.getEntry(r, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, k)];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < Math.max(0, k); c++) \n        {\n            d[r][c] = m.getEntry(r, r + c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r < c - k) \n            {\n                d[r][c] = 0.0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, Math.min(m.getColumnDimension() - k, m.getRowDimension()))];\n    for (int r = 0; r < d.length; r++) {\n        for (int c = 0; c < d[r].length; c++) {\n            d[r][c] = m.getEntry(r, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, m.getColumnDimension() - k)];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = Math.max(0, r + k); c < m.getColumnDimension(); c++) \n        {\n            d[r][c - r - k] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = r + k; c < m.getColumnDimension(); c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, k)];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < Math.max(0, k); c++) \n        {\n            d[r][c] = m.getEntry(r, r + c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        final Skew s = left.right.skew;\n        left.rotateCCW();\n        rotateCCW();\n        switch (s) {\n        case LEFT_HIGH:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.RIGHT_HIGH;\n            break;\n        case RIGHT_HIGH:\n            left.skew  = Skew.LEFT_HIGH;\n            right.skew = Skew.BALANCED;\n            break;\n        default:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        }\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH)\n        {\n            rotateCCW();\n            skew = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        }\n        else if (right.skew == Skew.BALANCED)\n        {\n            rotateCCW();\n            skew = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        }\n        else\n        {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s)\n            {\n            case LEFT_HIGH:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        final Skew s = left.right.skew;\n        left.rotateCCW();\n        rotateCCW();\n        switch (s) {\n        case LEFT_HIGH:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.RIGHT_HIGH;\n            break;\n        case RIGHT_HIGH:\n            left.skew  = Skew.LEFT_HIGH;\n            right.skew = Skew.BALANCED;\n            break;\n        default:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        }\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        final Skew s = left.right.skew;\n        left.rotateCCW();\n        rotateCCW();\n        switch (s) \n        {\n        case LEFT_HIGH:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.RIGHT_HIGH;\n            break;\n        case RIGHT_HIGH:\n            left.skew  = Skew.LEFT_HIGH;\n            right.skew = Skew.BALANCED;\n            break;\n        default:\n            left.skew  = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        }\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) \n        {\n            right.rotateCCW();\n            skew = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } else if (right.skew == Skew.BALANCED) {\n            right.rotateCCW();\n            skew = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) \n            {\n            case LEFT_HIGH:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return false;\n    default:\n        skew = Skew.RIGHT_LOW;\n        return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            final Skew s = left.left.skew;\n            left.rotateCCW();\n            rotateCCW();\n            switch (s) {\n                case LEFT_HIGH:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew  = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew)\n    {\n        case LEFT_HIGH:\n            final Skew s = left.right.skew;\n            left.rotateCCW();\n            rotateCCW();\n            switch (s)\n            {\n                case LEFT_HIGH:\n                    left.skew = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew)\n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                right.rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                right.rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                right.rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            final Skew s = left.left.skew;\n            left.rotateCCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew)\n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s)\n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // As matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) < SMALL_VALUE * norm) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++)\n    {\n        for (int j = FastMath.max(i - 1, 0); j < i; j++)\n        {\n            if (FastMath.abs(matrixT[i][j]) <= norm / (FastMath.pow(matrixT.length - j, 1.5)))\n                return j;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++)\n    {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) \n        {\n            if (FastMath.abs(matrixT[i][j]) < PRECISION * norm) \n            {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i]) < PRECISION * norm) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++)\n    {\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++)\n        {\n            if (FastMath.abs(matrixT[i][j]) < norm / 1000.0)\n            {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        // Look for sub-diagonal element smaller than NORM/10\n        if (FastMath.abs(matrixT[i][i - 1]) < norm / 10) \n        {\n            return i - 1;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++)\n    {\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++)\n        {\n            if (i != j)\n            {\n                if (FastMath.abs(matrixT[i][j]) / norm < Constants.SMALL_REAL)\n                {\n                    return i;\n                }\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        // Check for sub-diagonal element smaller than 1/sqrt(norm)\n        if (Math.abs(matrixT[i][i - 1]) < (1.0 / Math.sqrt(norm))) \n        {\n            return i - 1;\n        }\n    }\n    return -1; // No small sub-diagonal element found\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        for (int j = FastMath.max(i - 1, 0); j < i; j++) \n        {\n            if (FastMath.abs(matrixT[i][j]) < EPSILON * norm) \n            {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i]) < norm / (FastMath.pow(matrixT.length - i, 3))) {\n            return i;\n        }\n    }\n    return -1; // No small sub-diagonal element found\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) < 0)\n        {\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) < 0)\n        {\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) < 0)\n        {\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    if (handleJsDoc(node, irNode) != null) {\n        irNode.setJSDocInfo(handleJsDoc(node, irNode));\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node instanceof Name) {\n        return transformNameAsString((Name) node);\n    } else if (node instanceof NumberLiteral) {\n        return transformNumberAsString((NumberLiteral) node);\n    } else {\n        return transform(node);\n    }\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && node.getParent() instanceof ParenthesizedExpression) \n    {\n        return transformNameAsString((Name) node);\n    }\n    if (node instanceof NumberLiteral) {\n        return transformNumberAsString((NumberLiteral) node);\n    }\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME ||\n        node.getType() == com.google.javascript.rhino.head.Token.NUMBER) \n    {\n        return transformNameAsString((Name) node);\n    }\n    if (isPropAccess(node)) \n    {\n        return transformPropAccess(node);\n    }\n    if (node.getType() == com.google.javascript.rhino.head.Token.CALL) \n    {\n        return transformCall(node);\n    }\n    if (node.getType() == com.google.javascript.rhino.head.Token.LP &&\n        node instanceof ParenthesizedExpression) \n    {\n        return transformExpression((ParenthesizedExpression) node);\n    }\n    if (node.getType() == com.google.javascript.rhino.head.Token.BLOCK) \n    {\n        return transformBlock(node);\n    }\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && node instanceof Name) {\n      return transformNameAsString((Name) node);\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.NUMBER\n        && node instanceof NumberLiteral) {\n      return transformNumberAsString((NumberLiteral) node);\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.CALL) {\n      if (node instanceof CallExpression) {\n        CallExpression callNode = (CallExpression) node;\n        if (callNode.getArguments().length == 1) {\n          Node expr = callNode.getExpression();\n          if (isPropAccess(expr)) {\n            return transformCallExpressionAsPropertyAccess(callNode);\n          }\n        }\n      }\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.LP &&\n        node instanceof ParenthesizedExpression) {\n      return transformNodeWithInlineJsDoc(node);\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.GETPROP ||\n        node.getType() == com.google.javascript.rhino.head.Token.GETELEM) {\n      return transformNodeWithInlineJsDoc(node);\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT ||\n        node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID) {\n      return transformNodeWithInlineJsDoc(node);\n    } else if (node.getType() == com.google.javascript.rhino.head.Token.BLOCK) {\n      return transformNodeWithInlineJsDoc(node);\n    }\n    return transform(node);\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node instanceof Name) {\n        return transformNameAsString((Name)node);\n    } else if (node instanceof NumberLiteral) {\n        return transformNumberAsString((NumberLiteral)node);\n    } else if (node instanceof AstRoot) {\n        return transformTree((AstRoot)node, sourceFile, sourceString, config, errorReporter);\n    } else if (node instanceof ParenthesizedExpression) {\n        return transformParenthesizedExpression((ParenthesizedExpression)node);\n    } else if (node instanceof Block) {\n        return transformBlock((Block)node);\n    } else if (node instanceof ExpressionStatement) {\n        return transformExpressionStatement((ExpressionStatement)node);\n    } else if (node instanceof Assignment) {\n        return transformAssignment((Assignment)node);\n    } else if (node instanceof ForInStatement) {\n        return transformForInStatement((ForInStatement)node);\n    } else if (node instanceof Function) {\n        return transformFunction((Function)node);\n    } else if (node instanceof CallExpression) {\n        return transformCallExpression((CallExpression)node);\n    } else if (node instanceof MemberExpression) {\n        return transformMemberExpression((MemberExpression)node);\n    } else if (node instanceof ArrayLiteral) {\n        return transformArrayLiteral((ArrayLiteral)node);\n    } else if (node instanceof ObjectLiteral) {\n        return transformObjectLiteral((ObjectLiteral)node);\n    } else {\n        errorReporter.warning(\n            UNSUPPORTED_NODE_TYPE_WARNING,\n            sourceName,\n            node.getLineno(),\n            \"Unsupported AST node type: \" + node.getClass().toString(), 0);\n        return null;\n    }\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNode(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n\n    // Check if the node has inline JSDoc comments\n    if (node instanceof Name || node instanceof NumberLiteral)\n    {\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) {\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n        setSourceInfo(irNode, node);\n    }\n\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node instanceof Name || node instanceof NumberLiteral) \n    {\n        Node irNode = null;\n        if (node instanceof Name) {\n            irNode = transformNameAsString((Name)node);\n        } else if (node instanceof NumberLiteral) {\n            irNode = transformNumberAsString((NumberLiteral)node);\n        }\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) {\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n        setSourceInfo(irNode, node);\n        return irNode;\n    }\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node instanceof Name || node instanceof NumberLiteral) {\n        Node irNode = null;\n        if (node instanceof Name) {\n            irNode = transformNameAsString((Name) node);\n        } else if (node instanceof NumberLiteral) {\n            irNode = transformNumberAsString((NumberLiteral) node);\n        }\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) {\n            irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n        setSourceInfo(irNode, node);\n        return irNode;\n    } else {\n        Node irNode = transform(node);\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) {\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n        setSourceInfo(irNode, node);\n        return irNode;\n    }\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    final List<E> setOrder = new ArrayList<>(list);\n    return new SetUniqueList<>(set, setOrder);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n\n    return new SetUniqueList<>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    final List<E> setOrder = new ArrayList<E>(list);\n    return new SetUniqueList<E>(set, setOrder);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    final List<E> setOrder = new ArrayList<>(list);\n    return new SetUniqueList<>(set, setOrder);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n\n    return new SetUniqueList<>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n\n    return new SetUniqueList<>(set, list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LB);\n    Node arg = null;\n    boolean hasVarArgs = false;\n\n    do {\n      if (arg != null) {\n        next();\n        skipEOLs();\n        token = next();\n      }\n\n      if (token == JsDocToken.ELLIPSIS) {\n        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n        hasVarArgs = true;\n      } else {\n        arg = parseTypeExpression(token);\n      }\n\n      if (arg == null) {\n        return null;\n      }\n\n      array.addChildToBack(arg);\n\n      if (hasVarArgs) {\n        break;\n      }\n\n      skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\nNode array = newNode(Token.LB);\n\nNode arg = null;\nboolean hasVarArgs = false;\n\ndo {\n  if (arg != null) \n  {\n    next();\n    skipEOLs();\n    token = next();\n  }\n  if (token == JsDocToken.ELLIPSIS) {\n    arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n    hasVarArgs = true;\n  } else {\n    arg = parseTypeExpression(token);\n  }\n\n  if (arg == null) {\n    return null;\n  }\n\n  array.addChildToBack(arg);\n  if (hasVarArgs) {\n    break;\n  }\n  skipEOLs();\n} while (match(JsDocToken.COMMA));\n\nif (!match(JsDocToken.RB)) {\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n}\nnext();\nreturn array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\nNode array = newNode(Token.LB);\n    boolean hasVarArgs = false;\n    Node arg = null;\n    do {\n      if (arg != null) {\n        next();\n        skipEOLs();\n        token = next();\n      }\n      if (token == JsDocToken.ELLIPSIS) {\n        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n        hasVarArgs = true;\n      } else {\n        arg = parseTypeExpression(token);\n      }\n\n      if (arg == null) {\n        return null;\n      }\n\n      array.addChildToBack(arg);\n      if (hasVarArgs) {\n        break;\n      }\n      skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node array = newNode(Token.LB);\n\n  boolean hasVarArgs = false;\n  Node arg = null;\n  while (true) {\n    if (arg != null) {\n      next();\n      skipEOLs();\n      token = next();\n    }\n    if (token == JsDocToken.ELLIPSIS) {\n      arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n      hasVarArgs = true;\n    } else {\n      arg = parseTypeExpression(token);\n    }\n\n    if (arg == null) {\n      return null;\n    }\n\n    array.addChildToBack(arg);\n    if (hasVarArgs) {\n      break;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  }\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\nNode array = newNode(Token.LB);\n\nboolean hasVarArgs = false;\nNode arg = null;\ndo {\n  if (arg != null)\n  {\n    next();\n    skipEOLs();\n    token = next();\n  }\n  if (token == JsDocToken.ELLIPSIS)\n  {\n    arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n    hasVarArgs = true;\n  }\n  else\n  {\n    arg = parseTypeExpression(token);\n  }\n\n  if (arg == null)\n  {\n    return null;\n  }\n\n  array.addChildToBack(arg);\n  if (hasVarArgs)\n  {\n    break;\n  }\n  skipEOLs();\n} while (match(JsDocToken.COMMA));\n\nif (!match(JsDocToken.RB))\n{\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n}\nnext();\nreturn array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LB);\n    boolean hasVarArgs = false;\n    Node arg = null;\n\n    do {\n        if (arg != null) \n        {\n            next();\n            skipEOLs();\n            token = next();\n        }\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            hasVarArgs = true;\n        } \n        else \n        {\n            arg = parseTypeExpression(token);\n        }\n\n        if (arg == null) \n        {\n            return null;\n        }\n\n        array.addChildToBack(arg);\n        if (hasVarArgs) \n        {\n            break;\n        }\n        skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\nNode array = newNode(Token.LB);\n\nboolean hasVarArgs = false;\nNode arg = null;\ndo {\n  if (arg != null)\n  {\n    next();\n    skipEOLs();\n    token = next();\n  }\n  if (token == JsDocToken.ELLIPSIS)\n  {\n    arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n    hasVarArgs = true;\n  }\n  else\n  {\n    arg = parseTypeExpression(token);\n  }\n\n  if (arg == null) \n  {\n    return null;\n  }\n\n  array.addChildToBack(arg);\n  if (hasVarArgs)\n  {\n    break;\n  }\n  skipEOLs();\n} while (match(JsDocToken.COMMA));\n\nif (!match(JsDocToken.RB))\n{\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n}\nnext();\nreturn array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\nNode array = newNode(Token.LB);\nboolean hasVarArgs = false;\nNode arg = null;\ndo\n{\nif (arg != null)\n{\nnext();\nskipEOLs();\ntoken = next();\n}\nif (token == JsDocToken.ELLIPSIS)\n{\narg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\nhasVarArgs = true;\n}\nelse\n{\narg = parseTypeExpression(token);\n}\nif (arg == null)\n{\nreturn null;\n}\narray.addChildToBack(arg);\nif (hasVarArgs)\n{\nbreak;\n}\nskipEOLs();\n}\nwhile (match(JsDocToken.COMMA));\nif (!match(JsDocToken.RB))\n{\nreturn reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n}\nnext();\nreturn array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  Node array = newNode(Token.LB);\n  Node expr = null;\n  boolean hasVarArgs = false;\n  do {\n    if (expr != null) {\n      next();\n      skipEOLs();\n      token = next();\n    }\n\n    if (token == JsDocToken.ELLIPSIS) {\n      expr = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n      hasVarArgs = true;\n    } else {\n      expr = parseTypeExpression(token);\n    }\n\n    if (expr == null) {\n      return null;\n    }\n\n    array.addChildToBack(expr);\n    if (hasVarArgs) {\n      break;\n    }\n    skipEOLs();\n  } while (match(JsDocToken.COMMA));\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LB);\n    Node expr = null;\n    boolean hasVarArgs = false;\n\n    do {\n        if (expr != null) {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.COMMA || token == JsDocToken.RB);\n        }\n        if (token == JsDocToken.ELLIPSIS) {\n            expr = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n            hasVarArgs = true;\n        } else {\n            expr = parseTypeExpression(token);\n        }\n\n        if (expr == null) {\n            return null;\n        }\n\n        array.addChildToBack(expr);\n        if (hasVarArgs) {\n            break;\n        }\n\n        skipEOLs();\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    final double squaredSine = q0*q0 + q1*q1 + q2*q2 + q3*q3;\n    if (squaredSine == 0) \n    {\n        return new Vector3D(0, 0, 1);\n    } \n    else if (q0 < 0) \n    {\n        double inverse = Math.sqrt(squaredSine) / (-2 * q0);\n        return new Vector3D(inverse * (q1 + q2 + q3), inverse * (q2 + q3 - q0), inverse * (q3 + q0 - q1));\n    } \n    else\n    {\n        double inverse = Math.sqrt(squaredSine) / (2 * q0);\n        return new Vector3D(inverse * (q1 + q2 + q3), inverse * (q2 + q3 - q0), inverse * (q3 + q0 - q1));\n    }\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q0*q0+q1*q1+q2*q2;\n    if (squaredSine == 0) {\n        return new Vector3D(0, 0, 1);\n    } else if (q0 < 0) {\n        double inverse = Math.sqrt(squaredSine) / -2;\n        return new Vector3D(inverse * (q1 + q2 + q3), inverse * (q2 - q3 - q1), inverse * (q3 - q1 + q2));\n    }\n    double inverse = Math.sqrt(squaredSine) / 2;\n    return new Vector3D(inverse * (q1 + q2 + q3), inverse * (q2 - q3 - q1), inverse * (q3 - q1 + q2));\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        return new Vector3D(0.0, 0.0, 1.0);\n    } \n    else if (q0 < 0)\n    {\n        double inverse = Math.sqrt(squaredSine) / -2;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    } \n    else\n    {\n        double inverse = Math.sqrt(squaredSine) / 2;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        return new Vector3D(0.0, 0.0, 1.0);\n    }\n    else if (q0 < 0) \n    {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(inverse * q1, inverse * q2, inverse * q3);\n    }\n    else \n    {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(inverse * q1, inverse * q2, inverse * q3);\n    }\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = Math.pow(q1, 2) + Math.pow(q2, 2) + Math.pow(q3, 2);\n    if (squaredSine == 0) {\n        return new Vector3D(0, 0, 1);\n    } else if (q0 < 0) {\n        final double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    final double inverse = Math.sqrt(squaredSine) / squaredSine;\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        throw new ArithmeticException(\"Invalid rotation\");\n    }\n    else if (q0 < 0) \n    {\n        double inverse = Math.sqrt(squaredSine) / q0;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    else \n    {\n        double inverse = Math.sqrt(squaredSine) / q0;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(0, 0, 1);\n    } else if (q0 < 0) {\n        double inverse = Math.sqrt(squaredSine) / (-2 * q0);\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = Math.sqrt(squaredSine) / (2 * q0);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        if (q0 < 0) \n        {\n            return new Vector3D(q1, q2, q3).normalize();\n        }\n        else \n        {\n            return new Vector3D(q1, q2, q3).normalize();\n        }\n    }\n    else if (q0 < 0) \n    {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse).normalize();\n    }\n    else \n    {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse).normalize();\n    }\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(0, 0, 0);\n    } else if (q0 < 0) {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = Math.sqrt(squaredSine) / squaredSine;\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(0, 0, 0);\n    } else if (q0 < 0) {\n        double inverse = Math.sqrt(squaredSine) / squaredSine;\n        return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = Math.sqrt(squaredSine) / squaredSine;\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++)\n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            final int u = Utils.digit16(bytes[++i]);\n            final int l = Utils.digit16(bytes[++i]);\n            buffer.write((char) ((u << 4) + l));\n        }\n        else if (b != CR && b != LF) \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            if (i == bytes.length - 1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Utils.digit16(bytes[++i]);\n            final int l = Utils.digit16(bytes[++i]);\n            if (u > 0xFF || l > 0xFF) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((char) ((u << 4) + l));\n        }\n        else \n        {\n            if (b == '+') \n            {\n                b = ' ';\n            }\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++)\n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR)\n        {\n            try\n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e)\n            {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        }\n        else if (b != CR && b != LF)\n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int pos = 0; pos < bytes.length;) {\n        final byte b = bytes[pos++];\n        if (b == ESCAPE_CHAR) {\n            if (pos >= bytes.length) {\n                throw new DecoderException(\"Invalid URL encoding: missing hex character\");\n            }\n            final int u = Utils.digit16(bytes[pos++]);\n            final int l = Utils.digit16(bytes[pos++]);\n            final int value = (u << 4) + l;\n            if (value > 127) {\n                throw new DecoderException(\"Invalid URL encoding: hex character out of range\");\n            }\n            buffer.write((char) value);\n        } else {\n            if (b == '+') {\n                buffer.write(' ');\n            } else if (b >= SPACE && b <= TILDE) {\n                buffer.write(b);\n            } else {\n                throw new DecoderException(\"Invalid URL encoding: bad character\");\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else {\n            if (b == '+') {\n                b = ' ';\n            } else if (b == '%') {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    b = (char) ((u << 4) + l);\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding\", e);\n                }\n            } else {\n                // every other octet is appended\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            final int u = Utils.digit16(bytes[++i]);\n            final int l = Utils.digit16(bytes[++i]);\n            buffer.write((char) ((u << 4) + l));\n        } \n        else if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b != CR && b != LF) \n        {\n            buffer.write(b);\n        }\n    }\n\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++)\n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                if (bytes[++i] == CR) \n                {\n                    continue;\n                }\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                if (u >= 0 && l >= 0) \n                {\n                    buffer.write((char) ((u << 4) + l));\n                } else \n                {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\");\n                }\n            } catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } else if (b == '+') \n        {\n            buffer.write(' ');\n        } else if (b != CR && b != LF) \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            if (i == bytes.length - 1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null)\n        return null;\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n\n    Chronology chrono = partial.getChronology();\n\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DurationFieldType unitType = partial.getType(i);\n        DurationFieldType nextFieldType = partial.getType(i + 1);\n        DateTimeFieldType unitField = unitType.getField(chrono);\n        DateTimeFieldType nextField = nextFieldType.getField(chrono);\n\n        if (!unitField.getRange().equals(nextField.getRange())) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    Chronology chrono = partial.getChronology();\n    DateTimeFieldType previousField = null;\n    for (DateTimeFieldType field : partial.getFields()) {\n        long unitMillis = field.getUnitMillis();\n        if (previousField != null) {\n            if (previousField.getRange() != field.getRange() ||\n                previousField.getUnitMillis() != unitMillis) {\n                return false;\n            }\n        }\n        previousField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    List<DateTimeField> fields = partial.getFields();\n    if (fields.isEmpty()) {\n        return true;\n    }\n    DateTimeField lastField = fields.get(0);\n    for (int i = 1; i < fields.size(); i++) {\n        DateTimeField field = fields.get(i);\n        if (lastField.getRangeUnit() != field.getUnit()) {\n            return false;\n        }\n        lastField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n\n    int[] fields = partial.getFields();\n    Chronology chrono = partial.getChronology();\n\n    for (int i = 0; i < fields.length - 1; i++) {\n        int fieldIndex = fields[i];\n        int nextFieldIndex = fields[i + 1];\n\n        if (!isRangeEqual(chrono, fieldIndex, nextFieldIndex)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    List<DurationField> fields = partial.getFields();\n    for (int i = 0; i < fields.size() - 1; ++i) {\n        DurationField f1 = fields.get(i);\n        DurationField f2 = fields.get(i + 1);\n        if (f1.getRangeUnit().equals(f2.getUnit()) == false) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    Chronology chrono = partial.getChronology();\n    TemporalField previousField = null;\n    for (TemporalField field : partial.getFields()) {\n        if (previousField != null) {\n            if (!previousField.range().equals(field.range())) {\n                return false;\n            }\n        }\n        previousField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    List<DurationField> fields = partial.getFields();\n    List<DurationField> nextFields = partial.getNextFields();\n    if (fields.size() != nextFields.size()) {\n        return false;\n    }\n    for (int i = 0; i < fields.size(); i++) {\n        DurationField f = fields.get(i);\n        DurationField nf = nextFields.get(i);\n        if (!f.getRange().equals(nf.getUnit()) || f.getRange().getUnitMillis() != nf.getUnitMillis()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Usage of the isContiguous() method:\n\nLocalTime time = LocalTime.now();\nLocalDate date = LocalDate.now();\n\n// Contiguous partial\nSystem.out.println(\"Is time contiguous? \" + isContiguous(time)); // Output: true\n\n// Non-contiguous partial",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        ReadablePartial.Field field = partial.getField(i);\n        ReadablePartial.Field nextField = partial.getField(i + 1);\n        if (!field.getRange().equals(nextField.getUnit())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n\n    List<RangeField> fields = partial.getRangeFields();\n    List<DurationField> units = partial.getDurationFields();\n\n    for (int i = 0; i < units.size(); i++) {\n        RangeField range = fields.get(i);\n        DurationField unit = units.get(i);\n\n        if (i == units.size() - 1) {\n            return true;\n        }\n\n        RangeField nextUnit = fields.get(i + 1);\n\n        if (range.getRange() == nextUnit.getRange()) {\n            continue;\n        } else {\n            return false;\n        }\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n\n    int fieldCount = partial.size();\n    if (fieldCount == 0) {\n        return true;\n    }\n\n    Chronology chronology = partial.getChronology();\n    for (int i = 0; i < fieldCount - 1; ++i) {\n        ReadablePartial.Field field = partial.getField(i);\n        ReadablePartial.Field next = partial.getField(i + 1);\n\n        if (!chronology.getRange(field.getType()).equals(chronology.getRange(next.getType()))) {\n            return false;\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    if (param.isName()) {\n      Node paramNameNode = param;\n      param = param.getNext();\n      Node paramNode = new Node(Token.NAME, paramNameNode.getString());\n      strings.add(paramNode);\n    }\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : NodeUtil.getFunctionParameters(params)) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : NodeUtil.getFunctionParameters(params))\n  {\n    strings.add(Node.newString(Token.NAME, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    if (param.isName()) {\n      Node paramName = param.getFirstChild();\n      if (paramName != null && paramName.isString()) {\n        strings.add(paramName);\n      }\n    }\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    if (param.isString()) {\n      strings.add(param);\n    } else {\n      // Create a new string node with the same value as param.\n      Node string = Node.newString(Token.NAME, param.getString());\n      strings.add(string);\n    }\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    if (param.isString()) {\n      strings.add(param);\n    } else {\n      // Handle cases when string literal is missing from param name\n      if (param.isName() && param.getString().equals(\"arguments\")) {\n        Node expr = Node.newExpr(param);\n        Node getProp = Node.newGetProp(expr, IR.name(\"callee\"));\n        Node getPropCall = Node.newCall(getProp);\n        Node getPropCallExpr = Node.newExpr(getPropCall);\n        strings.add(getPropCallExpr);\n      } else {\n        Node expr = Node.newExpr(param);\n        Node getProp = Node.newGetProp(expr, IR.name(\"toString\"));\n        Node getPropCall = Node.newCall(getProp);\n        Node getPropCallExpr = Node.newExpr(getPropCall);\n        strings.add(getPropCallExpr);\n      }\n    }\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    if (param.isName()) {\n      Node string = IR.string(param.getString());\n      strings.add(string);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    strings.add(IR.string(param.getString()));\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    strings.add(param.cloneTree());\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : NodeUtil.getFunctionParameters(params)) \n  {\n    strings.add(Node.newString(Token.STRING, param.getString()));\n  }\n  return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean lastWasGap = true;\n\n    final char[] buffer = str.toCharArray();\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    final char[] buf = new char[buffer.length];\n    int count = 0;\n\n    boolean lastWasGap = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buf = str.toCharArray();\n    final char[] buffer = str.toCharArray();\n    int count = 0;\n\n    boolean lastWasGap = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = Character.toLowerCase(ch);\n        }\n    }\n\n    return new String(buf, 0, count);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    boolean lastWasGap = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[i] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buf = str.toCharArray();\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < buf.length; i++) {\n        final char ch = buf[i];\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n\n    final char[] buffer = str.toCharArray();\n    final char[] buf = new char[buffer.length];\n    int count = 0;\n\n    boolean lastWasGap = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buf[count++] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return getDefault().getID();\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC.getID();\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    // Support GMT+/-hh:mm formats\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return DateTimeZone.UTC.getID();\n        } else {\n            id = printOffset(offset);\n            return fixedOffsetZone(id, offset).getID();\n        }\n    }\n    throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return getDefault().getID();\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC.getID();\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    // Support GMT+/-hh:mm formats\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return DateTimeZone.UTC.getID();\n        } else {\n            id = printOffset(offset);\n            return fixedOffsetZone(id, offset).getID();\n        }\n    }\n    throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC.getID();\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return DateTimeZone.UTC.getID();\n        } else {\n            id = printOffset(offset);\n            return id;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"GMT+\"))\n    {\n        int offset = parseOffset(id.substring(3));\n        if (offset == 0L)\n        {\n            return \"UTC\";\n        }\n        else\n        {\n            return printOffset(offset);\n        }\n    }\n    else if (id.startsWith(\"GMT-\"))\n    {\n        int offset = -parseOffset(id.substring(3));\n        if (offset == 0L)\n        {\n            return \"UTC\";\n        }\n        else\n        {\n            return printOffset(offset);\n        }\n    }\n    else\n    {\n        return id;\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return id;\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n            return id;\n        }\n    }\n    // Support GMT+/-hh:mm formats\n    if (id.startsWith(\"GMT+\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n            return id;\n        }\n    }\n    if (id.startsWith(\"GMT-\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n            return id;\n        }\n    }\n    throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return id;\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n        }\n    }\n    // Support GMT+/-hh:mm formats\n    if (id.startsWith(\"GMT+\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n        }\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"GMT+\")) {\n        String convId = id.substring(4);\n        int offset = parseOffset(convId);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            convId = printOffset(offset);\n            return fixedOffsetZone(convId, offset).getID();\n        }\n    } else if (id.startsWith(\"GMT-\")) {\n        String convId = id.substring(4);\n        int offset = -parseOffset(convId);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            convId = printOffset(offset);\n            return fixedOffsetZone(convId, offset).getID();\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return getDefault().getID();\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC.getID();\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    // Support GMT+/-hh:mm formats\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return DateTimeZone.UTC.getID();\n        } else {\n            id = printOffset(offset);\n            return fixedOffsetZone(id, offset).getID();\n        }\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return id;\n    }\n    DateTimeZone zone = cProvider.getZone(id);\n    if (zone != null) {\n        return zone.getID();\n    }\n    if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n        int offset = parseOffset(id);\n        if (offset == 0L) {\n            return \"UTC\";\n        } else {\n            id = printOffset(offset);\n            return id;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) \n        {\n            return DateTimeZone.UTC.getID();\n        } else \n        {\n            return fixedOffsetZone(id, offset).getID();\n        }\n    }\n    return id;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian = new Array2DRowRealMatrix(dimension, dimension);\n    double[] x = new double[dimension];\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < dimension; j++) {\n            x[j] = params[j];\n            if (i == j) {\n                weightedJacobian.setEntry(i, j, weightedResidualJacobian[i] / sigma);\n            } else {\n                weightedJacobian.setEntry(i, j, (weightedResidualJacobian[i] * x[j]) / sigma);\n            }\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian;\n    if (jacobian != null) {\n        weightedJacobian = jacobian.scalarMultiply(Math.sqrt(weight));\n    } else {\n        weightedJacobian = new Array2DRowRealMatrix(params.length, 1);\n    }\n    for (int i = 0; i < params.length; i++) {\n        weightedJacobian.setEntry(i, 0, weightedJacobian.getEntry(i, 0) - jacobian.getEntry(i, 0) / Math.sqrt(weight));\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightedJacobian = zeros(jacobian.getColumnDimension(), jacobian.getRowDimension());\n    for (int j = 0; j < jacobian.getColumnDimension(); j++) {\n        weightedJacobian.setColumn(j, computeWeightedJacobianColumn(params, j));\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    final RealMatrix sqrtW = new LUDecomposition(weightedCovariance).getSolver().getInverse().scalarMultiply(0.5);\n    return sqrtW.operate(weightedJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Calculate the Jacobian as per the provided algorithm\n    // ...\n    \n    // Apply the weight matrix\n    return weightedJacobian.scalarMultiply(Math.pow(weights.getEntry(0, 0), 0.5));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian;\n    if (weightedJacobian == null) {\n        weightedJacobian = new Array2DRowRealMatrix(problemDimension, problemDimension);\n        for (int i = 0; i < problemDimension; i++) {\n            weightedJacobian.setEntry(i, i, weights[i]);\n        }\n    } else {\n        weightedJacobian = weightedJacobian.scalarMultiply(weights);\n    }\n    return weightedJacobian.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightedJacobian = zeros(jacobianDimension, pointDimension);\n    for (int i = 0; i < pointDimension; ++i) {\n        weightedJacobian.setEntry(i, i, computeWeightedDerivative(params, i));\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian;\n    if (diagonalOnly <= 0) {\n        weightedJacobian = times(diagW.scalarMultiply(0.5), new Array2DRowRealMatrix(jacobian)); // W^1/2 * J\n    } else {\n        weightedJacobian = times(diagW.scalarMultiply(0.5), new Array2DRowRealMatrix(diagV, jacobian)); // W^1/2 * V * J\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian = new Array2DRowRealMatrix(dimension, dimension);\n    double[] weights = new double[dimension];\n    for (int i = 0; i < dimension; i++) {\n        weights[i] = Math.sqrt(weights[i]);\n    }\n    double[][] weightedJacobianArray = weightedJacobian.getData();\n    double[][] jacobianArray = jacobian.getData();\n    for (int i = 0; i < dimension; i++) {\n        for (int j = 0; j < dimension; j++) {\n            weightedJacobianArray[i][j] = jacobianArray[i][j] * weights[j];\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    final RealMatrix weightedSqrtJacobian = weightedJacobian.scalarMultiply(Math.sqrt(weights));\n    return weightedSqrtJacobian.getData();\n}"
    ],
    [
      "private int least()  {\n    // Iterate over the values and find the least, setting any uninitialized values along the way.\n    int leastIndex = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.compare(values[i], values[i + 1]) < 0 ? values[i + 1] : values[i];\n        }\n        if (leastIndex == -1 || comparator.compare(values[i], values[leastIndex]) < 0)\n        {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    Comparator<V> comparator = valueComparator;\n    if (comparator == null)\n        throw new NullPointerException(\"No comparator set\");\n\n    for (int i = 0; i < values.length; i++)\n    {\n        if (values[i] == null)\n        {\n            values[i] = comparator.compare(values[i], values[(i + 1) % values.length]) < 0 ? values[i] : values[(i + 1) % values.length];\n            if (values[i] == null)\n                continue;\n        }\n        return i;\n    }\n    return -1;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"comparator not set\");\n    }\n\n    final int size = values.size();\n\n    for (int i = 0; i < size; i++) \n    {\n        if (values.get(i) == UNINITIALIZED) \n        {\n            values.set(i, comparator.compare(values.get(i), values.get(i)) < 0 ? values.get(i) : values.get(i));\n        }\n    }\n\n    for (int i = 0; i < size; i++) \n    {\n        if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n        {\n            leastIndex = i;\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int firstIndex = -1;\n    V firstValue = null;\n    for (int i = 0; i < values.length; i++) {\n        V value = values[i];\n        if (value == null) {\n            values[i] = firstValue;\n        } else {\n            int result = comparator.compare(firstValue, value);\n            if (result > 0) {\n                firstIndex = i;\n                firstValue = value;\n            }\n        }\n    }\n    return firstIndex;\n}",
      "private int least()  {\n    Comparator<V> c = comparator;\n    if (c == null) {\n        throw new NullPointerException(\"No comparator set for min()\");\n    }\n    int least = -1;\n    V min = null;\n    for (int i = 0; i < values.length; i++) {\n        V v = values[i];\n        if (v == null) {\n            values[i] = min;\n        } else {\n            int res = c.compare(min, v);\n            if (res == 0) {\n                if (least >= 0) {\n                    least = -1; // more than one min value found\n                }\n            } else if (res > 0) {\n                least = i;\n                min = v;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException();\n    }\n\n    if (values.length == 0) \n    {\n        return 0;\n    }\n\n    if (values[0] == null) \n    {\n        values[0] = values[leastNonNull(0)];\n        return 0;\n    }\n\n    for (int i = 1; i < values.length; ++i) \n    {\n        if (values[i] == null) \n        {\n            values[i] = values[leastNonNull(i)];\n        }\n\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n\n    return least;\n}",
      "private int least()  {\n    Comparator<? super V> comp = comparator;\n    if (comp == null) \n    {\n        comp = (Comparator<? super V>) ComparatorUtils.NATURAL_COMPARATOR;\n    }\n    for (int i = firstIndex; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = set(i);\n        }\n    }\n    return leastIndex(comp, values, firstIndex, values.length);\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException();\n    }\n\n    int low = 0;\n    int high = values.length - 1;\n    while (low < high)\n    {\n        final int mid = (low + high) >>> 1;\n        if (comparator.compare(values[mid], values[high]) <= 0)\n        {\n            low = mid + 1;\n        }\n        else\n        {\n            high = mid;\n        }\n    }\n    return low;\n}",
      "private int least()  {\n    // Comparator must be set\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator provided\");\n    }\n\n    // Find the index of the least element\n    int result = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = comparator.compare(values[i], values[i]) < 0 ? values[i] : values[i];\n        }\n        if (result == -1 || comparator.compare(values[i], values[result]) < 0) {\n            result = i;\n        }\n    }\n\n    return result;\n}",
      "private int least()  {\n    // Use a collating iterator to compare elements in the set\n    Iterator<Integer> iterator = collatedIterator(comparator, values.iterator());\n    \n    // Iterate through the set, setting any uninitialized values and finding the least\n    int leastIndex = -1;\n    while (iterator.hasNext()) {\n        int index = iterator.next();\n        if (values[index] == null) {\n            values[index] = leastIndex == -1 ? 0 : leastIndex + 1;\n        }\n        if (leastIndex == -1 || comparator.compare(values[index], values[leastIndex]) < 0) {\n            leastIndex = index;\n        }\n    }\n    \n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.isSimpleStep()) {\n            return parentPointer;\n        }\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName nodeName = ((NodeNameTest) nodeTest).getNodeName();\n            if (nodeTest.isWildcard()) {\n                return parentPointer.childIterator(null, false, null).getNodePointer();\n            } else {\n                return parentPointer.childIterator(nodeName, false, null).getNodePointer();\n            }\n        } else if (nodeTest instanceof NodeTypeTest) {\n            int nodeType = ((NodeTypeTest) nodeTest).getNodeType();\n            if (nodeType == Compiler.NODE_TYPE_NODE) {\n                return parentPointer.childIterator(null, true, null).getNodePointer();\n            } else {\n                return parentPointer.childIterator(null, false, nodeType).getNodePointer();\n            }\n        }\n        return null;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        Expression nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            return parentPointer.createChildPointer(\n                    ((NodeNameTest) nodeTest).getNodeName(),\n                    ((NodeNameTest) nodeTest).isWildcard());\n        } else if (nodeTest instanceof NodeTypeTest) {\n            return parentPointer.createChildPointer(\n                    ((NodeTypeTest) nodeTest).getNodeType());\n        } else {\n            throw new RuntimeException(\"Unsupported node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.getAxis() == Compiler.AXIS_CHILD) {\n            NodeTest nodeTest = step.getNodeTest();\n            QName qname = ((NodeNameTest) nodeTest).getNodeName();\n            String prefix = qname.getPrefix();\n            if (prefix != null) {\n                String namespaceURI = parentPointer.getJXPathContext()\n                        .getNamespaceURI(prefix);\n                nodeTest = new NodeNameTest(qname, namespaceURI);\n            }\n            return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n        }\n        // else Compiler.AXIS_ATTRIBUTE\n        if (!(step.getNodeTest() instanceof NodeNameTest)) {\n            throw new UnsupportedOperationException(\n                \"Not supported node test for attributes: \"\n                    + step.getNodeTest());\n        }\n        return parentPointer.attributeIterator(\n            ((NodeNameTest) step.getNodeTest()).getNodeName()).getNodePointer();\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.isSimple())\n    {\n        return parentPointer.child(\n                step.getNodeTest(),\n                false,\n                null);\n    }\n    else\n    {\n        return parentPointer.attribute(\n                ((NodeNameTest) step.getNodeTest()).getNodeName());\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeTypeTest) {\n            int nodeType = ((NodeTypeTest) nodeTest).getNodeType();\n            if (nodeType == Compiler.NODE_TYPE_NODE) {\n                return parentPointer.childIterator(nodeTest, false, null)\n                        .getNodePointer();\n            } else if (nodeType == Compiler.NODE_TYPE_ATTRIBUTE) {\n                return parentPointer.attributeIterator(\n                        ((NodeNameTest) nodeTest).getNodeName())\n                        .getNodePointer();\n            } else {\n                // nodeType == Compiler.NODE_TYPE_TEXT\n                return parentPointer.childIterator(nodeTest, false, null)\n                        .getNodePointer()\n                        .childIterator(new NodeTypeTest(Compiler.NODE_TYPE_TEXT), \n                                false, null)\n                        .getNodePointer();\n            }\n        } else if (nodeTest instanceof NodeNameTest) {\n            return parentPointer.childIterator((NodeNameTest) nodeTest, false, null)\n                    .getNodePointer();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported NodeTest: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer pointer = parentPointer;\n    NodeTest nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        pointer = pointer.childIterator(nodeTest, false, null).getNodePointer();\n    } else if (nodeTest instanceof NodeTypeTest) {\n        pointer = pointer.childIterator(nodeTest, false, null).getNodePointer();\n    } else {\n        pointer = pointer.childIterator(nodeTest, false, null).getNodePointer();\n    }\n    return pointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.isSimple()) {\n        return parentPointer.child(step.getAxis(), step.getNodeTest(), false, null);\n    }\n    else {\n        NodeIterator iterator = getNodeIterator(context, parentPointer, step);\n        if (iterator.setPosition(iterator.getPosition() + 1)) {\n            return iterator.getNodePointer();\n        }\n        else {\n            return createNullPointer(\n                    context,\n                    parentPointer,\n                    steps,\n                    currentStep);\n        }\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (parentPointer.isRoot()) {\n        return parentPointer;\n    }\n\n    NodeTest nodeTest = step.getNodeTest();\n    if (!(nodeTest instanceof NodeNameTest)) {\n        throw new UnsupportedOperationException(\n            \"Only NodeNameTest nodes are supported\");\n    }\n\n    QName qname = ((NodeNameTest) nodeTest).getNodeName();\n    String prefix = qname.getPrefix();\n    if (prefix != null) {\n        String namespaceURI = parentPointer.getNamespaceURI(prefix);\n        nodeTest = new NodeNameTest(qname, namespaceURI);\n    }\n\n    return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (parentPointer.isNodeType(Compiler.NODE_TYPE_NODE)) {\n        if (step.isSimpleStep()) {\n            return new NodePointer(\n                    parentPointer.getNodePointer(),\n                    step.getAxis(),\n                    step.getNodeTest(),\n                    step.getPredicates(),\n                    null,\n                    null);\n        }\n        else {\n            return doStepPredicatesStandard(\n                    parentPointer.getEvalContext(),\n                    parentPointer.getNodePointer(),\n                    step.getSteps(),\n                    0);\n        }\n    }\n\n    return new NullPointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (parentPointer.isDocumentPointer()) {\n        if (step.isSimpleStep()) {\n            return parentPointer;\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        if (step.isSimpleStep()) {\n            return parentPointer.childNodePointer(\n                step.getPosition(), step.isReversed());\n        }\n        else {\n            if (step.getAxis() == Compiler.AXIS_CHILD\n                || step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n                return parentPointer.childNodePointer(\n                    step.getPosition(), step.isReversed());\n            }\n            else {\n                return null;\n            }\n        }\n    }\n}"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field,definingCalendar,Locale.getDefault());\n}"
    ],
    [
      "private boolean setNextObject()  {\n    if (nextNode != null) \n    {\n        previousNode = nextNode;\n        nextNode = nextNode.getNext();\n        return true;\n    }\n    else \n    {\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n    if (nextNode == null)\n        return false;\n    lastReturnedNode = nextNode;\n    if (nextNode.getRight(orderType) != null) {\n        nextNode = nextNode.getRight(orderType);\n        while (nextNode.getLeft(orderType) != null) {\n            nextNode = nextNode.getLeft(orderType);\n        }\n    } else {\n        Node<K, V> parent = nextNode.getParent(orderType);\n        while (parent != null && nextNode == parent.getRight(orderType)) {\n            nextNode = parent;\n            parent = nextNode.getParent(orderType);\n        }\n        nextNode = parent;\n    }\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (iterator.hasNext() == false) {\n        return false;\n    }\n    final Map.Entry<V, K> entry = iterator.next();\n    nextObject = entry.getKey();\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (nextNode != null)\n    {\n        previousNode = nextNode;\n        nextNode = nextNode.getNextNode(orderType);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n    if (hasNext()) \n    {\n        lastReturnedNode = nextNode;\n        if (nextNode.getRight(orderType) != null) \n        {\n            nextNode = nextNode.getRight(orderType);\n        }\n        else \n        {\n            Node<K, V> parent = nextNode.getParent(orderType);\n            while (parent != null && nextNode == parent.getRight(orderType)) \n            {\n                nextNode = parent;\n                parent = parent.getParent(orderType);\n            }\n            if (parent != null) \n            {\n                nextNode = parent.getLeft(orderType);\n            }\n            else \n            {\n                nextNode = null;\n            }\n        }\n        return true;\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (hasNext())\n    {\n        lastReturnedNode = nextNode;\n        if (orderType == KEY) \n        {\n            nextNode = nextNode.getNext(KEY);\n        }\n        else \n        {\n            nextNode = nextNode.getNext(VALUE);\n        }\n        return true;\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextNode == null) \n    {\n        return false;\n    }\n    lastReturnedNode = nextNode;\n    previousNode = nextNode.getLeft(orderType);\n    if (previousNode == null) \n    {\n        nextNode = nextNode.getRight(orderType);\n    }\n    else \n    {\n        Node<K, V> rightNode = nextNode.getRight(orderType);\n        if (rightNode == null) \n        {\n            nextNode = previousNode.getParent(orderType);\n        }\n        else \n        {\n            nextNode = rightNode;\n        }\n    }\n    return nextNode != null;\n}",
      "private boolean setNextObject()  {\n    if (hasNext())\n    {\n        if (nextNode != null)\n        {\n            previousNode = nextNode;\n        }\n        if (orderType == VALUE)\n        {\n            nextNode = nextSmaller(lookup(lastReturnedNode.getValue(), KEY), VALUE);\n        }\n        else\n        {\n            nextNode = nextBigger(lookup(lastReturnedNode.getKey(), VALUE), VALUE);\n        }\n        lastReturnedNode = nextNode;\n        return true;\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (iterator.hasNext())\n    {\n        Map.Entry<V, K> nextObject = iterator.next();\n        this.key = nextObject.getKey();\n        this.value = nextObject.getValue();\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n    if (iterator == null)\n    {\n        return false;\n    }\n\n    while (iterator.hasNext())\n    {\n        Map.Entry<V, K> next = iterator.next();\n        nextObject = new MapEntry<V, K>(next.getKey(), next.getValue());\n        return true;\n    }\n\n    nextObject = null;\n    iterator = null;\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] result = new double[x.length];\n\n    for (int i = 0; i < x.length; ++i) \n    {\n        result[i] = FastMath.min(FastMath.max(x[i], lB[i]), uB[i]);\n    }\n\n    return result;\n}",
      "private double[] repair(final double[] x)  throws NoDataException {\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n        final double[] repaired = new double[x.length];\n\n        for (int i = 0; i < x.length; ++i) {\n            repaired[i] = FastMath.max(FastMath.min(x[i], uB[i]), lB[i]);\n        }\n        return repaired;\n    }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] result = new double[x.length];\n    for(int i = 0; i < x.length; ++i) {\n        result[i] = FastMath.max(lB[i], FastMath.min(uB[i], x[i]));\n    }\n    return result;\n}",
      "private double[] repair(final double[] x)  throws NullArgumentException, NoDataException {\n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        if (x.length == 0) {\n            throw new NoDataException();\n        }\n\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n        for (int i = 0; i < x.length; i++) {\n            if (x[i] < lB[i]) {\n                x[i] = lB[i];\n            }\n            if (x[i] > uB[i]) {\n                x[i] = uB[i];\n            }\n        }\n        return x;\n    }",
      "private double[] repair(final double[] x)  throws NullArgumentException, NoDataException {\n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        if (x.length == 0) {\n            throw new NoDataException();\n        }\n\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n        for (int i = 0; i < x.length; i++) {\n            if (x[i] < lB[i]) {\n                x[i] = lB[i];\n            }\n            if (x[i] > uB[i]) {\n                x[i] = uB[i];\n            }\n        }\n\n        return x;\n    }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    final double[] result = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            result[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            result[i] = uB[i];\n        } else {\n            result[i] = x[i];\n        }\n    }\n\n    return result;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  throws NoDataException {\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n        final double[] repaired = new double[x.length];\n\n        for (int i = 0; i < x.length; i++) {\n            repaired[i] = FastMath.min(FastMath.max(x[i], lB[i]), uB[i]);\n        }\n\n        return repaired;\n    }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] result = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (x[i] < lB[i]) {\n            result[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            result[i] = uB[i];\n        } else {\n            result[i] = x[i];\n        }\n    }\n    return result;\n}",
      "private double[] repair(final double[] x)  throws NullArgumentException, NoDataException {\n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        if (x.length == 0) {\n            throw new NoDataException();\n        }\n\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n        final double[] xFixed = new double[x.length];\n\n        for (int i = 0; i < x.length; i++) {\n            xFixed[i] = FastMath.max(lB[i], FastMath.min(x[i], uB[i]));\n        }\n\n        return xFixed;\n    }"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    \n    // apply Householder transformation to tridiagonal form\n    findEigenVectors(transformer.getT().getData());\n    \n    // return the Schur transform\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    \n    // return the Shur transformer\n    return new SchurTransformer(matrix, transformer);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    final int n = main.length;\n\n    // determine the initial shift value\n    double shift = 0.0;\n    for (int i = 0; i < n; i++) {\n        shift += main[i];\n    }\n    shift = shift / n;\n\n    // compute the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n    final int im = initQRStep(0, n, shift, hVec);\n\n    // initialize the result matrix\n    final double[][] result = new double[n][n];\n    for (int i = 0; i < n; ++i) {\n        System.arraycopy(matrix.getRowVector(i).getDataRef(), 0, result[i], 0, n);\n    }\n\n    // perform the QR transformation\n    for (int il = 0; il < n - 1; ++il) {\n        int iu = n - 1;\n        while (iu > il) {\n            performDoubleQRStep(il, iu, shift, hVec);\n\n            // update the result matrix\n            for (int i = 0; i < iu + 1; ++i) {\n                double[] resultI = result[i];\n                for (int j = il; j <= iu; ++j) {\n                    resultI[j] -= 2.0 * hVec[j - il] * result[i][j - il - 1];\n                }\n            }\n\n            iu--;\n        }\n\n        // apply the shift\n        shift = shift - main[il];\n\n        // compute the new houseHolder vector for the QR step\n        im = initQRStep(il, iu, shift, hVec);\n    }\n\n    // compute the eigenvalues from the tridiagonal matrix\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = main[i] - shift;\n        imagEigenvalues[i] = secondary[i];\n    }\n\n    // create and return the Shur transformer\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    final int n = main.length;\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    final double[] e = new double[n];\n    for (int i = 0; i < n - 1; i++) {\n        realEigenvalues[i] = main[i];\n        e[i] = secondary[i];\n    }\n    realEigenvalues[n - 1] = main[n - 1];\n    e[n - 1] = 0;\n    // Determine the largest main and secondary value in absolute term.\n    double maxAbsoluteValue = 0;\n    for (int i = 0; i < n; i++) {\n        if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n            maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n        }\n        if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n            maxAbsoluteValue = FastMath.abs(e[i]);\n        }\n    }\n    // Make null any main and secondary value too small to be significant\n    if (maxAbsoluteValue != 0) {\n        for (int i=0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                realEigenvalues[i] = 0;\n            }\n            if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                e[i]=0;\n            }\n        }\n    }\n    final HouseholderTransformer houseHolder = new HouseholderTransformer(matrix);\n    // compute the eigenvalue from the tridiagonal matrix\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = houseHolder.transform(new Complex(realEigenvalues[i], e[i])).getReal();\n        imagEigenvalues[i] = houseHolder.transform(new Complex(realEigenvalues[i], e[i])).getImaginary();\n    }\n    return new SchurTransformer(houseHolder);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    final int n = main.length;\n\n    // initialize the eigenvalues\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = main[i];\n        imagEigenvalues[i] = secondary[i];\n    }\n\n    // initialize the eigenvectors\n    eigenvectors = new RealMatrix[n];\n    for (int i = 0; i < n; i++) {\n        eigenvectors[i] = matrix.getRowMatrix(i);\n    }\n\n    // perform the QR iterations\n    for (int it = 0; it < maxIterations; it++) {\n        // find the first small sub-diagonal element\n        int il = findSmallSubDiagonalElement(0, getNorm());\n        int iu = n - il - 1;\n\n        // exit if all sub-diagonal elements are sufficiently small\n        if (il == iu) {\n            break;\n        }\n\n        // perform the QR step\n        double shift = (realEigenvalues[iu] + realEigenvalues[iu - 1]) / 2.0;\n        performQRStep(il, iu, shift);\n    }\n\n    // return the Shur transform\n    return new SchurTransformer(matrixT, matrixP, realEigenvalues, imagEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    // Initialize the eigenvalues\n    for (int i = 0; i < main.length; i++)\n    {\n        realEigenvalues[i] = main[i];\n    }\n    // Perform the QR transformation\n    new QRTransformer(matrix).transform(main, secondary, realEigenvalues);\n    // Find the eigenvectors from the tridiagonal matrix\n    findEigenVectors(transformer.getT().getData());\n    // Calculate the eigenvalues from the eigenvectors\n    for (int i = 0; i < main.length; i++)\n    {\n        realEigenvalues[i] = cdiv(eigenvectors[i].getEntry(0, 0), eigenvectors[i].getEntry(0, 1)).getReal();\n        imagEigenvalues[i] = cdiv(eigenvectors[i].getEntry(0, 0), eigenvectors[i].getEntry(0, 1)).getImaginary();\n    }\n    // Create and return a new ShurTransformer object\n    return new SchurTransformer(matrix, getEigenvectors(), realEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    \n    // create a copy of the tridiagonal matrix\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < matrixT.length; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    int il = 0;\n    int iu = matrixT.length - 1;\n    int shift = 0;\n\n    // find the initial shift\n    for (int i = iu - 1; i > il; i--) {\n        final double v = matrixT[i][i];\n        final double w = matrixT[i + 1][i];\n\n        if (FastMath.abs(v) <= Precision.EPSILON * FastMath.abs(w)) {\n            shift++;\n        } else {\n            break;\n        }\n    }\n\n    // the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    final int im = initQRStep(il, iu, shift, hVec);\n    performDoubleQRStep(il, im, iu, shift, hVec);\n\n    // find the first small sub-diagonal element\n    int l = findSmallSubDiagonalElement(il, norm);\n\n    while (l <= iu) {\n        // store the previous values of il and iu\n        final int im = il;\n        final int iuM = iu;\n\n        // move the sub-diagonal element to the diagonal\n        shift = findShift(l, iu, matrixT);\n        final double s = matrixT[l][l];\n\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // Find eigenvalues from tridiagonal matrix\n    findEigenvectors(transformer.getT().getData());\n\n    return new SchurTransformer(matrix, realEigenvalues, imagEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    final int n = main.length;\n    final double[][] houseHolderMatrix = new double[n][n];\n\n    // compute the Householder vectors to bring matrix to schur form\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i; j < n; j++) {\n            houseHolderMatrix[j][i] = secondary[i];\n        }\n        houseHolderMatrix[i][i] = main[i];\n    }\n    houseHolderMatrix[n - 1][n - 1] = main[n - 1];\n\n    // find eigenvalues from tridiagonal matrix\n    findEigenVectors(houseHolderMatrix);\n\n    // compute eigenvectors from schur form\n    findEigenVectorsFromSchur(new SchurTransformer(matrix));\n\n    // return the schur transform\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    final int n = main.length;\n\n    // compute matrix norm\n    double norm = getNorm();\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // compute initial shift\n    final double shift = -0.5 * (main[0] + main[n - 1]);\n    RealMatrix matrixT = transformer.getT();\n    double[] p = new double[n];\n    for (int j = 0; j < n; j++) {\n        p[j] = matrixT.getEntry(j, j);\n        matrixT.setEntry(j, j, p[j] - shift);\n    }\n\n    // initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    for (int il = 0; il < n - 1; ++il) {\n        // find first small sub-diagonal element\n        int iu = findSmallSubDiagonalElement(il, norm);\n\n        // compute the shift\n        double s = FastMath.abs(matrixT.getEntry(iu - 1, iu - 1)) + FastMath.abs(matrixT.getEntry(iu, iu));\n        if (s == 0.0) {\n            s = norm;\n        }\n        final double shift = -0.5 * (matrixT.getEntry(iu - 1, iu - 1) + matrixT.getEntry(iu, iu));\n\n        // compute the first QR step\n        final int im = initQRStep(il, iu, shift, hVec);\n        performDoubleQRStep(il, im, iu, shift, hVec);\n\n        // update the vectors\n        for (int j = il; j <= iu; j++) {\n            p[j] = matrixT.getEntry(j, j);\n            matrixT.setEntry(j, j, p[j] - shift);\n        }\n    }\n\n    // return the Shur transform\n    return new SchurTransformer(matrixT, p);\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = 0; i < Long.BYTES; i++) {\n            long mask = 0xFFL << (i * Long.BYTES);\n            if ((value & mask) != 0) {\n                result.add(EnumUtils.getEnum(enumClass, Long.toString(value, 2).substring(i * 8, (i+1) * 8)));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long bitVector : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if ((bitVector & (1L << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (long value : values) \n    {\n        while (value > 0) \n        {\n            if ((value & 1) == 1) \n            {\n                int index = Long.numberOfTrailingZeros(value);\n                E constant = enumClass.getEnumConstants()[index];\n                Validate.notNull(constant);\n                condensed.add(constant);\n            }\n            value >>>= 1;\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        while (value != 0) {\n            long bitMask = value & -value;\n            int index = (int) (Math.log(bitMask) / Math.log(2));\n            Enum<E> enumValue = enumClass.getEnumConstants()[index];\n            enumSet.add(enumValue);\n            value ^= bitMask;\n        }\n    }\n    return enumSet;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        for (final long bitVector : values) {\n            if ((bitVector & (1L << constant.ordinal())) != 0) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E enumValue : EnumUtils.getEnumConstants(enumClass)) {\n            if ((value & (1 << enumValue.ordinal())) > 0) {\n                result.add(enumValue);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = 0; i < Long.BYTES; i++) {\n            if ((value & (1L << i)) != 0L) {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (E constant : enumClass.getEnumConstants()) {\n            if ((value & (1L << constant.ordinal())) != 0L) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        while (value != 0) {\n            long masked = value & -value;\n            value ^= masked;\n            result.add(enumClass.getEnumConstants()[(int) (masked / Long.SIZE)]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E constant : enumClass.getEnumConstants()) {\n            if ((value & (1L << constant.ordinal())) != 0L) {\n                enumSet.add(constant);\n            }\n        }\n    }\n    return enumSet;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n\n    // Convert oldInstant to local millis in this zone\n    long localMillis = getZone().toLocalTimeMillis(newZone, oldInstant);\n    \n    // Convert local millis to UTC millis in new zone\n    return newZone.toUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    Chronology oldChronology = DateTimeUtils.getChronology(getChronology().withZone(DateTimeZone.UTC));\n    Chronology newChronology = DateTimeUtils.getChronology(newZone);\n    return newChronology.getMillis(oldChronology.getDateTime(oldInstant).toLocalDate());\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    return getChronology().withZone(newZone).toDateTime(oldInstant).getMillis();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n\n    // Convert oldInstant to local millis in this zone\n    long localMillis = getZone().toLocalTimeMillis(oldInstant);\n\n    // Convert local millis to UTC millis in the new zone\n    return newZone.toUTCMillis(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getDefaultZone();\n    }\n    if (DateTimeUtils.isUTC(oldInstant)) {\n        return newZone.toInstant(newZone.fromUTC(oldInstant)).toEpochMilli();\n    }\n    return newZone.toInstant(newZone.fromUTC(oldInstant)).toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    Instant oldDateTime = Instant.ofEpochMilli(oldInstant).atZone(DateTimeUtils.UTC).toInstant();\n    Instant newDateTime = oldDateTime.atZone(newZone).toInstant();\n    return newDateTime.toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    if (newZone == DateTimeUtils.getZone(getZone())) {\n        return oldInstant;\n    }\n    return getZone().getMillisKeepLocal(newZone, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    return newZone.toInstant(newZone.localToUTC(oldInstant));\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    long millis = getZone().toInstant(oldInstant).toEpochMilli();\n    return newZone.fromInstant(Instant.ofEpochMilli(millis)).toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    long millis = originalZone.getMillisKeepLocal(newZone, oldInstant);\n    return newZone.getMillisKeepLocal(originalZone, millis);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n// chart/axis/DateAxis.java\n// date formatters\n        DateFormat f1 = new SimpleDateFormat(\"HH:mm:ss.SSS\", locale);\n        DateFormat f2 = new SimpleDateFormat(\"HH:mm:ss\", locale);\n        DateFormat f3 = new SimpleDateFormat(\"HH:mm\", locale);\n        DateFormat f4 = new SimpleDateFormat(\"d-MMM, HH:mm\", locale);\n        DateFormat f5 = new SimpleDateFormat(\"d-MMM\", locale);\n        DateFormat f6 = new SimpleDateFormat(\"MMM-yyyy\", locale);\n        DateFormat f7 = new SimpleDateFormat(\"yyyy\", locale);\n\n        f1.setTimeZone(zone);\n        f2.setTimeZone(zone);\n        f3.setTimeZone(zone);\n        f4.setTimeZone(zone);\n        f5.setTimeZone(zone);\n        f6.setTimeZone(zone);\n        f7.setTimeZone(zone);\n\n        // milliseconds\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25,\n                DateTickUnitType.MILLISECOND, 5, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50,\n                DateTickUnitType.MILLISECOND, 10, f1));\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count = unit.getMultiple();\n        int current = calendar.get(unit.getCalendarField());\n        int value = count * (current / count) + count;\n        calendar.set(unit.getCalendarField(), value);\n\n        Date result = calendar.getTime();\n        if (result.getTime() <= date.getTime()) {\n            calendar.set(unit.getCalendarField(), value + count);\n            result = calendar.getTime();\n        }\n        return result;\n    }",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    value = value + count;\n\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count = unit.getMultiple();\n        int current = calendar.get(unit.getCalendarField());\n        int value = count * (current / count + 1);\n        \n        DateTickUnitType t = unit.getUnitType();\n        if (t.equals(DateTickUnitType.MILLISECOND)) {\n            years = calendar.get(Calendar.YEAR);\n            months = calendar.get(Calendar.MONTH);\n            days = calendar.get(Calendar.DATE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            minutes = calendar.get(Calendar.MINUTE);\n            seconds = calendar.get(Calendar.SECOND);\n            calendar.set(years, months, days, hours, minutes, seconds);\n            calendar.set(Calendar.MILLISECOND, value);\n            Date mm = calendar.getTime();\n            return mm;\n        }\n        else if (t.equals(DateTickUnitType.SECOND)) {\n            years = calendar.get(Calendar.YEAR);\n            months = calendar.get(Calendar.MONTH);\n            days = calendar.get(Calendar.DATE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            minutes = calendar.get(Calendar.MINUTE);\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                milliseconds = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                milliseconds = 500;\n            }\n            else {\n                milliseconds = 999;\n            }\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            calendar.set(years, months, days, hours, minutes, value);\n            Date dd = calendar.getTime();\n            return dd;\n        }\n        else if (t.equals(DateTickUnitType.MINUTE)) {\n            years = calendar.get(Calendar.YEAR);\n            months = calendar.get(Calendar.MONTH);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count = unit.getMultiple();\n        int current = calendar.get(unit.getCalendarField());\n        int value = count * ((current / count) + 1);\n        \n        DateTickUnitType t = unit.getUnitType();\n        if (t.equals(DateTickUnitType.MILLISECOND)) {\n            years = calendar.get(Calendar.YEAR);\n            months = calendar.get(Calendar.MONTH);\n            days = calendar.get(Calendar.DATE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            minutes = calendar.get(Calendar.MINUTE);\n            seconds = calendar.get(Calendar.SECOND);\n            calendar.set(years, months, days, hours, minutes, seconds);\n            calendar.set(Calendar.MILLISECOND, value);\n            Date mm = calendar.getTime();\n            if (mm.getTime() <= date.getTime()) {\n                calendar.set(Calendar.MILLISECOND, value + 1);\n                mm = calendar.getTime();\n            }\n            return mm;\n        }\n        else if (t.equals(DateTickUnitType.SECOND)) {\n            years = calendar.get(Calendar.YEAR);\n            months = calendar.get(Calendar.MONTH);\n            days = calendar.get(Calendar.DATE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            minutes = calendar.get(Calendar.MINUTE);\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                milliseconds = 0;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                milliseconds = 500;\n            }\n            else {\n                milliseconds = 999;\n            }\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            calendar.set(years, months, days, hours, minutes, value);\n            Date dd = calendar.getTime();\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n// chart/axis/DateAxis.java\n// date formatters\n    DateFormat f1 = new SimpleDateFormat(\"HH:mm:ss.SSS\", locale);\n    DateFormat f2 = new SimpleDateFormat(\"HH:mm:ss\", locale);\n    DateFormat f3 = new SimpleDateFormat(\"HH:mm\", locale);\n    DateFormat f4 = new SimpleDateFormat(\"d-MMM, HH:mm\", locale);\n    DateFormat f5 = new SimpleDateFormat(\"d-MMM\", locale);\n    DateFormat f6 = new SimpleDateFormat(\"MMM-yyyy\", locale);\n    DateFormat f7 = new SimpleDateFormat(\"yyyy\", locale);\n\n    f1.setTimeZone(zone);\n    f2.setTimeZone(zone);\n    f3.setTimeZone(zone);\n    f4.setTimeZone(zone);\n    f5.setTimeZone(zone);\n    f6.setTimeZone(zone);\n    f7.setTimeZone(zone);\n\n    // milliseconds\n    units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1));\n    units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5,\n                DateTickUnitType.MILLISECOND, 1, f1));\n    units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10,\n                DateTickUnitType.MILLISECOND, 1, f1));\n    units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25,\n                DateTickUnitType.MILLISECOND, 5, f1));\n    units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50,\n                DateTickUnitType.MILLISECOND, 10, f1));\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n    \n    if (unit.getUnitType().equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() <= date.getTime()) {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n\n    // milliseconds\n    if (unit.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    // seconds\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() <= date.getTime()) {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n\n    if (unit.getUnitType().equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() <= date.getTime()) {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    Date result = date;\n    if (unit.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() <= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value + 1);\n            mm = calendar.getTime();\n        }\n        result = mm;\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        calendar.set(years, months, days, hours, minutes, value);\n        Date dd = calendar.getTime();\n        if (dd.getTime() <= date.getTime()) {\n}\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup == null) {\n        return null;\n    }\n    Object result = lookup.lookup(variableName);\n    if (result == null) {\n        return null;\n    }\n    String value = result.toString();\n    if (value.indexOf(START_FMT) >= 0) {\n        // Recursive substitution\n        final int change = substitute(buf, startPos, value.length(), null);\n        if (change == 0) {\n            // Variable references another undefined variable\n            return null;\n        }\n        value = buf.toString();\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final Object value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName.startsWith(PREFIX)) {\n        final String resolved = getVariableResolver().resolve(variableName.substring(PREFIX.length()));\n        if (resolved == null) {\n            return null;\n        }\n        return resolved;\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final Object value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof Format) {\n        final Format fmt = (Format) value;\n        final String resolved = fmt.format(getLocale());\n        if (resolved == null) {\n            return null;\n        }\n        buf.replace(startPos, endPos, resolved);\n        return resolved;\n    } else if (value instanceof String) {\n        final String str = (String) value;\n        if (str.equals(variableName)) {\n            return value.toString();\n        }\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    Object value = variableResolver.resolve(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (enableSubstitutionInVariables) {\n        int pos = startPos;\n        int len = endPos - startPos;\n        for (int i = 0; i < len; i++) {\n            buf.append(variableName.charAt(i));\n        }\n        int result = substitute(buf, startPos, len, new ArrayList<>());\n        pos += result;\n        len = endPos - pos;\n        for (int i = 0; i < len; i++) {\n            buf.append(variableName.charAt(pos + i));\n        }\n        return value.toString();\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver != null) {\n        final String value = resolver.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n\n    if (enableSubstitutionInVariables) {\n        // we need to substitute any variables in the variable name\n        final int nestedVarCount = 0;\n        return resolveVariable(variableName, buf, startPos, endPos, nestedVarCount);\n    }\n\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final Object value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        String value = variableResolver.resolve(variableName);\n        if (value != null) {\n            int varLen = value.length();\n            buf.replace(startPos, endPos, value);\n            if (enableSubstitutionInVariables && value.indexOf(START_FMT) != -1) {\n                // recursive replace\n                int change = substitute(buf, startPos, varLen, priorVariables);\n                change = change + varLen - (endPos - startPos);\n                return value;\n            }\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String value = getVariableResolver().resolve(variableName);\n    if (value != null) {\n        return value;\n    }\n    if (enableSubstitutionInVariables) {\n        // Recursively substitute in variable names\n        int pos = startPos;\n        int bufEnd = endPos;\n        final int len = variableName.length();\n        final ArrayList<String> priorVariables = new ArrayList<>();\n        int nestedVarCount = 0;\n        while (pos < bufEnd) {\n            final int startMatchPos = buf.indexOf(variableName, pos);\n            if (startMatchPos < 0) {\n                break;\n            }\n            final int endMatchPos = startMatchPos + len;\n            final char c = buf.charAt(endMatchPos);\n            if (c == START_DELIM) {\n                nestedVarCount++;\n            } else if (c == END_DELIM) {\n                if (nestedVarCount <= 0) {\n                    break;\n                }\n                nestedVarCount--;\n            }\n            pos = endMatchPos + 1;\n        }\n        if (nestedVarCount == 0) {\n            final String varValue = getVariableResolver().resolve(variableName);\n            if (varValue != null) {\n                // recursive replace\n                final int varLen = varValue.length();\n                buf.replace(startPos, endPos, varValue);\n                return varValue;\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = str.toUpperCase();\n\n    // Create a new StringBuffer to store the soundex code.\n    final StringBuffer soundex = new StringBuffer();\n\n    // Add the first character of the string to the soundex code.\n    soundex.append(str.charAt(0));\n\n    // Iterate over the remaining characters in the string.\n    for (int i = 1; i < str.length(); i++) {\n        // Get the mapping code for the current character.\n        char code = getMappingCode(str.charAt(i));\n\n        // If the mapping code is not 0, add it to the soundex code.\n        if (code != 0) {\n            // If the previous character in the soundex code is the same as the current mapping code, skip it.\n            if (soundex.length() > 0 && soundex.charAt(soundex.length() - 1) == code) {\n                continue;\n            }\n            soundex.append(code);\n        }\n    }\n\n    // Return the soundex code.\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Clean the string\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // Get the first character\n    final StringBuilder soundex = new StringBuilder(1);\n    soundex.append(str.charAt(0));\n\n    // Get the mapping code for the first character\n    char lastMappingCode = getMappingCode(str.charAt(0));\n\n    // Iterate through the remaining characters\n    int count = 1;\n    for (int i = 1; i < str.length(); ++i) {\n        char ch = str.charAt(i);\n        char mappingCode = getMappingCode(ch);\n\n        if (mappingCode == lastMappingCode && count <= 2) {\n            ++count;\n        } else {\n            soundex.append(mappingCode);\n            lastMappingCode = mappingCode;\n            count = 1;\n        }\n    }\n\n    // Pad with zeros if necessary\n    while (soundex.length() < 4) {\n        soundex.append('0');\n    }\n\n    // Return the soundex code\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = str.toUpperCase();\n    final StringBuilder soundex = new StringBuilder(4);\n\n    soundex.append(str.charAt(0));\n    char previousCode = getMappingCode(str.charAt(0));\n\n    for (int i = 1; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        final char code = getMappingCode(c);\n\n        if (code == previousCode) {\n            continue;\n        }\n\n        if (code == '0') {\n            continue;\n        }\n\n        soundex.append(code);\n        previousCode = code;\n    }\n\n    soundex.setLength(Math.min(soundex.length(), 4));\n\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Clean the string\n    str = SoundexUtils.clean(str);\n\n    // Check if the string is empty\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // Get the first character and ensure it is mapped\n    final char c = str.charAt(0);\n    final char code = getMappingCode(c);\n    if (code == 0) {\n        throw new IllegalArgumentException(\"The first character of the string is not mapped: \" + c);\n    }\n\n    // Start building the soundex code\n    final StringBuilder soundexCode = new StringBuilder(4);\n    soundexCode.append(code);\n\n    // Iterate through the remaining characters\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char currentChar = chars[i];\n        final char mappingCode = getMappingCode(currentChar);\n\n        // Handle vowels and consonants\n        if (isVowel(currentChar) || mappingCode == 0) {\n            continue;\n        }\n\n        // Check for repeated letters\n        if (mappingCode == soundexCode.charAt(soundexCode.length() - 1)) {\n            continue;\n        }\n\n        // Append the mapping code\n        soundexCode.append(mappingCode);\n    }\n\n    // Pad the code with zeros if necessary\n    while (soundexCode.length() < 4) {\n        soundexCode.append('0');\n    }\n\n    // Return the soundex code\n    return soundexCode.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = str.toUpperCase();\n\n    // Create a new character array to hold the soundex code.\n    final char[] soundexCode = new char[4];\n\n    // Initialize the soundex code to the first character of the string.\n    soundexCode[0] = str.charAt(0);\n\n    // Get the mapping code for each character in the string, starting at the second character.\n    for (int i = 1, j = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        final char mappingCode = getMappingCode(c);\n\n        // If the mapping code is not 0, add it to the soundex code.\n        if (mappingCode != 0) {\n            // Check if the last character in the soundex code is the same as the current character.\n            if (soundexCode[j] != mappingCode) {\n                // If the last character is different, add the current character to the soundex code.\n                soundexCode[++j] = mappingCode;\n            }\n        }\n    }\n\n    // Return the soundex code as a string.\n    return new String(soundexCode, 0, j + 1);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = str.toUpperCase();\n\n    // Create a new StringBuilder to store the encoded string.\n    StringBuilder encoded = new StringBuilder(str.length());\n\n    // Iterate over each character in the string.\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n\n        // Get the mapping code for the character.\n        char code = getMappingCode(c);\n\n        // If the code is not 0, add it to the encoded string.\n        if (code != 0) {\n            encoded.append(code);\n        }\n    }\n\n    // Return the encoded string.\n    return encoded.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n\n    for (int i = 1; i < len; i++) {\n        key.append(map(chars[i]));\n    }\n\n    // Truncate key to 4 characters\n    if (key.length() > 4) {\n        key.delete(4, key.length());\n    }\n\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    final StringBuilder key = new StringBuilder(str.length());\n\n    key.append(str.charAt(0));\n\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        final char prev = chars[i - 1];\n\n        final char mappingCode = getMappingCode(c);\n\n        if (mappingCode == 0) {\n            continue;\n        }\n\n        if ((mappingCode == '0') || (mappingCode == prev)) {\n            continue;\n        }\n\n        key.append(mappingCode);\n    }\n\n    if (key.length() > 4) {\n        key.delete(4, key.length());\n    }\n\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Clean the string using the SoundexUtils.clean method\n    str = SoundexUtils.clean(str);\n\n    // Create a new StringBuilder to store the soundex code\n    StringBuilder soundex = new StringBuilder();\n\n    // Add the first character of the string to the soundex code\n    soundex.append(str.charAt(0));\n\n    // Loop through the remaining characters of the string\n    for (int i = 1; i < str.length(); i++) {\n        // Get the mapping code for the current character\n        char mappingCode = getMappingCode(str.charAt(i));\n\n        // If the mapping code is not 0, add it to the soundex code\n        if (mappingCode != 0) {\n            // If the current mapping code is the same as the previous one, skip it\n            if (soundex.charAt(soundex.length() - 1) == mappingCode) {\n                continue;\n            }\n\n            // Add the current mapping code to the soundex code\n            soundex.append(mappingCode);\n        }\n    }\n\n    // Return the soundex code\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Clean the input string\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // Convert the first character to uppercase\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(Character.toUpperCase(str.charAt(0)));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n\n    for (int i = 1; i < len; i++) {\n        final char c = Character.toUpperCase(chars[i]);\n        final char prev = key.charAt(key.length() - 1);\n        final char mappingCode = getMappingCode(c);\n\n        if (mappingCode == '0' || mappingCode == prev) {\n            continue;\n        } else {\n            key.append(mappingCode);\n        }\n    }\n\n    // Return the truncated soundex code\n    return key.substring(0, Math.min(key.length(), 4));\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Boolean.TYPE) {                \n            return JsonSerializer.PRIMITIVE_BOOLEAN;\n        } else if (clz == Byte.TYPE) {\n            return JsonSerializer.PRIMITIVE_BYTE;\n        }\n        else if (clz == Short.TYPE) {\n            return JsonSerializer.PRIMITIVE_SHORT;\n        }\n        else if (clz == Character.TYPE) {\n            return JsonSerializer.PRIMITIVE_CHAR;\n        }\n        else if (clz == Integer.TYPE) {\n            return JsonSerializer.PRIMITIVE_INT;\n        }\n        else if (clz == Long.TYPE) {\n            return JsonSerializer.PRIMITIVE_LONG;\n        }\n        else if (clz == Float.TYPE) {\n            return JsonSerializer.PRIMITIVE_FLOAT;\n        }\n        else if (clz == Double.TYPE) {\n            return JsonSerializer.PRIMITIVE_DOUBLE;\n        }\n        else if (clz == Void.TYPE) {\n            return JsonSerializer.PRIMITIVE_VOID;\n        } else {\n            throw new IllegalStateException(\"Unrecognized primitive type: \"+clz.getName());\n        }\n    } else {\n        // If it's not a primitive type, we need to check if it's a well-known type\n        if (_commonNonGenericTypes.containsKey(clz)) {\n            return _commonNonGenericTypes.get(clz);\n        } else {\n            return null;\n        }\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Boolean.TYPE) {                \n            return Boolean.TYPE;\n        } else if (clz == Byte.TYPE) {\n            return Byte.TYPE;\n        }\n        else if (clz == Short.TYPE) {\n            return Short.TYPE;\n        }\n        else if (clz == Character.TYPE) {\n            return Character.TYPE;\n        }\n        else if (clz == Integer.TYPE) {\n            return Integer.TYPE;\n        }\n        else if (clz == Long.TYPE) {\n            return Long.TYPE;\n        }\n        else if (clz == Float.TYPE) {\n            return Float.TYPE;\n        }\n        else if (clz == Double.TYPE) {\n            return Double.TYPE;\n        }\n        else if (clz == Void.TYPE) {\n            return Void.TYPE;\n        } else {\n            throw new IllegalStateException(\"Unrecognized primitive type: \"+clz.getName());\n        }\n    } else {\n        if (clz == String.class || clz == Object.class || clz == CharSequence.class) {\n            return String.class;\n        } else if (clz == UUID.class) {\n            return UUID.class;\n        } else if (clz == Date.class) {\n            return Date.class;\n        } else if (clz == Calendar.class) {\n            return Calendar.class;\n        } else if (clz == Boolean.class) {\n            return Boolean.class;\n        } else if (clz == Byte.class) {\n            return Byte.class;\n        } else if (clz == Character.class) {\n            return Character.class;\n        } else if (clz == Short.class) {\n            return Short.class;\n        } else if (clz == Float.class) {\n            return Float.class;\n        } else if (clz == Double.class) {\n            return Double.class;\n        } else if (clz == URI.class) {\n            return URI.class;\n        } else if (clz == URL.class) {\n            return URL.class;\n}\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return INT_TYPE;\n        }\n        if (clz == Boolean.TYPE) {\n            return BOOL_TYPE;\n        }\n        if (clz == Long.TYPE) {\n            return LONG_TYPE;\n        }\n        if (clz == Double.TYPE) {\n            return DOUBLE_TYPE;\n        }\n        if (clz == Character.TYPE) {\n            return CHAR_TYPE;\n        }\n        if (clz == Byte.TYPE) {\n            return BYTE_TYPE;\n        }\n        if (clz == Short.TYPE) {\n            return SHORT_TYPE;\n        }\n        if (clz == Float.TYPE) {\n            return FLOAT_TYPE;\n        }\n        if (clz == Void.TYPE) {\n            return VOID_TYPE;\n        }\n    } else if (clz == String.class) {\n        return STRING_TYPE;\n    } else if (clz == Object.class) {\n        return OBJECT_TYPE;\n    } else if (clz == CharSequence.class) {\n        return CHARSEQUENCE_TYPE;\n    } else if (clz == UUID.class) {\n        return UUID_TYPE;\n    } else if (clz == Date.class) {\n        return DATE_TYPE;\n    } else if (clz == Calendar.class) {\n        return CALENDAR_TYPE;\n    } else if (clz == Boolean.class) {\n        return BOOLEAN_TYPE;\n    } else if (clz == Byte.class) {\n        return BYTE_TYPE;\n    } else if (clz == Character.class) {\n        return CHAR_TYPE;\n    } else if (clz == Short.class) {\n        return SHORT_TYPE;\n    } else if (clz == Float.class) {\n        return FLOAT_TYPE;\n    } else if (clz == Double.class) {\n        return DOUBLE_TYPE;\n    } else if (clz == URI.class) {\n        return URI_TYPE;\n    } else if (clz == URL.class) {\n        return URL_TYPE;\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Boolean.TYPE) {                \n            return Boolean.FALSE;\n        } else if (clz == Byte.TYPE) {\n            return Byte.valueOf((byte)0);\n        }\n        else if (clz == Short.TYPE) {\n            return Short.valueOf((short)0);\n        }\n        else if (clz == Character.TYPE) {\n            return Character.valueOf('\\u0000');\n        }\n        else if (clz == Integer.TYPE) {\n            return Integer.valueOf(0);\n        }\n        else if (clz == Long.TYPE) {\n            return Long.valueOf(0L);\n        }\n        else if (clz == Float.TYPE) {\n            return Float.valueOf(0f);\n        }\n        else if (clz == Double.TYPE) {\n            return Double.valueOf(0d);\n        }\n        else if (clz == Void.TYPE) {\n            return null; // no null for primitive void\n        } else {\n            throw new IllegalStateException(\"Unrecognized primitive type: \"+clz.getName());\n        }\n    } else {\n        if (clz == String.class) {\n            return \"\";\n        } else if (clz == Object.class) {\n            return null;\n        } else if (clz == CharSequence.class) {\n            return \"\";\n        } else if (clz == UUID.class) {\n            return new UUID(0, 0);\n        } else if (clz == Integer.class) {\n            return 0;\n        } else if (clz == Long.class) {\n            return 0L;\n        } else if (clz == Date.class) {\n            return new Date(0L);\n        } else if (clz == Calendar.class) {\n            Calendar cal = Calendar.getInstance();\n            cal.setTime(new Date(0L));\n            return cal;\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return SimpleType.INTEGER_TYPE;\n    } else if (clz == Boolean.class) {\n        return SimpleType.BOOLEAN_TYPE;\n    } else if (clz == Long.class) {\n        return SimpleType.LONG_TYPE;\n    } else if (clz == Double.class) {\n        return SimpleType.DOUBLE_TYPE;\n    } else if (clz == Character.class) {\n        return SimpleType.CHAR_TYPE;\n    } else if (clz == Byte.class) {\n        return SimpleType.BYTE_TYPE;\n    } else if (clz == Short.class) {\n        return SimpleType.SHORT_TYPE;\n    } else if (clz == Float.class) {\n        return SimpleType.FLOAT_TYPE;\n    } else if (clz == String.class) {\n        return SimpleType.STRING_TYPE;\n    } else if (clz == Object.class) {\n        return SimpleType.OBJECT_TYPE;\n    } else if (clz == Timestamp.class) {\n        return SimpleType.TIMESTAMP_TYPE;\n    } else if (clz == BigDecimal.class) {\n        return SimpleType.BIG_DECIMAL_TYPE;\n    } else if (clz == BigInteger.class) {\n        return SimpleType.BIG_INTEGER_TYPE;\n    } else if (clz == Date.class) {\n        return SimpleType.DATE_TYPE;\n    } else if (clz == Calendar.class) {\n        return SimpleType.CALENDAR_TYPE;\n    } else if (clz == UUID.class) {\n        return SimpleType.UUID_TYPE;\n    } else if (clz == URI.class) {\n        return SimpleType.URI_TYPE;\n    } else if (clz == URL.class) {\n        return SimpleType.URL_TYPE;\n    } else if (clz == Class.class) {\n        return SimpleType.CLASS_TYPE;\n    } else if (clz == Locale.class) {\n        return SimpleType.LOCALE_TYPE;\n    } else if (clz == Currency.class) {\n        return SimpleType.CURRENCY_TYPE;\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Boolean.TYPE) {                \n            return BooleanDeserializer.primitiveInstance._type;\n        } else if (clz == Byte.TYPE) {\n            return ByteDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Short.TYPE) {\n            return ShortDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Character.TYPE) {\n            return CharacterDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Integer.TYPE) {\n            return IntegerDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Long.TYPE) {\n            return LongDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Float.TYPE) {\n            return FloatDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Double.TYPE) {\n            return DoubleDeserializer.primitiveInstance._type;\n        }\n        else if (clz == Void.TYPE) {\n            return VoidDeserializer.primitiveInstance._type;\n        } else {\n            throw new IllegalStateException(\"Unrecognized primitive type: \"+clz.getName());\n        }\n    } else {\n        switch (clz.getName()) {\n            case \"java.lang.String\":\n                return StringDeserializer.instance._type;\n            case \"java.lang.Integer\":\n                return IntegerDeserializer.wrapperInstance._type;\n            case \"java.lang.Long\":\n                return LongDeserializer.wrapperInstance._type;\n            case \"java.lang.Boolean\":\n                return BooleanDeserializer.wrapperInstance._type;\n            case \"java.lang.Double\":\n                return DoubleDeserializer.wrapperInstance._type;\n            case \"java.lang.Character\":\n                return CharacterDeserializer.wrapperInstance._type;\n            case \"java.util.UUID\":\n                return StdKeyDeserializer.TYPE_UUID._type;\n            case \"java.util.Date\":\n                return StdKeyDeserializer.TYPE_DATE._type;\n            case \"java.util.Calendar\":\n                return StdKeyDeserializer.TYPE_CALENDAR._type;\n            case \"java.net.URI\":\n                return StdKeyDeserializer.TYPE_URI._type;\n}\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Boolean.TYPE) {                \n            return Boolean.FALSE.getClass().getGenericInterfaces()[0];\n        } else if (clz == Byte.TYPE) {\n            return Byte.valueOf((byte) 0).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Short.TYPE) {\n            return Short.valueOf((short) 0).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Character.TYPE) {\n            return Character.valueOf(' ').getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Integer.TYPE) {\n            return Integer.valueOf(0).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Long.TYPE) {\n            return Long.valueOf(0).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Float.TYPE) {\n            return Float.valueOf(0.0f).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Double.TYPE) {\n            return Double.valueOf(0.0).getClass().getGenericInterfaces()[0];\n        }\n        else if (clz == Void.TYPE) {\n            return Void.class;\n        } else {\n            throw new IllegalStateException(\"Unrecognized primitive type: \"+clz.getName());\n        }\n    } else {\n        String name = clz.getName();\n        if (\"java.util.UUID\".equals(name)) {\n            return UUID.randomUUID().getClass().getGenericInterfaces()[0];\n        } else if (\"java.util.Date\".equals(name)) {\n            return new Date().getClass().getGenericInterfaces()[0];\n        } else if (\"java.util.Calendar\".equals(name)) {\n            return Calendar.getInstance().getClass().getGenericInterfaces()[0];\n        } else if (\"java.net.URI\".equals(name)) {\n            return URI.create(\"http://example.com\").getClass().getGenericInterfaces()[0];\n        } else if (\"java.net.URL\".equals(name)) {\n}\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return SimpleType.INT;\n    } else if (clz == Long.class) {\n        return SimpleType.LONG;\n    } else if (clz == Double.class) {\n        return SimpleType.DOUBLE;\n    } else if (clz == Boolean.class) {\n        return SimpleType.BOOLEAN;\n    } else if (clz == String.class) {\n        return SimpleType.STRING;\n    } else if (clz == Character.class) {\n        return SimpleType.CHAR;\n    } else if (clz == BigDecimal.class) {\n        return SimpleType.BIG_DECIMAL;\n    } else if (clz == BigInteger.class) {\n        return SimpleType.BIG_INTEGER;\n    } else if (clz == Date.class) {\n        return SimpleType.DATE;\n    } else if (clz == Calendar.class) {\n        return SimpleType.CALENDAR;\n    } else if (clz == URI.class) {\n        return SimpleType.URI;\n    } else if (clz == URL.class) {\n        return SimpleType.URL;\n    } else if (clz == Class.class) {\n        return SimpleType.CLASS;\n    } else if (clz == Locale.class) {\n        return SimpleType.LOCALE;\n    } else if (clz == Currency.class) {\n        return SimpleType.CURRENCY;\n    } else if (clz == byte[].class) {\n        return SimpleType.BYTE_ARRAY;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return _String;\n    } else if (clz == Object.class) {\n        return _Object;\n    } else if (clz == CharSequence.class) {\n        return _CharSequence;\n    } else if (clz == UUID.class) {\n        return _UUID;\n    } else if (clz == Integer.class) {\n        return _Integer;\n    } else if (clz == Long.class) {\n        return _Long;\n    } else if (clz == Date.class) {\n        return _Date;\n    } else if (clz == Calendar.class) {\n        return _Calendar;\n    } else if (clz == Boolean.class) {\n        return _Boolean;\n    } else if (clz == Byte.class) {\n        return _Byte;\n    } else if (clz == Character.class) {\n        return _Char;\n    } else if (clz == Short.class) {\n        return _Short;\n    } else if (clz == Float.class) {\n        return _Float;\n    } else if (clz == Double.class) {\n        return _Double;\n    } else if (clz == URI.class) {\n        return _URI;\n    } else if (clz == URL.class) {\n        return _URL;\n    } else if (clz == Class.class) {\n        return _Class;\n    } else if (clz == Locale.class) {\n        return _Locale;\n    } else if (clz == Currency.class) {\n        return _Currency;\n    } else if (clz == byte[].class) {\n        return _ByteArray;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return IntegerDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Boolean.TYPE) {\n            return BooleanDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Long.TYPE) {\n            return LongDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Double.TYPE) {\n            return DoubleDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Character.TYPE) {\n            return CharacterDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Byte.TYPE) {\n            return ByteDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Short.TYPE) {\n            return ShortDeserializer.primitiveInstance._getJavaType();\n        }\n        if (clz == Float.TYPE) {\n            return FloatDeserializer.primitiveInstance._getJavaType();\n        }\n    } else if (clz == String.class) {\n        return StringKD.forType(clz).getJavaType();\n    } else if (clz == UUID.class) {\n        // no need for caching, since it's a final class\n        return new SimpleType(TypeBindings.of(UUID.class), JsonTypeInfo.As.PROPERTY, TYPE_UUID);\n    } else if (clz == Integer.class) {\n        // no need for caching, since it's a final class\n        return new SimpleType(TypeBindings.of(Integer.class), JsonTypeInfo.As.PROPERTY, TYPE_INT);\n    } else if (clz == Long.class) {\n        // no need for caching, since it's a final class\n        return new SimpleType(TypeBindings.of(Long.class), JsonTypeInfo.As.PROPERTY, TYPE_LONG);\n    } else if (clz == Date.class) {\n        return new SimpleType(TypeBindings.of(Date.class), JsonTypeInfo.As.PROPERTY, TYPE_DATE);\n    } else if (clz == Calendar.class) {\n}\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    // ... (existing implementation)\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isVariableDeclaration()) {\n    return PrototypeMemberDeclaration.extractDeclaration(n);\n  } else if (n.isAssign()) {\n    if (NodeUtil.isExprAssign(n)) {\n      return PrototypeMemberDeclaration.extractDeclaration(n.getFirstChild());\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isVariableDeclaration()) {\n        return new VariablePrototypeMemberDeclaration(n);\n    } else if (n.isMethodDeclaration()) {\n        return new MethodPrototypeMemberDeclaration(n);\n    } else if (n.isConstructorDeclaration()) {\n        return new ConstructorPrototypeMemberDeclaration(n);\n    } else if (n.isGetter()) {\n        return new GetterPrototypeMemberDeclaration(n);\n    } else if (n.isSetter()) {\n        return new SetterPrototypeMemberDeclaration(n);\n    }\n\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    PrototypeMemberDeclaration prototypeMemberDeclaration = null;\n\n    if (n.isVariableDeclaration()) {\n        for (Node declaration : n.getDeclarations()) {\n            if (declaration.isVariableDeclarator()) {\n                Node init = declaration.getInit();\n                if (init != null && init.isExpressionStatement()) {\n                    Node expr = init.getFirstChild();\n                    if (expr.isCallExpression()) {\n                        Node exprName = expr.getFirstChild();\n                        if (exprName.isName()) {\n                            String name = exprName.getString();\n                            if (name.equals(\"define\") || name.equals(\"defineProperty\")) {\n                                prototypeMemberDeclaration =\n                                    PrototypeMemberDeclaration.create(\n                                        declaration, expr.getLastChild());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else if (n.isExpressionStatement()) {\n        Node expr = n.getFirstChild();\n        if (expr.isCallExpression()) {\n            Node exprName = expr.getFirstChild();\n            if (exprName.isName()) {\n                String name = exprName.getString();\n                if (name.equals(\"define\") || name.equals(\"defineProperty\")) {\n                    prototypeMemberDeclaration =\n                        PrototypeMemberDeclaration.create(\n                            null, expr.getLastChild());\n                }\n            }\n        }\n    }\n\n    return prototypeMemberDeclaration;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    PrototypeMemberDeclaration prototypeMemberDeclaration = null;\n\n    if (n.isVariableDeclaration()) {\n        for (Node declaration : n.getDeclarations()) {\n            if (declaration.isVariableDeclarator()) {\n                Node init = declaration.getInit();\n                if (init != null && init.isAssign()) {\n                    Node left = init.getFirstChild();\n                    if (left.isMemberExpression()) {\n                        Node object = left.getFirstChild();\n                        Node property = left.getLastChild();\n                        if (object.isName() && property.isName()\n                            && !object.equals(property)) {\n                            prototypeMemberDeclaration =\n                                new PrototypeMemberDeclaration(object.getString(),\n                                                            property.getString(),\n                                                            init);\n                        }\n                    }\n                }\n            }\n        }\n    } else if (n.isMethodDeclaration()) {\n        Node name = n.getSecondChild();\n        if (name.isName()) {\n            prototypeMemberDeclaration =\n                new PrototypeMemberDeclaration(name.getString(), null, n);\n        }\n    }\n\n    return prototypeMemberDeclaration;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isVar()) {\n      for (Node child = n.getFirstChild(); child != null;\n           child = child.getNext()) {\n        if (child.isVar()) {\n          return new PrototypeMemberDeclaration(child);\n        }\n      }\n    }\n\n    if (NodeUtil.isExprAssign(n)) {\n      Node lhs = n.getFirstChild();\n      if (lhs.isName()) {\n        return new PrototypeMemberDeclaration(lhs);\n      }\n    }\n\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isVar()) {\n        for (Node child = n.getFirstChild(); child != null; \n            child = child.getNext()) {\n            if (!child.isVar()) {\n                return new PrototypeMemberDeclaration(n);\n            }\n        }\n    } \n    else if (n.isExprAssign()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), \n            n.getLastChild().getLastChild());\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    PrototypeMemberDeclaration prototypeMemberDeclaration = null;\n\n    if (n.isVariableDeclaration()) {\n        for (Node declaration : n.getDeclarations()) {\n            if (declaration.isVariableDeclarator()) {\n                Node initializer = declaration.getInitializer();\n                if (initializer != null) {\n                    PrototypeMemberDeclaration.Kind kind = null;\n                    if (initializer.isAssign()) {\n                        kind = PrototypeMemberDeclaration.Kind.ASSIGNMENT;\n                    } else if (initializer.isFor()) {\n                        kind = PrototypeMemberDeclaration.Kind.FOR_INIT;\n                    } else if (initializer.isThrow()) {\n                        kind = PrototypeMemberDeclaration.Kind.THROW;\n                    } else if (initializer.isDebuggerStatement()) {\n                        kind = PrototypeMemberDeclaration.Kind.DEBUGGER;\n                    } else if (initializer.isLabeledStatement()) {\n                        kind = PrototypeMemberDeclaration.Kind.LABELED;\n                    } else if (initializer.isWith()) {\n                        kind = PrototypeMemberDeclaration.Kind.WITH;\n                    } else if (initializer.isSwitch()) {\n                        kind = PrototypeMemberDeclaration.Kind.SWITCH;\n                    } else if (initializer.isCatch()) {\n                        kind = PrototypeMemberDeclaration.Kind.CATCH;\n                    } else if (initializer.isTry()) {\n                        kind = PrototypeMemberDeclaration.Kind.TRY;\n                    } else if (initializer.isDebuggerStatement()) {\n                        kind = PrototypeMemberDeclaration.Kind.DEBUGGER;\n                    } else if (initializer.isExpressionStatement()) {\n                        kind = PrototypeMemberDeclaration.Kind.EXPRESSION;\n                    } else if (initializer.isYield()) {\n                        kind = PrototypeMemberDeclaration.Kind.YIELD;\n                    } else if (initializer.isAwait()) {\n                        kind = PrototypeMemberDeclaration.Kind.AWAIT;\n                    } else if (initializer.isDebuggerStatement()) {\n                        kind = PrototypeMemberDeclaration.Kind.DEBUGGER;\n                    } else if (initializer.isReturn()) {\n                        kind = PrototypeMemberDeclaration.Kind.RETURN;\n                    } else if (initializer.isBreak()) {\n                        kind = PrototypeMemberDeclaration.Kind.BREAK;\n                    } else if (initializer.isContinue()) {\n                        kind = PrototypeMemberDeclaration.Kind.CONTINUE;\n}\n}\n}\n}\n}\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isVar()) {\n    return new PrototypeMemberDeclaration(n);\n  } else if (NodeUtil.isExprAssign(n)) {\n    if (n.getFirstChild().isName()) {\n      return new PrototypeMemberDeclaration(n);\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isVariableDeclaration()) {\n    return extractVarDeclaration(n);\n  } else if (n.isExpressionStatement()) {\n    return extractExprStatement(n);\n  }\n\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension()*n, mat.getColumnDimension()*m);\n    for (int r = 0; r < mat.getRowDimension(); r++) \n    {\n        for (int c = 0; c < mat.getColumnDimension(); c++) \n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    result.setEntry((r + i*mat.getRowDimension()), (c + j*mat.getColumnDimension()), mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension()*n][mat.getColumnDimension()*m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r+i*mat.getRowDimension()][c+j*mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    RealMatrix out = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < n; ++i) \n    {\n        for (int j = 0; j < m; ++j) \n        {\n            for (int r = 0; r < mat.getRowDimension(); ++r) \n            {\n                for (int c = 0; c < mat.getColumnDimension(); ++c) \n                {\n                    out.setEntry((i * mat.getRowDimension()) + r, (j * mat.getColumnDimension()) + c, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension()*n, mat.getColumnDimension()*m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < mat.getRowDimension(); r++) {\n                for (int c = 0; c < mat.getColumnDimension(); c++) {\n                    result.setEntry(r+(mat.getRowDimension()*i), c+(mat.getColumnDimension()*j), mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(rows*n, cols*m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < rows; r++) {\n                for (int c = 0; c < cols; c++) {\n                    result.setEntry(r+i*rows, c+j*cols, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n < 0 || m < 0) {\n        throw new IllegalArgumentException(\"Replication factor must be nonnegative\");\n    }\n    final int r = mat.getRowDimension();\n    final int c = mat.getColumnDimension();\n    final RealMatrix repmat = MatrixUtils.createRealMatrix(n * r, m * c);\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            for (int p = 0; p < n; p++) {\n                for (int q = 0; q < m; q++) {\n                    repmat.setEntry((p * r) + i, (q * c) + j, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return repmat;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int r = mat.getRowDimension() * n;\n    int c = mat.getColumnDimension() * m;\n    RealMatrix out = MatrixUtils.createRealMatrix(r, c);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            for (int rr = 0; rr < mat.getRowDimension(); ++rr) {\n                for (int cc = 0; cc < mat.getColumnDimension(); ++cc) {\n                    out.setEntry(rr + i * mat.getRowDimension(), cc + j * mat.getColumnDimension(), mat.getEntry(rr, cc));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) {\n        throw new IllegalArgumentException(\"Row and column replicates must be positive\");\n    }\n    final int r = mat.getRowDimension() * n;\n    final int c = mat.getColumnDimension() * m;\n    final double[][] result = new double[r][c];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < mat.getRowDimension(); k++) {\n                for (int l = 0; l < mat.getColumnDimension(); l++) {\n                    result[(k + i * mat.getRowDimension())][(l + j * mat.getColumnDimension())] = mat.getEntry(k, l);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int r = mat.getRowDimension() * n;\n    int c = mat.getColumnDimension() * m;\n    RealMatrix out = MatrixUtils.createRealMatrix(r, c);\n    int r2 = 0;\n    int c2 = 0;\n    for(int i = 0; i<n; i++) {\n        for(int j = 0; j<m; j++) {\n            for(int x = 0; x < mat.getRowDimension(); x++) {\n                for(int y = 0; y < mat.getColumnDimension(); y++) {\n                    out.setEntry(r2, c2, mat.getEntry(x, y));\n                    c2++;\n                }\n                r2++;\n            }\n            c2 = 0;\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix out = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setMatrix(mat, i * mat.getRowDimension(), j * mat.getColumnDimension(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return out;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0)\n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0)\n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else\n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0)\n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else\n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long inB = current.bytesReadFromStream;\n    if (inB > Integer.MAX_VALUE) {\n        inB -= Integer.MAX_VALUE;\n    }\n    return current.bytesRead - inB;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesInflated != -1) return current.bytesInflated;\n\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = Math.min(bytesRead, current.bytesRead);\n\n    current.bytesInflated = bytesInflated;\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesRead > 0xffffffffL)\n    {\n        return current.bytesRead - current.bytesReadFromStream;\n    }\n    else\n    {\n        return current.bytesRead;\n    }\n}",
      "private long getBytesInflated()  {\n    if (current.bytesRead > current.bytesReadFromStream) {\n        return current.bytesReadFromStream;\n    } else {\n        return Math.min(current.bytesRead, Integer.MAX_VALUE) -\n                Math.max(0L, current.bytesRead - current.bytesReadFromStream);\n    }\n}",
      "private long getBytesInflated()  {\n    if (current.bytesReadFromStream >= current.entry.getCompressedSize()\n        && current.hasDataDescriptor) {\n        final int expected = current.bytesReadFromStream\n            - current.entry.getCompressedSize()\n            + current.entry.getUncompressedSize();\n        final int len = Math.min(expected, current.bytesRead);\n        return len - inf.getBytesRead();\n    }\n    return current.bytesReadFromStream - inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long diff = bytesRead - inB;\n    final long bytesInflated = diff > Integer.MAX_VALUE ? bytesRead : inB + diff;\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inB;\n\n    if (bytesInflated < current.bytesRead) {\n        bytesInflated = current.bytesRead;\n    } else {\n        bytesInflated -= current.bytesReadFromStream;\n    }\n\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long ret = totalRead;\n\n    if (ret > inB) {\n        ret = inB;\n    }\n\n    if (totalRead - diff >= ret) {\n        ret = totalRead - diff;\n    }\n\n    return ret;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesReadFromStream <= current.entry.getCompressedSize() && current.hasDataDescriptor) {\n        if (current.bytesRead >= current.bytesReadFromStream && current.bytesRead >= current.entry.getCompressedSize()) {\n            return current.bytesRead - current.entry.getCompressedSize();\n        } else {\n            return current.bytesReadFromStream - current.entry.getCompressedSize();\n        }\n    } else {\n        return current.bytesReadFromStream - current.bytesRead;\n    }\n}",
      "private long getBytesInflated()  {\n    final long bytesInflated = in.getBytesRead() - current.bytesReadFromStream;\n    if (bytesInflated >= current.bytesReadFromStream) {\n        return bytesInflated;\n    }\n    return current.bytesReadFromStream - (0xffffffffl - bytesInflated);\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection) object).isEmpty();\n    } else if (object instanceof Map) {\n        return ((Map) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof Iterable<?>) \n    {\n        return !((Iterable<?>) object).iterator().hasNext();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection) object).isEmpty();\n    } else if (object instanceof Map) {\n        return ((Map) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return 0 == ((Object[]) object).length;\n    }\n    if (object instanceof Iterator) {\n        return !((Iterator) object).hasNext();\n    }\n    if (object instanceof Enumeration) {\n        return !((Enumeration) object).hasMoreElements();\n    }\n    try {\n        return 0 == Array.getLength(object);\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return !it.hasMoreElements();\n    }\n\n    try \n    {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  return !name.isEmpty() && Character.isJavaIdentifierStart(name.charAt(0)) && name.chars().allMatch(Character::isJavaIdentifierPart);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null) {\n    return false;\n  }\n\n  for (int i = 0; i < name.length(); ++i) {\n    char ch = name.charAt(i);\n    if (!isValidIdentifierChar(ch)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return !name.contains(\".\") && name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null || name.isEmpty()) {\n    return false;\n  }\n  return name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.length() == 0) {\n    return false;\n  }\n\n  int pos = 0;\n  int limit = name.length();\n\n  while (pos < limit) {\n    char ch = name.charAt(pos++);\n    if ((ch >= 'A' && ch <= 'Z') ||\n        (ch >= 'a' && ch <= 'z')) {\n      while (pos < limit) {\n        ch = name.charAt(pos++);\n        if ((ch >= '0' && ch <= '9') ||\n            (ch >= 'A' && ch <= 'Z') ||\n            (ch >= 'a' && ch <= 'z') ||\n            ch == '.') {\n          continue;\n        }\n        --pos;\n        break;\n      }\n    } else if (ch == '.') {\n      if (pos == limit) {\n        return false;\n      } else {\n        ch = name.charAt(pos++);\n        if ((ch >= '0' && ch <= '9') ||\n            (ch >= 'A' && ch <= 'Z') ||\n            (ch >= 'a' && ch <= 'z')) {\n          continue;\n        }\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return !name.equals(\"es3\") && !name.equals(\"es5\");\n}\n\n// so that the results are different for es5 and es3.",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null) {\n    return false;\n  }\n  return name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n  if (name.indexOf('.') != -1) {\n    // Qualified names cannot contain '.'.\n    return false;\n  }\n  for (int i = 0; i < name.length(); i++) {\n    char ch = name.charAt(i);\n    if (!Character.isJavaIdentifierPart(ch) && ch != '.') {\n      return false;\n    }\n  }\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return !name.contains(\".\") && name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int im = iu - 2;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) \n    {\n        boolean notlast = k != iu - 1;\n        if (k != im) \n        {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) \n            {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) \n        {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) \n        {\n            s = -s;\n        }\n        if (s != 0.0) \n        {\n            if (k != im) \n            {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) \n            {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) \n            {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) \n                {\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int im = iu - 2;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++)\n    {\n        boolean notlast = k != iu - 1;\n        if (k != im)\n        {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon))\n            {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0)\n        {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0)\n        {\n            s = -s;\n        }\n        if (s != 0.0)\n        {\n            if (k != im)\n            {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im)\n            {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++)\n            {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast)\n                {\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode)\n            textNodes.add((TextNode) child);\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return textNodes;\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludedSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludedSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludedSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Days.days(days).getPeriod();\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return zeroInstance.getPeriod();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = chrono.get(zeroInstance.getType(), start.getMillis(), end.getMillis());\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return zeroInstance.getPeriod() * days;\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return zeroInstance.getPeriod() * seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Days.days(days).getStandardSeconds();\n    }\n    if (zeroInstance instanceof Weeks) {\n        return Weeks.weeksBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Months) {\n        return Months.monthsBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Years) {\n        return Years.yearsBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Seconds) {\n        return secondsBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Minutes) {\n        return Minutes.minutesBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Hours) {\n        return Hours.hoursBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Days) {\n        return Days.daysBetween(start, end).getStandardSeconds();\n    } else if (zeroInstance instanceof Duration) {\n        return Duration.between(start, end).getStandardSeconds();\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int weeks = chrono.weeks().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Weeks.weeks(weeks).compareTo((Weeks)zeroInstance);\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Seconds.seconds(seconds).compareTo((Seconds)zeroInstance);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return zeroInstance.compareTo(ReadablePeriod.parsePeriod(amount+\"\"));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"zeroInstance must not be null\");\n    }\n    Chronology chrono = start.getChronology();\n    int amount = zeroInstance.getField(chrono).getDifference(\n            end.getMillis(), start.getMillis());\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int weeks = chrono.weeks().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Weeks.weeks(weeks).compareTo((Weeks) zeroInstance);\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Seconds.seconds(seconds).compareTo((Seconds) zeroInstance);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return zeroInstance.compareTo(zeroInstance.plus(amount));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int weeks = chrono.weeks().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return weeks;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Weeks.weeks(days / 7).get(zeroInstance);\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Seconds.seconds(seconds).get(zeroInstance);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || this.legends.size() <= index) {\n        return null;\n    }\n    return this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index >= 0 && index < this.legends.size()) \n    {\n        return this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) {\n        throw new IllegalArgumentException(\"Invalid 'index': \" + index);\n    }\n    return this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (this.legends != null) {\n        if (index >= 0 && index < this.legends.size()) {\n            legend = this.legends.get(index);\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    // TODO: Implement the getLegend method with the following logic:\n    //\n    // 1. Check if the legend is enabled.\n    // 2. Iterate through the legend list and return the legend at the specified index.\n    // 3. If the index is out of bounds, throw an exception.\n\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index >= this.legends.size()) {\n        return null;\n    }\n    return this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) {\n        throw new IllegalArgumentException(\"Invalid 'index': \" + index);\n    }\n    return this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    // TODO: Implement the getLegend method from the context to return the legend title.\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // get the legend item for the main dataset\n    if (index >= 0 && index < 1) \n    {\n        if (this.legendItems != null) \n        {\n            if (index == 0) \n            {\n                return this.legendItems.get(0);\n            }\n        }\n        return null;\n    } \n    else \n    {\n        // get the legend items for the renderer(s)\n        if (index >= 1 && index < getLegendItems().getLegendItems().size()) \n        {\n            return this.legendItems.get(index);\n        }\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    // get the legend from the plot's m_Renderer\n    if (this.renderer != null) {\n        LegendTitle legend = this.renderer.getLegend(index);\n        if (legend != null) {\n            return legend;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (!nameMap.isEmpty()) {\n        entriesOfThatName = nameMap.values().toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName).iterator();\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entries = new ArrayList<>(getEntries());\n    entries.sort((e1, e2) -> offsetComparator.compare(e1, e2));\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.isEmpty()) {\n        return Collections.enumeration(Arrays.asList(entriesOfThatName));\n    }\n\n    for (Map.Entry<String, List<ZipArchiveEntry>> entry : nameMap.entrySet()) {\n        entriesOfThatName = nameMap.get(entry.getKey()).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Collections.enumeration(Arrays.asList(entriesOfThatName));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entries = new ArrayList<>(getEntries());\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(Arrays.asList(getEntriesInPhysicalOrder()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (!nameMap.isEmpty()) {\n        entriesOfThatName = nameMap.values().toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName).elements();\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entries = new ArrayList<>(getEntries());\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return new Enumeration<ZipArchiveEntry>()\n    {\n        int idx = 0;\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return new Enumeration<ZipArchiveEntry>()\n    {\n        int pos = 0;\n        final List<ZipArchiveEntry> entries = getEntriesInPhysicalOrder();\n\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entries = new ArrayList<>(getEntries());\n    Collections.sort(entries, new Comparator<ZipArchiveEntry>() {\n\n}\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node optParamType = parseOptionalParameterType(next());\n    if (optParamType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return optParamType;\n  } else if (token == JsDocToken.RB) {\n    return newNode(Token.RB);\n  } else {\n    reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n  }\n\n  return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return typeNode;\n    } else {\n      return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node expr = parseOptionalParameterType(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n    return expr;\n  } else if (token == JsDocToken.LB) {\n    skipEOLs();\n    Node expr = parseTopLevelTypeExpression(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      } else {\n        next();\n      }\n    }\n    return expr;\n  } else if (token == JsDocToken.QMARK) {\n    skipEOLs();\n    Node expr = parseTopLevelTypeExpression(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      } else {\n        next();\n      }\n    }\n    return wrapNode(Token.QMARK, expr);\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node paramTypeNode = parseOptionalParameterType(next());\n    if (paramTypeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return paramTypeNode;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node expr = parseOptionalParameterType(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n    return expr;\n  } else if (token == JsDocToken.LB) {\n    skipEOLs();\n    Node expr = parseTopLevelTypeExpression(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      } else {\n        next();\n      }\n    }\n    return expr;\n  } else {\n    return parseParamTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node expr = parseOptionalParameterType(next());\n    if (expr != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return expr;\n  } else {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC)\n    {\n        skipEOLs();\n        if (match(JsDocToken.ELLIPSIS))\n        {\n            Node paramType = newNode(Token.ELLIPSIS);\n            next();\n            skipEOLs();\n            if (!match(JsDocToken.RB))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else\n            {\n                next();\n            }\n            return paramType;\n        }\n        else\n        {\n            Node paramType = parseTopLevelTypeExpression(next());\n            skipEOLs();\n            if (!match(JsDocToken.RC))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else\n            {\n                next();\n            }\n            return paramType;\n        }\n    }\n    else\n    {\n        Node paramType = parseOptionalParameterType(token);\n        skipEOLs();\n        if (!match(JsDocToken.RC))\n        {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        }\n        else\n        {\n            next();\n        }\n        return paramType;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        Node optionalParamType = parseOptionalParameterType(next());\n        if (optionalParamType != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n                next();\n            }\n        }\n\n        return optionalParamType;\n    } else if (token == JsDocToken.RP) {\n        return newNode(Token.ELLIPSIS);\n    } else {\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n            if (match(JsDocToken.EQUALS)) {\n                next();\n                typeNode = wrapNode(Token.EQUALS, typeNode);\n            }\n        }\n\n        return typeNode;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node optionalParameterType = parseOptionalParameterType(next());\n        if (optionalParameterType != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        \n        return optionalParameterType;\n    } \n    else if (token == JsDocToken.ELLIPSIS) \n    {\n        skipEOLs();\n        return wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC)\n    {\n        skipEOLs();\n        Node optionalParamType = parseOptionalParameterType(next());\n        if (optionalParamType != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else\n            {\n                next();\n            }\n        }\n\n        return optionalParamType;\n    }\n    else if (token == JsDocToken.LB)\n    {\n        skipEOLs();\n        Node topLevelTypeExpression = parseTopLevelTypeExpression(next());\n        if (topLevelTypeExpression != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RB))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            else\n            {\n                next();\n            }\n        }\n\n        return topLevelTypeExpression;\n    }\n    else if (token == JsDocToken.QMARK)\n    {\n        skipEOLs();\n        Node topLevelTypeExpression = parseTopLevelTypeExpression(next());\n        if (topLevelTypeExpression != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RB))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            else\n            {\n                next();\n            }\n        }\n\n        return wrapNode(Token.QMARK, topLevelTypeExpression);\n    }\n    else if (token == JsDocToken.BANG)\n    {\n        skipEOLs();\n        Node topLevelTypeExpression = parseTopLevelTypeExpression(next());\n        if (topLevelTypeExpression != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RB))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            else\n            {\n                next();\n            }\n        }\n\n        return wrapNode(Token.BANG, topLevelTypeExpression);\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<>();\n    String line;\n    try (final StringReader sr = new StringReader(t.getStackTraceString()))\n    {\n        final BufferedReader br = new BufferedReader(sr);\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\"Caused by:\")) {\n                break;\n            }\n            result.add(line);\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> stackTrace = new ArrayList<String>();\n    final String[] frames = t.getStackTrace();\n    for (int i = 0; i < frames.length; i++) {\n        stackTrace.add(frames[i]);\n    }\n    return stackTrace;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<String>();\n    String line;\n    try (Reader reader = new StringReader(t.getStackTraceString()))\n    {\n        while ((line = reader.readLine()) != null)\n        {\n            if (line.startsWith(\"at \"))\n            {\n                result.add(line.substring(3));\n            }\n        }\n    } catch (IOException e)\n    {\n        // ignore\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> result = new ArrayList<>();\n    String stackTrace = t.toString();\n    int startIdx = stackTrace.indexOf('\\n') + 1;\n    int endIdx = stackTrace.lastIndexOf('\\n');\n    while (startIdx <= endIdx) \n    {\n        String frame = stackTrace.substring(startIdx, endIdx);\n        result.add(frame);\n        startIdx = stackTrace.indexOf('\\n', startIdx) + 1;\n        endIdx = stackTrace.lastIndexOf('\\n', endIdx - 1);\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> result = new ArrayList<String>();\n    final String trace = t.toString();\n    final StringTokenizer tokenizer = new StringTokenizer(trace);\n    while (tokenizer.hasMoreTokens()) {\n        final String token = tokenizer.nextToken();\n        if (token.startsWith(\"at\")) {\n            if (token.contains(\".\")) {\n                result.add(token.substring(token.lastIndexOf(\".\") + 1));\n            } else {\n                result.add(token.substring(3));\n            }\n        }\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<String>();\n    for (StackTraceElement element : t.getStackTrace()) \n    {\n        if (!element.toString().startsWith(\"\\t\\t\\t at \")) {\n            result.add(element.toString());\n        }\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<String>();\n    StackTraceElement[] frames = t.getStackTrace();\n    for (StackTraceElement frame : frames) {\n        result.add(frame.toString());\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final String stackTrace = t.toString();\n    final String lines[] = stackTrace.split(\"\\\\n\");\n    for (final String line : lines) {\n        if (!line.startsWith(\"at \")) {\n            continue;\n        }\n        frames.add(line);\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<>();\n    for (StackTraceElement frame : t.getStackTrace()) {\n        result.add(frame.toString());\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> result = new ArrayList<String>();\n    final String[] trace = t.getStackTrace();\n    for (final String frame : trace) \n    {\n        if (!frame.trim().startsWith(\"at \")) \n        {\n            result.add(frame);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_FALSE)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    else if (p == PEEKED_TRUE)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_BOOLEAN)\n    {\n        boolean value = (peekedByte == (byte) 't' || peekedByte == (byte) 'T') ? true : false;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return value;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_FALSE)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    else if (p == PEEKED_TRUE)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } \n    else \n    {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else \n    {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else \n    {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n\n    final int strLen = str.length();\n    final int pads = size - strLen;\n\n    if (pads <= 0) \n    {\n        return str;\n    }\n\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n\n    return leftPad(str, strLen + pads / 2, padChar)\n           .concat(rightPad(str, size, padChar));\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Check if the call node is an arrow function.\n  if (call.getType() == Token.ARROW) {\n    return false;\n  }\n  // Check if the call node is a constructor.\n  if (call.isConstructor()) {\n    return false;\n  }\n  // Check if the call node is a method call.\n  if (!call.isMethodCall()) {\n    return false;\n  }\n  // Get the method node.\n  Node method = call.getFirstChild();\n  // Check if the method node is a name node.\n  if (!method.isName()) {\n    return false;\n  }\n  // Get the name of the method.\n  String methodName = method.getString();\n  // Check if the method's return type is void.\n  FunctionType functionType = compiler.getTypeRegistry().getFunctionType(methodName);\n  if (functionType == null || functionType.getReturnType() == null ||\n      functionType.getReturnType().isVoid()) {\n    return false;\n  }\n  // Check if the method's return type is a primitive type.\n  if (functionType.getReturnType().isPrimitiveType()) {\n    return false;\n  }\n  // Check if the method's return type is a function.\n  if (functionType.getReturnType().isFunctionType()) {\n    return false;\n  }\n  // Check if the method's return type is a string.\n  if (functionType.getReturnType().isStringType()) {\n    return false;\n  }\n  // Check if the method's return type is an object.\n  if (!functionType.getReturnType().isObject()) {\n    return false;\n  }\n  // Check if the call's arguments have side effects.\n  for (Node arg : call.getLastChild().children()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getChildren()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg) || NodeUtil.canBeSideEffected(arg))\n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getParameters().getChildren())\n    {\n        if (mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Iterate over the arguments.\n  for (Node arg : call.getChildren()) \n  {\n    // Check if the argument's expression has side effects.\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getLastChild().children()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Collect the arguments of the method call.\n  List<Node> arguments = getArgumentList(call);\n\n  // Check each argument for side effects.\n  for (Node argument : arguments) \n  {\n    if (mayHaveSideEffects(argument)) \n    {\n      return true;\n    }\n  }\n\n  // No arguments have side effects.\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Check if the arguments are literals, constants, or references\n  // to variables that are not going to be modified.\n  for (Node arg : call.getChildren())\n  {\n    if (!NodeUtil.isLiteralValue(arg, false) &&\n        !NodeUtil.isConstant(arg) &&\n        !mayHaveSideEffects(arg))\n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // TODO: Implement this method based on the provided context and code snippets.\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isConstructor() || !call.hasImplementedInterfaces()) {\n        return true;\n    }\n\n    for (Node arg : call.getParameters()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if there are arguments that are functions, objects, or arrays\n    // and therefore may have side effects.\n    for (Node arg : call.getLastChild().children()) \n    {\n        if (arg.isFunction() || arg.isObjectLit() || arg.isArrayLit()) \n        {\n            return true;\n        }\n    }\n\n    // Otherwise, assume that the arguments do not have side effects.\n    return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null)\n    {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n\n    // check for escape sequences\n    while (true) {\n        ch = reader.read();\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n            // finished token if we reached a delimiter, end of line or end of stream\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isDelimiter(ch) && !isEscape(ch)) {\n            // token finished mark (delimiter) reached: add it to token\n            token.content.append((char) ch);\n            token.type = TOKEN;\n            return token;\n        } else {\n            // normal char: add it to token\n            token.content.append((char) ch);\n            // read the next char and set eol\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        boolean eol = readEndOfLine(ch);\n\n        if (isDelimiter(ch)) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                return token; // simple token finished\n            }\n        } else if (eol) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else {\n            // error invalid char after simple token\n            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                    \") invalid char after token\");\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n\n    // token finished when token finish mark reached or end of file or end of line\n    while (true) {\n        ch = reader.read();\n        if (isDelimiter(ch)) {\n            if (!isEscape(ch)) {\n                token.type = TOKEN;\n                return token;\n            }\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            if (isEscape(reader.lookAhead())) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                token.type = TOKEN;\n                return token;\n            }\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n\n    while (true) {\n        ch = reader.read();\n\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        }\n\n        if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        }\n\n        if (isDelimiter(ch) && !isEscape(ch)) {\n            token.type = TOKEN;\n            return token;\n        }\n\n        token.content.append((char) ch);\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEndOfFile(ch)) {\n            // end of file reached before end of token\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isDelimiter(ch)) {\n            if (!isEscape(ch)) {\n                // unescaped delimiter reached\n                token.type = TOKEN;\n                return token;\n            } else {\n                // escaped delimiter: read the next character\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n\n    // token finished when we reach an unescaped delimiter, EOF, or EOL\n    while (true) {\n        if (isDelimiter(ch) && !isEscape(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            ch = reader.read();\n            token.content.append((char) ch);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        boolean eol = readEndOfLine(ch);\n\n        if (isDelimiter(ch) && !isEscape(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (eol) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    while (true) {\n        ch = reader.read();\n        if (isDelimiter(ch)) {\n            if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                // token finish mark (delimiter) reached: return token\n                return token;\n            }\n        } else if (isEndOfFile(ch)) {\n            // error condition (end of file before end of token)\n            throw new IOException(\"(startline \" + startLineNumber +\n                    \") EOF reached before simple token finished\");\n        } else if (readEndOfLine(ch)) {\n            // token finish mark (eol) reached: return token\n            return token;\n        } else if (!isWhitespace(ch)) {\n            // error invalid char between token and next delimiter\n            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                    \") invalid char between simple token and delimiter\");\n        }\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) \n        {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        for (int i = 0; i < last; i++) \n        {\n            counts[i] = (int) (index / uniCounterOffset[i]);\n            index -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] = index;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index >= getSize())\n    {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int remainder = index;\n    for (int i = dimension - 1; i >= 0; i--)\n    {\n        int count = 0;\n        for (int j = i - 1; j >= 0; j--)\n        {\n            count *= size[j];\n        }\n        int newRemainder = remainder / count;\n        counts[i] = newRemainder;\n        remainder -= newRemainder * count;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index >= getSize() || index < 0)\n        {\n            throw new OutOfRangeException(index, 0, getSize() - 1);\n        }\n        int[] result = new int[dimension];\n        for (int i = 0; i < dimension; i++)\n        {\n            result[i] = getCount(index / uniCounterOffset[i]);\n            index -= index / uniCounterOffset[i] * uniCounterOffset[i];\n        }\n        return result;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize())\n    {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++)\n    {\n        counts[i] = getCount(index / uniCounterOffset[i]);\n        index -= index / uniCounterOffset[i] * uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n        int[] result = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            int count = 0;\n            for (int j = 0; j < i; j++) {\n                count += uniCounterOffset[j] * result[j];\n            }\n            result[i] = (index - count) / uniCounterOffset[i];\n        }\n        return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize)\n        {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] result = new int[dimension];\n        for (int i = 0; i < dimension; i++)\n        {\n            long resultValue = 0;\n            for (int j = 0; j < dimension - i - 1; j++)\n            {\n                long shift = 1;\n                for (int k = 0; k < j; k++)\n                {\n                    shift *= size[k];\n                }\n                resultValue += (x[j] / shift) * size[j + i + 1];\n            }\n            result[i] = (int) resultValue;\n            long shift = 1;\n            for (int j = 0; j < i; j++)\n            {\n                shift *= size[j];\n            }\n            result[i] += (int) ((x[i] / shift) % size[i + 1]);\n        }\n        return result;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= getSize())\n        {\n            throw new OutOfRangeException(index, 0, getSize());\n        }\n        int[] result = new int[dimension];\n        int current = index;\n        for (int i = dimension - 1; i >= 0; i--)\n        {\n            int count = uniCounterOffset[i];\n            int value = current / count;\n            current -= value * count;\n            result[i] = value;\n        }\n        return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index >= getSize() || index < 0) \n    {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] result = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        result[i] = getCount(index);\n        index -= uniCounterOffset[i];\n        index /= size[i];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n\n    int[] counts = new int[dimension];\n    int uniIndex = index;\n\n    for (int i = dimension - 1; i >= 0; i--) {\n        int counterSize = size[i];\n        int shift = uniIndex / counterSize;\n        counts[i] = shift;\n        uniIndex -= shift * counterSize;\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index >= getSize() || index < 0) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int uniIndex = 0;\n    for (int i = 0; i < dimension; i++) {\n        int count = uniCounterOffset[i];\n        counts[i] = uniIndex / count;\n        uniIndex %= count;\n    }\n    counts[last] = index - uniIndex;\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (true) {\n        next = next._nextSegment;\n        if (next == null) {\n            return this;\n        }\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (true) {\n        JsonPointer nextNext = next._nextSegment;\n        if (nextNext == null) {\n            return next;\n        }\n        next = nextNext;\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Create a new byte array buffer to hold data from the input stream.\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n\n    // Read data from the input stream into the buffer.\n    while ((bytesRead = data.read(buffer)) != -1)\n    {\n        // Update the digest with the bytes read from the buffer.\n        digest.update(buffer, 0, bytesRead);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    return updateDigest(digest, data, STREAM_BUFFER_LENGTH);\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    return updateHmac(digest, data);\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Create a new byte array buffer with the STREAM_BUFFER_LENGTH size\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    // Read data from the stream into the buffer\n    int bytesRead = data.read(buffer);\n    // Continue reading until there is no more data\n    while (bytesRead != -1) {\n        // Update the digest with the current buffer\n        digest.update(buffer, 0, bytesRead);\n        // Read more data from the stream into the buffer\n        bytesRead = data.read(buffer);\n    }\n    // Return the updated digest\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    return updateHmac(digest, data);\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Use the updateHmac method from HmacUtils\n    return HmacUtils.updateHmac(digest, data);\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException ex) {\n                throw new CloneFailedException(ex);\n            }\n        }\n        if (obj instanceof Collection) {\n            final Collection<Object> collection = (Collection<Object>) obj;\n            final Collection<Object> clone = new ArrayList<>();\n            for (final Object o : collection) {\n                clone.add(clone(o));\n            }\n            return (T) clone;\n        }\n        if (obj instanceof Map) {\n            final Map<Object, Object> map = (Map<Object, Object>) obj;\n            final Map<Object, Object> clone = new HashMap<>();\n            for (final Map.Entry<Object, Object> entry : map.entrySet()) {\n                clone.put(clone(entry.getKey()), clone(entry.getValue()));\n            }\n            return (T) clone;\n        }\n        if (obj instanceof NumberUtils.BigDecimalHolder) {\n            return (T) new NumberUtils.BigDecimalHolder((NumberUtils.BigDecimalHolder) obj);\n        }\n        if (obj instanceof SerializationUtils.ClassLoaderAwareObjectInputStream) {\n            try {\n                final SerializationUtils.ClassLoaderAwareObjectInputStream in = (SerializationUtils.ClassLoaderAwareObjectInputStream) obj;\n                return (T) SerializationUtils.clone(in.getObjectStream(), in.getClassLoader());\n            } catch (final IOException e) {\n                throw new CloneFailedException(e);\n            }\n        }\n        if (obj instanceof ObjectUtils.ModeResult) {\n            final ObjectUtils.ModeResult result = (ObjectUtils.ModeResult) obj;\n            return (T) new ObjectUtils.ModeResult(result.getMode(), result.getCount());\n        }\n        if (obj instanceof FieldUtils.Field) {\n            final FieldUtils.Field field = (FieldUtils.Field) obj;\n            return (T) new FieldUtils.Field(field.getDeclaringClass(), field.getName(), field.isForceAccess());\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n\n    final Class<?> clz = obj.getClass();\n    if (clz.isPrimitive()) {\n        return obj;\n    }\n\n    if (obj instanceof Collection) {\n        final Collection<T> coll = (Collection<T>) obj;\n        final Collection<T> clone = (Collection<T>) clz.getConstructor().newInstance();\n        for (final T o : coll) {\n            clone.add(clone(o));\n        }\n        return (T) clone;\n    }\n\n    if (obj instanceof Map) {\n        final Map<Object, Object> map = (Map<Object, Object>) obj;\n        final Map<Object, Object> clone = (Map<Object, Object>) clz.getConstructor().newInstance();\n        for (final Map.Entry<Object, Object> e : map.entrySet()) {\n            clone.put(clone(e.getKey()), clone(e.getValue()));\n        }\n        return (T) clone;\n    }\n\n    if (obj instanceof Enum<?>) {\n        return obj;\n    }\n\n    if (obj instanceof Array) {\n        return obj;\n    }\n\n    if (obj instanceof Serializable) {\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(bais);\n            oos.writeObject(obj);\n            oos.flush();\n            oos.close();\n\n            ByteArrayInputStream bais = new ByteArrayInputStream(bais.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            T clone = (T) ois.readObject();\n            ois.close();\n\n            return clone;\n        } catch (ClassNotFoundException e) {\n            throw new CloneFailedException(\"Could not find class for serializable object\", e);\n        } catch (IOException e) {\n            throw new CloneFailedException(\"Could not serialize object\", e);\n        }\n    }\n\n    if (clz.isInterface()) {\n        return obj;\n    }\n\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (CloneNotSupportedException e) {\n}\n}\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException e) {\n                throw new CloneFailedException(e);\n            }\n        } else {\n            return SerializationUtils.clone(obj);\n        }\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"Failed to clone object\", ex);\n        }\n    }\n    return SerializationUtils.clone(obj);\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException ex) { // NOPMD\n                throw new CloneFailedException(\"Could not clone object of type \" + obj.getClass() + \": \" + ex.getMessage());\n            }\n        }\n        if (obj instanceof Map) {\n            final Map<Object, Object> result = new HashMap<Object, Object>();\n            for (final Map.Entry<Object, Object> entry : ((Map<Object, Object>) obj).entrySet()) {\n                final Object key = entry.getKey();\n                final Object value = entry.getValue();\n                if (value instanceof Map) {\n                    result.put(key, clone((Map<Object, Object>) value));\n                } else if (value instanceof List) {\n                    result.put(key, clone((List<Object>) value));\n                } else {\n                    result.put(key, value);\n                }\n            }\n            return (T) result;\n        } else if (obj instanceof List) {\n            final List<Object> result = new ArrayList<Object>();\n            for (final Object item : ((List<Object>) obj)) {\n                if (item instanceof Map) {\n                    result.add(clone((Map<Object, Object>) item));\n                } else if (item instanceof List) {\n                    result.add(clone((List<Object>) item));\n                } else {\n                    result.add(item);\n                }\n            }\n            return (T) result;\n        } else {\n            return NumberUtils.createBigDecimal(obj.toString()).floatValue() == 0.0F ? null : obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException ex) { // NOPMD\n                throw new CloneFailedException(\"Unable to clone object of class: \" + obj.getClass(), ex);\n            }\n        } else {\n            try {\n                // try to find a suitable serialization method\n                final Method serializeMethod = SerializationUtils.findSerializeMethod(obj);\n                final Method deserializeMethod = SerializationUtils.findDeserializeMethod(obj);\n                final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                serializeMethod.invoke(obj, baos);\n                final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n                return (T) deserializeMethod.invoke(null, bais);\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Unable to clone object of class: \" + obj.getClass(), ex);\n            }\n        }\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n\n    try {\n        if (obj instanceof Cloneable) {\n            return (T) ((Cloneable) obj).clone();\n        }\n    } catch (final CloneNotSupportedException e) {\n        throw new CloneFailedException(\"Failed to clone object\", e);\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (final CloneNotSupportedException ex) { // NOPMD\n                throw new CloneFailedException(\"Cloning not supported for \" + obj.getClass().getName(), ex);\n            }\n        }\n        return SerializationUtils.clone(obj);\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) ((Cloneable) obj).clone();\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Failed to clone object\", ex);\n        }\n    }\n    if (obj instanceof ClassLoaderAwareObjectInputStream.SerializableObject) {\n        try {\n            final ClassLoaderAwareObjectInputStream.SerializableObject so =\n                    (ClassLoaderAwareObjectInputStream.SerializableObject) obj;\n            return (T) SerializationUtils.deserialize(SerializationUtils.serialize(so));\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Failed to clone object\", ex);\n        }\n    }\n    if (obj instanceof Integer || obj instanceof Double || obj instanceof Float) {\n        return obj;\n    }\n    if (obj instanceof BigDecimal) {\n        return new BigDecimal((BigDecimal) obj);\n    }\n    if (obj instanceof String) {\n        return new String((String) obj);\n    }\n    if (obj instanceof ArrayList) {\n        final ArrayList<Object> list = new ArrayList<Object>();\n        for (final Object o : (ArrayList<Object>) obj) {\n            list.add(clone(o));\n        }\n        return (T) list;\n    }\n    if (obj instanceof HashMap) {\n        final HashMap<Object, Object> map = new HashMap<Object, Object>();\n        for (final Map.Entry<Object, Object> e : ((HashMap<Object, Object>) obj).entrySet()) {\n            map.put(clone(e.getKey()), clone(e.getValue()));\n        }\n        return (T) map;\n    }\n    if (obj instanceof HashSet) {\n        final HashSet<Object> set = new HashSet<Object>();\n        for (final Object o : (HashSet<Object>) obj) {\n            set.add(clone(o));\n        }\n        return (T) set;\n    }\n    if (obj instanceof Enum<?>) {\n        return obj;\n    }\n    if (obj instanceof Array) {\n}\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // Check if the symbol is a function.\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  // Get the function's parameters.\n  List<Parameter> params = sym.getFunctionType().getParameters();\n\n  // Iterate over the parameters and check if their names match.\n  for (Parameter param : params) {\n    if (param.getName().equals(paramName)) {\n      return param.getSymbol();\n    }\n  }\n\n  // If we didn't find a match, return null.\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Map<String, Symbol> params = type.getParameters();\n  if (params == null) {\n    return null;\n  }\n  return params.get(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n  return sym.getFunctionType().getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  // First, see if the paramName is a member of the object in the function.\n  Symbol objectSymbol = sym.getFunctionType().getReceiverType().getSymbol();\n  if (objectSymbol != null) {\n    Symbol objectProperty = objectSymbol.getProperty(paramName, null);\n    if (objectProperty != null) {\n      return objectProperty;\n    }\n  }\n\n  // Otherwise, assume it's a parameter to the function.\n  for (FunctionParameter param : sym.getFunctionType().getParameters()) {\n    if (param.getVariable().getName().equals(paramName)) {\n      return param.getVariable();\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    for (FunctionType.Parameter parameter : type.getParametersList()) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter.getSymbol();\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  // First check for a parameter with the same name.\n  for (Parameter param : sym.getFunctionType().getParametersList()) {\n    if (param.getName().equals(paramName)) {\n      return param.getSymbol();\n    }\n  }\n\n  // If we didn't find a parameter with the same name, we need to\n  // look for a parameter in the scope of the function's prototype.\n  Symbol prototypeSym = getSymbolForInstancesOf(sym);\n  if (prototypeSym == null) {\n    return null;\n  }\n\n  FunctionType prototypeType = prototypeSym.getFunctionType();\n  if (prototypeType == null) {\n    return null;\n  }\n\n  // Check for a parameter with the same name in the prototype's scope.\n  for (Parameter param : prototypeType.getParametersList()) {\n    if (param.getName().equals(paramName)) {\n      return param.getSymbol();\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  for (Parameter param : sym.getFunctionType().getParametersList()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.getFunctionType().isNominalConstructor()) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // Check if the symbol is a function\n  if (sym.getFunctionType() == null)\n  {\n    return null;\n  }\n\n  // Get the parameter list from the function type\n  List<FunctionType.Parameter> params = sym.getFunctionType().getParameters();\n\n  // Iterate through the parameters\n  for (FunctionType.Parameter param : params)\n  {\n    // Check if the parameter name matches\n    if (param.getName().equals(paramName))\n    {\n      return param.getSymbol();\n    }\n  }\n\n  // No matching parameter found\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameter(paramName);\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    RealMatrix columnMeans = columnMeans(matrix);\n    RealMatrix centeredMatrix = subtract(matrix, columnMeans);\n    RealMatrix covarianceMatrix = multiply(centeredMatrix.transpose(), centeredMatrix);\n\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarMultiply((n - 1d) / n);\n    }\n    \n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    n = matrix.getRowDimension();\n    covarianceMatrix = new BlockRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        for (int j = i; j < matrix.getColumnDimension(); j++) {\n            covarianceMatrix.setEntry(i, j, computeCovariance(matrix.getColumnVector(i), matrix.getColumnVector(j), biasCorrected));\n            covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(i, j));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    \n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n\n    // Calculate the sample mean for each column\n    double[] sampleMean = new double[nCols];\n    for (int i = 0; i < nCols; i++) {\n        sampleMean[i] = 0;\n        for (int j = 0; j < nRows; j++) {\n            sampleMean[i] += matrix.getEntry(j, i);\n        }\n        sampleMean[i] /= nRows;\n    }\n\n    // Calculate the covariance matrix\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double covariance = 0;\n            for (int k = 0; k < nRows; k++) {\n                covariance += (matrix.getEntry(k, i) - sampleMean[i])\n                        * (matrix.getEntry(k, j) - sampleMean[j]);\n            }\n            covariance /= (nRows - 1);\n\n            if (biasCorrected && i != j) {\n                covariance *= (nRows - 1) / nRows;\n            }\n\n            covarianceMatrix.setEntry(i, j, covariance);\n            covarianceMatrix.setEntry(j, i, covariance);\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Calculate the number of observations\n    int n = matrix.getRowDimension();\n\n    // Calculate the mean of each covariate vector\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++)\n    {\n        means[i] = matrix.getColumnVector(i).getEntry(0) / n;\n    }\n\n    // Calculate the covariance matrix\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < matrix.getColumnDimension(); i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            if (i == j) \n            {\n                covarianceMatrix.setEntry(i, j, computeCovariance(matrix.getColumnVector(i).getData(), means[i], n, biasCorrected));\n            } \n            else\n            {\n                covarianceMatrix.setEntry(i, j, computeCovariance(matrix.getColumnVector(i).getData(), matrix.getColumnVector(j).getData(), means[i], means[j], n, biasCorrected));\n                covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(i, j));\n            }\n        }\n    }\n    \n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    \n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n\n    // Calculate the column means\n    double[] columnMeans = new double[nCols];\n    for (int i = 0; i < nCols; i++) {\n        columnMeans[i] = 0;\n        for (int j = 0; j < nRows; j++) {\n            columnMeans[i] += matrix.getEntry(j, i);\n        }\n        columnMeans[i] /= nRows;\n    }\n\n    // Calculate the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double covariance = 0;\n            for (int k = 0; k < nRows; k++) {\n                covariance += (matrix.getEntry(k, i) - columnMeans[i])\n                        * (matrix.getEntry(k, j) - columnMeans[j]);\n            }\n            covariance /= (nRows - 1);\n            if (biasCorrected) {\n                covariance *= (nRows - 1.0) / nRows;\n            }\n            covarianceMatrix.setEntry(i, j, covariance);\n            covarianceMatrix.setEntry(j, i, covariance);\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Extract the data from the matrix as a 2D array\n    double[][] data = matrix.getData();\n    int nRows = data.length;\n    int nCols = data[0].length;\n\n    // Check if the data is rectangular and has at least two rows and one column\n    if (nRows < 2 || nCols < 1) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                nRows, nCols);\n    }\n\n    // Calculate the mean of each column\n    double[] means = new double[nCols];\n    for (int j = 0; j < nCols; j++) {\n        means[j] = 0;\n        for (int i = 0; i < nRows; i++) {\n            means[j] += data[i][j];\n        }\n        means[j] /= nRows;\n    }\n\n    // Calculate the covariance matrix\n    double[][] covarianceData = new double[nCols][nCols];\n    for (int j = 0; j < nCols; j++) {\n        for (int k = 0; k <= j; k++) {\n            covarianceData[j][k] = 0;\n            for (int i = 0; i < nRows; i++) {\n                covarianceData[j][k] += (data[i][j] - means[j]) * (data[i][k] - means[k]);\n            }\n            if (biasCorrected) {\n                covarianceData[j][k] /= (nRows - 1);\n            } else {\n                covarianceData[j][k] /= nRows;\n            }\n            covarianceData[k][j] = covarianceData[j][k];\n        }\n    }\n\n    // Create and return the covariance matrix object\n    return new Array2DRowRealMatrix(covarianceData);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Get the number of rows (observations) in the matrix\n    int n = matrix.getRowDimension();\n\n    // Get the number of columns (covariates) in the matrix\n    int k = matrix.getColumnDimension();\n\n    // Create a covariance matrix of size k x k\n    RealMatrix covarianceMatrix = new BlockRealMatrix(k, k);\n\n    // Iterate over each pair of columns (covariates)\n    for (int j = 0; j < k - 1; j++) {\n        for (int i = j + 1; i < k; i++) {\n            // Calculate the covariance between the two columns\n            double covariance = covariance(matrix.getColumnVector(j), matrix.getColumnVector(i), biasCorrected);\n\n            // Set the covariance value in the covariance matrix\n            covarianceMatrix.setEntry(j, i, covariance);\n            covarianceMatrix.setEntry(i, j, covariance);\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Get the number of rows and columns in the input matrix\n    int numRows = matrix.getRowDimension();\n    int numCols = matrix.getColumnDimension();\n\n    // Ensure that the matrix has at least one column and two rows\n    if (numCols < 1 || numRows < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, numRows, numCols);\n    }\n\n    // Calculate the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(numCols, numCols);\n    for (int i = 0; i < numCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double covariance = 0.0;\n\n            // Iterate over the rows of the matrix to calculate the covariance\n            for (int k = 0; k < numRows; k++) {\n                double x = matrix.getEntry(k, i);\n                double y = matrix.getEntry(k, j);\n                covariance += (x - matrix.getColumnVector(i).getEntry(0)) * (y - matrix.getColumnVector(j).getEntry(0));\n            }\n\n            // Adjust the covariance estimate if biasCorrected is true\n            if (biasCorrected && numRows > 2) {\n                covariance *= (numRows - 1.0) / numRows;\n            }\n\n            // Set the covariance in the covariance matrix\n            covarianceMatrix.setEntry(i, j, covariance);\n            covarianceMatrix.setEntry(j, i, covariance);\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n\n    for (int j = 0; j < nCols; j++) {\n        double colSum = 0;\n        for (int i = 0; i < nRows; i++) {\n            colSum += matrix.getEntry(i, j);\n        }\n        double colAvg = colSum / nRows;\n        for (int i = 0; i < nRows; i++) {\n            double temp = matrix.getEntry(i, j) - colAvg;\n            outMatrix.addToEntry(j, j, temp * temp);\n        }\n    }\n\n    if (biasCorrected) {\n        for (int i = 0; i < nCols; i++) {\n            outMatrix.setEntry(i, i, outMatrix.getEntry(i, i) / (nRows - 1));\n        }\n    }\n\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Get the number of observations (length of covariate vectors)\n    int n = matrix.getRowDimension();\n\n    // Get the number of variables (number of columns)\n    int p = matrix.getColumnDimension();\n\n    // Initialize the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(p, p);\n\n    // Compute the covariance matrix using the formula\n    for (int i = 0; i < p; i++) {\n        for (int j = i; j < p; j++) {\n            double covariance = 0;\n            for (int k = 0; k < n; k++) {\n                covariance += (matrix.getEntry(k, i) - matrix.getEntry(k, i).mean())\n                        * (matrix.getEntry(k, j) - matrix.getEntry(k, j).mean());\n            }\n            if (biasCorrected) {\n                covariance /= (n - 1);\n            } else {\n                covariance /= n;\n            }\n            covarianceMatrix.setEntry(i, j, covariance);\n            covarianceMatrix.setEntry(j, i, covariance);\n        }\n    }\n\n    return covarianceMatrix;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"Bit count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    } else {\n        final long bitsOut;\n        int overflowBits = 0;\n        long overflow = 0l;\n        if (bitsCachedSize >= count) {\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                bitsOut = (bitsCached & MASKS[count]);\n                bitsCached >>>= count;\n            } else {\n                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            }\n            bitsCachedSize -= count;\n        } else {\n            int bitsToAddCount = count - bitsCachedSize;\n            overflowBits = 8 - bitsToAddCount;\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                return -1;\n            }\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n                overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n            } else {\n                bitsCached <<= bitsToAddCount;\n                long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n                bitsCached |= bitsToAdd;\n                overflow = nextByte & MASKS[overflowBits];\n            }\n            bitsOut = bitsCached & MASKS[count];\n            bitsCached = overflow;\n            bitsCachedSize = overflowBits;\n        }\n        return bitsOut;\n    }\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be in range [1, 63]\");\n    }\n\n    if (count > bitsCachedSize) {\n        if (ensureCache(count)) {\n            return -1;\n        }\n    }\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        final long bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    } else {\n        final long bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) \n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE + \", but was \" + count);\n    if (ensureCache(count))\n        return -1;\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Requested bit length (\" + count + \") exceeds the maximum (\" + MAXIMUM_CACHE_SIZE + \")\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Negative bit length (\" + count + \")\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    } else {\n        return processBitsGreater57(count);\n    }\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Requested bits \" + count + \" exceeds maximum cache size \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count > bitsCachedSize) {\n        if (ensureCache(count)) {\n            return -1;\n        }\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Cannot read more than \" + MAXIMUM_CACHE_SIZE + \" bits at once\");\n    }\n\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Negative read count: \" + count);\n    }\n\n    if (ensureCache(count)) {\n        return -1;\n    }\n\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be positive and not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count > bitsCachedSize) {\n        if (ensureCache(count)) {\n            return -1;\n        }\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Requested bit length (\" + count + \") exceeds maximum (\" + MAXIMUM_CACHE_SIZE + \").\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Requested bit length (\" + count + \") is negative.\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"Number of bits to read must be between 0 and 63\");\n    }\n\n    if (count <= bitsCachedSize) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n\n    if (ensureCache(count)) {\n        return -1;\n    }\n\n    final long bitsOut;\n    int overflowBits = 0;\n    long overflow = 0l;\n    // utils/BitInputStream.java\n    // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n    int bitsToAddCount = count - bitsCachedSize;\n    overflowBits = 8 - bitsToAddCount;\n    final long nextByte = in.read();\n    if (nextByte < 0) {\n        return -1;\n    }\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        long bitsToAdd = nextByte & MASKS[bitsToAddCount];\n        bitsCached |= (bitsToAdd << bitsCachedSize);\n        overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits];\n    } else {\n        bitsCached <<= bitsToAddCount;\n        long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount];\n        bitsCached |= bitsToAdd;\n        overflow = nextByte & MASKS[overflowBits];\n    }\n    bitsOut = bitsCached & MASKS[count];\n    bitsCached = overflow;\n    bitsCachedSize = overflowBits;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent instanceof LabeledStatement) \n  {\n    return ((LabeledStatement) parent).getLabel().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  while (target != null) \n  {\n    if (target.hasLabel() && target.getLabel().equals(label)) \n    {\n      return true;\n    }\n    target = target.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null || label.equals(target.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent instanceof Label) {\n    return parent.getString().equals(label);\n  } else if (parent instanceof For) {\n    String forLabel = ((For) parent).getLabel();\n    return forLabel != null && forLabel.equals(label);\n  } else if (parent instanceof Do) {\n    String doLabel = ((Do) parent).getLabel();\n    return doLabel != null && doLabel.equals(label);\n  } else if (parent instanceof While) {\n    String whileLabel = ((While) parent).getLabel();\n    return whileLabel != null && whileLabel.equals(label);\n  } else {\n    return false;\n  }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.getFirstChild().getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null)\n        return true;\n    return ((LabelledNode) target).getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null ||\n        (target.getPropName() != null &&\n         label.equals(target.getPropName()) ||\n         (target.getType() == Token.LABEL &&\n          label.equals(((Node)target.getLastChild()).getPropName())));\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  for (Node c = target.getParent(); c != null; c = c.getParent()) \n  {\n    if (c.getPropName().equals(label)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  Node parent = target.getParent();\n  while (parent != null) \n  {\n    if (parent.hasLabel() && parent.getLabel().equals(label)) \n    {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.getFirstChild().getString().equals(label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYDataset dataset = (XYDataset) getItemDataset(series);\n    if (dataset == null) \n    {\n        return null;\n    }\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator instanceof StandardCategoryURLGenerator) \n    {\n        Comparable seriesKey = dataset.getSeriesKey(series);\n        Comparable categoryKey = dataset.getXValue(series, item);\n        return ((StandardCategoryURLGenerator) generator).generateURL(dataset,\n                seriesKey, categoryKey);\n    }\n    if (generator instanceof StandardPieURLGenerator) \n    {\n        Comparable categoryKey = dataset.getXValue(series, item);\n        return ((StandardPieURLGenerator) generator).generateURL(dataset,\n                categoryKey, item);\n    }\n    else \n    {\n        return generator.generateURL(dataset, series, item);\n    }\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    if (dataset == null) {\n        return null;\n    }\n    XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n    if (urlGenerator == null) {\n        return null;\n    }\n    String url = urlGenerator.generateURL(dataset, series, item);\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = (XYDataset) getDataset();\n    if (dataset != null) {\n        XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n        if (urlGenerator != null) {\n            return urlGenerator.generateURL(dataset, series, item);\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = (XYDataset) getItemDataset(series);\n    if (dataset == null) \n    {\n        return null;\n    }\n    XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n    if (urlGenerator == null) \n    {\n        return null;\n    }\n    return urlGenerator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    if (dataset == null) {\n        return null;\n    }\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    if (dataset == null) {\n        return null;\n    }\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    if (dataset == null) {\n        return null;\n    }\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator instanceof TimeSeriesURLGenerator) \n    {\n        TimeSeriesURLGenerator timeSeriesURLGenerator = (TimeSeriesURLGenerator) generator;\n        return timeSeriesURLGenerator.generateURL(dataset, series, item);\n    }\n    else if (generator instanceof StandardCategoryURLGenerator) \n    {\n        StandardCategoryURLGenerator standardCategoryURLGenerator = (StandardCategoryURLGenerator) generator;\n        CategoryDataset categoryDataset = (CategoryDataset) dataset;\n        return standardCategoryURLGenerator.generateURL(categoryDataset, series, item);\n    }\n    else if (generator instanceof StandardPieURLGenerator) \n    {\n        StandardPieURLGenerator standardPieURLGenerator = (StandardPieURLGenerator) generator;\n        PieDataset pieDataset = (PieDataset) dataset;\n        return standardPieURLGenerator.generateURL(pieDataset, null, item);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = (XYDataset) getItemDataset(series);\n    if (dataset == null) \n    {\n        return null;\n    }\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) \n    {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = (XYDataset) getItemDataset(series);\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    for (int i = 0; i < str.length(); ++i) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':\n                result = (result * 10) + (c - '0');\n                break;\n            case '.':\n                return result;\n            default:\n                return -1;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    for(int i = 0; i < str.length(); i++)\n    {\n        char c = str.charAt(i);\n        if(c > '9' || c < '0') return -1;\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    for (int c : str.toCharArray()) {\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + (c - '0');\n        } else {\n            break;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    int digit;\n    char ch;\n    for (int i = 0, len = str.length(); i < len; i++) {\n        ch = str.charAt(i);\n        digit = CharTypes.charToHex(ch);\n        if (digit >= 0) {\n            result = (result << 4) | digit;\n        } else {\n            break;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c == '+') {\n            return result;\n        } else if (c == '-') {\n            return -result;\n        } else if (c >= '0' && c <= '9') {\n            result = (result * 10) + (c - '0');\n        } else {\n            return -1;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    for(int i=0; i<str.length(); i++) \n    {\n        int c = str.charAt(i) - '0';\n        if(c >= 0 && c <= 9) \n        {\n            result = result * 10 + c;\n        } else \n        {\n            return -1;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    if (str.length() == 1) {\n        char c = str.charAt(0);\n        if (c >= '0' && c <= '9') {\n            result = c - '0';\n        }\n    } else if (str.length() == 2) {\n        char c = str.charAt(0);\n        if (c >= '0' && c <= '9') {\n            char d = str.charAt(1);\n            if (d >= '0' && d <= '9') {\n                result = (c - '0') * 10 + (d - '0');\n            }\n        }\n    } else if (str.length() == 3) {\n        char c = str.charAt(0);\n        if (c >= '0' && c <= '9') {\n            char d = str.charAt(1);\n            if (d >= '0' && d <= '9') {\n                char e = str.charAt(2);\n                if (e >= '0' && e <= '9') {\n                    result = (c - '0') * 100 + (d - '0') * 10 + (e - '0');\n                }\n            }\n        }\n    } else {\n        throw new IllegalArgumentException(\"Invalid index format: \" + str);\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    for (int i = 0, len = str.length(); i < len; i++) {\n        char c = str.charAt(i);\n        switch (c) {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                result = (result << 4) | (c - '0');\n                break;\n            default:\n                return result;\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    for (int c = str.charAt(0); c >= '0' && c <= '9'; c = str.charAt(++result));\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = -1;\n    int pos = 0;\n    while (pos < str.length()) {\n        final int ch = str.charAt(pos++);\n        if (ch == '0' || ch == '1' || ch == '2' || ch == '3' || ch == '4' || ch == '5' || ch == '6' || ch == '7' || ch == '8' || ch == '9') {\n            result = (result << 3) + (result << 1) + (ch - '0');\n        } else if (ch == 'k' || ch == 'K') {\n            return result * 1024;\n        } else if (ch == 'm' || ch == 'M') {\n            return result * 1024 * 1024;\n        } else {\n            break;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).toArray(new Object[k]);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_COLLECTION,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n    return nextPermutation(c.size(), k).stream().map(i -> c.toArray()[i]).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_LARGER_THAN_COLLECTION,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n\n    Object[] result = new Object[k];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = c.iterator().next();\n    }\n\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream()\n            .map(c::get)\n            .toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    Object[] result = new Object[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = c.toArray()[index[i]];\n    }\n\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).toArray(new Object[0]);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] result = new Object[k];\n    int j = 0;\n    for (int i : index) {\n        if (j < k) {\n            result[j] = c.toArray()[i];\n        }\n        j++;\n    }\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_LARGER_THAN_COLLECTION,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n    return nextPermutation(c.size(), k).stream().map(c::get).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream()\n    .map(c::get)\n    .toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n            c.size(), k, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n            k);\n    }\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] result = new Object[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = c.toArray()[index[i]];\n    }\n    return result;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node expr = buildMethodCall(methodName, argumentNode, srcref);\n    return expr;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = new Name(methodName);\n\n    // Create call node\n    Node callNode = new Call(methodNameNode, 1);\n    callNode.addNext(argumentNode);\n\n    // Add source information\n    if (srcref != null) {\n      callNode.setSourceInfo(srcref.getSourceInfo());\n    }\n\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = new Name(methodName);\n    methodNameNode.setOriginalPosition(srcref);\n    Node callExpr = new Call(methodNameNode);\n    callExpr.setOriginalPosition(srcref);\n    if (argumentNode != null) {\n        callExpr.addChildToBack(argumentNode);\n    }\n    return callExpr;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  // Create a call node.\n  Node callNode = new Node(Token.CALL);\n\n  // Set the method name.\n  callNode.addChildToFront(new Node(Token.NAME).setString(methodName));\n\n  // Set the method argument.\n  callNode.addChildToBack(argumentNode);\n\n  // Set the source reference.\n  if (srcref != null) {\n    callNode.setSourceInfo(srcref.getSourceInfo());\n  }\n\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  return new Node(Token.CALL, methodName, argumentNode, srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node expr = buildMethodCallExpr(methodName, argumentNode);\n    return new ExpressionStatement(expr, srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCallExpr = new Node(Token.CALL);\n    Node nameNode = new Node(Token.NAME);\n    nameNode.setString(methodName);\n    methodCallExpr.addChild(nameNode);\n    methodCallExpr.addChild(argumentNode);\n    methodCallExpr.setLoc(srcref);\n\n    return methodCallExpr;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = new Name(methodName);\n    methodNameNode.setOriginalPosition(srcref);\n    Node callExpressionNode = new Call(methodNameNode);\n    callExpressionNode.setOriginalPosition(srcref);\n    if (argumentNode != null) {\n      callExpressionNode.addChildToBack(argumentNode);\n    }\n    return callExpressionNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  return new FunctionCallBuilder()\n      .setMethodName(methodName)\n      .setArgument(argumentNode)\n      .setContext(srcref)\n      .build();\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node methodNameNode = new Name(methodName);\n  methodNameNode.setSrc(srcref);\n  Node callNode = new Call(methodNameNode);\n  callNode.setSrc(srcref);\n  if (argumentNode != null) {\n    callNode.addChildToBack(argumentNode);\n  }\n  return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final ArrayList<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    \n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs where the first element is the value and the second is the index.\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    \n    // Sort the list of pairs using the comparator from the util/MathArrays.java file.\n    Collections.sort(list, comp);\n    \n    // Create an array of indices in the sorted order.\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = list.get(i).getValue();\n    }\n    \n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs where the first element is the value\n    // and the second element is the index of the value in doubles.\n    final List<Pair<Double, Integer>> list = new ArrayList<>();\n    final int len = doubles.length;\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Create a comparator for increasing order.\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final List<Pair<Double, Integer>> list = new ArrayList<>();\n    final int len = doubles.length;\n\n    // Create pairs of values and indices.\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the pairs using the comparator from MathArrays.\n    Collections.sort(list, MathArrays.comp);\n\n    // Retrieve indices of original locations.\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = list.get(i).getValue();\n    }\n\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs, where each pair holds a value and its index.\n    final List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list in ascending order based on the value.\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final List<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final List<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    // Sort by key in ascending order.\n    Collections.sort(list, MathArrays.OrderDirection.INCREASING);\n    // Get indices from list.\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = list.get(i).getValue();\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final ArrayList<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    \n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final List<Pair<Double, Integer>> list = new ArrayList<>();\n\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort by fitness value.\n    Collections.sort(list, MathArrays.comparator(MathArrays.OrderDirection.INCREASING));\n\n    // Extract indices of original locations.\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        final Pair<Double, Integer> e = list.get(i);\n        indices[i] = e.getValue();\n    }\n\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs (value, index)\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list using the comparator from MathArrays.java\n    Collections.sort(list, MathArrays.comp);\n\n    // Retrieve the indices from the sorted pairs\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = list.get(i).getValue();\n    }\n\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int m = main.length;\n        double[][] ta = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            ta[i][i] = main[i];\n            if (i > 0) {\n                ta[i][i - 1] = secondary[i - 1];\n            }\n            if (i < main.length - 1) {\n                ta[i][i + 1] = secondary[i];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(ta);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) {\n            if (householderVectors[m][m - 1] != 0.0) {\n                for (int j = 0; j <= m - 1; j++) {\n                    ort[j] = householderVectors[j][m - 1];\n                }\n\n                for (int j = m; j <= high; j++) {\n                    double g = 0.0;\n                    for (int i = m; i <= high; i++) {\n                        g = g + householderVectors[i][m - 1] * qa[i][j];\n                    }\n                    g = -g / householderVectors[m][m - 1];\n                    for (int i = m; i <= high; i++) {\n                        qa[i][j] = qa[i][j] + g * householderVectors[i][m - 1];\n                    }\n                }\n                for (int i = m - 1; i >= 0; i--) {\n                    qa[i][m] = -qa[i][m];\n                }\n                qa[m][m] = 1 + qa[m][m];\n                for (int i = 0; i < m - 1; i++) {\n                    qa[i][m] = 0;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    qa[i][m] = 0;\n                }\n                qa[m][m] = 1;\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n}\n}\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) {\n            if (householderVectors[m][m - 1] != 0.0) {\n                for (int j = 0; j <= m - 1; j++) {\n                    ort[j] = householderVectors[j][m - 1];\n                }\n\n                for (int j = 0; j <= m - 1; j++) {\n                    double g = 0.0;\n                    for (int i = 0; i <= j; i++) {\n                        g += qa[i][j] * ort[i];\n                    }\n                    for (int i = 0; i <= j; i++) {\n                        qa[i][j] -= g * ort[i];\n                    }\n                }\n            }\n        }\n\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int m = main.length;\n        double[][] qa = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hKi = householderVectors[i];\n            for (int j = i + 1; j < m; ++j) \n            {\n                double beta = 0;\n                for (int k = 0; k <= i; ++k) \n                {\n                    beta -= qa[k][j] * hKi[k];\n                }\n                beta /= hKi[i];\n\n                for (int k = 0; k <= i; ++k) \n                {\n                    qa[k][j] += -beta * hKi[k];\n                }\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) {\n            if (householderVectors[m][m - 1] != 0.0) {\n                for (int i = m + 1; i <= high; i++) {\n                    ort[i] = householderVectors[i][m - 1];\n                }\n\n                for (int j = m; j <= high; j++) {\n                    double g = 0.0;\n                    for (int i = m; i <= high; i++) {\n                        g += qa[i][j] * ort[i];\n                    }\n                    g = -g / ort[m - 1];\n                    for (int i = m; i <= high; i++) {\n                        qa[i][j] += g * ort[i];\n                    }\n                }\n                for (int i = m; i <= high; i++) {\n                    qa[i][m - 1] = -qa[i][m - 1];\n                }\n                qa[m][m - 1] = 1 + qa[m][m - 1];\n                for (int i = 0; i < m - 1; i++) {\n                    qa[i][m - 1] = 0;\n                }\n            } else {\n                for (int i = 0; i <= high; i++) {\n                    qa[i][m - 1] = 0;\n                }\n                qa[m][m - 1] = 1;\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n        if (nct < n) {\n}\n}\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) \n        {\n            if (householderVectors[m][m - 1] != 0.0) \n            {\n                for (int i = 0; i < m; i++) \n                {\n                    ort[i] = householderVectors[i][m - 1];\n                }\n\n                for (int j = 0; j < m; j++) \n                {\n                    double g = 0.0;\n                    for (int i = 0; i < m; i++) \n                    {\n                        g += qa[i][j] * ort[i];\n                    }\n                    g = -g / ort[j];\n                    for (int i = 0; i < m; i++) \n                    {\n                        qa[i][j] += g * ort[i];\n                    }\n                }\n            }\n        }\n\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = householderVectors.length;\n        final double[][] qa = new double[n][n];\n\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                qa[i][k] = 0;\n            }\n            qa[k][k] = 1;\n        }\n\n        for (int k = 0; k < n - 1; k++) {\n            final double[] hK = householderVectors[k];\n            for (int j = k + 1; j < n; ++j) {\n                double beta = 0;\n                for (int i = k; i < n; ++i) {\n                    beta -= qa[i][j] * hK[i];\n                }\n                beta /= main[k] * hK[k];\n\n                for (int i = k; i < n; ++i) {\n                    qa[i][j] += beta * hK[i];\n                }\n            }\n        }\n\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) {\n            if (householderVectors[m][m - 1] != 0.0) {\n                for (int j = m - 1; j >= 0; j--) {\n                    ort[j] = householderVectors[j][m - 1];\n                }\n\n                for (int j = m; j >= 0; j--) {\n                    double g = 0.0;\n                    for (int i = m; i >= 0; i--) {\n                        g += qa[i][j] * ort[i];\n                    }\n                    g = -g / ort[m - 1];\n                    for (int i = m; i >= 0; i--) {\n                        qa[i][j] += g * ort[i];\n                    }\n                }\n            }\n        }\n\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int n = householderVectors.length;\n        final double[][] qa = new double[n][n];\n\n        // fill up the part of the matrix not affected by Householder transforms\n        for (int k = n - 1; k >= 0; --k) {\n            qa[k][k] = 1;\n        }\n\n        // build up first part of the matrix by applying Householder transforms\n        for (int k = 0; k <= n - 2; ++k) {\n            final double[] hK = householderVectors[k];\n            qa[k][k] = 1;\n            if (hK[k] != 0.0) {\n                for (int j = k; j <= n - 1; ++j) {\n                    double beta = 0;\n                    for (int i = k; i <= n - 1; ++i) {\n                        beta -= qa[i][j] * hK[i];\n                    }\n                    beta /= main[k] * hK[k];\n\n                    for (int i = k; i <= n - 1; ++i) {\n                        qa[i][j] += beta * hK[i];\n                    }\n                }\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(qa);\n    }\n\n    // return the cached matrix\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        final int n = householderVectors.length;\n        final int high = n - 1;\n        final double[][] qa = new double[n][n];\n\n        for (int i = 0; i < n; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                qa[i][j] = (i == j) ? 1 : 0;\n            }\n        }\n\n        for (int m = high - 1; m >= 1; m--) \n        {\n            if (householderVectors[m][m - 1] != 0.0) \n            {\n                for (int i = m + 1; i <= high; i++) \n                {\n                    ort[i] = householderVectors[i][m - 1];\n                }\n\n                for (int j = m; j <= high; j++) \n                {\n                    double g = 0.0;\n                    for (int i = m; i <= high; i++) \n                    {\n                        g += qa[i][j] * ort[i];\n                    }\n                    g = -g / ort[m];\n                    for (int i = m; i <= high; i++) \n                    {\n                        qa[i][j] += g * ort[i];\n                    }\n                }\n                for (int i = m; i <= high; i++) \n                {\n                    qa[i][m] = -qa[i][m];\n                }\n                qa[m][m] = 1 + qa[m][m];\n                for (int i = 0; i < m - 1; i++) \n                {\n                    qa[i][m] = 0;\n                }\n            } \n            else \n            {\n                for (int i = 0; i <= high; i++) \n                {\n                    qa[i][m] = 0;\n                }\n                qa[m][m] = 1;\n            }\n        }\n        // Set up the final bidiagonal matrix or order p.\n        int p = n;\n}\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = this.keyToGroupMap.get(key);\n    return (group != null) ? group : this.defaultGroup;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(element);\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedNavigableSet<E> transformedSet = new TransformedNavigableSet<>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(element);\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> decoratedSet = set;\n    if (set instanceof TransformedSet) {\n        decoratedSet = ((TransformedSet<E>) set).decorated();\n    }\n    Set<E> transformedSet = new TransformedSet<>(decoratedSet, transformer);\n    if (set instanceof NavigableSet) {\n        return new TransformedNavigableSet<>(decoratedSet, transformer);\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = SetUtils.transformedSet(set, transformer);\n    for (E element : transformedSet) {\n        if (!set.contains(element)) {\n            set.add(element);\n        }\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> decoratedSet = set;\n    if (set instanceof TransformedSet) {\n        decoratedSet = ((TransformedSet<E>) set).decorated();\n    }\n    \n    Set<E> transformedSet = new HashSet<>();\n    for (E element : decoratedSet) {\n        E transformedElement = transformer.transform(element);\n        transformedSet.add(transformedElement);\n    }\n    \n    return transformedSet;\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[Math.max(capacity, old.length * 2)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char old[] = buffer;\n        final int newLength = Math.max(capacity, old.length * 2);\n        buffer = new char[newLength];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[Math.max(capacity, old.length * 2)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newCapacity = Math.max(capacity, buffer.length * 2);\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        final int newCapacity = Math.max(capacity, old.length * 2);\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newLength = Math.max(capacity, old.length * 2);\n        buffer = new char[newLength];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newLength = Math.max(capacity, old.length * 2);\n        buffer = new char[newLength];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char old[] = buffer;\n        final int newLength = Math.max(capacity, old.length * 2);\n        buffer = new char[newLength];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newCapacity = Math.max(capacity, buffer.length * 2);\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newCapacity = Math.max(capacity, old.length * 2);\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        Number number = dataset.getValue(series, 0);\n        if (number != null) {\n            min = Math.min(min, number.doubleValue());\n            max = Math.max(max, number.doubleValue());\n        }\n    }\n    for (int item = 1; item < dataset.getColumnCount(); item++) {\n        double currentMax = Double.NEGATIVE_INFINITY;\n        for (int series = 0; series < dataset.getRowCount(); series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                currentMax = Math.max(currentMax, number.doubleValue());\n                min = Math.min(min, currentMax);\n                max = Math.max(max, currentMax);\n            }\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                runningTotal += value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double runningTotal = 0.0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                runningTotal += number.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        Number number = dataset.getValue(0, item);\n        if (number != null) {\n            min = Math.min(min, number.doubleValue());\n            max = Math.max(max, number.doubleValue());\n        }\n    }\n    result = new Range(min, max);\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        int itemCount = dataset.getColumnCount();\n        for (int item = 0; item < itemCount; item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                runningTotal += number.doubleValue();\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double runningTotal = 0.0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                runningTotal += number.doubleValue();\n            }\n            min = Math.min(min, runningTotal);\n            max = Math.max(max, runningTotal);\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double sum = 0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                sum = sum + number.doubleValue();\n            }\n        }\n        minimum = Math.min(minimum, sum);\n        maximum = Math.max(maximum, sum);\n    }\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double runningTotal = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                runningTotal += value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double runningTotal = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                runningTotal += value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < dataset.getRowCount(); series++) {\n        double sum = 0.0;\n        for (int item = 0; item < dataset.getColumnCount(); item++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                sum += value;\n                min = Math.min(min, sum);\n                max = Math.max(max, sum);\n            }\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    if ((hoursOffset == -23 && minutesOffset == -59) || (hoursOffset == 23 && minutesOffset == 59)) {\n        throw new IllegalArgumentException(\"Offset exceeds maximum\");\n    }\n    if (minutesOffset != 0) {\n        return new BasicChronology(UTC, null, 0, minutesOffset).getZone();\n    } else {\n        return new BasicChronology(UTC, null, hoursOffset, 0).getZone();\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hoursOffset, -23, 23);\n    FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minutesOffset, -59, 59);\n    if (minutesOffset == 0) {\n        return forOffsetHours(hoursOffset);\n    } else if (hoursOffset == 0) {\n        int minutes = minutesOffset >= 0 ? minutesOffset : -minutesOffset;\n        if (minutes >= 60) {\n            minutes -= 60;\n            hoursOffset++;\n        } else if (minutes <= -60) {\n            minutes += 60;\n            hoursOffset--;\n        }\n        return forOffsetHours(hoursOffset).withOffsetMinutes(minutes);\n    } else {\n        int minutes = minutesOffset >= 0 ? minutesOffset : -minutesOffset;\n        int hours = hoursOffset >= 0 ? hoursOffset : -hoursOffset;\n        if (minutes >= 60) {\n            minutes -= 60;\n            hours++;\n        } else if (minutes <= -60) {\n            minutes += 60;\n            hours--;\n        }\n        if (hours > 23 || hours < -23) {\n            throw new IllegalArgumentException(\"Offset hours out of range, must be in range -23 to +23\");\n        }\n        return new BasicChronology(hours, minutes);\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hoursOffset, -23, 23);\n    FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minutesOffset, -59, 59);\n\n    if (minutesOffset < 0 && hoursOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Invalid zone: minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n\n    return new BasicChronology(ISOChronology.getInstance(), new TimeZoneOffset(hoursOffset, minutesOffset));\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23, but was: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59, but was: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"The minutes offset must be positive when the hours offset is 0.\");\n    }\n    if (minutesOffset == 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"The hours offset must be positive when the minutes offset is 0.\");\n    }\n    if (hoursOffset == -23 && minutesOffset == -59) {\n        return DateTimeUtils.UTC;\n    }\n    return new BasicFixedDateTimeZone(\"Z\" + hoursOffset + \":\" + minutesOffset, hoursOffset, minutesOffset, millisOfHour(hoursOffset, minutesOffset));\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hoursOffset, -23, 23);\n    FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minutesOffset, -59, 59);\n    if (hoursOffset == 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are zero\");\n    }\n\n    return new BasicChronology(UTC).withZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hoursOffset, -23, 23);\n    FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minutesOffset, -59, 59);\n    if (minutesOffset > 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be negative when hours are positive\");\n    }\n    if (hoursOffset > 23 && minutesOffset != 0) {\n        throw new IllegalArgumentException(\"Hours must be -23 or -24 to have a non-zero minute offset\");\n    }\n    if (hoursOffset < -23 && minutesOffset != 0) {\n        throw new IllegalArgumentException(\"Hours must be +23 or +24 to have a non-zero minute offset\");\n    }\n    if (hoursOffset == 23 && minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Hours cannot be +23 when minutes offset is +60 or more\");\n    }\n    if (hoursOffset == -23 && minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Hours cannot be -23 when minutes offset is -60 or less\");\n    }\n    return new BasicChronology(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23, but was \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59, but was \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when the hours are zero.\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when the hours are positive.\");\n    }\n    if (minutesOffset == 0 && hoursOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    return new BasicFixedDateTimeZone(hoursOffset, minutesOffset, \"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + hoursOffset + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"hoursOffset cannot be greater than 23\");\n    }\n    if (hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"hoursOffset cannot be less than -23\");\n    }\n    if (minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"minutesOffset cannot be greater than 59\");\n    }\n    if (minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"minutesOffset cannot be less than -59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) \n    {\n        throw new IllegalArgumentException(\"minutesOffset cannot be negative when hoursOffset is positive\");\n    }\n    if (hoursOffset == -23 && minutesOffset == -59) \n    {\n        throw new ArithmeticException(\"The resulting offset would be more than 23:59:59.000\");\n    }\n    if (hoursOffset == 23 && minutesOffset == +59) \n    {\n        throw new ArithmeticException(\"The resulting offset would be more than 23:59:59.000\");\n    }\n\n    final long offsetMillis = safeMultiply(hoursOffset, DateTimeConstants.MILLIS_PER_HOUR)\n                          + safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    return new BasicFixedDateTimeZone(offsetMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"hoursOffset must be in the range -23 to 23, but was \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"minutesOffset must be in the range -59 to 59, but was \" + minutesOffset);\n    }\n    if (minutesOffset != 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"minutesOffset (\" + minutesOffset + \") cannot be used with a positive hoursOffset (\" + hoursOffset + \")\");\n    }\n\n    return DateTimeZone.forOffsetHoursMinutes(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"hoursOffset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"minutesOffset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    } else if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Negative minutes not supported when hours are positive\");\n    } else if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Negative minutes not supported when hours are negative\");\n    }\n    // Calculate the millis offset.\n    long millisOffset = 0L;\n    millisOffset = safeMultiply(hoursOffset, DateTimeConstants.MILLIS_PER_HOUR);\n    millisOffset = safeAdd(millisOffset, safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE));\n    // Make sure we did not overflow.\n    if (hoursOffset == 23 && minutesOffset == 59 && millisOffset > DateTimeConstants.MILLIS_PER_DAY) {\n        throw new IllegalArgumentException(\"The calculated offset exceeds +/- 23:59:59.000\");\n    }\n    if (hoursOffset == -23 && minutesOffset == -59 && millisOffset < -DateTimeConstants.MILLIS_PER_DAY) {\n        throw new IllegalArgumentException(\"The calculated offset exceeds +/- 23:59:59.000\");\n    }\n    return new BasicFixedInstantZone(hoursOffset, minutesOffset, millisOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = -1;\n    int end = -1;\n    char last = 0;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n    while (true) {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n        if (depth == 0) // found the end\n            break;\n    }\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = -1;\n    int end = -1;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Did not find balanced marker at '\" + queue.substring(start) + \"'\");\n        }\n\n        Character c = consume();\n        if (last == 0 || last != ESC) \n        {\n            if (c.equals('\\'') && c != open && !inDoubleQuote) \n            {\n                inSingleQuote = !inSingleQuote;\n            }\n            else if (c.equals('\"') && c != open && !inSingleQuote) \n            {\n                inDoubleQuote = !inDoubleQuote;\n            }\n\n            if (inSingleQuote || inDoubleQuote) \n            {\n                continue;\n            }\n\n            if (c.equals(open)) \n            {\n                depth++;\n                if (start == -1) \n                {\n                    start = pos;\n                }\n            }\n            else if (c.equals(close)) \n            {\n                depth--;\n            }\n        }\n\n        if (depth > 0 && last != 0) \n        {\n            end = pos; // don't include the outer match pair in the return\n        }\n        last = c;\n        if (depth == 0) \n        {\n            break;\n        }\n    }\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    while (depth >= 0) {\n        if (queue.isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    }\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    last = 0;\n    while (!queue.isEmpty()) {\n        Character c = queue.consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n        if (depth == 0)\n            break;\n    }\n    if (depth > 0) {\n        Validate.fail(\"Did not find balanced marker at '\" + queue.substring(start, end) + \"'\");\n    }\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    last = 0;\n    while (depth >= 0) {\n        if (isEmpty()) return end >= 0 ? queue.substring(start, end) : \"\";\n        char c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote) continue;\n\n            if (c.equals(open)) depth++;\n            else if (c.equals(close)) depth--;\n        }\n\n        if (depth > 0 && last != 0) end = pos - 1; // don't include the outer match pair in the return\n        last = c;\n    }\n    return end >= 0 ? queue.substring(start, end) : \"\";\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n    char last = 0;\n\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return unescape(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    int end = -1;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return unescape(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = -1;\n    int end = -1;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n\n    while (!queue.isEmpty()) {\n        if (depth == 0) {\n            start = queue.getPosition();\n        }\n        Character c = queue.consume();\n        if (last != 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n            }\n            else if (c.equals(close)) {\n                depth--;\n            }\n        }\n        last = c;\n        if (depth > 0 && last != 0)\n            end = queue.getPosition(); // don't include the outer match pair in the return\n        if (depth == 0 && end >= 0) {\n            break;\n        }\n    }\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = -1;\n    int end = -1;\n    char last = 0;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NoDataException, MathIllegalStateException {\n        RealMatrix q = getQ();\n\n        // (R^T R)^-1 = (qR^T qR)^-1\n        RealMatrix invRTR = new LUDecomposition(q.transpose().multiply(q).multiply(getMatrix())).getSolver().getInverse();\n\n        // (X^T X)^-1 = (qR^T X)^-1 (qR^T qR)^-1 qR^T X\n        RealMatrix invXTX = q.transpose().multiply(getMatrix()).multiply(invRTR).multiply(getMatrix().transpose()).multiply(getX());\n\n        // return the diagonal elements of (X^T X)^-1\n        RealMatrix retval = new Array2DRowRealMatrix(invXTX.getColumnDimension(), invXTX.getColumnDimension());\n        for (int i = 0; i < retval.getColumnDimension(); ++i) {\n            retval.setEntry(i, i, invXTX.getEntry(i, i));\n        }\n\n        return retval;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws MathIllegalStateException {\n        // Validate that sample data is present before proceeding\n        if (y == null) {\n            throw new NullPointerException(\"Data must be loaded before calculating variance.\");\n        }\n        if (q == null) {\n            throw new NullPointerException(\"Data must be loaded before calculating variance.\");\n        }\n\n        // Calculate the variance-covariance matrix\n        int p = beta.getDimension();\n        RealMatrix RRT = q.transpose().multiply(q);\n        RealMatrix RRTInv = new LUDecomposition(RRT).getSolver().getInverse();\n        RealMatrix inv = new Array2DRowRealMatrix(p, p);\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                inv.setEntry(i, j, RRTInv.getEntry(i, j));\n            }\n        }\n        RealMatrix result = inv.multiply(RRT.getColumnVector(p));\n\n        // Set diagonal elements to the variance of the corresponding beta\n        for (int i = 0; i < p; i++) {\n            double var = getResidualSumSquares() / (n - p);\n            result.setEntry(i, i, result.getEntry(i, i) * var);\n        }\n        return result;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NullPointerException {\n        RealMatrix R = getR();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix inverse = new LUDecomposition(RTR).getSolver().getInverse();\n        return inverse.getSubMatrix(0, beta.getDimension() - 1, 0, beta.getDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NoDataException, MathIllegalStateException {\n        RealMatrix qrt = getQrt();\n\n        int p = beta.getColumnDimension();\n\n        RealMatrix RRT = qrt.getColumnVector(0, p).transpose().multiply(qrt.getColumnVector(0, p));\n        RealMatrix RRTinv = new LUDecomposition(RRT).getSolver().getInverse();\n\n        RealMatrix inv = new Array2DRowRealMatrix(p, p);\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                inv.setEntry(i, j, RRTinv.getEntry(i, j));\n            }\n        }\n\n        return inv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NoDataException, NotConvergedException {\n        if (sampleSize < 2) {\n            throw new NotConvergedException(LocalizedFormats.SINGULAR_MATRIX, sampleSize);\n        }\n        RealMatrix R = getQR().getR();\n        RealMatrix RRT = R.transpose().multiply(R);\n        RealMatrix betaVariance = RRT.scalarMultiply(1.0 / sampleSize).getSolver().getInverse();\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NotConvergedException, NoDataException {\n        RealMatrix Q = getQ();\n        RealMatrix R = getR();\n        int rRank = Math.min(beta.getColumnDimension(), R.getColumnDimension());\n\n        RealMatrix RRT = R.transpose().multiply(R);\n        RealMatrix invRRT = new LUDecomposition(RRT).getSolver().getInverse();\n\n        RealMatrix topRRT = new Array2DRowRealMatrix(RRT.getData(), 0, rRank, 0, rRank);\n        RealMatrix topInvRRT = new Array2DRowRealMatrix(invRRT.getData(), 0, rRank, 0, rRank);\n\n        RealMatrix topQR = new Array2DRowRealMatrix(Q.getData(), 0, rRank, 0, Q.getColumnDimension());\n\n        if (topQR.getColumnDimension() != topInvRRT.getColumnDimension()) {\n            throw new RuntimeException(\"Internal error: inconsistent dimensions\");\n        }\n        if (topQR.getRowDimension() != topInvRRT.getRowDimension()) {\n            throw new RuntimeException(\"Internal error: inconsistent dimensions\");\n        }\n\n        RealMatrix result = topQR.transpose().multiply(topInvRRT).multiply(topQR);\n        return result;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws MathIllegalStateException, NoDataException {\n    \t// Check if data is available\n    \tif (getX() == null || getY() == null) {\n    \t\tthrow new NoDataException(\"No data has been loaded into the model.\");\n    \t}\n    \tRealMatrix qrt = getQRDecomposition().getR().transpose();\n    \tRealMatrix scaledR = qrt.scalarMultiply(Math.sqrt(getX().getRowDimension()));\n    \treturn scaledR.multiply(scaledR.transpose()).scalarMultiply(getOmegaInverse());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NotConvergedException, NoDataException {\n        if (Omega == null) {\n            throw new NoDataException(\"Data must be loaded before calculating the variance-covariance matrix.\");\n        }\n        RealMatrix R = getR();\n        RealMatrix inverseRRT = new LUDecomposition(R.transpose().multiply(R)).getSolver().getInverse();\n        return inverseRRT;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws NoDataException {\n        // Check if sample data has been loaded\n        if (x == null || y == null) {\n            throw new NoDataException();\n        }\n\n        // Calculate the QR decomposition\n        RealMatrix qrt = getQRDecomposition().getR().transpose();\n\n        // Calculate the variance-covariance matrix\n        RealMatrix betaVar = qrt.operate(qrt.transpose()).scalarMultiply(getOmegaInverse());\n\n        // Return only the top p rows, where p = the length of the beta vector\n        return betaVar.getSubMatrix(0, betaVar.getRowDimension() - getIntercept().getRowDimension(), 0, betaVar.getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  throws MathIllegalStateException {\n        if (beta == null) {\n            throw new MathIllegalStateException(\"Data must be loaded into the model before calculating variance-covariance matrix.\");\n        }\n        RealMatrix qrt = getQR().getR().transpose();\n        return qrt.transpose().multiply(qrt).scalarMultiply(getResidualSumSquares()/(n-k));\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hoursOffset = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutesOffset = (offset / DateTimeConstants.MILLIS_PER_MINUTE) - (hoursOffset * 60);\n    if (hoursOffset >= 0) {\n        return '+' + formatOffset(hoursOffset) + (minutesOffset >= 0 ? ':' + formatOffset(minutesOffset) : \"\");\n    }\n    return '-' + formatOffset(-hoursOffset) + (minutesOffset >= 0 ? ':' + formatOffset(-minutesOffset) : \"\");\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = Math.abs(offset / DateTimeConstants.MILLIS_PER_MINUTE) % 60;\n    if (minutes == 0) {\n        return (hours > 0 ? \"+\" : \"-\") + hours + \"H\";\n    } else {\n        return (hours > 0 ? \"+\" : \"-\") + hours + \":\" + minutes;\n    }\n}",
      "private static String printOffset(int offset)  {\n    int hoursOffset = offset / 3600000;\n    int minutesOffset = (offset / 60000) % 60;\n    if (hoursOffset >= 0) \n    {\n        if (minutesOffset >= 0) \n        {\n            return \"+\" + hoursOffset + \":\" + minutesOffset;\n        }\n        else\n        {\n            return \"+\" + hoursOffset + \":\" + (-minutesOffset);\n        }\n    }\n    else \n    {\n        if (minutesOffset >= 0) \n        {\n            return \"-\" + hoursOffset + \":\" + minutesOffset;\n        }\n        else\n        {\n            return \"-\" + hoursOffset + \":\" + (-minutesOffset);\n        }\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n\n    int hours = Math.abs(offset / DateTimeConstants.MILLIS_PER_HOUR);\n    int minutes = Math.abs(offset / DateTimeConstants.MILLIS_PER_MINUTE % 60);\n    StringBuilder sb = new StringBuilder();\n    if (offset < 0) {\n        sb.append('-');\n    } else {\n        sb.append('+');\n    }\n    FormatUtils.appendPaddedInteger(sb, hours, 2);\n    sb.append(':');\n    FormatUtils.appendPaddedInteger(sb, minutes, 2);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hoursOffset = offset / 3600000;\n    int minutesOffset = (offset / 60000) % 60;\n    if (hoursOffset >= 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    StringBuilder buf = new StringBuilder(8);\n    if (hoursOffset > 0) \n    {\n        buf.append('+');\n    } \n    else if (hoursOffset < 0)\n    {\n        buf.append('-');\n        hoursOffset = -hoursOffset;\n    }\n    FormatUtils.writePaddedInteger(buf, hoursOffset, 2);\n    if (minutesOffset != 0 || hoursOffset == 0) \n    {\n        buf.append(':');\n        FormatUtils.writePaddedInteger(buf, minutesOffset, 2);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n\n    StringBuilder buf = new StringBuilder(6);\n    if (offset > 0) {\n        buf.append('+');\n    } else {\n        buf.append('-');\n        offset = -offset;\n    }\n\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hoursOffset = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutesOffset = Math.abs(offset % DateTimeConstants.MILLIS_PER_HOUR / DateTimeConstants.MILLIS_PER_MINUTE);\n    StringBuilder sb = new StringBuilder(6);\n    if (hoursOffset < 0) {\n        sb.append('-');\n    } else {\n        sb.append('+');\n    }\n    FormatUtils.appendPaddedInteger(sb, Math.abs(hoursOffset), 2);\n    sb.append(':');\n    FormatUtils.appendPaddedInteger(sb, minutesOffset, 2);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hoursOffset = offset / 3600000;\n    int minutesOffset = (offset / 60000) % 60;\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int hoursInMinutes = hoursOffset * 60;\n    if (hoursInMinutes < 0) {\n        minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n    } else {\n        minutesOffset = hoursInMinutes + minutesOffset;\n    }\n    int hours = minutesOffset / 60;\n    int minutes = minutesOffset % 60;\n    StringBuffer buf = new StringBuffer(30);\n    if (hoursOffset > 0) {\n        if (hoursOffset >= 10) {\n            buf.append(hoursOffset);\n        } else {\n            buf.append(\"0\").append(hoursOffset);\n        }\n        if (minutesOffset >= 0) {\n            buf.append(':');\n            if (minutesOffset >= 10) {\n                buf.append(minutesOffset);\n            } else {\n                buf.append(\"0\").append(minutesOffset);\n            }\n        }\n    } else if (hoursOffset < 0) {\n        buf.append('-');\n        if (hoursOffset <= -10) {\n            buf.append(hoursOffset);\n        } else {\n            buf.append(\"0\").append(hoursOffset);\n        }\n        if (minutesOffset <= 0) {\n            buf.append(':');\n            if (minutesOffset <= -10) {\n                buf.append(minutesOffset);\n            } else {\n                buf.append(\"0\").append(minutesOffset);\n            }\n        }\n    } else {\n        if (minutesOffset >= 0) {\n            buf.append('+');\n            if (minutesOffset >= 10) {\n                buf.append(minutesOffset);\n            } else {\n                buf.append(\"0\").append(minutesOffset);\n            }\n        }\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n\n    int hours = (offset / DateTimeConstants.MILLIS_PER_HOUR);\n    int minutes = ((offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE);\n\n    StringBuilder buf = new StringBuilder(6);\n    if (hours >= 0) {\n        buf.append('+');\n    } else {\n        buf.append('-');\n        hours = Math.abs(hours);\n    }\n\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n\n    if (minutes >= 0) {\n        buf.append(':');\n    }\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hoursOffset = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutesOffset = (offset / DateTimeConstants.MILLIS_PER_MINUTE) - (hoursOffset * 60);\n    if (hoursOffset >= 0) {\n        return \"+\" + formatTwoDigits(hoursOffset) + \":\" + formatTwoDigits(minutesOffset);\n    } else {\n        return \"-\" + formatTwoDigits(-hoursOffset) + \":\" + formatTwoDigits(-minutesOffset);\n    }\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key must not be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n  // Add all the symbols from the parent's scope.\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  // Add the current scope's symbols.\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  // Add all the slots from the parent scope.\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  // Add all the slots that have changed during the flow.\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : changedSlots.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Add all the symbols from the parent cache.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    // Add any new symbols that have been defined in this scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.dirtySymbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.dirtySymbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    if (linkedEquivalent != null) {\n      for (StaticSlot<JSType> slot : linkedEquivalent.allFlowSlots().values()) {\n        if (!slots.containsKey(slot.getName())) {\n          slots.put(slot.getName(), slot);\n        }\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet())\n  {\n    if (!slots.containsKey(symbolEntry.getKey()))\n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  FlatFlowScopeCache cache = this.cache;\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    if (linkedEquivalent != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : linkedEquivalent.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    // Get all the symbols defined in the parent scope.\n    for (StaticSlot<JSType> slot : parent.allFlowSlots().values()) {\n      slots.put(slot.getName(), slot);\n    }\n\n    // Get all the symbols defined in this scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n  return slots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0], nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0], nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0], nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0].length, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0].length, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0].getClass(), nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(columnData[0], nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a != a) {\n        return a;\n    }\n\n    final double absA = FastMath.abs(a);\n    if (absA > 0.15) {\n        final double absAtanh = 0.5 * FastMath.log((1 + absA) / (1 - absA));\n        return a < 0.0 ? -absAtanh : absAtanh;\n    } else {\n        final double a2 = absA * absA;\n        if (absA > 0.087) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))));\n        } else if (absA > 0.031) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (absA > 0.003) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            return a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 0.15) \n    {\n        double absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return a < 0.0 ? -absAtanh : absAtanh;\n    } \n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.087) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n            return a < 0 ? -absAtanh : absAtanh;\n        } \n        else if (a > 0.031) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            return a < 0 ? -absAtanh : absAtanh;\n        } \n        else if (a > 0.003) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            return a < 0 ? -absAtanh : absAtanh;\n        } \n        else \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            return a < 0 ? -absAtanh : absAtanh;\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a != a)\n    {\n        return a;\n    }\n\n    double absAtanh;\n    if (a > 0.15)\n    {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else\n    {\n        final double a2 = a * a;\n        if (a > 0.087)\n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else\n        if (a > 0.031)\n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else\n        if (a > 0.003)\n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else\n        {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n    return a < 0 ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    if (a > 0.15) {\n        final double absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return (a > 0) ? absAtanh : -absAtanh;\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            return a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 0.15) \n    {\n        double absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return a < 0 ? -absAtanh : absAtanh;\n    }\n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.087) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n            return a < 0 ? -absAtanh : absAtanh;\n        }\n        else if (a > 0.031) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            return a < 0 ? -absAtanh : absAtanh;\n        }\n        else if (a > 0.003) \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            return a < 0 ? -absAtanh : absAtanh;\n        }\n        else \n        {\n            double absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            return a < 0 ? -absAtanh : absAtanh;\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 0.15) {\n        double absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return a < 0 ? -absAtanh : absAtanh;\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            return a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            return a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a != a) {\n        return a;\n    }\n    if (a >= 0.5) {\n        if (a <= 1.5) {\n            final double x = a - 1.0;\n            final double y = x * x;\n            return 0.5 * FastMath.log((1.0 + x) / (1.0 - x));\n        } else {\n            return FastMath.log((1.0 + a) / (1.0 - a));\n        }\n    } else {\n        if (a <= -0.5) {\n            if (a >= -1.5) {\n                final double x = a + 1.0;\n                final double y = x * x;\n                return -0.5 * FastMath.log((1.0 + x) / (1.0 - x));\n            } else {\n                return -FastMath.log((1.0 + a) / (1.0 - a));\n            }\n        } else {\n            if (a > -0.25) {\n                final double x = a * a;\n                return a * (1 + x * (F_1_3 + x * (F_1_5 + x * (F_1_7 + x * (F_1_9 + x * (F_1_11 + x * (F_1_13 + x * (F_1_15 + x * F_1_17))))))));\n            } else {\n                final double x = FastMath.log(1.0 - a);\n                final double y = FastMath.log1p(a);\n                final double z = FastMath.log(x + y);\n                return y - z / 2.0;\n            }\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 0.15) \n    {\n        double absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return a < 0.0 ? -absAtanh : absAtanh;\n    } \n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.087) \n        {\n            final double atanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))));\n            return a < 0.0 ? -atanh : atanh;\n        } \n        else if (a > 0.031) \n        {\n            final double atanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n            return a < 0.0 ? -atanh : atanh;\n        } \n        else if (a > 0.003) \n        {\n            final double atanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n            return a < 0.0 ? -atanh : atanh;\n        } \n        else \n        {\n            final double atanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n            return a < 0.0 ? -atanh : atanh;\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a != a) \n        return a;\n    \n    final double absAtanh;\n    if (a > 0.15) \n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    else {\n        final double a2 = a * a;\n        if (a > 0.087) \n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        else if (a > 0.031) \n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        else if (a > 0.003) \n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        else\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n    }\n\n    return a < 0 ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    if (a != a)\n        return a;\n\n    final double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n    return (a < 0) ? -absAtanh : absAtanh;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid normalizedSum\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ILLEGAL_NORMALIZED_SUM, normalizedSum);\n    }\n    // Check for infinite elements in the input array\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN,\n                    values[i], Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        }\n    }\n    // Check if the input array sums to zero\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    // Create a new array to hold the normalized values\n    double[] normalizedValues = new double[values.length];\n    // Normalize the elements in the input array\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check arguments\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NAN_OR_INFINITY,\n                normalizedSum);\n    }\n\n    // Compute sum and count non-NaN elements\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n\n    // Throw exception if sum is 0\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUM_IS_ZERO);\n    }\n\n    // Compute normalization factor\n    double factor = normalizedSum / sum;\n\n    // Normalize non-NaN elements and return result\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * factor;\n        } else {\n            result[i] = Double.NaN;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check target sum\n    MathUtils.checkFinite(normalizedSum);\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARGUMENT_MUST_NOT_BE_INFINITE, \"normalizedSum\");\n    }\n\n    // Check for infinite elements\n    for (double v : values) {\n        MathUtils.checkFinite(v);\n    }\n\n    // Compute sum\n    double sum = 0d;\n    for (double v : values) {\n        sum += v;\n    }\n\n    // Check if sum is zero\n    if (sum == 0d) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUM_ZERO);\n    }\n\n    // Compute normalization factor\n    double factor = normalizedSum / sum;\n\n    // Apply normalization factor to non-NaN elements\n    for (int i = 0; i < values.length; ++i) {\n        values[i] *= factor;\n    }\n\n    return values;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid arguments.\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_OR_NAN_TARGET_SUM);\n    }\n\n    // Check for infinite values in the input array.\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n        }\n    }\n\n    // Compute the sum of non-NaN elements.\n    double sum = 0;\n    int numNonNaN = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            numNonNaN++;\n        }\n    }\n\n    // Check if the input array sums to zero.\n    if (numNonNaN == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_ARRAY_SUM);\n    }\n\n    // Normalize the array.\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check arguments\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARGUMENT_NAN_OR_INFINITY,\n                                                \"normalizedSum\", normalizedSum);\n    }\n    MathUtils.checkFinite(values);\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n    if (nonNaNCount == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUM_IS_ZERO);\n    }\n\n    // Normalize the array\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = (values[i] / sum) * normalizedSum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    MathUtils.checkFinite(normalizedSum);\n\n    double sum = 0.0d;\n    int nonNaNCount = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            nonNaNCount++;\n        }\n    }\n\n    if (nonNaNCount == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUM_IS_ZERO);\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INFINITY_IN_ARRAY);\n    }\n\n    double[] result = new double[values.length];\n\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = Double.NaN;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid arguments.\n    MathUtils.checkFinite(normalizedSum);\n    for (double value : values) {\n        MathUtils.checkFinite(value);\n    }\n\n    // Compute the sum of non-NaN values.\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    // Handle cases where the sum is 0 or infinite.\n    if (Math.abs(sum) <= FastMath.ulp(normalizedSum)) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUM_IS_ZERO);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_INFINITE);\n    }\n\n    // Normalize the values.\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid parameters\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.BAD_NORMALIZED_SUM, normalizedSum);\n    }\n    if (values == null) {\n        throw new IllegalArgumentException(\"Input array cannot be null\");\n    }\n\n    // Check for infinite elements in the input array\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITY_IN_ARRAY);\n        }\n    }\n\n    // Compute the sum of non-NaN elements in the input array\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    // Check if the input array sums to zero\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    }\n\n    // Normalize the input array and return the result\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid target sum\n    MathUtils.checkFinite(normalizedSum);\n\n    // Find the sum of the non-NaN entries\n    double sum = 0.0;\n    int numNonNan = 0;\n    for (final double v : values) {\n        if (!Double.isNaN(v)) {\n            numNonNan++;\n            sum += v;\n        }\n    }\n\n    // Throw exception if the input array sums to zero\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Cannot normalize array, the input array sums to zero\");\n    }\n\n    // Normalize the array elements\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i]; // Copy NaN to output array\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check arguments\n    MathUtils.checkFinite(normalizedSum);\n    for (int i = 0; i < values.length; i++) {\n        MathUtils.checkFinite(values[i]);\n    }\n    if (values.length == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.EMPTY_ARRAY);\n    }\n\n    // Compute the sum of non-NaN elements\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    // Handle zero sum or infinite target sum\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    } else if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INFINITY_TARGET_SUM);\n    }\n\n    // Create the normalized array\n    double[] normalized = new double[values.length];\n\n    // Apply the normalization factor\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = Double.NaN;\n        }\n    }\n\n    return normalized;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime md = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                md.setZone(iZone);\n            }\n            return md;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime md = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                md.setZone(iZone);\n            }\n            return md;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                mutableDateTime.setZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix pinvXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = pinvXTOIX.multiply(XTOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix betaInv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector beta = betaInv.multiply(getX().transpose().multiply(OI).operate(getY()));\n        \n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTIOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = XTOIX.getSolver().getInverse().multiply(XTIOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix invXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = invXTOIX.multiply(XTOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        DecompositionSolver XTOIXSolver = new LUDecomposition(XTOIX).getSolver();\n        if (!XTOIXSolver.isNonSingular()) {\n            throw new SingularMatrixException();\n        }\n        RealMatrix XTOIXInverse = XTOIXSolver.getInverse();\n        \n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        \n        RealVector beta = XTOIXInverse.operate(XTOIY);\n        \n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        DecompositionSolver XTOIXSolver = new LUDecomposition(XTOIX).getSolver();\n        if (!XTOIXSolver.isNonSingular()) {\n            throw new SingularMatrixException();\n        }\n        RealMatrix XTOIXinv = XTOIXSolver.getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = XTOIXinv.operate(XTOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix pinvXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = pinvXTOIX.operate(XTOIY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        DecompositionSolver solver = new LUDecomposition(XTOIX).getSolver();\n        if (!solver.isNonSingular()) \n        {\n            throw new SingularMatrixException();\n        }\n        RealVector XTY = getX().transpose().multiply(getY());\n        return solver.solve(XTY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix pinvXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector beta = pinvXTOIX.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix invXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        RealVector beta = invXTOIX.multiply(XTOIY);\n        return beta;\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.findFirst(new Evaluator.Id(id), this);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n\n    StringBuilder result = new StringBuilder();\n    int index = 0;\n    for (String customPattern : customPatterns) {\n        result.append(pattern.substring(index, pattern.indexOf(\"{\", index)));\n        result.append(customPattern);\n        index = pattern.indexOf(\"}\", index) + 1;\n    }\n    result.append(pattern.substring(index));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    ParsePosition pos = new ParsePosition(0);\n    StringBuilder sb = new StringBuilder();\n\n    while (pos.getIndex() < pattern.length()) {\n        pos = eatLeadingLiteral(pattern, pos, sb);\n        if (pos.getIndex() >= pattern.length()) {\n            break;\n        }\n        char c = pattern.charAt(pos.getIndex());\n        pos.next();\n\n        if (customPatterns != null && c == '%') {\n            String customPattern = customPatterns.get(customPatterns.size() - 1);\n            customPatterns.remove(customPatterns.size() - 1);\n            sb.append(customPattern);\n            continue;\n        }\n\n        if (c == '%') {\n            String quoted = appendQuotedString(pattern, pos, null, true);\n            if (quoted != null) {\n                sb.append(quoted);\n                continue;\n            }\n            if (pos.getIndex() >= pattern.length()) {\n                throw new IllegalArgumentException(\"Missing format character after %\");\n            }\n            char formatChar = pattern.charAt(pos.getIndex());\n            pos.next();\n            sb.append(formatChar);\n        } else {\n            sb.append(c);\n        }\n    }\n\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    int end = 0;\n    int customPatternIndex = 0;\n    if (customPatterns != null) {\n        customPatternIndex = customPatterns.size() - 1;\n    }\n    for (int i = 0; i < pattern.length(); ++i) {\n        if (pattern.charAt(i) == '%') {\n            end = i;\n            if (start == end) {\n                result.append('%');\n            } else {\n                result.append(pattern.substring(start, end));\n            }\n            if (customPatterns != null && customPatternIndex >= 0) {\n                result.append(customPatterns.get(customPatternIndex));\n                customPatternIndex--;\n            } else {\n                result.append('%');\n            }\n            start = end + 1;\n        }\n    }\n    if (start != end) {\n        result.append(pattern.substring(start, end + 1));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String fullPattern = pattern;\n    for (int i = customPatterns.size() - 1; i >= 0; i--) {\n        String customPattern = customPatterns.get(i);\n        if (fullPattern.contains(customPattern)) {\n            fullPattern = fullPattern.replaceFirst(customPattern, customPatterns.get(i));\n        }\n    }\n    return fullPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuffer buf = new StringBuffer();\n    int p = 0;\n    int custom = 0;\n    for (int i = 0; i < pattern.length(); i++) \n    {\n        char c = pattern.charAt(i);\n        if (c == ESCAPE) \n        {\n            if (i + 1 >= pattern.length() || pattern.charAt(i + 1) == ESCAPE) \n            {\n                buf.append(c);\n                i++;\n            } \n            else if (pattern.charAt(i + 1) == QUOTED_STRING) \n            {\n                String quotedPattern = appendQuotedString(pattern, next(new ParsePosition(i + 1)), null, false).toString();\n                if (customPatterns != null && customPatterns.size() > custom) \n                {\n                    String customPattern = customPatterns.get(custom);\n                    if (customPattern.equals(quotedPattern)) \n                    {\n                        buf.append(customPattern);\n                        custom++;\n                        i++;\n                        continue;\n                    }\n                }\n                buf.append(quotedPattern);\n                i++;\n            } \n            else \n            {\n                buf.append(c);\n            }\n        } \n        else \n        {\n            buf.append(c);\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    ParsePosition pos = new ParsePosition(0);\n    StringBuilder appendTo = new StringBuilder();\n\n    while (pos.getIndex() < pattern.length()) {\n        final String quoted = appendQuotedString(pattern, pos, appendTo, false);\n        if (quoted != null) {\n            continue;\n        }\n\n        final char c = pattern.charAt(pos.getIndex());\n        switch (c) {\n        case '$':\n            next(pos);\n            final String customFormat = customPatterns.get(customPatterns.size() - 1);\n            appendQuotedString(customFormat, pos, appendTo, false);\n            next(pos);\n            break;\n        default:\n            appendQuotedString(c + \"\", pos, appendTo, false);\n            next(pos);\n        }\n    }\n\n    return appendTo.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(\"M{\");\n    buffer.append(pattern.length());\n    buffer.append(\"}\");\n    buffer.append(pattern);\n    if (customPatterns.isEmpty() == false)\n    {\n        buffer.append(\"|\");\n        for (int i = 0; i < customPatterns.size(); i++)\n        {\n            buffer.append(customPatterns.get(i));\n        }\n    }\n    return buffer.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String fullPattern = pattern;\n    if (customPatterns != null) {\n        final StringBuilder buf = new StringBuilder();\n        final String[] splitPattern = pattern.split(\"\\\\{\");\n\n        int i = 0;\n        for (String part : splitPattern) {\n            if (i > 0) {\n                final char firstChar = part.charAt(0);\n                if (firstChar >= '0' && firstChar <= '9') {\n                    final int customIndex = Integer.parseInt(part.substring(0, 1));\n                    if (customIndex >= 0 && customIndex < customPatterns.size()) {\n                        buf.append(customPatterns.get(customIndex));\n                    } else {\n                        buf.append(part);\n                    }\n                } else {\n                    if (firstChar == '#') {\n                        final int customIndex = Integer.parseInt(part.substring(1, part.indexOf('}')));\n                        if (customIndex >= 0 && customIndex < customPatterns.size()) {\n                            buf.append(customPatterns.get(customIndex));\n                        } else {\n                            buf.append(part);\n                        }\n                    } else {\n                        buf.append(part);\n                    }\n                }\n            } else {\n                buf.append(part);\n            }\n            i++;\n        }\n        fullPattern = buf.toString();\n    }\n    return fullPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    appendQuotedString(pattern, pos, buf, false);\n    if (customPatterns.size() > 0) {\n        for (String customPattern : customPatterns) {\n            appendQuotedString(pattern, pos, buf, false);\n            next(pos);\n            appendQuotedString(customPattern, pos, buf, true);\n        }\n    }\n    appendQuotedString(pattern, pos, buf, false);\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    ParsePosition pos = new ParsePosition(0);\n    StringBuilder patternWithFormats = new StringBuilder(pattern);\n    int customPatternsIndex = 0;\n    while (pos.getIndex() < pattern.length()) {\n        if (pos.getIndex() == customPatternsIndex) {\n            patternWithFormats.append(customPatterns.get(customPatternsIndex));\n            customPatternsIndex++;\n        } else {\n            appendQuotedString(pattern, pos, patternWithFormats, false);\n        }\n    }\n    return patternWithFormats.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    \n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromType = fromArgs[i];\n    Type toType = toArgs[i];\n\n    if (fromType instanceof TypeVariable) {\n      fromType = typeVarMap.get(((TypeVariable<?>) fromType).getName());\n    }\n\n    if (toType instanceof TypeVariable) {\n      toType = typeVarMap.get(((TypeVariable<?>) toType).getName());\n    }\n\n    if (!matches(fromType, toType, typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] replaced = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, replaced);\n    return replaced[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] added = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, added);\n    return added[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] replaced = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, replaced);\n    return replaced[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] replaced = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, replaced);\n    return replaced[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] added = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, added);\n    return added[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] replaced = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, replaced);\n    return replaced[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] added = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, added);\n    return added[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] added = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, added);\n    return added[0];\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  return colorToNodeMap[graph.getDirectedGraphNode(node).getValue().color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = graph.getAnnotation(node);\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    Set<N> nodesInSamePartition = new HashSet<>();\n    nodesInSamePartition.add(node);\n\n    // Find all nodes that have the same color as the given node.\n    for (N otherNode : graph.getGraphvizNodes()) {\n        if (graph.getGraphvizNode(otherNode).getColor().equals(graph.getGraphvizNode(node).getColor()))\n        {\n            nodesInSamePartition.add(otherNode);\n        }\n    }\n\n    // Return the first node in the set as the super node.\n    return nodesInSamePartition.iterator().next();\n}",
      "public N getPartitionSuperNode(N node)  {\n  GraphColoring.Color c = graph.getGraphvizGraph().getGraphvizNode(node).getColor();\n  return colorToNodeMap[c.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (colorToNodeMap == null) {\n    return node;\n  }\n\n  Color color = graph.getGraphvizGraph().getGraphvizNodes().stream()\n      .filter(n -> n.getId().equals(node.toString()))\n      .map(n -> n.getColor())\n      .map(Integer::parseInt)\n      .map(Color::new)\n      .findFirst()\n      .orElseThrow(() -> new IllegalStateException(\"Node not found: \" + node));\n\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getAnnotation(node, GraphColoring.Color.class).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    for (int i = 0; i < colorToNodeMap.length; i++)\n    {\n        if (colorToNodeMap[i] == node)\n        {\n            return colorToNodeMap[i];\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  AdjacencyGraph<N, E> graph = getGraph();\n  GraphColoring.Color[] colorToNodeMap = graph.colorToNodeMap;\n  GraphColoring.Color color = colorToNodeMap[graph.getAnnotation(node)];\n  while(graph.getAnnotation(colorToNodeMap[color.value]) != color)\n  {\n    colorToNodeMap[graph.getAnnotation(colorToNodeMap[color.value])] = color;\n    color = colorToNodeMap[graph.getAnnotation(color.value)];\n  }\n  return colorToNodeMap[graph.getAnnotation(node)];\n}",
      "public N getPartitionSuperNode(N node)  {\n  for (int i = 0; i < colorToNodeMap.length; i++)\n  {\n    if (colorToNodeMap[i] != null)\n    {\n      if (graph.getDirectedGraphNode(colorToNodeMap[i]).getOutEdges().contains(graph.getDirectedGraphNode(node).getInEdge(i)))\n      {\n        return colorToNodeMap[i];\n      }\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = graph.getAnnotation(node, Color.class);\n    if (color.value == 0) {\n      color.value = color();\n      colorToNodeMap[color.value] = node;\n    }\n    return colorToNodeMap[color.value];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n        while (true) {\n\n            // improve integral with a larger number of steps\n            final double t = stage(n);\n\n            // estimate error\n            final double delta = FastMath.abs(t - oldt);\n            final double limit =\n                FastMath.max(getAbsoluteAccuracy(),\n                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n            // check convergence\n            if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n                return t;\n            }\n\n            // prepare next iteration\n            double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n            n = FastMath.max((int) (ratio * n), n + 1);\n            oldt = t;\n            iterations.incrementCount();\n\n        }\n\n    }",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n        while (true) {\n\n            // improve integral with a larger number of steps\n            final double t = stage(n);\n\n            // estimate error\n            final double delta = FastMath.abs(t - oldt);\n            final double limit =\n                FastMath.max(getAbsoluteAccuracy(),\n                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n            // check convergence\n            if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n                return t;\n            }\n\n            // prepare next iteration\n            double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n            n = FastMath.max((int) (ratio * n), n + 1);\n            oldt = t;\n            iterations.incrementCount();\n\n        }\n\n    }",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n        while (true) {\n\n            // improve integral with a larger number of steps\n            final double t = stage(n);\n\n            // estimate error\n            final double delta = FastMath.abs(t - oldt);\n            final double limit =\n                FastMath.max(getAbsoluteAccuracy(),\n                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n            // check convergence\n            if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n                return t;\n            }\n\n            // prepare next iteration\n            double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n            n = FastMath.max((int) (ratio * n), n + 1);\n            oldt = t;\n            iterations.incrementCount();\n\n        }\n\n    }",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n        while (true) {\n\n            // improve integral with a larger number of steps\n            final double t = stage(n, f);\n\n            // estimate error\n            final double delta = FastMath.abs(t - oldt);\n            final double limit =\n                FastMath.max(getAbsoluteAccuracy(),\n                             getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n            // check convergence\n            if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n                return t;\n            }\n\n            // prepare next iteration\n            double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n            n = FastMath.max((int) (ratio * n), n + 1);\n            oldt = t;\n            iterations.incrementCount();\n\n        }\n\n    }",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n, f);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n, f);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n, f);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}",
      "public double integrate(UnivariateFunction f)  {\n    int n = 2;\n    while (true) {\n\n        // improve integral with a larger number of steps\n        final double t = stage(n, f);\n\n        // estimate error\n        final double delta = FastMath.abs(t - oldt);\n        final double limit =\n            FastMath.max(getAbsoluteAccuracy(),\n                         getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5);\n\n        // check convergence\n        if ((iterations.getCount() + 1 >= getMinimalIterationCount()) && (delta <= limit)) {\n            return t;\n        }\n\n        // prepare next iteration\n        double ratio = FastMath.min(4, FastMath.pow(delta / limit, 0.5 / abscissas.length));\n        n = FastMath.max((int) (ratio * n), n + 1);\n        oldt = t;\n        iterations.incrementCount();\n\n    }\n\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Iterator iterator1 = keys1.iterator();\n    Set keys2 = map2.keySet();\n    Iterator iterator2 = keys2.iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key1);\n        Paint p2 = (Paint) map2.get(key2);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.containsAll(keys2)) {\n        return false;\n    }\n    for (Comparable key : keys1) {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) return true;\n    if (map1.size() != map2.size()) return false;\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.containsAll(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Iterator i = keys.iterator(); i.hasNext();) \n    {\n        Comparable key = (Comparable) i.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    Iterator iterator1 = keys1.iterator();\n    Iterator iterator2 = keys2.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        Paint p1 = (Paint) map1.get(key1);\n        Paint p2 = (Paint) map2.get(key2);\n        if (!ObjectUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  String replacement = getReplacement(expr.getString());\n  if (replacement != null) {\n    Node replacementNode = IR.string(replacement).srcref(expr);\n    parent.replaceChild(expr, replacementNode);\n    recordReplacement(expr, replacement);\n    reportCodeChange();\n    return replacementNode;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    switch (expr.getType()) {\n        case Token.ADD:\n            Node left = expr.getFirstChild();\n            Node right = left.getNext();\n            Node prefix = buildReplacement(left, null, new StringBuilder());\n            return buildReplacement(right, prefix, new StringBuilder());\n        case Token.STRING:\n            String key = expr.getString();\n            String replacement = getReplacement(key);\n            if (replacement == null) {\n                recordReplacement(expr, key);\n            } else {\n                Node replacementNode = IR.string(replacement).srcref(expr);\n                parent.replaceChild(expr, replacementNode);\n                reportCodeChange();\n            }\n            return null;\n        default:\n            StringBuilder keyBuilder = new StringBuilder();\n            Node replacement = buildReplacement(expr, null, keyBuilder);\n            String key = keyBuilder.toString();\n            String replacementValue = getReplacement(key);\n            if (replacementValue == null) {\n                recordReplacement(expr, key);\n                return replacement;\n            }\n            Node replacementNode = IR.string(replacementValue).srcref(expr);\n            parent.replaceChild(expr, replacementNode);\n            reportCodeChange();\n            return null;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    switch (expr.getType()) {\n        case Token.STRING:\n            String replacement = getReplacement(expr.getString());\n            if (replacement != null) {\n                return IR.string(replacement).srcref(expr);\n            }\n            break;\n        case Token.ADD:\n            Node left = expr.getFirstChild();\n            Node right = left.getNext();\n            Node prefix = buildReplacement(left, right, new StringBuilder());\n            return buildReplacement(right, prefix, new StringBuilder());\n        default:\n            String key = placeholderToken;\n            StringBuilder keyBuilder = new StringBuilder(key);\n            Node prefix = buildReplacement(expr, null, keyBuilder);\n            recordReplacement(expr, key);\n            return prefix;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    StringBuilder keyBuilder = new StringBuilder();\n    Node prefix = buildReplacement(expr, null, keyBuilder);\n    String key = keyBuilder.toString();\n\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n        Node replacementNode = IR.string(replacement);\n        parent.replaceChild(expr, prefix);\n        parent.replaceChild(prefix, replacementNode);\n        recordReplacement(replacementNode, key);\n        reportCodeChange();\n        return replacementNode;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  String key = buildReplacement(expr, null, new StringBuilder()).getString();\n  String replacement = getReplacement(key);\n  if (replacement != null) {\n    recordReplacement(expr, key);\n    return new StringLiteral(replacement).srcref(expr);\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String key = buildReplacement(expr, null, new StringBuilder()).toString();\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      recordReplacement(expr, key);\n      return IR.string(replacement).srcref(expr);\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    StringBuilder keyBuilder = new StringBuilder();\n    Node prefix = buildReplacement(expr, null, keyBuilder);\n    String key = keyBuilder.toString();\n\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n        recordReplacement(expr, key);\n        return IR.string(replacement).srcref(expr);\n    } else {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isCall()) \n  {\n    Node callee = expr.getFirstChild();\n    if (callee.isName()) \n    {\n      String name = callee.getString();\n      Config config = findMatching(name);\n      if (config != null) \n      {\n        doSubstitutions(t, config, expr);\n        return expr.cloneTree();\n      }\n    }\n    return expr;\n  }\n  if (expr.isGetProp()) \n  {\n    Node target = expr.getFirstChild();\n    String propName = expr.getLastChild().getString();\n    Config config = findMatchingClass(getJSType(target), methods.get(propName));\n    if (config != null) \n    {\n      doSubstitutions(t, config, expr);\n      return expr.cloneTree();\n    }\n    return expr;\n  }\n\n  String key = buildReplacement(expr, null, new StringBuilder()).toString();\n  return getReplacement(key);\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isName()) {\n    String replacement = getReplacement(expr.getString());\n    if (replacement != null) {\n      parent.replaceChild(expr, IR.string(replacement).srcref(expr));\n      recordReplacement(expr, replacement);\n      reportCodeChange();\n      return IR.string(replacement);\n    }\n  }\n  if (expr.isString()) {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      parent.replaceChild(expr, IR.string(replacement).srcref(expr));\n      recordReplacement(expr, replacement);\n      reportCodeChange();\n      return IR.string(replacement);\n    }\n  }\n  if (expr.getType() == Token.ADD) {\n    Node left = expr.getFirstChild();\n    Node right = left.getNext();\n    Node replacement = buildReplacement(right, expr, keyBuilder);\n    if (replacement != left) {\n      parent.replaceChild(expr, replacement);\n      recordReplacement(expr, keyBuilder.toString());\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  keyBuilder.append(placeholderToken);\n  parent.replaceChild(expr, IR.add(\n      IR.string(placeholderToken), expr.cloneTree()));\n  recordReplacement(expr, placeholderToken);\n  reportCodeChange();\n  return IR.string(placeholderToken);\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  String key = buildReplacement(expr, null, new StringBuilder()).getString();\n  String replacement = getReplacement(key);\n  if (replacement != null) {\n    recordReplacement(expr, key);\n    return new StringLiteral(replacement);\n  }\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    double[] result = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, result, 0, coefficients.length);\n    return result;\n}",
      "public double[] getCoefficients()  {\n    double[] temp = new double[coefficients.length];\n    for (int i = 0; i < coefficients.length; i++)\n    {\n        temp[i] = coefficients[i];\n    }\n    return temp;\n}",
      "public double[] getCoefficients()  {\n    double[] temp = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, temp, 0, coefficients.length);\n    return temp;\n}",
      "public double[] getCoefficients()  {\n    double[] temp = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, temp, 0, coefficients.length);\n    return temp;\n}",
      "public double[] getCoefficients()  {\n    double[] temp = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, temp, 0, coefficients.length);\n    return temp;\n}",
      "public double[] getCoefficients()  {\n    double[] coefficientsCopy = new double[coefficients.length];\n    for (int i = 0; i < coefficients.length; i++) {\n        coefficientsCopy[i] = coefficients[i];\n    }\n    return coefficientsCopy;\n}",
      "public double[] getCoefficients()  {\n    double[] copy = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, copy, 0, coefficients.length);\n    return copy;\n}",
      "public double[] getCoefficients()  {\n    double[] coefficientsCopy = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, coefficientsCopy, 0, coefficients.length);\n    return coefficientsCopy;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isVar() && node.hasOneChild()) {\n      Node sibling = node.getNextSibling();\n      if (sibling != null && sibling.isComment()) {\n        Comment comment = sibling.getComment();\n        if (comment != null) {\n          JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, node);\n          parsedComments.add(comment);\n          if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n            JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n            if (info != null) {\n              validateTypeAnnotations(info, node);\n              String desc = info.getDescription();\n              if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n              } else {\n                builder.setDesc(desc);\n              }\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = handleJsDoc(node, null);\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null && !desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.trim());\n        builder.setIsHidden(info.isDeprecated());\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = handleJsDoc(node, null);\n    if (jsDocInfo != null) {\n      if (jsDocInfo.getDesc() != null) {\n        builder.setDesc(jsDocInfo.getDesc());\n      } else {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isVar() && node.hasOneChild()) {\n      Node helpVarNode = node.getFirstChild();\n      if (helpVarNode.isName()) {\n        String name = helpVarNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n          Node valueNode = helpVarNode.getNextSibling();\n          if (valueNode.isString()) {\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isVar() && node.hasOneChild()) {\n      Node child = node.getFirstChild();\n      if (child.isName() && child.hasOneChild()) {\n        Node grandChild = child.getFirstChild();\n        if (grandChild.isString()) {\n          String desc = grandChild.getString();\n          if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n            builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n            builder.setIsHidden(true);\n          } else {\n            builder.setDesc(desc);\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = handleJsDoc(node, null);\n    if (info != null) {\n      validateDescription(builder, info);\n      return true;\n    } else {\n      return false;\n    }\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = handleJsDoc(node, node);\n    if (info != null) {\n      if (info.getDescription() != null) {\n        builder.setDesc(info.getDescription().getContent());\n        if (info.isDeprecated()) {\n          builder.setIsHidden(true);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isVar()) {\n      Node nameNode = node.getFirstChild();\n      String name = nameNode.getString();\n      if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n        Node valueNode = nameNode.getFirstChild();\n        String desc = extractStringFromStringExprNode(valueNode);\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null && info.getDescription() != null) {\n      builder.setDesc(info.getDescription());\n      return true;\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, node);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node);\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, node);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n        if (info != null) {\n          validateTypeAnnotations(info, node);\n        }\n        builder.setDesc(info.getDescription().replaceFirst(\"Hidden: \", \"\"));\n        builder.setIsHidden(info.isDeprecated());\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSION_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        SimpleRegression regression = new SimpleRegression();\n        for (int i = 0; i < xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        double cov = regression.getCovariance();\n        if (biasCorrected) {\n            cov = cov * (xArray.length - 1) / xArray.length;\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    SimpleRegression regression = new SimpleRegression();\n    if (xArray.length != yArray.length) {\n        throw new IllegalArgumentException(\"Arrays must be of the same length\");\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        for(int i=0; i<xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        return regression.getCovariance(biasCorrected);\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                   xArray.length, 2);\n    }\n    SimpleRegression regression = new SimpleRegression();\n    for(int i=0; i<xArray.length; i++) {\n        regression.addData(xArray[i], yArray[i]);\n    }\n    double covariance = regression.getCovariance();\n    if( biasCorrected ) {\n        covariance = (covariance * (xArray.length - 1)) / xArray.length;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    SimpleRegression regression = new SimpleRegression();\n    if (xArray.length != yArray.length) {\n        throw new IllegalArgumentException(\"Arrays must be of equal length\");\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        for(int i=0; i<xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        if (biasCorrected) {\n            return regression.getCovariance() / (regression.getN() - 1);\n        } else {\n            return regression.getCovariance();\n        }\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                n, 2);\n    }\n\n    SimpleRegression regression = new SimpleRegression();\n    for(int i=0; i<xArray.length; i++) {\n        regression.addData(xArray[i], yArray[i]);\n    }\n    double covariance = regression.getCovariance();\n\n    if (biasCorrected) {\n        covariance -= (regression.getSumVarX() * regression.getSumVarY() / regression.getN());\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                   xArray.length, 2);\n    }\n    SimpleRegression regression = new SimpleRegression();\n    for(int i=0; i<xArray.length; i++) {\n        regression.addData(xArray[i], yArray[i]);\n    }\n    if (biasCorrected) {\n        return regression.getCovariance() / (regression.getN() - 1);\n    } else {\n        return regression.getCovariance();\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    SimpleRegression regression = new SimpleRegression();\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        for(int i=0; i<xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        return regression.getCovariance(biasCorrected);\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                n, 2);\n    }\n\n    SimpleRegression regression = new SimpleRegression();\n    for(int i=0; i<xArray.length; i++) {\n        regression.addData(xArray[i], yArray[i]);\n    }\n\n    if(biasCorrected) {\n        return regression.getCovariance() * ((xArray.length - 1) / xArray.length);\n    } else {\n        return regression.getCovariance();\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    SimpleRegression regression = new SimpleRegression();\n    if (xArray.length != yArray.length) {\n        throw new IllegalArgumentException(\"Arrays must be of the same length\");\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        for(int i=0; i<xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        if (biasCorrected) {\n            return regression.getCovariance() / (regression.getN() - 1);\n        } else {\n            return regression.getCovariance();\n        }\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    SimpleRegression regression = new SimpleRegression();\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        for(int i=0; i<xArray.length; i++) {\n            regression.addData(xArray[i], yArray[i]);\n        }\n        if(biasCorrected){\n            return regression.getSumXX() / (regression.getN() - 1);\n        }else{\n            return regression.getSumXX() / regression.getN();\n        }\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        pos += skipped;\n    } else {\n        throw new IllegalArgumentException();\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) \n    {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    final long skipped = in.skip(Math.min(value, Integer.MAX_VALUE));\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) \n    {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    final int max = (int) Math.min(value, Integer.MAX_VALUE);\n    int total = 0;\n\n    while (total < max) \n    {\n        int len = max - total;\n        if (len > this.tmpbuf.length) \n        {\n            len = this.tmpbuf.length;\n        }\n        final int read = in.read(this.tmpbuf, 0, len);\n        if (read == -1) \n        {\n            break;\n        }\n        total += read;\n    }\n    pos += total;\n    count(total);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    ensureOpen();\n    final int max = (int) Math.min(value, Integer.MAX_VALUE);\n    int total = 0;\n\n    while (total < max) {\n        int len = max - total;\n        if (len > this.tmpbuf.length) {\n            len = this.tmpbuf.length;\n        }\n        final int read = in.read(this.tmpbuf, 0, len);\n        if (read == -1) {\n            this.entryEOF = true;\n            break;\n        }\n        total += read;\n    }\n    bytesRead += total;\n}",
      "private void realSkip(final long value) throws IOException  {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    throw new IOException(\"Unexpected end of underlying stream\");\n                }\n                skipped += x;\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }",
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                throw new EOFException(\"Unexpected end of stream, expected: \" + value + \" bytes, skipped: \" + skipped);\n            }\n            skipped += x;\n        }\n        pos += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n        if (value >= 0) {\n            long skipped = 0L;\n            while (skipped < value) {\n                final int rem = (int) (value - skipped);\n                final int read = in.read(skipBuf, 0, rem < skipBuf.length ? rem : skipBuf.length);\n                if (read == -1) {\n                    return;\n                }\n                pos += read;\n                skipped += read;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }",
      "private void realSkip(final long value) throws IOException  {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return;\n                }\n                skipped += x;\n            }\n            pos += skipped;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                throw new IOException(\"Unexpected end of ZIP archive\");\n            }\n            skipped += x;\n        }\n        pos += skipped;\n    } else {\n        throw new IllegalArgumentException();\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target.getClass(), fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + target.getClass());\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target.getClass(), fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + target.getClass().getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target.getClass(), fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + target.getClass());\n    }\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    return readDeclaredField(target, fieldName, forceAccess, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    return readDeclaredField(target, fieldName, forceAccess, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target.getClass(), fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + target.getClass().getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else \n        {\n            sb.append(part);\n        }\n    }\n    return GoogleJsMessageIdGenerator.FP.fingerprint(sb.toString())\n        .toString(Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts)\n    if (part instanceof PlaceholderReference)\n      sb.append(((PlaceholderReference) part).getName());\n    else\n      sb.append(part);\n  String tcValue = sb.toString();\n  return String.valueOf(MessageId.generateId(tcValue, \"\"));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        }\n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return Long.toHexString(MessageId.generateId(tcValue, tcValue)).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n\n  return String.valueOf(FP.fingerprint(sb.toString()));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts)\n  {\n    sb.append(part);\n  }\n  String tcValue = sb.toString();\n\n  return String.valueOf(\n      MessageId.generateId(tcValue, null));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) \n  {\n    if (part instanceof PlaceholderReference) \n    {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else \n    {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n  return Long.toHexString(FP.fingerprint(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts)\n  {\n    if (part instanceof PlaceholderReference) \n    {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n        CaseFormat.UPPER_UNDERSCORE,\n        ((PlaceholderReference) part).getName()));\n    } else\n    {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n  return GoogleJsMessageIdGenerator.FP.fingerprint(tcValue)\n    .toBase64().replace(\"/\", \"_\")\n    .replace(\"+\", \"-\");\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n\n  String tcValue = sb.toString();\n  return String.valueOf(\n      MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        }\n        else\n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return Long.toString(FP.fingerprint(tcValue), 36);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return GoogleJsMessageIdGenerator.fingerprint(tcValue);\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.size();\n    long currentPosition = endPosition - minDistanceFromEnd;\n    if (currentPosition < 0) {\n        currentPosition = 0;\n    }\n    archive.position(currentPosition);\n\n    final long distanceToCover = maxDistanceFromEnd - minDistanceFromEnd;\n    final byte[] signatureBuffer = new byte[sig.length];\n\n    while (currentPosition < endPosition) {\n        if (archive.read(signatureBuffer, 0, sig.length) == sig.length) {\n            if (Arrays.equals(sig, signatureBuffer)) {\n                return true;\n            }\n        }\n        currentPosition++;\n        archive.position(currentPosition);\n    }\n\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.size();\n    long currentPosition = endPosition - minDistanceFromEnd;\n    if (currentPosition < 0) {\n        currentPosition = 0;\n    }\n    archive.position(currentPosition);\n    while (currentPosition < endPosition) {\n        if (verifySignature(sig)) {\n            return true;\n        }\n        currentPosition++;\n        archive.position(currentPosition);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    long startPosition = currentPosition - minDistanceFromEnd;\n    if (startPosition < 0) {\n        startPosition = 0;\n    }\n    archive.position(startPosition);\n    while (currentPosition - archive.position() <= maxDistanceFromEnd) {\n        if (checkSignature(sig)) {\n            return true;\n        }\n        currentPosition--;\n        archive.position(currentPosition);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endOfArchivePosition = archive.size();\n    final long minPosition = endOfArchivePosition - maxDistanceFromEnd;\n    final long maxPosition = endOfArchivePosition - minDistanceFromEnd;\n    archive.position(maxPosition);\n    final int sigSize = sig.length;\n    byte[] buffer = new byte[sigSize];\n    while (archive.position() >= minPosition) {\n        archive.read(buffer, 0, sigSize);\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n        archive.position((int) archive.position() - 1);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endOfFile = archive.size();\n    final long initialPosition = archive.position();\n    long position = endOfFile - minDistanceFromEnd;\n    if (position > initialPosition) {\n        position -= maxDistanceFromEnd;\n    }\n    if (position < initialPosition) {\n        return false;\n    }\n    archive.position(position);\n    final byte[] signature = new byte[sig.length];\n    archive.readFully(signature);\n    return Arrays.equals(sig, signature);\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.size();\n    final long minPosition = endPosition - maxDistanceFromEnd;\n    final long startPosition = Math.max(minPosition, endPosition - minDistanceFromEnd);\n    archive.seek(startPosition);\n    final byte[] signatureBuffer = new byte[sig.length];\n    while (archive.read(signatureBuffer) == sig.length) {\n        if (Arrays.equals(sig, signatureBuffer)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.size();\n    final long minPosition = endPosition - maxDistanceFromEnd;\n    long currentPosition = archive.position();\n    if (currentPosition < minPosition) {\n        return false;\n    }\n    archive.position(currentPosition - minDistanceFromEnd);\n    final byte[] buffer = new byte[sig.length];\n    archive.read(buffer, 0, sig.length);\n    for (int i = 0; i < sig.length; i++) {\n        if (sig[i] != buffer[i]) {\n            archive.position(currentPosition);\n            return false;\n        }\n    }\n    archive.position(currentPosition);\n    return true;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long startPosition = currentPosition - minDistanceFromEnd;\n    if (startPosition < 0) {\n        startPosition = 0;\n    }\n    final long distance = maxDistanceFromEnd - minDistanceFromEnd;\n    if (distance <= 0) {\n        throw new IllegalStateException(\"invalid range: \" + minDistanceFromEnd + \" - \" + maxDistanceFromEnd);\n    }\n    archive.position(startPosition);\n    for (long i = 0; i < distance; i++) {\n        if (archive.read() == sig[i]) {\n            if (archive.read() == sig[i + 1]) {\n                if (archive.read() == sig[i + 2]) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    long startPosition = currentPosition - maxDistanceFromEnd;\n    if (startPosition < 0) {\n        startPosition = 0;\n    }\n    archive.position(startPosition);\n    long endPosition = startPosition - minDistanceFromEnd;\n    if (endPosition < 0) {\n        endPosition = 0;\n    }\n    while (currentPosition >= endPosition) {\n        if (compareBytes(sig, (int) (currentPosition - sig.length), (int) currentPosition) == 0) {\n            return true;\n        }\n        currentPosition--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endOfFilePosition = archive.size();\n    long currentPosition = endOfFilePosition;\n\n    while (currentPosition >= minDistanceFromEndFromEnd) {\n        final long newPosition = currentPosition - maxDistanceFromEnd;\n        archive.position(newPosition);\n        if (Arrays.equals(sig, archive.read(sig.length))) {\n            return true;\n        }\n        currentPosition = newPosition;\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n\tAxisLocation location = getDomainAxisLocation(index);\n\tRectangleEdge result = Plot.resolveDomainAxisLocation(location,\n\t\t\tthis.orientation);\n\tif (result == null) {\n\t\tresult = RectangleEdge.opposite(getDomainAxisEdge(0));\n\t}\n\treturn result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n\n    // Check for the special case where both axes are on the same edge\n    if ((orientation == PlotOrientation.HORIZONTAL && location == AxisLocation.TOP_OR_LEFT) ||\n        (orientation == PlotOrientation.VERTICAL && location == AxisLocation.LEFT_OR_BOTTOM))\n    {\n        return getRangeAxisEdge(0);\n    }\n\n    // Otherwise, use the standard logic\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, orientation);\n\n    if (result == null)\n    {\n        result = RectangleEdge.opposite(getRangeAxisEdge(0));\n    }\n\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge(index));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n\tAxisLocation location = getDomainAxisLocation(index);\n\tPlotOrientation orientation = getOrientation();\n\tif (location == AxisLocation.TOP_OR_RIGHT) {\n\t\tif (orientation == PlotOrientation.HORIZONTAL) {\n\t\t\treturn RectangleEdge.RIGHT;\n\t\t} else if (orientation == PlotOrientation.VERTICAL) {\n\t\t\treturn RectangleEdge.TOP;\n\t\t}\n\t} else if (location == AxisLocation.TOP_OR_LEFT) {\n\t\tif (orientation == PlotOrientation.HORIZONTAL) {\n\t\t\treturn RectangleEdge.LEFT;\n\t\t} else if (orientation == PlotOrientation.VERTICAL) {\n\t\t\treturn RectangleEdge.TOP;\n\t\t}\n\t} else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n\t\tif (orientation == PlotOrientation.HORIZONTAL) {\n\t\t\treturn RectangleEdge.RIGHT;\n\t\t} else if (orientation == PlotOrientation.VERTICAL) {\n\t\t\treturn RectangleEdge.BOTTOM;\n\t\t}\n\t} else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n\t\tif (orientation == PlotOrientation.HORIZONTAL) {\n\t\t\treturn RectangleEdge.LEFT;\n\t\t} else if (orientation == PlotOrientation.VERTICAL) {\n\t\t\treturn RectangleEdge.BOTTOM;\n\t\t}\n\t}\n\treturn null;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n\tAxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getOrientation();\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n    \n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream != null)\n    {\n        if (_bufferedData != null)\n        {\n            try\n            {\n                return new ByteArrayInputStream(_bufferedData, 0, _bufferedStart + _bufferedLength);\n            }\n            catch (OutOfMemoryError e)\n            {\n                // Can't happen, but just in case...\n                return new ByteArrayInputStream(_bufferedData, 0, _bufferedStart + _bufferedLength);\n            }\n        }\n        return _originalStream;\n    }\n    else if (_bufferedData != null)\n    {\n        try\n        {\n            return new ByteArrayInputStream(_bufferedData, 0, _bufferedStart + _bufferedLength);\n        }\n        catch (OutOfMemoryError e)\n        {\n            // Can't happen, but just in case...\n            return new ByteArrayInputStream(_bufferedData, 0, _bufferedStart + _bufferedLength);\n        }\n    }\n    return null;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        if (_bufferedData == null) \n        {\n            return null;\n        }\n        else \n        {\n            try \n            {\n                return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n            } \n            catch (Exception e) \n            {\n                // should not be thrown, but just in case\n                return null;\n            }\n        }\n    }\n    else \n    {\n        if (_bufferedData == null) \n        {\n            return _originalStream;\n        }\n        else \n        {\n            try \n            {\n                InputStream in = _originalStream;\n                if (\"file\".equals(in.getClass().getSimpleName())) \n                {\n                    return new ConcatInputStream(in, new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n                }\n                else\n                {\n                    return new ConcatInputStream(in, new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n                }\n            } \n            catch (Exception e) \n            {\n                // should not be thrown, but just in case\n                return null;\n            }\n        }\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null)\n    {\n        if (_bufferedData != null)\n        {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return new ByteArrayInputStream(new byte[0]);\n    }\n\n    if (_bufferedData != null)\n    {\n        try {\n            InputStream in = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n            return new TeeInputStream(_originalStream, in);\n        } catch (IOException ioe)\n        {\n            throw new RuntimeException(ioe);\n        }\n    }\n\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        if (_bufferedData == null) {\n            return _originalStream;\n        }\n        try {\n            if (_bufferedStart == 0 && _bufferedLength == 0) {\n                return new ByteArrayInputStream(_bufferedData);\n            }\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        } catch (OutOfMemoryError e) {\n            // in case array copy fails, fall back to streaming\n            return _originalStream;\n        }\n    }\n    return _decoratedInputStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        InputStream in = _originalStream;\n        if (_bufferedData != null) {\n            in = new ByteArrayInputStream(_bufferedData, 0, _bufferedLength);\n        }\n        return in;\n    } else {\n        if (_bufferedData != null) {\n            return new ByteArrayInputStream(_bufferedData, 0, _bufferedLength);\n        }\n    }\n    return null;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        if (_bufferedData != null) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return _decoratedInput;\n    }\n    return _decoratedInput != null ? _decoratedInput : _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    if (_bufferedData == null) \n    {\n        return _inputDecorator._decorate(_decoratedStream, _ctxt);\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        try {\n            return _decorate(_originalStream, _ctxt);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }\n    return _bufferedData;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        if (_bufferedData == null) \n        {\n            return null;\n        }\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    if (_bufferedData != null) \n    {\n        try \n        {\n            OutputStream out = _createDataOutputWrapper(_originalStream);\n            out.write(_bufferedData, _bufferedStart, _bufferedLength);\n            out.flush();\n        } \n        catch (IOException e) \n        {\n            // Ignore exception; just return original stream\n        }\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        try {\n            return _decorate(_originalStream, _ctxt);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    } else {\n        if (_bufferedData == null) {\n            return null;\n        }\n        final InputStream in = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        try {\n            return _decorate(in, _ctxt);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // check arguments...delegated\n    // check if the section exists\n    if (section >= 0 && section < getDataset().getItemCount()) {\n        Comparable key = getDataset().getKey(section);\n        if (key != null) {\n            result = key;\n        }\n    }\n    // generate a unique key if necessary\n    else {\n        // generate a unique key - we use the default group as the key\n        Comparable group = getDataset().getGroup(section);\n        if (group == null) {\n            group = getDataset().getDefaultGroup();\n        }\n        result = group;\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionIndexMap.get(section);\n\n    // generate a new key if necessary\n    if (key == null) {\n        key = generateSectionKey(section);\n        this.sectionIndexMap.put(section, key);\n        this.indexSectionMap.put(key, section);\n    }\n\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    Comparable key = getKey(section);\n    if (key != null) {\n        result = key;\n    }\n    else {\n        // generate a key.  Note that we can't use a simple integer\n        // index, because it would be easy to accidentally duplicate keys\n        // if the user does things in the wrong order.\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = this.keys.get(section);\n    if (result == null)\n    {\n        int category = getCategory(section);\n        Comparable categoryKey = getCategoryKey(category);\n        if (categoryKey == null)\n        {\n            throw new IllegalStateException(\"No category key found for section \" + section + \" (category = \" + category + \").\");\n        }\n        result = categoryKey;\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    Comparable k = getKey(section);\n    if (k != null) \n    {\n        result = k;\n    }\n    else \n    {\n        DrawingSupplier ds = getDrawingSupplier();\n        if (ds != null) \n        {\n            result = ds.getNextPieKey();\n        }\n        else \n        {\n            result = new SimplePieKey(\"Untitled Pie\", section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        // generate a new key\n        key = generateSectionKey(section);\n        this.sectionKeys.put(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // check arguments...delegated\n    // fetch the key...\n    result = getSeries(section).getKey();\n    // generate a key if necessary...\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}\n\n// This method is called by the PiePlot class to get the outline stroke for a section.",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) {\n        if (this.extract == TableOrder.BY_ROW) {\n            result = this.source.getColumnKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) {\n            result = this.source.getRowKey(section);\n        }\n    }\n    if (result == null) {\n        // generate a unique key for this section\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = this.keyToGroupMap.getGroup(section);\n    if (result == null) {\n        // generate a key for the section\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.keyToGroupMap.getGroup(this.categoryToPieDataset.getKey(section));\n    if (key == null)\n    {\n        key = this.keyToGroupMap.getKey(this.categoryToPieDataset.getRowKey(section));\n    }\n    if (key == null)\n    {\n        key = this.keyToGroupMap.getKey(this.categoryToPieDataset.getColumnKey(section));\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            Object ob = _currentObject();\n            return (ob instanceof Number) && Double.isNaN(((Number)ob).doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Number) _currentObject());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Float) _currentObject());\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false; // Integer can't be NaN\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            Object obj = _currentObject();\n            if (obj instanceof Number) {\n                Number number = (Number) obj;\n                return number.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return JsonToken.VALUE_NUMBER_FLOAT == _currToken && Float.isNaN((Float) _currentObject());\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT\n                && Float.isNaN((Float)_currentObject());\n        }",
      "@Override\n        public boolean isNaN()  {\n            Object ob = _currentObject();\n            if (ob instanceof Number) {\n                return Double.isNaN(((Number) ob).doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            Object value = _currentObject();\n            return (value instanceof Double && Double.isNaN((Double) value)) \n                || (value instanceof Float && Float.isNaN((Float) value)) \n                || (value instanceof BigDecimal && ((BigDecimal) value).doubleValue() \n                   == Double.longBitsToDouble(0x7ff0_0000_0000_0001L));\n        }",
      "@Override\n        public boolean isNaN()  {\n            Object obj = _currentObject();\n            if (obj instanceof Double) {\n                return Double.isNaN((Double) obj);\n            } else if (obj instanceof Float) {\n                return Float.isNaN((Float) obj);\n            } else {\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            Object value = _currentObject();\n            if (value instanceof Number) {\n                Number n = (Number) value;\n                return Double.isNaN(n.doubleValue());\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    return startsWith(str, prefix, ignoreCase);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    return startsWith(str, prefix, ignoreCase, null);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    return str != null && prefix != null && str.startsWith(prefix.toString(), ignoreCase);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int prefixOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, prefixOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    return StringUtils.startsWith(str, prefix, ignoreCase);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_STRING) \n    {\n        String result = peekedString;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        String result = peekedString;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        String result = peekedString;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else if (p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextUnquotedValue();\n        String result = peekedString;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_STRING)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    else if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Long.toString(peekedLong);\n    }\n    else if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED)\n    {\n        if (p == PEEKED_UNQUOTED)\n        {\n            peekedString = nextUnquotedValue();\n        }\n        else\n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    }\n\n    if (p == PEEKED_LONG) {\n      peekedString = Long.toString(peekedLong);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        result = peekedString;\n    } else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_STRING) \n    {\n        String result = peekedString;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n    } else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    String result = peekedString; // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_STRING)\n    {\n        String result = peekedString;\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED)\n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    else if (p == PEEKED_UNQUOTED)\n    {\n        peekedString = nextUnquotedValue();\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            result = nextUnquotedValue();\n        } else {\n            result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextUnquotedValue();\n    } else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_STRING)\n    {\n        String result = peekedString;\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED)\n    {\n        if (p == PEEKED_UNQUOTED)\n        {\n            peekedString = nextUnquotedValue();\n        }\n        else\n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  { \n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  { \n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  { \n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  { \n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  { \n    if (str == null) {\n        return null;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        } else if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        } else if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        return (s2 == null);\n    }\n    if (s2 == null)\n    {\n        return false;\n    }\n    if (s1.length != s2.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!equal(s1[i], s2[i]))\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        return (s2 == null);\n    }\n    if (s2 == null)\n    {\n        return false;\n    }\n    if (s1.length != s2.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!equal(s1[i], s2[i]))\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        return (s2 == null);\n    }\n    if (s2 == null)\n    {\n        return false;\n    }\n    if (s1.length != s2.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++)\n    {\n        if (!Arrays.equals(s1[i].getBounds2D().getCenterX(), s2[i].getBounds2D().getCenterX()) || !Arrays.equals(s1[i].getBounds2D().getCenterY(), s2[i].getBounds2D().getCenterY()))\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n\n    if (s2 == null) \n    {\n        return false;\n    }\n\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        return (s2 == null);\n    }\n    if (s2 == null)\n    {\n        return false;\n    }\n    if (s1.length != s2.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!equal(s1[i], s2[i]))\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) \n    {\n        lastSymbolFile = symbolName;\n        Integer index = symbolMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolFileIndex = index;\n        }\n        else \n        {\n            lastSymbolFileIndex = symbolMap.size();\n            symbolMap.put(symbolName, lastSymbolFileIndex);\n        }\n    }\n    return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) \n    {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) \n      {\n        lastSymbolFileIndex = index;\n      } else \n      {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolFile) \n  {\n    lastSymbolFile = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolFileIndex = index;\n    } \n    else \n    {\n      lastSymbolFileIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolFileIndex);\n    }\n  }\n  return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n        lastSymbolFile = symbolName;\n        Integer index = nameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolIndex = index;\n        } else {\n            lastSymbolIndex = nameMap.size();\n            nameMap.put(symbolName, lastSymbolIndex);\n        }\n    }\n    return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) \n    {\n        lastSymbolFile = symbolName;\n        Integer index = symbolMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolIndex = index;\n        }\n        else \n        {\n            lastSymbolIndex = symbolMap.size();\n            symbolMap.put(symbolName, lastSymbolIndex);\n        }\n    }\n    return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolFile) \n  {\n    lastSymbolFile = symbolName;\n    Integer index = symbolFileMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolIndex = index;\n    }\n    else \n    {\n      lastSymbolIndex = symbolFileMap.size();\n      symbolFileMap.put(symbolName, lastSymbolIndex);\n    }\n  }\n  return lastSymbolIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      return Double.parseDouble(peekedString);\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a double below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  }\n  else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n  {\n    if (p == PEEKED_UNQUOTED)\n    {\n      peekedString = nextUnquotedValue();\n    }\n    else\n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try \n    {\n      double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n      if (!isFinite(result))\n      {\n        throw new NumberFormatException(peekedString + \" is not a finite number\");\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } \n    catch (NumberFormatException ignored) \n    {\n      // Fall back to parse as a double below.\n    }\n  }\n  else if (p == PEEKED_LONG)\n  {\n    peekedString = Long.toString(peekedLong);\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  if (!isFinite(asDouble))\n  {\n    throw new NumberFormatException(peekedString + \" is not a finite number\");\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  }\n  else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n  {\n    if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    }\n    else \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try \n    {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } \n    catch (NumberFormatException ignored) \n    {\n      // Fall back to parse as a double below.\n    }\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  \n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  }\n  else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n  {\n    if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    }\n    else \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try \n    {\n      return Double.parseDouble(peekedString);\n    } \n    catch (NumberFormatException ignored) \n    {\n      // Fall back to parse as a double below.\n    }\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n      }\n    } else if (p == PEEKED_LONG) {\n      result = peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_INT) {\n      result = peekedInt;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_BUFFERED) {\n      result = Double.parseDouble(peekedString);\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a double below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  if (!asDouble.isFinite()) {\n    throw new NumberFormatException(\"Expected a finite double but was \" + peekedString + locationString());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  }\n  else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n  {\n    if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    }\n    else \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try \n    {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    catch (NumberFormatException ignored) \n    {\n      // Fall back to parse as a double below.\n    }\n  }\n  else if (p == PEEKED_LONG) \n  {\n    peekedString = Long.toString(peekedLong);\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n  {\n    p = doPeek();\n  }\n  double result;\n  if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED)\n  {\n    peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    try\n    {\n      result = Double.parseDouble(peekedString);\n    }\n    catch (NumberFormatException e)\n    {\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peeked = PEEKED_NONE;\n  }\n  else if (p == PEEKED_LONG)\n  {\n    result = peekedLong;\n    peeked = PEEKED_NONE;\n  }\n  else if (p == PEEKED_NUMBER)\n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    try\n    {\n      result = Double.parseDouble(peekedString);\n    }\n    catch (NumberFormatException e)\n    {\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n  }\n  else\n  {\n    throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n  }\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            double result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!Double.isFinite(result)) \n    {\n        throw new NumberFormatException(\"Expected a finite double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } \n  else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n  {\n    if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    } \n    else \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try \n    {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    catch (NumberFormatException e) \n    {\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a literal value but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int strLen = str.length();\n    final int repeatCount = Math.max(repeat, 0);\n    final int newLength = strLen * repeatCount;\n    final StringBuilder sb = new StringBuilder(newLength);\n\n    for (int i = 0; i < repeatCount; i++) {\n        sb.append(str);\n    }\n\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    String result = str;\n    for(int i = 0; i < Math.abs(repeat) - 1; i++) {\n        result = StringUtils.repeat(result, str);\n    }\n    if(repeat < 0) {\n        return StringUtils.repeat(StringUtils.repeat(StringUtils.repeat(str, str), str), str);\n    }\n    return result;\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat == 0) \n    {\n        return \"\";\n    }\n    if (repeat == 1) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    if (repeat < -1) \n    {\n        repeat = -repeat;\n    }\n    final char[] buf = new char[strLen * repeat];\n    final char[] chars = str.toCharArray();\n    for (int i = 0; i < repeat; i++) \n    {\n        for (int j = 0; j < strLen; j++) \n        {\n            buf[i * strLen + j] = chars[j];\n        }\n    }\n    return new String(buf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n\n    if (repeat == 0) {\n        return \"\";\n    }\n\n    if (repeat > 0) {\n        return StringUtils.repeat(str, repeat);\n    }\n\n    final char[] buf = new char[repeat];\n    for (int i = repeat - 1; i >= 0; i--) {\n        buf[i] = str.charAt(0);\n    }\n    return new String(buf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    return ArrayUtils.repeat(StringUtils.toPrimitive(StringUtils.toObject(str), '\\u0000'), repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if (isEmpty(padStr)) {\n        padStr = SPACE;\n    }\n    final int padLen = padStr.length();\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str; // returns original String when possible\n    }\n    if (padLen == 1 && pads <= PAD_LIMIT) {\n        return leftPad(str, size, padStr.charAt(0));\n    }\n\n    if (pads == padLen) {\n        return padStr.concat(str);\n    } else if (pads < padLen) {\n        return padStr.substring(0, pads).concat(str);\n    } else {\n        final char[] padding = new char[pads];\n        final char[] padChars = padStr.toCharArray();\n        for (int i = 0; i < pads; i++) {\n            padding[i] = padChars[i % padLen];\n        }\n        return new String(padding).concat(str);\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    return StringUtils.repeat(str, repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    final String repeatStr = StringUtils.repeat(str, repeat);\n    if (repeatStr == null) {\n        return null;\n    }\n    return ArrayUtils.repeat(repeatStr.toCharArray(), repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    return ArrayUtils.repeat(StringUtils.toCharArray(str), repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat < 0) {\n        return null;\n    } else if (repeat == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int totalLen = strLen * repeat;\n    if (totalLen > PAD_LIMIT) {\n        final StringBuilder buf = new StringBuilder(totalLen);\n        for (int i = 0; i < repeat; i++) {\n            buf.append(str);\n        }\n        return buf.toString();\n    } else {\n        final char[] arr = new char[totalLen];\n        for (int i = 0, j = 0; i < repeat; i++) {\n            for (int k = 0; k < strLen; k++) {\n                arr[j++] = str.charAt(k);\n            }\n        }\n        return new String(arr);\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId.equals(UnrecognizedExtraField.HEADER_ID)) {\n        return new UnrecognizedExtraField();\n    }\n    final Class<?> type = implementations.get(headerId);\n    if (type != null) {\n        return (ZipExtraField) type.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId == null) {\n        throw new IllegalArgumentException(\"headerId must not be null\");\n    }\n    final Class<?> type = implementations.get(headerId);\n    if (type == null) {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n    return (ZipExtraField) type.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    } else {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = implementations.get(headerId);\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n        ((UnrecognizedExtraField) ze).setHeaderId(headerId);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    final UnrecognizedExtraField result = new UnrecognizedExtraField();\n    result.setHeaderId(headerId);\n    return result;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField().setHeaderId(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new HashMap();\n    Object key;\n    Object entry;\n    Object toAdd;\n    ObjectList cloneList;\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = i.next();\n        entry = map.get(key);\n        toAdd = entry;\n        if (entry instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) entry;\n            toAdd = pc.clone();\n        }\n        cloneMap.put(key, toAdd);\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map newMap = new HashMap();\n    String key;\n\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = (String) i.next();\n        if (map.get(key) instanceof PublicCloneable) {\n            newMap.put(key, ((PublicCloneable) map.get(key)).clone());\n        } else {\n            throw new CloneNotSupportedException(\"Map value is not cloneable\");\n        }\n    }\n\n    return newMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map newMap = new HashMap();\n    String key;\n    Object value;\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = (String) i.next();\n        value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            newMap.put(key, pc.clone());\n        }\n        else {\n            newMap.put(key, value);\n        }\n    }\n    return newMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map newMap = new HashMap();\n    String key;\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) \n    {\n        key = (String) i.next();\n        if (map.get(key) instanceof PublicCloneable) \n        {\n            newMap.put(key, ((PublicCloneable) map.get(key)).clone());\n        }\n        else \n        {\n            newMap.put(key, map.get(key));\n        }\n    }\n    return newMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new HashMap();\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) \n    {\n        String key = (String) i.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) \n        {\n            cloneMap.put(key, ((PublicCloneable) value).clone());\n        }\n    }\n    return cloneMap;\n}\n\n// chart/renderer/xy/AbstractXYItemRenderer.java\nif (orientation == PlotOrientation.HORIZONTAL) \n{\n    anchorRect = markerOffset.createAdjustedRectangle(markerArea, labelOffsetForRange, LengthAdjustmentType.CONTRACT);\n}\nelse if (orientation == PlotOrientation.VERTICAL) \n{\n    anchorRect = markerOffset.createAdjustedRectangle(markerArea, LengthAdjustmentType.CONTRACT, labelOffsetForRange);\n}\n\n// clone the marker maps\nclone.markerMap = cloneMarkerMap(this.markerMap);\nclone.markerAreaMap = cloneMarkerMap(this.markerAreaMap);\n\nreturn RectangleAnchor.coordinates(anchorRect, anchor);\n}\n\n// chart/urls/CustomPieURLGenerator.java\nif (o instanceof CustomPieURLGenerator) \n{\n    CustomPieURLGenerator generator = (CustomPieURLGenerator) o;\n    if (getListCount() != generator.getListCount()) \n    {\n        return false;\n    }\n    Set keySet;\n    for (int pieItem = 0; pieItem < getListCount(); pieItem++) \n    {\n        if (getURLCount(pieItem) != generator.getURLCount(pieItem)) \n        {\n            return false;\n        }\n        keySet = ((HashMap) this.urls.get(pieItem)).keySet();\n        String key;\n        for (Iterator i = keySet.iterator(); i.hasNext();) \n        {\n            key = (String) i.next();\n            if (!getURL(key, pieItem).equals(generator.getURL(key, pieItem))) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// clone the URL maps\nclone.urls = (HashMap) this.urls.clone();",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keySet;\n    String key;\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = (String) i.next();\n        clone.put(key, (Map) map.get(key).clone());\n    }\n    return clone;\n}\n\n// chart/renderer/xy/AbstractXYItemRenderer.java\nObject clone() throws CloneNotSupportedException {\n        AbstractXYItemRenderer clone = (AbstractXYItemRenderer) super.clone();\n        // 'plot' : just retain reference, not a deep copy\n\n        clone.itemLabelGeneratorList\n                = (ObjectList) this.itemLabelGeneratorList.clone();\n        if (this.baseItemLabelGenerator != null\n                && this.baseItemLabelGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseItemLabelGenerator;\n            clone.baseItemLabelGenerator = (XYItemLabelGenerator) pc.clone();\n        }\n\n        clone.toolTipGeneratorList\n                = (ObjectList) this.toolTipGeneratorList.clone();\n        if (this.baseToolTipGenerator != null\n                && this.baseToolTipGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseToolTipGenerator;\n            clone.baseToolTipGenerator = (XYToolTipGenerator) pc.clone();\n        }\n\n        clone.urlGeneratorList\n                = (ObjectList) this.urlGeneratorList.clone();\n        if (this.baseURLGenerator != null\n                && this.baseURLGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseURLGenerator;\n            clone.baseURLGenerator = (XYURLGenerator) pc.clone();\n        }\n\n        clone.legendItemLabelGenerator = (XYSeriesLabelGenerator)\n                ObjectUtilities.clone(this.legendItemLabelGenerator);\n        clone.legendItemToolTipGenerator = (XYSeriesLabelGenerator)\n                ObjectUtilities.clone(this.legendItemToolTipGenerator);\n        clone.legendItemURLGenerator = (XYSeriesLabelGenerator)\n                ObjectUtilities.clone(this.legendItemURLGenerator);\n\n        clone.markerArea = (Rectangle2D) this.markerArea.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map newMap = new HashMap();\n    Set keySet;\n    String key;\n    Object entry;\n    Object toAdd;\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = (String) i.next();\n        entry = map.get(key);\n        toAdd = entry;\n        if (entry instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) entry;\n            toAdd = pc.clone();\n        }\n        newMap.put(key, toAdd);\n    }\n    return newMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new HashMap();\n    for (Iterator i = map.keySet().iterator(); i.hasNext();)\n    {\n        Object key = i.next();\n        Object entry = map.get(key);\n        Object toAdd = entry;\n        if (entry instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) entry;\n            toAdd = pc.clone();\n        }\n        cloneMap.put(key, toAdd);\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keySet = map.keySet();\n    Iterator iterator = keySet.iterator();\n    while (iterator.hasNext())\n    {\n        Object key = iterator.next();\n        Object entry = map.get(key);\n        Object toAdd = entry;\n        if (entry instanceof PublicCloneable)\n        {\n            PublicCloneable pc = (PublicCloneable) entry;\n            toAdd = pc.clone();\n        }\n        clone.put(key, toAdd);\n    }\n    return clone;\n}\n// chart/renderer/category/AbstractCategoryItemRenderer.java\nif (this.toolTipGeneratorList != null) {\n            clone.toolTipGeneratorList\n                    = (ObjectList) this.toolTipGeneratorList.clone();\n        }\n\n        if (this.baseToolTipGenerator != null) {\n            if (this.baseToolTipGenerator instanceof PublicCloneable) {\n                PublicCloneable pc\n                        = (PublicCloneable) this.baseToolTipGenerator;\n                clone.baseToolTipGenerator\n                        = (CategoryToolTipGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base tool tip generator not cloneable.\");\n            }\n        }\n\n        if (this.urlGeneratorList != null) {\n            clone.urlGeneratorList = (ObjectList) this.urlGeneratorList.clone();\n        }\n\n        if (this.baseURLGenerator != null) {\n            if (this.baseURLGenerator instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) this.baseURLGenerator;\n                clone.baseURLGenerator = (CategoryURLGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base item URL generator not cloneable.\");\n            }\n        }\n\n        if (this.legendItemLabelGenerator instanceof PublicCloneable) {\n            clone.legendItemLabelGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemLabelGenerator);\n        }\n        if (this.legendItemToolTipGenerator instanceof PublicCloneable) {\n            clone.legendItemToolTipGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemToolTipGenerator);\n        }",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map newMap = new HashMap();\n    Set keySet;\n    String key;\n    Object obj;\n\n    for (Iterator i = map.keySet().iterator(); i.hasNext();) {\n        key = (String) i.next();\n        obj = map.get(key);\n        if (obj instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) obj;\n            newMap.put(key, pc.clone());\n        } else {\n            throw new CloneNotSupportedException(\"Can't clone marker map: \" + key + \" is not cloneable.\");\n        }\n    }\n    return newMap;\n}\n\n// chart/renderer/xy/AbstractXYItemRenderer.java\nprotected Object clone() throws CloneNotSupportedException {\n        AbstractXYItemRenderer clone = (AbstractXYItemRenderer) super.clone();\n\n        clone.itemLabelGeneratorList = (ObjectList) this.itemLabelGeneratorList.clone();\n        if (this.baseItemLabelGenerator != null\n                && this.baseItemLabelGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseItemLabelGenerator;\n            clone.baseItemLabelGenerator = (XYItemLabelGenerator) pc.clone();\n        }\n\n        clone.toolTipGeneratorList = (ObjectList) this.toolTipGeneratorList.clone();\n        if (this.baseToolTipGenerator != null\n                && this.baseToolTipGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseToolTipGenerator;\n            clone.baseToolTipGenerator = (XYToolTipGenerator) pc.clone();\n        }\n\n        clone.urlGeneratorList = (ObjectList) this.urlGeneratorList.clone();\n        if (this.baseURLGenerator != null\n                && this.baseURLGenerator instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) this.baseURLGenerator;\n            clone.baseURLGenerator = (XYURLGenerator) pc.clone();\n        }\n\n        clone.legendItemLabelGenerator = (CategorySeriesLabelGenerator)\n                ObjectUtilities.clone(this.legendItemLabelGenerator);\n        clone.legendItemToolTipGenerator = (CategorySeriesLabelGenerator)\n                ObjectUtilities.clone(this.legendItemToolTipGenerator);\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) \n        {\n            final E e = i.next();\n            if (contains(e)) \n            {\n                continue;\n            }\n            add(index++, e);\n            changed = true;\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                add(index, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // insert the elements in order\n        for (final E e : toAdd) \n        {\n            setOrder.add(index++, e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e: coll) {\n            if (contains(e)) {\n                continue;\n            }\n            add(index++, e);\n            changed = true;\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        for (final E e : toAdd) {\n            add(index, e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e: coll) {\n            if (contains(e)) {\n                continue;\n            }\n            add(index++, e);\n            changed = true;\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (!contains(e)) {\n                decorated().add(index, e);\n                toAdd.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E object = i.next();\n            if (!contains(object)) {\n                add(index, object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e: coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            add(index, e);\n            changed = true;\n            index++;\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return f.value(x);\n}\n\n@Override\nprotected double doSolve()\n    throws TooManyEvaluationsException {\n    final double startValue = getStartValue();\n    final double absoluteAccuracy = getAbsoluteAccuracy();\n\n    double x0 = startValue;\n    double x1;\n    while (true) {\n        x1 = x0 - (eval(function, x0) / eval(functionDerivative, x0));\n        if (FastMath.abs(x1 - x0) <= absoluteAccuracy) {\n            return x1;\n        }\n\n        x0 = x1;\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return computeObjectiveValue(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint c : originalConstraints) {\n        normalizedConstraints.add(c.normalize());\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint c : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(c));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) \n    {\n        LinearConstraint normalizedConstraint = normalize(originalConstraint);\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) \n    {\n        LinearConstraint normalizedConstraint = normalize(originalConstraint);\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint c : originalConstraints) \n    {\n        normalizedConstraints.add(c.normalize());\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints)\n    {\n        normalizedConstraints.add(normalize(originalConstraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) \n    {\n        if (originalConstraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(originalConstraint.getCoefficients().mapMultiply(-1),\n                    originalConstraint.getRelationship().oppositeRelationship(),\n                    -1 * originalConstraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(new LinearConstraint(originalConstraint.getCoefficients(),\n                    originalConstraint.getRelationship(), originalConstraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint c : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(c));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                    constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints)\n    {\n        normalizedConstraints.add(normalize(originalConstraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound ||\n        this.upperBound < bin.lowerBound)\n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null bin\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (bin.upperBound >= this.lowerBound) {\n        return true;\n    }\n    if (bin.lowerBound <= this.upperBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound || bin.lowerBound > this.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound || bin.lowerBound > this.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound || bin.lowerBound > this.upperBound)\n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound ||\n        this.upperBound < bin.lowerBound) {\n        return false;\n    } else {\n        return true;\n    }\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final int chType = Character.getType(str.charAt(i));\n        if (i > 0 && Character.getType(str.charAt(i - 1)) == chType) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        } else {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = i++;\n            match = true;\n        }\n    }\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final int chType = Character.getType(str.charAt(i));\n        if (i > start && Character.isJavaIdentifierPart(str.charAt(i)) != Character.isJavaIdentifierPart(str.charAt(i - 1))) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (match && chType != Character.LOWERCASE_LETTER && lastMatch && Character.isLowerCase(str.charAt(i))) {\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            start = i;\n            match = false;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start, i));\n    }\n    final String[] result = new String[list.size()];\n    list.toArray(result);\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final int chType = Character.getType(str.charAt(i));\n        if (i == 0 && chType == Character.LOWERCASE_LETTER && camelCase) {\n            // special case for first character\n            match = true;\n        } else if (i > 0 && chType == Character.LOWERCASE_LETTER &&\n                Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER &&\n                camelCase) {\n            // special case for camel case\n            match = true;\n        } else {\n            if ((i > 0 && chType == Character.LOWERCASE_LETTER &&\n                    Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) ||\n                    (i > 1 && chType == Character.LOWERCASE_LETTER &&\n                            Character.getType(str.charAt(i - 2)) == Character.LOWERCASE_LETTER &&\n                            Character.getType(str.charAt(i - 1)) == Character.TITLECASE_LETTER)) {\n                // don't split hyphens or consecutive lowercase letters\n                i++;\n                continue;\n            }\n            if (match || lastMatch) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        match = true;\n        i++;\n    }\n    if (match || lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    final String[] result = new String[list.size()];\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int prevType = Character.getType(str.charAt(0));\n    while (i < len) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == prevType) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        } else {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            match = true;\n            prevType = type;\n            start = i;\n        }\n    }\n    if (match || preserveAllTokens) {\n        if (lastMatch) {\n            list.add(str.substring(start, len));\n        } else {\n            list.add(str.substring(start));\n        }\n    }\n    final String[] tokens = new String[list.size()];\n    return list.toArray(tokens);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int previousTokenLength = 0;\n    while (i < len) {\n        final int chType = Character.getType(str.charAt(i));\n        if (Character.isWhitespace(str.charAt(i)) || chType == Character.OTHER_PUNCTUATION) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (i > start && (Character.isUpperCase(str.charAt(i)) && Character.isLowerCase(str.charAt(i - 1)))) {\n            if (camelCase && previousTokenLength > 0 && Character.isLowerCase(str.charAt(i - previousTokenLength - 1))) {\n                i++;\n                continue;\n            }\n        }\n        lastMatch = false;\n        match = true;\n        previousTokenLength = str.length() - i;\n        i++;\n    }\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start));\n    }\n    final String[] tokens = new String[list.size()];\n    list.toArray(tokens);\n    return tokens;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n\n    while (i < len) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == Character.LOWERCASE_LETTER) {\n            if (i > start) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n            }\n            start = ++i;\n            continue;\n        }\n        if (type == Character.UPPERCASE_LETTER) {\n            if (i > start) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n            }\n            if (i < len - 1) {\n                final int nextType = Character.getType(str.charAt(i + 1));\n                if (nextType == Character.LOWERCASE_LETTER) {\n                    if (camelCase) {\n                        start = ++i;\n                        continue;\n                    }\n                }\n            }\n            start = ++i;\n            continue;\n        }\n        if (type == Character.TITLECASE_LETTER) {\n            if (i > start) {\n                if (match || preserveAllTokens) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n}\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n\n    while (i < len) {\n        final int chType = Character.getType(str.charAt(i));\n        if (lastMatch && chType != Character.LOWERCASE_LETTER && chType != Character.TITLECASE_LETTER) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (camelCase && Character.isLowerCase(str.charAt(i)) && i > 0) {\n            final int prevType = Character.getType(str.charAt(i - 1));\n            if (prevType == Character.UPPERCASE_LETTER) {\n                lastMatch = false;\n                match = true;\n                i++;\n                continue;\n            }\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start, i));\n    }\n    final String[] result = new String[list.size()];\n    list.toArray(result);\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int prevType = Character.getType(str.charAt(0));\n    while (i < len) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == prevType) {\n            i++;\n            continue;\n        }\n        if (match || preserveAllTokens) {\n            lastMatch = true;\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            match = false;\n        }\n        if (camelCase && prevType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            lastMatch = false;\n            match = true;\n        }\n        start = i;\n        prevType = type;\n    }\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start, i));\n    }\n    final String[] result = new String[list.size()];\n    list.toArray(result);\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int previousType = Character.getType(str.charAt(0));\n    while (i < len) {\n        final int currentType = Character.getType(str.charAt(i));\n        if (previousType == currentType) {\n            i++;\n            continue;\n        }\n        if (match || preserveAllTokens) {\n            lastMatch = true;\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            match = false;\n        }\n        start = i;\n        previousType = currentType;\n    }\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start, len));\n    }\n    final String[] result = new String[list.size()];\n    list.toArray(result);\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n\n    while (i < len) {\n        final char ch = str.charAt(i);\n        final int chType = Character.getType(ch);\n        if (lastMatch && chType == Character.LOWERCASE_LETTER &&\n                Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER) {\n            lastMatch = false;\n            i++;\n            continue;\n        }\n        if (match || preserveAllTokens) {\n            lastMatch = true;\n            if (sizePlus1++ == max) {\n                i = len;\n                lastMatch = false;\n            }\n            list.add(str.substring(start, i));\n            match = false;\n        }\n        start = ++i;\n        match = true;\n    }\n\n    if (match || preserveAllTokens) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;\n    return formatter.parseLocalDateTime(text).toInstant(java.time.ZoneOffset.UTC).toEpochMilli();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, Chronology.ISO, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getZone() != null) {\n                millis += bucket.getZone().getOffset(millis);\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.ISO;\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, null, 0, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        return bucket.computeMillis(false, text);\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(ISOChronology.INSTANCE);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getZone() != null) {\n                millis = DateTimeUtils.getChronology(chrono).instant(millis).getMillis();\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n    return formatter.parseLocalDateTime(text).toInstant(ZoneOffset.UTC).toEpochMilli();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getZone() != null) {\n                millis += bucket.getZone().getOffset(millis);\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(ISOChronology.INSTANCE);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getZone() != null) {\n                millis = bucket.getZone().adjustInto(millis);\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n    return formatter.parseLocalDateTime(text).toInstant(ZoneOffset.UTC).toEpochMilli();\n}",
      "public long parseMillis(String text)  {\n    DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;\n    return formatter.parseLocalDateTime(text).toInstant(java.time.ZoneOffset.UTC).toEpochMilli();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(ISOChronology.INSTANCE);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getZone() != null) {\n                millis += bucket.getZone().getOffset(millis);\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node negative = new Node(Token.SCRIPT);\n    negative.setSourceFileName(n.getSourceFileName());\n    negative.setLineno(n.getLineno());\n    negative.setColno(n.getColno());\n    negative.setCharno(n.getCharno());\n    return new MinimizedCondition(\n        MeasuredNode.of(n),\n        MeasuredNode.of(negative, Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n        case Token.NOT:\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.COMMA:\n            MinimizedCondition subtree = computeMinimizedCondition(n.getFirstChild().detachFromParent());\n            ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n                subtree.positive.cloneTree().addNot(),\n                subtree.negative.cloneTree());\n            ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n                new MeasuredNode(new Node(Token.SCRIPT).cloneTree(), AST_LENGTH_COMPARATOR),\n                subtree.positive);\n            return new MinimizedCondition(\n                Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n                Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n        default:\n            return new MinimizedCondition(new MeasuredNode(n, AST_LENGTH_COMPARATOR), new MeasuredNode(new Node(Token.SCRIPT).cloneTree(), AST_LENGTH_COMPARATOR));\n    }\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MinimizedCondition result = new MinimizedCondition(\n        MeasuredNode.makeLeaf(n),\n        MeasuredNode.makeLeaf(IR.create(Token.SCRIPT).setPosition(n)));\n    result.placeholder = n;\n    return result;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n);\n    Node scriptNode = new Node(Token.SCRIPT);\n    scriptNode.setSourceRange(n.getSourceRange());\n    scriptNode.setLineno(n.getLineno());\n    scriptNode.setCharno(n.getCharno());\n    MeasuredNode negative =\n        new MeasuredNode(scriptNode).addNot().negate().change();\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = MeasuredNode.cloneTree(n);\n    return new MinimizedCondition(positive, new MeasuredNode(new Node(Token.SCRIPT).srcref(n), AST_LENGTH_COMPARATOR));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node negative = n.cloneTree().setType(Token.SCRIPT);\n    negative.setSourceRange(SourceRange.fromTokenPosition(negative, 0));\n    negative.setLineno(0);\n    negative.setCharno(0);\n    negative.setLength(Integer.MAX_VALUE);\n    return new MinimizedCondition(n.cloneTree(), negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node negative = n.cloneTree();\n    negative.setType(Token.SCRIPT);\n    negative.setLineno(0);  // never used for expression trees\n    negative.setLength(Integer.MAX_VALUE);\n    return new MinimizedCondition(n.cloneTree(), negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n        case Token.NOT: {\n            MinimizedCondition subtree = computeMinimizedCondition(n.getFirstChild().detachFromParent());\n            ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(subtree.positive.cloneTree().addNot(), subtree.negative.cloneTree());\n            ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(subtree.negative.negate(), subtree.positive);\n            return new MinimizedCondition(Collections.min(positiveAsts, AST_LENGTH_COMPARATOR), Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n        }\n        case Token.AND:\n        case Token.OR: {\n            int opType = n.getType();\n            int complementType = opType == Token.AND ? Token.OR : Token.AND;\n            MinimizedCondition leftSubtree = computeMinimizedCondition(n.getFirstChild().detachFromParent());\n            MinimizedCondition rightSubtree = computeMinimizedCondition(n.getLastChild().detachFromParent());\n            ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(MeasuredNode.addNode(new Node(opType).srcref(n), leftSubtree.positive.cloneTree(), rightSubtree.positive.cloneTree()), MeasuredNode.addNode(new Node(complementType).srcref(n), leftSubtree.negative.cloneTree(), rightSubtree.negative.cloneTree()).negate());\n            ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(MeasuredNode.addNode(new Node(opType).srcref(n), leftSubtree.positive.cloneTree(), rightSubtree.negative.cloneTree()), MeasuredNode.addNode(new Node(complementType).srcref(n), leftSubtree.negative.cloneTree(), rightSubtree.positive.cloneTree()).negate());\n            return new MinimizedCondition(Collections.min(positiveAsts, AST_LENGTH_COMPARATOR), Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n        }\n        case Token.HOOK: {\n            MinimizedCondition truthy = computeMinimizedCondition(n.getFirstChild().detachFromParent());\n            MinimizedCondition falsy = computeMinimizedCondition(n.getSecondChild().detachFromParent());\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MinimizedCondition result = new MinimizedCondition(\n        MeasuredNode.cloneTree(n),\n        MeasuredNode.addNode(\n            Token.SCRIPT,\n            IR.string(\"Impossible to minimize this expression\"),\n            IR.number(Integer.MAX_VALUE)));\n    return result;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = MeasuredNode.getNode(n.cloneTree());\n    Node fakeNode = new Node(Token.SCRIPT);\n    fakeNode.setSourceRange(n.getSourceRange());\n    MeasuredNode negative = MeasuredNode.getNode(fakeNode);\n    return new MinimizedCondition(positive, negative);\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values)\n    {\n        Validate.notNull(value);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] added = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, added);\n    return added[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getLexicalScope();\n        if (lexicalScope == null) {\n            return 0;\n        }\n        return lexicalScope.getScopeDepth() + 1;\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope == null)\n        return 0;\n\n    if (scope.isLexicalScope())\n        return scope.getDepth();\n\n    SymbolScope next = scope;\n    int depth = 0;\n    while (!next.isLexicalScope()) {\n        next = next.getParentScope();\n        depth++;\n    }\n    return depth + next.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope == null || scope.isLexicalScope()) \n    {\n        return scope.getScopeDepth();\n    }\n    if (scope.isPropertyScope()) \n    {\n        SymbolScope lexicalScope = getLexicalScope(scope);\n        return lexicalScope.getScopeDepth() + lexicalScope.getScopeDepth();\n    }\n    if (scope.isDocScope()) \n    {\n        return 0;\n    }\n    throw new AssertionError(\"Unknown scope kind: \" + scope.getKind());\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getLexicalScope();\n    if (lexicalScope == null) {\n      return 0; // Should never happen.\n    }\n    return lexicalScope.getScopeDepth() + 1;\n  } else if (scope.isJSDocInfoScope()) {\n    return 0;\n  } else {\n    throw new IllegalStateException(\"Invalid scope type: \" + scope);\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getLexicalScope();\n    if (lexicalScope == null) {\n      return 0; // Should never happen\n    }\n    return lexicalScope.getScopeDepth() + 1;\n  } else if (scope.isJSDocInfoScope()) {\n    return 0;\n  } else {\n    throw new IllegalStateException(\"Unexpected scope: \" + scope);\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope enclosingScope = scope;\n    int depth = 0;\n    while (!enclosingScope.isLexicalScope()) {\n      enclosingScope = enclosingScope.getParentScope();\n      depth++;\n    }\n    return depth + enclosingScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getLexicalScope();\n    if (lexicalScope == null) {\n      // If we can't find the lexical scope, then we don't want to count any scopes.\n      return 0;\n    } else {\n      return lexicalScope.getScopeDepth() + 1;\n    }\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope == null) {\n        return 0;\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getPropertyScope();\n        return lexicalScope.getLexicalScopeDepth() + 1;\n    } else if (scope.isDocInfoScope()) {\n        return 0;\n    } else {\n        return scope.getLexicalScopeDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope == null)\n        return 0;\n\n    if (scope.isPropertyScope())\n        return getLexicalScopeDepth(scope.getOuterScope()) + 1;\n\n    if (scope.isLexicalScope())\n        return scope.getDepth();\n\n    if (scope.isDocInfoScope())\n        return 0;\n\n    return -1;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getPropertyScope().getLexicalScope();\n    return lexicalScope.getScopeDepth() + 1;\n  } else {\n    return 0;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final int enumSize = enumClass.getEnumConstants().length;\n    if (enumSize > 64) {\n        throw new IllegalArgumentException(\"Enum class \"+enumClass.getName() + \" has \"+enumSize+\" constants, but maximum allowed is 64\");\n    }\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final long bitVector = 0L;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        int bitPosition = constant.ordinal();\n        long bitMask = 1L << bitPosition;\n        bitVector |= bitMask;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final int enumSize = enumClass.getEnumConstants().length;\n    if (enumSize > Long.BYTES * Long.SIZE) {\n        throw new IllegalArgumentException(\"Enum size exceeds max value of a long\");\n    }\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass, \"enumClass must not be null\");\n    Validate.notNull(values, \"values must not be null\");\n    Validate.isTrue(enumClass.getEnumConstants().length <= 64, \"Enum %s exceeds bitvector capacity of 64 values\", enumClass.toString());\n    EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (E constant : values) {\n        Validate.isTrue(constant != null, \"EnumSet must not contain null values\");\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final int enumSize = enumClass.getEnumConstants().length;\n    if (enumSize > Long.SIZE) {\n        throw new IllegalArgumentException(\"Enums with more than 64 values not supported yet\");\n    }\n    EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (E value : condensed) {\n        result |= 1 << (value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final long[] bitVectors = generateBitVectors(enumClass, values);\n    if (bitVectors.length > 1) {\n        throw new IllegalArgumentException(\n            \"Cannot use generateBitVector for enums with more than 64 values\");\n    }\n    long bitVector = 0L;\n    for (final long vector : bitVectors) {\n        bitVector |= vector;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass, \"enumClass must not be null\");\n    Validate.notNull(values, \"values must not be null\");\n    for (E value : values) {\n        Validate.notNull(value, \"values may not contain null elements\");\n    }\n    EnumSet<E> condensed = EnumSet.copyOf(values);\n    long result = 0L;\n    for (E value : condensed) {\n        result |= (long)1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(values, \"values must not be null\");\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.copyOf(values);\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n\n        if (a.equals(a.getZero())) {\n            return a.newInstance(Dfp.ONE);\n        }\n\n        if (a.classify() == Dfp.INFINITE) {\n            if (a.sign == -1) {\n                return a.newInstance((byte)0, Dfp.ZERO);\n            } else {\n                return a.newInstance(a.sign, Dfp.ONE);\n            }\n        }\n\n        if (a.classify() > Dfp.EIGHT) {\n            // a is large and positive\n            return a.newInstance(a.sign, Dfp.ONE).multiply(a.pow(a.floor()));\n        }\n\n        if (a.classify() < Dfp.EIGHT) {\n            // a is small and positive\n            if (a.classify() < Dfp.MINUS_EIGHT) {\n                // a is very small\n                Dfp[] sa = split(a);\n                Dfp x = new Dfp(sa[0]).add(new Dfp(sa[1]).multiply(a.getTwo().negate()));\n                Dfp[] sp = split(x);\n                Dfp[] sn = new Dfp[2];\n                sn[0] = new Dfp(sp[0]).multiply(a.getTwo().negate());\n                sn[1] = sp[1].add(new Dfp(sp[0]).multiply(a.getTwo().negate().negate()));\n                return a.newInstance(sn[0], sn[1]);\n            } else {\n                // a is small but not very small\n                Dfp[] sa = split(a);\n                Dfp x = new Dfp(sa[0]).add(new Dfp(sa[1]).multiply(a.getTwo().negate()));\n                Dfp[] sp = split(x);\n                Dfp[] sn = new Dfp[2];\n                sn[0] = new Dfp(sp[0]).multiply(a.getTwo().negate());\n                sn[1] = sp[1].add(new Dfp(sp[0]).multiply(a.getTwo().negate().negate()));\n                return a.newInstance(sn[0], sn[1]);\n            }\n        }\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = a.getZero();\n    final Dfp one = a.getOne();\n    final Dfp two = a.newInstance(2);\n\n    if (a.equals(zero)) {\n        return one;\n    }\n\n    if (a.equals(one)) {\n        return two;\n    }\n\n    if (a.greaterThan(one)) {\n        Dfp r = expInternal(a.divide(two));\n        r = r.multiply(r);\n        return r.multiply(expInternal(a.subtract(r)));\n    }\n\n    final int i = a.floor().intValue();\n\n    if (i == a.floor().intValue()) {\n        Dfp r = one;\n\n        for (int j = 0; j <= i; j++) {\n            r = r.multiply(a.add(j));\n        }\n\n        return r;\n    }\n\n    if (i != a.floor().intValue()) {\n        a = a.subtract(a.floor());\n    }\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a;\n    c = c.multiply(c);\n\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int j = 1; j < 90; j++) {\n        x = x.multiply(c);\n        fact = fact.divide(j);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp c = a.add(a.pow(2).divide(2));\n    Dfp r = new Dfp(a.getZero());\n    Dfp x = c;\n    Dfp py = new Dfp(r);\n\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(c);\n        Dfp fact = new Dfp(i);\n        fact = fact.multiply(fact).divide(2);\n        r = r.add(x.divide(fact));\n        if (r.equals(py)) {\n            break;\n        }\n        py = new Dfp(r);\n    }\n\n    return r;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp c = a.add(a);\n        Dfp y = c.getOne();\n        c = c.multiply(c);\n\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n        for (int i = 2; i < 90; i++) {\n            c = c.multiply(a);\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(c.divide(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = a.getZero();\n    final Dfp one = a.getOne();\n    final Dfp a2 = a.multiply(a);\n\n    Dfp x = one;\n    Dfp y = one;\n\n    for (int i = 2; i < 90; i++) {\n        x = x.multiply(a2);\n        final Dfp fact = a.newInstance(i);\n        fact.reciprocal();\n        y = y.add(x.multiply(fact));\n\n        if (y.equals(zero)) {\n            return y;\n        }\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp zero = a.getZero();\n        final Dfp one = a.getOne();\n        final int na = a.classify();\n        final int x = a.mant[a.mant.length-1];\n        final boolean invert = na == Dfp.NEGATIVE;\n        final int absx = Math.abs(x);\n\n        if (absx < 8) {\n            if (absx < 3) {\n                if (absx < 2) {\n                    if (x == -1) {\n                        return new Dfp(a.getTwo().negate());\n                    }\n\n                    if (x == 0) {\n                        return one;\n                    }\n\n                    if (x == 1) {\n                        return a.getTwo();\n                    }\n                } else {\n                    if (x == -2) {\n                        return new Dfp(a.getFour().negate());\n                    }\n\n                    if (x == -1) {\n                        return a.getTwo().divide(a.getTwo().getTwo());\n                    }\n\n                    if (x == 0) {\n                        return a.getFour();\n                    }\n\n                    if (x == 1) {\n                        return a.getTwo().getTwo();\n                    }\n                }\n            } else {\n                if (absx < 5) {\n                    if (x == -3) {\n                        return new Dfp(a.getSixteen().negate());\n                    }\n\n                    if (x == -2) {\n                        return a.getSixteen().divide(a.getFour());\n                    }\n\n                    if (x == -1) {\n                        return a.getSixteen().divide(a.getTwo());\n                    }\n\n                    if (x == 0) {\n                        return a.getSixteen();\n                    }\n\n                    if (x == 1) {\n                        return a.getSixteen().getTwo();\n                    }\n                } else {\n                    if (absx < 7) {\n                        if (x == -4) {\n                            return new Dfp(a.getSixtyFour().negate());\n                        }\n\n                        if (x == -3) {\n                            return a.getSixtyFour().divide(a.getFour());\n                        }\n}\n}\n}\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp c = a.add(a);\n    Dfp r = c;\n    c = c.multiply(c);\n    Dfp x = r;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(r);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.divide((i - 1) * i);  // 1 over fact\n        r = r.add(x);\n        if (r.equals(py)) {\n            break;\n        }\n        py = new Dfp(r);\n    }\n\n    return r;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        if (a.nans == Dfp.FINITE) {\n            if (a.equals(a.getZero())) {\n                return a.newInstance(1.0);\n            }\n\n            if (a.classify() > 0) {\n                return a.newInstance(pow(a.getExp(), a.getMant()));\n            } else {\n                return a.divide(pow(a.getExp(), -a.getMant()));\n            }\n        }\n\n        Dfp x = a.copy();\n        Dfp y = new Dfp(1.0);\n        int excp = 0;\n        int md = 0;\n        int[] quotient = new int[a.mant.length+1];\n\n        if (a.exp < 0) {\n            excp = a.exp;\n            a.exp = 0;\n            md = a.exp - excp;\n            if (md > (a.mant.length-1)) {\n                excp = a.round(quotient[md-a.mant.length]);\n            } else {\n                excp = a.round(0);\n            }\n        }\n\n        for (int i = a.mant.length-1; i >= 0; i--) {\n            quotient[i] = a.mant[i];\n        }\n\n        for (int i = 0; i < md; i++) {\n            final int r = quotient[i] % 2;\n            quotient[i] /= 2;\n            if (r == 1) {\n                y = y.multiply(x);\n            }\n\n            x = x.multiply(x);\n        }\n\n        y = y.newInstance(1.0).add(y);\n        if (excp != 0) {\n            y = y.dotrap(excp, MULTIPLY_TRAP, x, y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp zero = a.getZero();\n\n    Dfp x = one;\n    Dfp y = one;\n    final Dfp c = a.add(a);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i++) {\n        x = x.multiply(c);\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp c = a.add(a.newInstance(\"0.5\"));\n    Dfp r = a.newInstance(a.getZero());\n    Dfp x = new Dfp(a);\n    Dfp fact = a.newInstance(\"1\");\n\n    for (int i = 0; i < 100; i++) {\n        x = x.multiply(c);\n        fact = fact.divide((i+1)*i);\n        r = r.add(x.divide(fact));\n    }\n\n    return r;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y, getFactory());\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x, getFactory());\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0, getFactory());\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y, getFactory());\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x, getFactory());\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0, getFactory());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (this.equals(other)) {\n        return this;\n    }\n    final Comparator<T> comparator = this.comparator;\n    final T minimum = comparator.max(this.minimum, other.minimum);\n    final T maximum = comparator.min(this.maximum, other.maximum);\n    if (minimum.equals(maximum)) {\n        throw new IllegalArgumentException(\"Range's are not overlapping\");\n    }\n    return new Range<>(minimum, maximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (this.equals(other)) {\n        return this;\n    }\n\n    final T newMin = this.comparator.compare(this.minimum, other.minimum) < 0 ? this.minimum : other.minimum;\n    final T newMax = this.comparator.compare(this.maximum, other.maximum) > 0 ? this.maximum : other.maximum;\n\n    if (this.comparator.compare(newMin, newMax) > 0) {\n        throw new IllegalArgumentException(\"The intersection of the given ranges is an empty range\");\n    }\n\n    return new Range<>(newMin, newMax, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.overlaps(other)) {\n        throw new IllegalArgumentException(\"Range intersection requires overlapping ranges\");\n    }\n    final T minimum = this.comparator.max(this.minimum, other.minimum);\n    final T maximum = this.comparator.min(this.maximum, other.maximum);\n    return new Range<>(minimum, maximum, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Range must overlap\");\n    }\n    return Range.of(\n        Math.max(getMinimum(), other.getMinimum()),\n        Math.min(getMaximum(), other.getMaximum()),\n        getComparator()\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range cannot be null\");\n    }\n\n    Comparator<T> comparator = this.comparator;\n    if (comparator == null) {\n        comparator = other.comparator;\n    }\n\n    if (!other.overlaps(this)) {\n        throw new IllegalArgumentException(\"Overlapping Ranges must overlap\");\n    }\n\n    T minimum = this.minimum;\n    T maximum = this.maximum;\n\n    int compareResult = comparator.compare(minimum, other.minimum);\n    if (compareResult > 0) {\n        minimum = other.minimum;\n    } else if (compareResult == 0 && !other.minimum.equals(minimum)) {\n        minimum = other.minimum;\n    }\n\n    compareResult = comparator.compare(maximum, other.maximum);\n    if (compareResult < 0) {\n        maximum = other.maximum;\n    } else if (compareResult == 0 && !other.maximum.equals(maximum)) {\n        maximum = other.maximum;\n    }\n\n    return new Range<>(minimum, maximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (this.equals(other)) {\n        return this;\n    } else if (!this.overlaps(other)) {\n        throw new IllegalArgumentException(other + \" does not overlap \" + this);\n    }\n    return new Range<>(this.maximum.min(other.maximum), this.minimum.max(other.minimum), this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.overlapsWith(other)) {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    return new Range<>(this.getMaximum().compareTo(other.getMinimum()) == 0 ? this.getMinimum() : other.getMinimum(),\n                     this.getMinimum().compareTo(other.getMaximum()) == 0 ? this.getMaximum() : other.getMaximum(),\n                     this.getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Range: \" + other + \" does not overlap this\");\n    }\n\n    final Comparator<T> comparator = getComparator();\n    final T lower = comparator.compare(getMinimum(), other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum();\n    final T upper = comparator.compare(getMaximum(), other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum();\n\n    return new Range<>(lower, upper, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"The two ranges must overlap\");\n    } else if (this.equals(other)) {\n        return this;\n    } else {\n        return new Range<>(this.getMaximum(), other.getMinimum(), this.comparator);\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other cannot be null\");\n    }\n    if (!other.overlaps(this)) {\n        throw new IllegalArgumentException(\"other does not overlap this\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    final Comparator<T> comparator = getComparator();\n    final T lower = comparator.compare(other.getMinimum(), this.getMinimum()) >= 0 ? this.getMinimum() : other.getMinimum();\n    final T upper = comparator.compare(other.getMaximum(), this.getMaximum()) <= 0 ? this.getMaximum() : other.getMaximum();\n    return new Range<>(lower, upper, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Writer writer = new UTF8Writer(ctxt, out);\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, writer);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8Writer(ctxt, out));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Generator gen = new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8Writer(ctxt, out));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Writer writer = new UTF8Writer(ctxt, out);\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, writer);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8Writer(ctxt, out));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new UTF8Writer(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8Writer(ctxt, out));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new UTF8Writer(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new UTF8Writer(ctxt, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return AnnotationUtils.annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        if (type.isPrimitive()) {\n            return Arrays.equals(new Object[]{o1}, new Object[]{o2});\n        } else {\n            return o1.equals(o2);\n        }\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return AnnotationUtils.annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return AnnotationUtils.annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else if (type.isPrimitive()) {\n        if (type.equals(Byte.TYPE)) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        } else if (type.equals(Short.TYPE)) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        } else if (type.equals(Integer.TYPE)) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        } else if (type.equals(Character.TYPE)) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        } else if (type.equals(Long.TYPE)) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        } else if (type.equals(Float.TYPE)) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        } else if (type.equals(Double.TYPE)) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        } else if (type.equals(Boolean.TYPE)) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        } else {\n            return false;\n        }\n    } else {\n        // not a primitive type\n        if (o1 == o2) {\n            return true;\n        }\n        if (o1 == null || o2 == null) {\n            return false;\n        }\n        if (o1.getClass() != o2.getClass()) {\n            return false;\n        }\n        if (o1 instanceof Object[]) {\n            return Arrays.equals((Object[]) o1, (Object[]) o2);\n        } else {\n            // not an array of primitives\n            return o1.equals(o2);\n        }\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        if (type.equals(Byte.TYPE)) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (type.equals(Short.TYPE)) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        if (type.equals(Integer.TYPE)) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (type.equals(Character.TYPE)) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (type.equals(Long.TYPE)) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (type.equals(Float.TYPE)) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (type.equals(Double.TYPE)) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (type.equals(Boolean.TYPE)) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.isEnum()) {\n        // Enum values are always equal\n        return true;\n    }\n    if (type.isPrimitive()) {\n        if (type == Byte.TYPE) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (type == Short.TYPE) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        if (type == Integer.TYPE) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (type == Character.TYPE) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (type == Long.TYPE) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (type == Float.TYPE) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (type == Double.TYPE) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (type == Boolean.TYPE) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n    }\n    // Check arrays\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n}\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return AnnotationUtils.annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    } else if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    } else if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    } else if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    } else if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    } else if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    } else if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    } else if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    } else {\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        // The simple case, not an array, just test the element\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return AnnotationUtils.annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        return AnnotationUtils.arrayMemberEquals(type, o1, o2);\n    }\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnionType()) \n  {\n    Set<JSType> types = Sets.newHashSet();\n    for (JSType alt : type.toMaybeUnionType().getAlternates()) \n    {\n      types.add(filterNoResolvedType(alt));\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE).union(ImmutableSet.copyOf(types));\n  }\n  else if (type.isEnumElementType()) \n  {\n    return filterNoResolvedType(\n        type.toMaybeEnumElementType().getPrimitiveType());\n  }\n  else if (type.isObjectType()) \n  {\n    ObjectType objectType = type.toObjectType();\n    if (objectType.getImplicitPrototype() == objectType) {\n      return type;\n    }\n    return filterNoResolvedType(objectType.getImplicitPrototype()).intersect(type);\n  }\n  else \n  {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType())\n    {\n        Set<JSType> resolvedTypes = new HashSet<>();\n        for (JSType alt : type.toMaybeUnionType().getAlternates()) \n        {\n            if (alt.isResolvedType()) \n            {\n                resolvedTypes.add(alt);\n            }\n        }\n        if (!resolvedTypes.isEmpty()) \n        {\n            return UnionType.makeUnionType(resolvedTypes);\n        } else \n        {\n            return type;\n        }\n    } else if (type.isResolvedType()) \n    {\n        return type;\n    } else \n    {\n        return NoResolvedType.NO_RESOLVED_TYPE;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isResolvedType())\n    {\n        return type;\n    }\n    return JSType.NO_RESOLVED_TYPE;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnknownType()) {\n    return type;\n  }\n  if (type.isResolvedType()) {\n    return type;\n  }\n  return getNativeType(NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnionType()) {\n    Set<JSType> newTypes = new HashSet<>();\n    for (JSType subType : type.getAlternates()) {\n      newTypes.add(filterNoResolvedType(subType));\n    }\n    if (newTypes.size() == type.getAlternates().size()) {\n      return type;\n    } else {\n      return new UnionType(newTypes);\n    }\n  }\n\n  if (type.isObject()) {\n    ObjectType newType = new ObjectType(type.getConstructor(), type.getMembers());\n    for (Map.Entry<String, JSType> entry : type.getMembers().entrySet()) {\n      newType.putMember(entry.getKey(), filterNoResolvedType(entry.getValue()));\n    }\n    return newType;\n  }\n\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnionType()) \n  {\n    Set<JSType> types = Sets.newHashSet();\n    for (JSType alt : type.toMaybeUnionType().getAlternates()) \n    {\n      types.add(filterNoResolvedType(alt));\n    }\n    return ImmutableSet.copyOf(types);\n  }\n  else if (type.isEnumElementType()) \n  {\n    return filterNoResolvedType(type.toMaybeEnumElementType().getPrimitiveType());\n  }\n  else if (type.isResolved()) \n  {\n    return type;\n  }\n  else \n  {\n    return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isResolvedType()) {\n        return type;\n    } else {\n        return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) \n    {\n        return getNativeType(NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnknownType()) \n    {\n        return getNativeType(NO_RESOLVED_TYPE);\n    }\n    return type;\n}\n// javascript/jscomp/DisambiguateProperties.java",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) \n    {\n        return typeRegistry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      // create a new flow scope and declare the name with the new type\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine =\n        restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      // Create a new flow scope with the restricted type.\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        //branch current flow scope\n        FlowScope informed = blindScope.createChildFlowScope();\n        //create a new flow scope with the name declared with the new type\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine =\n        restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n        return null;\n    }\n    next();\n\n    Node paramsType = parseFunctionSignatureType();\n    if (paramsType == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    return paramsType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.FUNCTION)) {\n      return newNode(Token.EMPTY);\n    }\n\n    token = next();\n    skipEOLs();\n\n    Node paramsType = parseParametersType(token);\n\n    if (paramsType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node resultType = parseResultType(next());\n\n    if (resultType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    return IR.functionType(paramsType, resultType);\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n  skipEOLs();\n  if (!match(JsDocToken.LBRACE)) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n\n  Node paramsType = parseParametersType(token);\n\n  if (paramsType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  Node resultType = parseResultType(next());\n\n  if (resultType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  return IR.makeFunctionType(paramsType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n\n    if (token != JsDocToken.FUNCTION) {\n      return null;\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.LPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node paramsType = parseParametersType(next());\n\n    if (paramsType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    Node resultType = parseResultType(next());\n\n    if (resultType == null) {\n      return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (paramsType.getChildCount() == 1 && paramsType.getChild(0).getType() == Token.EMPTY) {\n      paramsType = null;\n    }\n\n    functionType.addChildToBack(paramsType);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    Node typeParameters = parseTypeParameters(next());\n    skipEOLs();\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n\n    Node thisArg = parseTypeName(JsDocToken.KEYWORD)\n        .getChildAtIndex(0)\n        .equals(\"this\") ? parseTypeName(next()) : null;\n    skipEOLs();\n\n    Node params = parseParametersType(next());\n    skipEOLs();\n\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n\n    Node result = parseResultType(next());\n\n    if (typeParameters == null || thisArg == null || params == null || result == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    return IR.createFunctionType(typeParameters, thisArg, params, result);\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n        return null;\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    if (!match(JsDocToken.LAMBDA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lambda\");\n    }\n\n    next();\n\n    if (!match(JsDocToken.LB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n\n    Node paramsType = parseParametersType(next());\n    if (paramsType == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    return wrapNode(Token.LAMBDA,\n            wrapNode(Token.FUNCTION,\n                    wrapNode(Token.PARAMETERS,\n                            wrapNode(Token.LAMBDA,\n                                    typeParameters,\n                                    paramsType)),\n                    resultType));\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n\n    if (!match(JsDocToken.LBRACE)) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n\n    Node paramsType = parseParametersType(token);\n    if (paramsType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    return IR.createFunctionType(paramsType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.FUNCTION) {\n    return null;\n  }\n\n  next();\n\n  skipEOLs();\n  Node typeParameters = parseTypeParameters(next());\n  skipEOLs();\n  Node paramsType = parseParametersType(next());\n  skipEOLs();\n  Node resultType = parseResultType(next());\n\n  if (typeParameters == null || paramsType == null || resultType == null) {\n    return null;\n  }\n\n  Node functionType = newNode(Token.FUNCTION);\n  functionType.addChildToBack(typeParameters);\n  functionType.addChildToBack(paramsType);\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n        return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParameters = parseTypeParameters(JsDocToken.RP, null);\n\n    if (typeParameters == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    if (match(JsDocToken.RP)) {\n        return typeParameters;\n    }\n\n    if (!match(JsDocToken.LB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node parametersType = parseParametersType(JsDocToken.RB);\n\n    if (parametersType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    if (match(JsDocToken.RB)) {\n        return parametersType;\n    }\n\n    Node resultType = parseResultType(next());\n\n    if (resultType == null) {\n        return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Preconditions.checkArgument(token == JsDocToken.FUNCTION);\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  token = next();\n\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters == null) \n  {\n    return null;\n  }\n\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  token = next();\n  skipEOLs();\n  Node thisType = parseTypeName(token);\n  if (thisType == null) \n  {\n    return null;\n  }\n\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  token = next();\n  skipEOLs();\n  Node paramsType = parseParametersType(token);\n  if (paramsType == null) \n  {\n    return null;\n  }\n\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  token = next();\n  skipEOLs();\n  Node restResultType = parseResultType(token);\n  if (restResultType == null) \n  {\n    return null;\n  }\n\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  return wrapNode(Token.FUNCTION, typeParameters, thisType, paramsType, restResultType);\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    if (buf.length() > 0) {\n        return buf.toString();\n    }\n    return str;\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    if (buf.length() > 0) {\n        return buf.toString();\n    }\n    return str;\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLength = str.length();\n    if (strLength == 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(strLength);\n    for (int i = 0; i < strLength; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues result = null;\n\n    if (statistics != null && !statistics.isEmpty()) {\n\n        SummaryStatistics summaryStatisticsPrototype = null;\n        for (SummaryStatistics stat : statistics) {\n            if (summaryStatisticsPrototype == null) {\n                summaryStatisticsPrototype = stat;\n            } else {\n                if (!summaryStatisticsPrototype.equals(stat)) {\n                    throw new IllegalArgumentException(\"Cannot aggregate, not all SummaryStatistics have the same prototype.\");\n                }\n            }\n        }\n\n        result = new AggregateSummaryStatistics(summaryStatisticsPrototype);\n        for (SummaryStatistics stat : statistics) {\n            ((AggregateSummaryStatistics) result).mergeStatistics(stat);\n        }\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues result = new DefaultStatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        result.addValue(stat.getSum(), stat.getSumSquares(), stat.getN());\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues result = new DefaultStatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        result.add(stat);\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues result = null;\n\n    if (statistics != null && !statistics.isEmpty()) {\n\n        StatisticalSummary statsPrototype = null;\n\n        // Find prototype statistics\n        for (SummaryStatistics s : statistics) {\n            if (statsPrototype == null) {\n                statsPrototype = s;\n            } else {\n                if (!statsPrototype.getClass().equals(s.getClass())) {\n                    throw new IllegalArgumentException(\n                            \"Cannot aggregate SummaryStatistics of different types\");\n                }\n            }\n        }\n\n        // Create result object\n        result = (StatisticalSummaryValues) statsPrototype.copy();\n\n        // Accumulate values from all statistics objects\n        for (SummaryStatistics s : statistics) {\n            result.addValue(s.getValues());\n        }\n\n        // Compute the result\n        result.compute();\n    }\n\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues result = null;\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        if (result == null) {\n            result = new StatisticalSummaryValuesImpl();\n            result.setSumOfSquares(stat.getSumOfSquares());\n            result.setSum(stat.getSum());\n            result.setSumSquares(stat.getSumSquares());\n            result.setCount(stat.getN());\n        } else {\n            result.setSumOfSquares(result.getSumOfSquares() + stat.getSumOfSquares());\n            result.setSum(result.getSum() + stat.getSum());\n            result.setSumSquares(result.getSumSquares() + stat.getSumSquares());\n            result.setCount(result.getCount() + stat.getN());\n        }\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues result = null;\n\n    if (statistics != null && !statistics.isEmpty()) {\n\n        result = statistics.iterator().next();\n\n        for (SummaryStatistics next : statistics) {\n            if (result != next) {\n                result.combine(next);\n            }\n        }\n    }\n\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues result = new StatisticalSummaryValues();\n    for (StatisticalSummary stat : statistics) {\n        for (Map.Entry<String, Double> entry : stat.getValues().entrySet()) {\n            result.addValue(entry.getKey(), entry.getValue());\n        }\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    // Create an iterator for the collection.\n    Iterator<SummaryStatistics> it = statistics.iterator();\n    SummaryStatistics result = it.next();\n    while (it.hasNext()) {\n        SummaryStatistics next = it.next();\n        result.merge(next);\n    }\n    return result.getSummaryStatisticsValues();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics result = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        result.merge(stat);\n    }\n    return result.getSummaryStatisticsValues();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics result = new SummaryStatistics();\n\n    // Merge all the statistics into a single SummaryStatistics object\n    for (SummaryStatistics stat : statistics) {\n        result.addValue(stat.getSum());\n        result.addValue(stat.getSumSquares());\n        result.addValue(stat.getN());\n        result.addValue(stat.getMin());\n        result.addValue(stat.getMax());\n    }\n\n    // Create a StatisticalSummaryValues object from the merged SummaryStatistics object\n    StatisticalSummaryValues summaryValues = new StatisticalSummaryValues();\n    summaryValues.setSum(result.getSum());\n    summaryValues.setSumSquares(result.getSumSquares());\n    summaryValues.setN(result.getN());\n    summaryValues.setMin(result.getMin());\n    summaryValues.setMax(result.getMax());\n\n    return summaryValues;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(\"Insufficient observed points in sample\",\n                n, 2);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double dev = sample1[i] - sample2[i] - meanDifference;\n        result += dev * dev / (n - 1);\n    }\n    return result;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        sumSquaredDifferences += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return sumSquaredDifferences / n;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += FastMath.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                    n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow((sample1[i] - sample2[i] - meanDifference), 2);\n        }\n        return result / ((double) n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be >= 2\");\n    }\n    double sumSq = 0;\n    for (int i = 0; i < n; i++) {\n        final double dev = sample1[i] - sample2[i] - meanDifference;\n        sumSq += dev * dev;\n    }\n    return sumSq / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        } else if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += (diff - meanDifference) * (diff - meanDifference);\n        }\n        return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifference = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifference += diff * diff;\n    }\n    return sumSquaredDifference / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        } else if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                    n, 2);\n        }\n        double sumSq = 0;\n        for (int i = 0; i < n; i++) {\n            double dev = sample1[i] - sample2[i] - meanDifference;\n            sumSq += dev * dev;\n        }\n        return sumSq / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        } else if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                    n, 2);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            variance += diff * diff;\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                    n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tdouble total = 0.0;\n\tfor (Comparable key : dataset.getKeys()) {\n\t\tNumber number = dataset.getValue(key);\n\t\tif (number != null && number.doubleValue() > 0.0) {\n\t\t\ttotal += number.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tdouble total = 0.0;\n\tfor (Comparable key : dataset.getKeys()) {\n\t\tNumber value = dataset.getValue(key);\n\t\tif (value != null && value.doubleValue() >= 0) {\n\t\t\ttotal = total + value.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number number = dataset.getValue(key);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                total = total + value;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number number = dataset.getValue(key);\n        if (number != null) {\n            total += number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getKeys().size();\n    for (int item = 0; item < categoryCount; item++) {\n        Number number = dataset.getValue(item);\n        if (number != null) {\n            total += number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tdouble total = 0.0;\n\tfor (int item = 0; item < dataset.getSeriesCount(); item++) {\n\t\tComparable key = dataset.getSeriesKey(item);\n\t\tNumber value = dataset.getValue(key);\n\t\tif (value != null) {\n\t\t\ttotal += value.doubleValue();\n\t\t}\n\t}\n\treturn total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n\tif (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Comparable key = dataset.getSeriesKey(series);\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getKeys().size();\n    for (int item = 0; item < categoryCount; item++) {\n        Number number = dataset.getValue(item);\n        if (number != null && number.doubleValue() > 0.0) {\n            total += number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tdouble total = 0.0;\n\tint seriesCount = dataset.getSeriesCount();\n\tfor (int series = 0; series < seriesCount; series++) {\n\t\tComparable key = dataset.getKey(series);\n\t\tNumber value = dataset.getValue(key);\n\t\tif (value != null) {\n\t\t\tdouble dvalue = value.doubleValue();\n\t\t\tif (dvalue >= 0.0) {\n\t\t\t\ttotal += dvalue;\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NAME) {\n      String name = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return name;\n    }\n    throw new IOException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_NAME)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    }\n    if (p == PEEKED_BUFFERED)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    }\n    if (p == PEEKED_SINGLE_QUOTED)\n    {\n        peekedName = nextQuotedValue('\\'');\n        peeked = PEEKED_NAME;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED)\n    {\n        peekedName = nextQuotedValue('\"');\n        peeked = PEEKED_NAME;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    }\n    if (p == PEEKED_UNQUOTED)\n    {\n        peekedName = nextUnquotedValue();\n        peeked = PEEKED_NAME;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedName;\n    } else {\n        throw new IOException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_NAME)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_UNQUOTED)\n    {\n        peekedString = nextUnquotedValue();\n    }\n    else\n    if (p == PEEKED_SINGLE_QUOTED)\n    {\n        peekedString = nextQuotedValue('\\'');\n    }\n    else\n    if (p == PEEKED_DOUBLE_QUOTED)\n    {\n        peekedString = nextQuotedValue('\"');\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NAME;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n      p = doPeek();\n    }\n    if (p == PEEKED_NAME)\n    {\n      String result = peekedString;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    else\n    {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_STRING) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED) \n    {\n        peekedString = nextQuotedValue('\\'');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        peekedString = nextQuotedValue('\"');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_LONG)\n    {\n        peekedString = Long.toString(peekedLong);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_UNQUOTED)\n    {\n        peekedString = nextUnquotedValue();\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_STRING) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_STRING) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_UNQUOTED) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_BUFFERED) \n    {\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    \n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n      p = doPeek();\n    }\n    if (p == PEEKED_NAME)\n    {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED)\n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_NAME;\n      return peekedString;\n    }\n    if (p == PEEKED_UNQUOTED)\n    {\n      peekedString = nextUnquotedValue();\n      peeked = PEEKED_NAME;\n      return peekedString;\n    }\n    if (p == PEEKED_BUFFERED)\n    {\n      if (peekedString == null)\n      {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n      }\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedName;\n    } else {\n      throw new IOException(\"Expected a property name but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n    {\n        return null;\n    } else if (array.length == 0)\n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n    {\n        return null;\n    } \n    else if (array.length == 0)\n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++)\n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++)\n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0)\n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining <= 0) {\n            inUncompressedChunk = false;\n            return 0;\n        }\n        final int bytesToRead = Math.min(uncompressedBytesRemaining, len);\n        final int bytesRead = in.read(b, off, bytesToRead);\n        if (bytesRead > 0) {\n            uncompressedBytesRemaining -= bytesRead;\n            current.bytesReadFromStream += bytesRead;\n        }\n        return bytesRead;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else if (inUncompressedChunk) {\n        int bytesToRead = Math.min(uncompressedBytesRemaining, len);\n        in.read(b, off, bytesToRead);\n        uncompressedBytesRemaining -= bytesToRead;\n        return bytesToRead;\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining <= 0) {\n            return -1;\n        }\n        int bytesToRead = Math.min(uncompressedBytesRemaining, len);\n        int bytesRead = in.read(b, off, bytesToRead);\n        if (bytesRead >= 0) {\n            uncompressedBytesRemaining -= bytesRead;\n        }\n        return bytesRead;\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesLeftInCurrentChunk = (int) Math.min(uncompressedBytesRemaining,\n                                                     len);\n        if (bytesLeftInCurrentChunk > 0) {\n            in.read(b, off, bytesLeftInCurrentChunk);\n            uncompressedBytesRemaining -= bytesLeftInCurrentChunk;\n            return bytesLeftInCurrentChunk;\n        } else {\n            inUncompressedChunk = false;\n            currentCompressedChunk.reset();\n        }\n    }\n\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n\n    int bytesRead = currentCompressedChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        if (hasNextCompressedChunk()) {\n            currentCompressedChunk = getNextCompressedChunk();\n            currentCompressedChunk.reset();\n            bytesRead = currentCompressedChunk.read(b, off, len);\n        }\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        final int bytesToCopy = Math.min(uncompressedBytesRemaining, len);\n        in.read(b, off, bytesToCopy);\n        uncompressedBytesRemaining -= bytesToCopy;\n        return bytesToCopy;\n    } else if (currentCompressedChunk != null)\n    {\n        final int bytesToCopy = Math.min(currentCompressedChunk.available(), len);\n        currentCompressedChunk.read(b, off, bytesToCopy);\n        return bytesToCopy;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        if (currentUncompressedChunk == null)\n        {\n            readNextBlock();\n            if (endReached)\n            {\n                return -1;\n            }\n        }\n        int bytesToRead = len;\n        if (bytesToRead > uncompressedBytesRemaining) \n        {\n            bytesToRead = (int) uncompressedBytesRemaining;\n        }\n        int bytesRead = currentUncompressedChunk.read(b, off, bytesToRead);\n        uncompressedBytesRemaining -= bytesRead;\n        if (uncompressedBytesRemaining == 0)\n        {\n            currentUncompressedChunk.close();\n            currentUncompressedChunk = null;\n            inUncompressedChunk = false;\n        }\n        return bytesRead;\n    }\n    else if (currentCompressedChunk != null) \n    {\n        int bytesToRead = len;\n        if (bytesToRead > currentCompressedChunk.available()) \n        {\n            bytesToRead = currentCompressedChunk.available();\n        }\n        int bytesRead = currentCompressedChunk.read(b, off, bytesToRead);\n        if (currentCompressedChunk.available() == 0)\n        {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n            inUncompressedChunk = true;\n        }\n        return bytesRead;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk = currentCompressedChunk.getNext();\n            if (currentCompressedChunk == null) {\n                endReached = true;\n            } else {\n                currentCompressedChunk.reset();\n            }\n            return readOnce(b, off, len);\n        }\n        return read;\n    }\n\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            inUncompressedChunk = false;\n            if (currentCompressedChunk == null) {\n                endReached = true;\n            }\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else {\n        return inUncompressedChunk ? in.read(b, off, len) : -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesLeftInChunk = (int) Math.min(uncompressedBytesRemaining,\n                len);\n        if (bytesLeftInChunk <= 0) {\n            return -1;\n        }\n        in.read(b, off, bytesLeftInChunk);\n        uncompressedBytesRemaining -= bytesLeftInChunk;\n        return bytesLeftInChunk;\n    } else {\n        return currentCompressedChunk.read(b, off, len);\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n            read = currentCompressedChunk.read(b, off, len);\n        }\n        return read;\n    } else {\n        return -1;\n    }\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  if (!(site instanceof CallOrNewOrDotCallSite)) {\n    return null;\n  }\n  CallOrNewOrDotCallSite callSite = (CallOrNewOrDotCallSite) site;\n  return callSite.getArgument(argIndex);\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg;\n  if (site.isCall()) {\n    CallNode callNode = site.getNode();\n    if (callNode.getArguments().size() <= argIndex) {\n      return null;\n    }\n    arg = callNode.getArguments().get(argIndex);\n  } else if (site.isNew()) {\n    NewNode newExpr = site.getNode();\n    if (newExpr.getArguments().size() <= argIndex) {\n      return null;\n    }\n    arg = newExpr.getArguments().get(argIndex);\n  } else if (site.isDotCall()) {\n    DotCallNode dotCallNode = site.getNode();\n    if (dotCallNode.getArguments().size() <= argIndex) {\n      return null;\n    }\n    arg = dotCallNode.getArguments().get(argIndex);\n  } else {\n    assert false : \"Bad usage site: \" + site;\n    return null;\n  }\n\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getNode();\n\n    if (node.isCall()) {\n      return NodeUtil.getArgument(node, argIndex);\n    } else if (node.isNew()) {\n      return NodeUtil.getArgument(node, argIndex + 1);\n    } else if (node.isDot()) {\n      return NodeUtil.getArgument(node, argIndex + 1);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = site.getUseSource();\n\n    // skip the function/method name\n    while (arg.isName() || arg.isGetProp()) {\n        arg = arg.getNext();\n    }\n\n    int index = 0;\n    while (arg != null) {\n        if (index == argIndex) {\n            return arg;\n        }\n        index++;\n        arg = arg.getNext();\n    }\n\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node argNode;\n  if (site.isCallUseSite()) {\n    argNode = site.getCallNode().getArg(argIndex);\n  } else if (site.isNewUseSite()) {\n    argNode = site.getNewNode().getArg(argIndex);\n  } else if (site.isDotCallUseSite()) {\n    argNode = site.getDotCallNode().getArg(argIndex);\n  } else {\n    throw new IllegalStateException(\n        \"Unexpected usage site: \" + site);\n  }\n  return argNode;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = site.getArgument(argIndex);\n    if (site.isMethodCallOrNew() && site.getReceiver() != null) {\n      arg = site.getReceiver();\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = getArgumentForCallOrNewOrDotCallHelper(site, argIndex);\n    if (arg == null) {\n      return null;\n    }\n\n    if (site instanceof CallSite) {\n      CallSite callSite = (CallSite) site;\n      Node function = callSite.getFunction();\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return arg;\n      }\n      if (callSite.isCallExpression()) {\n        return arg;\n      }\n      if (callSite.isDotCallExpression()) {\n        return arg;\n      }\n    }\n\n    if (site instanceof NewSite) {\n      NewSite newSite = (NewSite) site;\n      Node type = newSite.getType();\n      if (type.isName()) {\n        String name = type.getString();\n        if (\"Array\".equals(name)) {\n          return arg;\n        }\n      }\n    }\n\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  if (!(site instanceof DirectUseSite)) {\n    return null;\n  }\n\n  DirectUseSite directSite = (DirectUseSite) site;\n  Node node = directSite.getNode();\n\n  if (node.isCall()) {\n    return ((CallNode) node).getArg(argIndex);\n  } else if (node.isNew()) {\n    // new expressions have no arguments.\n    return null;\n  } else if (node.isGetProp()) {\n    GetPropNode getPropNode = (GetPropNode) node;\n    if (getPropNode.isOnlyModifiesThisCall()) {\n      // getPropNode.getArg(argIndex) may not be the right argument we're looking for.\n      // It may be a call to a method on the object which is then used to\n      // generate a new object.\n      return getPropNode.getLastChild();\n    } else {\n      return getPropNode.getArg(argIndex);\n    }\n  } else {\n    return null;\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = site.getNode();\n    if (arg.isCall()) {\n        Node callee = arg.getFirstChild();\n        if (callee.isName()) {\n            if (\"require\".equals(callee.getString())) {\n                return null;\n            }\n        }\n        arg = arg.get(argIndex + 1);\n    } else if (arg.isNew()) {\n        arg = arg.get(argIndex + 1);\n    } else if (arg.isGetProp()) {\n        arg = arg.get(argIndex + 1);\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  if (!site.isCallOrNewOrDotCall()) {\n    return null;\n  }\n  CallOrNewOrDotCall callOrNewOrDotCall = site.asCallOrNewOrDotCall();\n  List<? extends Node> arguments = callOrNewOrDotCall.getArguments();\n  if (argIndex >= arguments.size()) {\n    return null;\n  }\n  return arguments.get(argIndex);\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  ObjectType implicitProto = type.toObjectType().getImplicitPrototype();\n  if (implicitProto != null) {\n    return getTypeDeprecationInfo(implicitProto);\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    ObjectType implicitProto = type.toObjectType().getImplicitPrototype();\n    if (implicitProto != null) \n    {\n        return getTypeDeprecationInfo(implicitProto);\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  ObjectType implicitProto = type.toObjectType().getImplicitPrototype();\n  if (implicitProto != null) {\n    return getTypeDeprecationInfo(implicitProto);\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  ObjectType implicitProto = type.getImplicitPrototype();\n  if (implicitProto != null) {\n    return getTypeDeprecationInfo(implicitProto);\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n    ObjectType implicitProto = type.toObjectType();\n    if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n        \n        return \"\";\n    }\n\n    if (type.isUnionType()) \n    {\n        return getTypeDeprecationInfo(type.toMaybeUnionType().getAlternates().get(0));\n    }\n\n    if (type.isObjectType()) \n    {\n        return getPropertyDeprecationInfo(type.toObjectType(), null);\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n    ObjectType implicitProto = type.toObjectType().getImplicitPrototype();\n    if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  ObjectType implicitProto = type.getImplicitPrototype();\n  if (implicitProto != null) {\n    return getTypeDeprecationInfo(implicitProto);\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) \n  {\n    if (info.getDeprecationReason() != null) \n    {\n      return info.getDeprecationReason();\n    }\n    \n    return \"\";\n  }\n  return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    return FastDatePrinter.cache.get(key);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    return TimeZoneDisplayCache.getString(key);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    return FastDatePrinter.cache.getString(key);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    return getTimeZoneDisplayCache().getTimeZoneDisplay(tz, daylight, style, locale);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final int key = (daylight ? 0x80000000 : 0) | style | (locale == null ? 0 : locale.hashCode());\n    String result = cache.get(key);\n    if (result != null) {\n        return result;\n    }\n    result = new TimeZoneDisplayKey(tz, daylight, style, locale).toString();\n    cache.put(key, result);\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    return cache.get(key);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n\n    return cache.getString(key);\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cache.get(key);\n    if (result == null) {\n        result = getTimeZoneDisplayFallback(tz, daylight, style, locale);\n        cache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n\n    return cache.getString(key, new Callable<String>() {\n}\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    return getTimeZoneDisplayCache().getTimeZoneDisplay(tz, daylight, style, locale);\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n\tList<?> columns = getRowKeys();\n\tfor (int i = 0; i < columns.size(); i++) \n\t{\n\t\tif (columns.get(i).equals(key)) \n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tList keys = getRowKeys();\n\treturn keys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int column = this.columnMap.get(key);\n    if (column == null) {\n        column = this.columnMap.get(key + this.categoryOffset);\n    }\n    if (column == null) {\n        column = -1;\n    }\n    return column;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tList<Comparable> keys = getRowKeys();\n    if (keys == null || keys.isEmpty()) \n    {\n        return -1;\n    }\n    for (int i=0; i<keys.size(); i++)\n    {\n        if (key.equals(keys.get(i)))\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return Arrays.asList(this.columnKeys).indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"null key\");\n    }\n\n    for (int i = 0; i < getColumnCount(); i++) \n    {\n        Comparable currentKey = getColumnName(i);\n        if (currentKey.equals(key)) \n        {\n            return i;\n        }\n    }\n\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tList keys = getRowKeys();\n\tfor (int i = 0; i < keys.size(); i++) {\n\t\tif (keys.get(i).equals(key)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    List keys = getRowKeys();\n    for (Comparable k : keys)\n    {\n        if (k.equals(key))\n        {\n            return keys.indexOf(key);\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tList<?> columns = getRowKeys();\n\tfor(int i = 0; i < columns.size(); i++) {\n\t    if(key.equals(columns.get(i))) {\n\t        return i;\n\t    }\n\t}\n\treturn -1;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (isSequence(min, point, max)) {\n        return checkPoint(min, max, new Complex(point, 0));\n    } else {\n        if (FastMath.abs(point - best(a, b, true).getValue()) <= tolerance) {\n            return Location.BOUNDARY;\n        } else if (FastMath.abs(point - best(a, b, false).getValue()) <= tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.OUTSIDE;\n        }\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif (isSequence(min, point, max)) \n\t{\n\t\tfinal double z = point;\n\t\tfinal double tolerance = FastMath.max(getRelativeAccuracy() * z, getAbsoluteAccuracy());\n\t\treturn (FastMath.abs(z.getImaginary()) <= tolerance) ||\n\t\t\t   (z.abs() <= getFunctionValueAccuracy()) ? Location.INSIDE : Location.OUTSIDE;\n\t}\n\treturn Location.BOUNDARY;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (isSequence(min, point, max)) {\n        if (FastMath.abs(point) <= tolerance) {\n            return Location.BOUNDARY;\n        } else if (point < min) {\n            return Location.OUTSIDE;\n        } else if (point > max) {\n            return Location.OUTSIDE;\n        } else {\n            return Location.INSIDE;\n        }\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (isSequence(min, point, max)) \n        {\n            if (FastMath.abs(point - oldx) <= tolerance) {\n                return Location.BOUNDARY;\n            }\n            return (FastMath.abs(computeObjectiveValue(point)) <= functionValueAccuracy) ? Location.INSIDE : Location.OUTSIDE;\n        }\n        return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (isSequence(min, point, max)) {\n            if (FastMath.abs(point) <= tolerance) {\n                return Location.BOUNDARY;\n            } else {\n                return Location.INSIDE;\n            }\n        } else {\n            return Location.OUTSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif (point < min) {\n\t\tif (point + tolerance < min) {\n\t\t\treturn Location.OUTSIDE;\n\t\t} else {\n\t\t\treturn Location.BOUNDARY;\n\t\t}\n\t} else if (point > max) {\n\t\tif (point - tolerance > max) {\n\t\t\treturn Location.OUTSIDE;\n\t\t} else {\n\t\t\treturn Location.BOUNDARY;\n\t\t}\n\t} else {\n\t\tif (abs(point) <= tolerance) {\n\t\t\treturn Location.INSIDE;\n\t\t} else {\n\t\t\treturn Location.BOUNDARY;\n\t\t}\n\t}\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (isSequence(min, point, max)) {\n        if (FastMath.abs(point) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n    }\n    return checkPoint(min, max, point);\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (isSequence(min, point, max)) \n        {\n            if (FastMath.abs(point - min) <= tolerance) \n            {\n                return Location.BOUNDARY;\n            }\n            else if (FastMath.abs(point - max) <= tolerance) \n            {\n                return Location.BOUNDARY;\n            }\n            else\n            {\n                return Location.INSIDE;\n            }\n        }\n        else\n        {\n            return Location.OUTSIDE;\n        }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif (isSequence(min, point, max)) \n\t{\n\t\tif (FastMath.abs(point) <= tolerance) \n\t\t{\n\t\t\treturn Location.BOUNDARY;\n\t\t}\n\t\treturn isRoot(min, max, new Complex(point, 0)) ? Location.INSIDE : Location.OUTSIDE;\n\t}\n\t\n\treturn Location.UNKNOWN;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (isSequence(min, point, max)) \n        {\n            return (Math.abs(point) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n        }\n        return Location.OUTSIDE;\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000.0, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(0.2, numberFormat, 2));\n    units.add(new NumberTickUnit(0.5, numberFormat, 5));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    \n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50000000, numberFormat, 5));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 10), numberFormat, 4));\n    units.add(new NumberTickUnit(Math.pow(10, 11), numberFormat, 4));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -7), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -6), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat, 5));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(3, numberFormat, 2));\n    units.add(new NumberTickUnit(4, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 2));\n    units.add(new NumberTickUnit(6, numberFormat, 2));\n    units.add(new NumberTickUnit(7, numberFormat, 2));\n    units.add(new NumberTickUnit(8, numberFormat, 2));\n    units.add(new NumberTickUnit(9, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000.0, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    \n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(3, numberFormat, 2));\n    units.add(new NumberTickUnit(4, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 2));\n    units.add(new NumberTickUnit(6, numberFormat, 2));\n    units.add(new NumberTickUnit(7, numberFormat, 2));\n    units.add(new NumberTickUnit(8, numberFormat, 2));\n    units.add(new NumberTickUnit(9, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 10), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 11), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 12), numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(3, numberFormat, 2));\n    units.add(new NumberTickUnit(4, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(6, numberFormat, 5));\n    units.add(new NumberTickUnit(7, numberFormat, 5));\n    units.add(new NumberTickUnit(8, numberFormat, 5));\n    units.add(new NumberTickUnit(9, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -7), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -6), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat, 5));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat, 5));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegative = Double.NEGATIVE_INFINITY;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double negative = tableau.getEntry(0, col);\n        if (negative > maxNegative) {\n            maxNegative = negative;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegativeCoefficient = Double.NEGATIVE_INFINITY;\n    \n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) \n    {\n        double coefficient = tableau.getEntry(0, col);\n        if (coefficient > maxNegativeCoefficient) \n        {\n            maxNegativeCoefficient = coefficient;\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minVal = Double.MAX_VALUE;\n\n    // loop through the objective function row\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        if (tableau.getEntry(0, col) < minVal) {\n            minVal = tableau.getEntry(0, col);\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegativeCoeff = Double.NEGATIVE_INFINITY;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double coeff = tableau.getEntry(0, col);\n        if (maxNegativeCoeff < coeff) {\n            maxNegativeCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minVal = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) \n    {\n        final double val = tableau.getEntry(0, i);\n        if (val < minVal) \n        {\n            minVal = val;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minVal = Double.MAX_VALUE;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double sum = 0;\n        for (int row = 0; row < tableau.getNumObjectiveFunctions(); row++) {\n            sum += tableau.getEntry(row, col);\n        }\n\n        if (sum < minVal) {\n            minVal = sum;\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegative = Double.NEGATIVE_INFINITY;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        final double entry = tableau.getEntry(0, col);\n        if (entry < maxNegative) {\n            maxNegative = entry;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoeff = Double.MIN_VALUE;\n\n    for (int j = tableau.getNumObjectiveFunctions(); j < tableau.getWidth() - 1; j++) {\n        double coeff = tableau.getEntry(0, j);\n        if (coeff > minCoeff) {\n            minCoeff = coeff;\n            pivotCol = j;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegativeCoeff = Double.NEGATIVE_INFINITY;\n\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double negativeCoeff = tableau.getEntry(0, col);\n        if (negativeCoeff > maxNegativeCoeff) {\n            maxNegativeCoeff = negativeCoeff;\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double maxNegativeCoeff = Double.NEGATIVE_INFINITY;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        final double coeff = tableau.getEntry(0, col);\n        if (coeff > maxNegativeCoeff) {\n            maxNegativeCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}"
    ]
  ]
}