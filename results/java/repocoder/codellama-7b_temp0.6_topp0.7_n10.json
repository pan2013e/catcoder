{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.5643216080402009,
    "pass@1": 0.3557788944723619,
    "compile@3": 0.6731574539363481,
    "pass@3": 0.4283500837520937,
    "compile@5": 0.7171970965940814,
    "pass@5": 0.4573462550849485
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    return replace(str, null, 0, size, 1);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replace(str, null, 0, size, 1);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replace(str, null, 0, size, 1);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replace(str, null, 0, size, 1);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replace(str, null, 0, size, 1);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int n = m.getRowDimension();\n        final RealMatrix out = createMatrix(n, n);\n        for (int i = 0; i < n; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n        return out;\n    }\n    else {\n        final int n = m.getColumnDimension();\n        final RealMatrix out = createMatrix(n, n);\n        for (int i = 0; i < n; ++i) {\n            out.setEntry(i, i, m.getEntry(i, i));\n        }\n        return out;\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    final int m2 = m.getColumnDimension();\n    if (n != m2) {\n        throw new IllegalArgumentException(\"Matrix must be square\");\n    }\n\n    final RealMatrix out = createMatrix(n, n);\n    for (int i = 0; i < n; ++i) {\n        out.setEntry(i, i, m.getEntry(i, i));\n    }\n\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            if (i == j) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            if (i == j) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            } else {\n                out.setEntry(i, j, 0);\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() == 1) {\n        final RealMatrix out = createMatrix(n, n);\n        for (int i = 0; i < n; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n        return out;\n    }\n    final RealMatrix out = createMatrix(n, 1);\n    for (int i = 0; i < n; ++i) {\n        out.setEntry(i, 0, m.getEntry(i, i));\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            out.setEntry(i, j, m.getEntry(i, i));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            out.setEntry(i, j, m.getEntry(i, i));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            if (i == j) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            if (i == j) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    final int m1 = m.getColumnDimension();\n    final RealMatrix out;\n    if (m1 == 1) {\n        out = createMatrix(n, n);\n        for (int i = 0; i < n; ++i) {\n            out.setEntry(i, i, m.getEntry(i, 0));\n        }\n    } else if (n == 1) {\n        out = createMatrix(m1, m1);\n        for (int i = 0; i < m1; ++i) {\n            out.setEntry(i, i, m.getEntry(0, i));\n        }\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n    return out;\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException \n    {\n        if (id == null) {\n            return getDefault();\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            id = convId;\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Check if the ID is a fixed offset\n        int offset = parseOffset(id);\n        if (offset != 0) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        // Check if the ID is a time zone ID\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            id = convId;\n        }\n\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                return fixedOffsetZone(id, offset);\n            }\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            id = convId;\n        }\n\n        // Check for UTC\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Check for fixed offset\n        int offset = parseOffset(id);\n        if (offset != 0L) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        // Check the provider\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // If this point is reached, mapping must link to another.\n        return forID((String)cProvider.getZone(id));\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException \n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException \n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            id = convId;\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = id;\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return add(one);\n    }\n\n    if (x == RADIX-2) {\n        return add(one).subtract(one);\n    }\n\n    // do the multiply\n    int product[] = new int[mant.length];\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;\n        carry = r / RADIX;\n        product[i] = r - carry * RADIX;\n    }\n\n    // normalize\n    while (carry != 0) {\n        product[mant.length] = carry % RADIX;\n        carry = carry / RADIX;\n        mant.length++;\n    }\n\n    // return the result\n    return newInstance(product, exp + 1);\n}",
      "private Dfp multiplyFast(final int x)  {\n    // make sure we don't mix number with different precision\n    if (field.getRadixDigits() != x.field.getRadixDigits()) \n    {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n    }\n\n    Dfp result = newInstance(getZero());\n\n    /* handle special cases */\n    if (nans != FINITE || x.nans != FINITE) \n    {\n        if (isNaN()) \n        {\n            return this;\n        }\n\n        if (x.isNaN()) \n        {\n            return x;\n        }\n\n        if (nans == INFINITE && x.nans == FINITE) \n        {\n            return this;\n        }\n\n        if (x.nans == INFINITE && nans == FINITE) \n        {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) \n        {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    Dfp b = newInstance(x);\n\n    /* initialize the result object */\n    Dfp result = newInstance(getZero());\n\n    /* compute the result */\n    int rl = 0;\n}",
      "private Dfp multiplyFast(final int x)  {\n    // make sure we don't mix number with different precision\n    if (field.getRadixDigits() != x.field.getRadixDigits()) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n    }\n\n    Dfp result = newInstance(getZero());\n\n    /* handle special cases */\n    if (nans != FINITE || x.nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (x.isNaN()) {\n            return x;\n        }\n\n        if (nans == INFINITE && x.nans == FINITE) {\n            return this;\n        }\n\n        if (x.nans == INFINITE && nans == FINITE) {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    Dfp b = newInstance(x);\n\n    /* initialize the result object */\n    Dfp result = newInstance(getZero());\n    if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return newInstance(this).negate();\n    }\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        mant[i] = rh;\n    }\n\n    final int excp = round(rl * RADIX / x);\n    if (excp != 0) {\n        return dotrap(excp, MULTIPLY_TRAP, newInstance(x), this);\n    }\n\n    return this;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return newInstance(this).negate();\n    }\n\n    if (x == RADIX-2) {\n        return newInstance(this).subtract(newInstance(this).divide(newInstance(2)));\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    final int excp = result.round(rl * RADIX / x);  // do the rounding\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return newInstance(this).add(newInstance(this));\n    }\n\n    if (x == RADIX-2) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-3) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-4) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-5) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-6) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-7) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-8) {\n        return newInstance(this).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this)).add(newInstance(this));\n    }\n\n    if (x == RADIX-9) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    // make sure we don't mix number with different precision\n    if (field.getRadixDigits() != x.field.getRadixDigits()) \n    {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n    }\n\n    Dfp result = newInstance(getZero());\n\n    /* handle special cases */\n    if (nans != FINITE || x.nans != FINITE) \n    {\n        if (isNaN()) \n        {\n            return this;\n        }\n\n        if (x.isNaN()) \n        {\n            return x;\n        }\n\n        if (nans == INFINITE && x.nans == FINITE) \n        {\n            return this;\n        }\n\n        if (x.nans == INFINITE && nans == FINITE) \n        {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) \n        {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    Dfp b = newInstance(x);\n\n    /* initialize the result object */\n    Dfp result = newInstance(getZero());\n\n    int rl = 0;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return newInstance(this).add(newInstance(this));\n    }\n\n    Dfp result = newInstance(this);\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    if (result.mant[mant.length-1] == 0) {\n        // normalize\n        result.shiftLeft();\n        final int r = rl * RADIX;        // compute the next digit and put it in\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[0] = rh;\n    }\n\n    final int excp = result.round(rl * RADIX / x);  // do the rounding\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    // make sure we don't mix number with different precision\n    if (field.getRadixDigits() != x.field.getRadixDigits()) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n    }\n\n    Dfp result = newInstance(getZero());\n\n    /* handle special cases */\n    if (nans != FINITE || x.nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (x.isNaN()) {\n            return x;\n        }\n\n        if (nans == INFINITE && x.nans == FINITE) {\n            return this;\n        }\n\n        if (x.nans == INFINITE && nans == FINITE) {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n            return x;\n        }\n\n        if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n    }\n\n    /* copy this and the arg */\n    Dfp a = newInstance(this);\n    Dfp b = newInstance(x);\n\n    /* initialize the result object */\n    Dfp result = newInstance(getZero());\n    // dfp/Dfp.java\n    if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        result = newInstance(getZero());\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n}\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getSecondChild();\n            child != null;\n            child = child.getNext()) {\n        if (child.isParamList()) {\n            for (Node param = child.getFirstChild();\n                    param != null;\n                    param = param.getNext()) {\n                function.addChildToBack(\n                        IR.param(IR.name(param.getString()), IR.number(index++)));\n            }\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(new JSDocInfo());\n\n  Node param = function.getFirstChild();\n  for (Node child = exportedFunction.getFirstChild().getNext();\n       child != null;\n       child = child.getNext()) {\n    if (child.isStringKey()) {\n      param.addChildToBack(\n          NodeUtil.newParamNode(child.getString()));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild().getNext();\n            child != null;\n            child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n            function.addChildToBack(\n                    IR.param(IR.name(child.getString()), IR.number(index++)));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild().getNext();\n       child != null;\n       child = child.getNext()) {\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.param(IR.name(child.getString()), IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild().getNext();\n            child != null;\n            child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n            function.addChildToBack(\n                    IR.param(IR.name(child.getString()), IR.number(index++)));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(exportedFunction.getFirstChild().getString());\n  function.setJSType(exportedFunction.getJSType());\n\n  Node paramList = NodeUtil.getFunctionParameters(exportedFunction);\n  for (Node param : paramList.children()) {\n    Node paramNode = NodeUtil.newParamNode(param.getString());\n    paramNode.setJSType(param.getJSType());\n    function.addChildToBack(paramNode);\n  }\n\n  Node returnType = NodeUtil.getFunctionReturnType(exportedFunction);\n  if (returnType != null) {\n    function.setJSType(returnType.getJSType());\n  }\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(exportedFunction.getFirstChild().cloneNode(),\n      IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(exportedFunction.getJSDocInfo());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    NodeUtil.addFeatureToScript(\n        compiler.getScriptNode(),\n        Feature.EXPORT_INTERNAL);\n\n    return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params,\n                                               covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final int n = params.length;\n    final double[] sigma = new double[n];\n    final double[][] covariance = computeCovariances(params,\n                                                     covarianceSingularityThreshold);\n    for (int i = 0; i < n; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params,\n                                               covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params,\n                                               covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params,\n            covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final int n = params.length;\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    final double[] sigma = new double[n];\n    for (int i = 0; i < n; i++) {\n        sigma[i] = Math.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final int n = params.length;\n    final double[][] covariance = computeCovariances(params,\n                                                     covarianceSingularityThreshold);\n    final double[] sigma = new double[n];\n    for (int i = 0; i < n; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final int n = params.length;\n    final double[][] covariance = computeCovariances(params,\n                                                     covarianceSingularityThreshold);\n    final double[] sigma = new double[n];\n    for (int i = 0; i < n; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected for variable \" + varName + \".\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  throws IllegalArgumentException {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalArgumentException(\"Cyclic substitution detected for variable \" + varName);\n        }\n    }"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all symbols required in these files.\n  Set<String> required = Sets.newHashSet();\n  for (INPUT input : inputs) {\n    required.addAll(input.getRequires());\n  }\n\n  // Collect all symbols provided in these files.\n  Set<String> provided = Sets.newHashSet();\n  for (INPUT input : inputs) {\n    provided.addAll(input.getProvides());\n  }\n\n  // Gather all the dependencies.\n  Multimap<String, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      if (provided.contains(req)) {\n        deps.put(req, input);\n      }\n    }\n  }\n\n  // Get the direct dependencies.\n  Multimap<INPUT, INPUT> directDeps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        directDeps.put(input, dep);\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedInputs = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedInputs is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedInputs) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n  // to the reader.\n  if (sortedInputs.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n\n    // If we're not sorting, just return the original list.\n    if (!sorted) {\n      return inputs;\n    }\n\n    // If we're sorting, return the sorted list.\n    return sortedList;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> inputs = Lists.newArrayList(roots);\n    List<INPUT> deps = Lists.newArrayList();\n    Multimap<INPUT, INPUT> depsMap = HashMultimap.create();\n\n    // Collect all symbols provided in these files.\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          depsMap.put(input, dep);\n        }\n      }\n    }\n\n    // Get the direct dependencies.\n    for (INPUT input : inputs) {\n      for (INPUT dep : depsMap.get(input)) {\n        deps.add(dep);\n      }\n    }\n\n    if (sorted) {\n      // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n      return topologicalStableSort(inputs, depsMap);\n    } else {\n      return deps;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  List<INPUT> inputs = Lists.newArrayList(roots);\n  List<INPUT> deps = Lists.newArrayList();\n  Set<INPUT> seen = Sets.newHashSet();\n  while (!inputs.isEmpty()) {\n    INPUT input = inputs.remove(0);\n    if (seen.contains(input)) {\n      continue;\n    }\n    seen.add(input);\n    deps.add(input);\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && !seen.contains(dep)) {\n        inputs.add(dep);\n      }\n    }\n  }\n  if (sorted) {\n    return topologicalStableSort(roots, deps);\n  } else {\n    return deps;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all symbols required in these files.\n  Set<String> required = Sets.newHashSet();\n  for (INPUT input : roots) {\n    required.addAll(input.getRequires());\n  }\n\n  // Gather all the dependencies.\n  Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    if (required.containsAll(input.getRequires())) {\n      deps.putAll(input, inputs);\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(roots, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n  // to the reader.\n  if (sortedList.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedList);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    // Collect all symbols required in these files.\n    Set<String> requires = Sets.newHashSet();\n    for (INPUT input : roots) {\n      requires.addAll(input.getRequires());\n    }\n\n    // Collect all symbols provided in these files.\n    Set<String> provides = Sets.newHashSet();\n    for (INPUT input : roots) {\n      provides.addAll(input.getProvides());\n    }\n\n    // Get the direct dependencies.\n    final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : roots) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    List<INPUT> sortedInputs = topologicalStableSort(roots, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedInputs is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedInputs) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedInputs.size() < roots.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(roots);\n      subGraph.removeAll(sortedInputs);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n\n    // Find all the inputs that are not required by any other input.\n    Set<INPUT> noRequires = Sets.newHashSet();\n    for (INPUT input : inputs) {\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all symbols required in these files.\n  Set<String> requires = new HashSet<>();\n  for (INPUT input : inputs) {\n    requires.addAll(input.getRequires());\n  }\n\n  // Collect all symbols provided in these files.\n  Set<String> provides = new HashSet<>();\n  for (INPUT input : inputs) {\n    provides.addAll(input.getProvides());\n  }\n\n  // Get the direct dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Find the roots.\n  Set<INPUT> rootsSet = new HashSet<>(roots);\n  List<INPUT> rootsList = new ArrayList<>(roots);\n  List<INPUT> rootsSubGraph = new ArrayList<>(roots);\n  for (INPUT input : inputs) {\n    if (rootsSet.contains(input)) {\n      continue;\n    }\n\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && rootsSet.contains(dep)) {\n        rootsSubGraph.add(input);\n        break;\n      }\n    }\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedList = topologicalStableSort(inputs, deps);\n\n  // The dependency graph of inputs has a cycle iff sortedList is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> inputs = Lists.newArrayList(roots);\n    List<INPUT> dependencies = Lists.newArrayList();\n\n    // Collect all symbols required in these files.\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && !dependencies.contains(dep)) {\n          dependencies.add(dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    List<INPUT> sortedInputs = topologicalStableSort(inputs, dependencies);\n\n    // The dependency graph of inputs has a cycle iff sortedInputs is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedInputs) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedInputs.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedInputs);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, dependencies)));\n    }\n\n    if (sorted) {\n      return sortedInputs;\n    } else {\n      return inputs;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  // Collect all the dependencies.\n  final Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String req : input.getRequires()) {\n      INPUT dep = provideMap.get(req);\n      if (dep != null && dep != input) {\n        deps.put(input, dep);\n      }\n    }\n  }\n\n  // Get the dependencies of the roots.\n  List<INPUT> dependencies = Lists.newArrayList();\n  for (INPUT root : roots) {\n    dependencies.addAll(getDependenciesOf(root, deps));\n  }\n\n  // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n  List<INPUT> sortedDependencies = Lists.newArrayList();\n  if (sorted) {\n    sortedDependencies = topologicalStableSort(dependencies, deps);\n  } else {\n    sortedDependencies.addAll(dependencies);\n  }\n\n  // The dependency graph of inputs has a cycle iff sortedDependencies is a proper\n  // subset of inputs. Also, it has a cycle iff the subgraph\n  // (inputs - sortedDependencies) has a cycle. It's fairly easy to prove this\n  // by the lemma that a graph has a cycle iff it has a subgraph where\n  // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n  // to the reader.\n  if (sortedDependencies.size() < inputs.size()) {\n    List<INPUT> subGraph = Lists.newArrayList(inputs);\n    subGraph.removeAll(sortedDependencies);\n\n    throw new CircularDependencyException(\n        cycleToString(findCycle(subGraph, deps)));\n  }\n\n  return sortedDependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    // Collect all symbols required in these files.\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String req : input.getRequires()) {\n        INPUT dep = provideMap.get(req);\n        if (dep != null && dep != input) {\n          deps.put(input, dep);\n        }\n      }\n    }\n\n    // Get the direct dependencies.\n    List<INPUT> directDeps = Lists.newArrayList();\n    for (INPUT input : roots) {\n      for (INPUT dep : deps.get(input)) {\n        if (!directDeps.contains(dep)) {\n          directDeps.add(dep);\n        }\n      }\n    }\n\n    // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n    List<INPUT> sortedList = topologicalStableSort(directDeps, deps);\n\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sortedList.size() < inputs.size()) {\n      List<INPUT> subGraph = Lists.newArrayList(inputs);\n      subGraph.removeAll(sortedList);\n\n      throw new CircularDependencyException(\n          cycleToString(findCycle(subGraph, deps)));\n    }\n\n    if (sorted) {\n      return sortedList;\n    } else {\n      return inputs;\n    }\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        final Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getZero();\n        c[1] = a;\n\n        Dfp y;\n        if (a.lessThan(a.getField().getPi().divide(4))) {\n            y = cosInternal(c);\n        } else {\n            final Dfp[] piSplit = a.getField().getPiSplit();\n            c[0] = piSplit[0].divide(2).subtract(a);\n            c[1] = piSplit[1].divide(2);\n            y = sinInternal(c);\n        }\n\n        return new Dfp[] {y, a.subtract(y)};\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().newInstance(a.getUnscaledValue(), a.getScale());\n        c[1] = a.getField().newInstance(a.getUnscaledValue(), a.getScale());\n\n        return c;\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        final Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] c = new Dfp[2];\n        c[0] = a.getField().getPiSplit()[0].divide(2).subtract(a);\n        c[1] = a.getField().getPiSplit()[1].divide(2);\n        return c;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n\n        Dfp[] result = new Dfp[2];\n        result[0] = a.newInstance(a.getField().getPiSplit()[0].divide(2).subtract(a));\n        result[1] = a.newInstance(a.getField().getPiSplit()[1].divide(2).subtract(a));\n\n        return result;\n\n    }"
    ],
    [
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    if (id() != null) {\n        accum.append('#').append(id());\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            accum.append(parent.cssSelector()).append(\" > \");\n        }\n        String tagName = tagName();\n        if (tagName.length() > 0) {\n            accum.append(tagName);\n        }\n        if (className().length() > 0) {\n            accum.append('.').append(className());\n        }\n        if (hasClass()) {\n            accum.append(\":nth-child(\").append(elementSiblingIndex() + 1).append(\")\");\n        }\n    }\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    cssSelector(accum);\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    cssSelector(accum);\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    // if element has ID, use #id\n    if (hasId()) \n    {\n        return \"#\" + id();\n    }\n\n    // get parent selector\n    String parentSelector = \"\";\n    Element parent = parent();\n    if (parent != null) \n    {\n        parentSelector = parent.cssSelector() + \" > \";\n    }\n\n    // create unique selector for this element\n    StringBuilder sb = new StringBuilder(parentSelector);\n    sb.append(tagName());\n\n    // add class selectors\n    if (hasClass()) \n    {\n        for (String className : classNames()) \n        {\n            sb.append(\".\");\n            sb.append(className);\n        }\n    }\n\n    // add pseudo-class selectors\n    if (hasPseudoClass()) \n    {\n        for (PseudoClass pseudoClass : pseudoClassList) \n        {\n            sb.append(\":\");\n            sb.append(pseudoClass);\n        }\n    }\n\n    // add pseudo-element selector\n    if (hasPseudoElement()) \n    {\n        sb.append(\"::\");\n        sb.append(pseudoElement);\n    }\n\n    // add nth-child selector\n    if (hasNthChild()) \n    {\n        sb.append(\":nth-child(\");\n        sb.append(nthChild);\n        sb.append(\")\");\n    }\n\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    // ID takes precedence\n    if (hasId())\n        return \"#\" + id();\n\n    // parent selector\n    Element parent = parent();\n    String parentSelector = parent != null ? parent.cssSelector() + \" > \" : \"\";\n\n    // sibling selector\n    int siblingIndex = 1;\n    Element prev = parent != null ? parent.child(0) : null;\n    while (prev != null && prev != this) {\n        if (prev.tagName().equals(tagName()))\n            siblingIndex++;\n        prev = prev.nextElementSibling();\n    }\n\n    // unique selector\n    StringBuilder sb = new StringBuilder();\n    sb.append(parentSelector);\n    sb.append(tagName());\n    if (hasClass()) {\n        sb.append(\".\");\n        sb.append(TextUtil.join(classNames(), \".\"));\n    }\n    if (hasAttr()) {\n        sb.append(\"[\");\n        sb.append(attributes().attr(\"id\"));\n        sb.append(\"]\");\n    }\n    sb.append(\":nth-child(\");\n    sb.append(siblingIndex);\n    sb.append(\")\");\n\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    cssSelector(accum);\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    cssSelector(accum);\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    if (id() != null) {\n        accum.append('#').append(id());\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            accum.append(parent.cssSelector()).append(\" > \");\n        }\n        accum.append(tagName());\n        if (!className().isEmpty()) {\n            accum.append('.').append(className());\n        }\n        if (!hasClass()) {\n            accum.append(':').append(cssSelectorUnique(this));\n        }\n    }\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    cssSelector(accum);\n    return accum.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder accum = new StringBuilder();\n    if (hasId()) {\n        accum.append('#').append(id());\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            accum.append(parent.cssSelector()).append(\" > \");\n        }\n        String tagName = tagName();\n        if (tagName.length() > 0) {\n            accum.append(tagName);\n            if (hasClass()) {\n                for (String className : classNames()) {\n                    accum.append('.').append(className);\n                }\n            }\n            if (hasAttribute(\"class\")) {\n                accum.append(\":nth-child(\").append(elementSiblingIndex() + 1).append(\")\");\n            }\n        }\n    }\n    return accum.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += 1;\n            break;\n        case Token.OR:\n        case Token.AND:\n            for (Node c : n.children()) {\n                cost += estimateCostOneLevel(c);\n            }\n            break;\n        case Token.LP:\n        case Token.RP:\n            cost += 1;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += 1;\n    }\n    for (Node child : n.children()) {\n        cost += estimateCostOneLevel(child);\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += 1;\n    }\n    for (Node c : n.children()) {\n        if (c.isNot()) {\n            cost += 1;\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    for (Node c : n.children()) {\n        if (c.isParenthesis()) {\n            cost++;\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch(n.getType())\n    {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.OR:\n        case Token.AND:\n            for(Node c : n.children())\n                cost += estimateCostOneLevel(c);\n            break;\n        case Token.PAREN:\n            cost = 1;\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.isNot()) {\n    cost++;\n  }\n  if (n.getFirstChild().isNot()) {\n    cost++;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) {\n        cost++;\n    }\n    if (n.getFirstChild() != null) {\n        cost += estimateCostOneLevel(n.getFirstChild());\n    }\n    if (n.getSecondChild() != null) {\n        cost += estimateCostOneLevel(n.getSecondChild());\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.PAREN:\n            cost = 1;\n            break;\n        case Token.AND:\n            cost = 2;\n            break;\n        case Token.OR:\n            cost = 2;\n            break;\n        case Token.HOOK:\n            cost = 2;\n            break;\n        case Token.NAME:\n            cost = 1;\n            break;\n        case Token.NUMBER:\n            cost = 1;\n            break;\n        case Token.STRING:\n            cost = 1;\n            break;\n        case Token.REGEXP:\n            cost = 1;\n            break;\n        case Token.NULL:\n            cost = 1;\n            break;\n        case Token.THIS:\n            cost = 1;\n            break;\n        case Token.TRUE:\n            cost = 1;\n            break;\n        case Token.FALSE:\n            cost = 1;\n            break;\n        case Token.GETPROP:\n            cost = 2;\n            break;\n        case Token.GETELEM:\n            cost = 2;\n            break;\n        case Token.TYPEOF:\n            cost = 1;\n            break;\n        case Token.VOID:\n            cost = 1;\n            break;\n        case Token.POS:\n            cost = 1;\n            break;\n        case Token.NEG:\n            cost = 1;\n            break;\n        case Token.BITNOT:\n            cost = 1;\n            break;\n        case Token.DELPROP:\n            cost = 2;\n            break;\n        case Token.INC:\n            cost = 1;\n            break;\n        case Token.DEC:\n            cost = 1;\n            break;\n        case Token.CALL:\n            cost = 2;\n            break;\n        case Token.NEW:\n            cost = 2;\n            break;\n        case Token.FUNCTION:\n            cost = 2;\n            break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += 1;\n            break;\n        case Token.OR:\n            cost += 2;\n            break;\n        case Token.AND:\n            cost += 2;\n            break;\n        case Token.HOOK:\n            cost += 2;\n            break;\n        case Token.PAREN:\n            cost += 1;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot())\n    {\n        cost++;\n    }\n    if (n.isParenthesis())\n    {\n        cost++;\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int len = this.length();\n    if (len == 0) \n    {\n        return this;\n    }\n    for (int i = 0, j = len - 1; j > i; i++, j--) \n    {\n        char tmp = this.buffer[i];\n        this.buffer[i] = this.buffer[j];\n        this.buffer[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (this.buffer.length > 1) {\n        int len = this.buffer.length;\n        for (int i = 0, j = len - 1; j > i; i++, j--) {\n            char tmp = this.buffer[i];\n            this.buffer[i] = this.buffer[j];\n            this.buffer[j] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = this.length();\n    if (len == 0) {\n        return this;\n    }\n    int mid = len / 2;\n    for (int i = 0; i < mid; i++) {\n        int j = len - i - 1;\n        char tmp = this.buffer[i];\n        this.buffer[i] = this.buffer[j];\n        this.buffer[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n        int len = this.length();\n        if (len == 0) \n        {\n            return this;\n        }\n        for (int i = 0, j = len - 1; j > i; i++, j--) \n        {\n            char tmp = this.buffer[i];\n            this.buffer[i] = this.buffer[j];\n            this.buffer[j] = tmp;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n        if (this.buffer.length > 1) {\n            int i = 0;\n            int j = this.buffer.length - 1;\n            char tmp;\n            while (j > i) {\n                tmp = this.buffer[j];\n                this.buffer[j] = this.buffer[i];\n                this.buffer[i] = tmp;\n                j--;\n                i++;\n            }\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n        if (this.buffer.length > 1) {\n            int i = 0;\n            int j = this.buffer.length - 1;\n            char tmp;\n            while (j > i) {\n                tmp = this.buffer[j];\n                this.buffer[j] = this.buffer[i];\n                this.buffer[i] = tmp;\n                j--;\n                i++;\n            }\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n    int len = this.length;\n    if (len == 0) {\n        return this;\n    }\n    int mid = len >>> 1;\n    for (int i = 0; i < mid; i++) {\n        char tmp = this.buffer[i];\n        this.buffer[i] = this.buffer[len - i - 1];\n        this.buffer[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n        int len = this.length;\n        if (len <= 1) {\n            return this;\n        }\n        int mid = len >>> 1;\n        for (int i = 0; i < mid; i++) {\n            int j = len - i - 1;\n            char c = this.buffer[i];\n            this.buffer[i] = this.buffer[j];\n            this.buffer[j] = c;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n    int len = this.length;\n    if (len == 0) \n    {\n        return this;\n    }\n    int mid = len / 2;\n    for (int i = 0; i < mid; i++) \n    {\n        char tmp = this.buffer[i];\n        this.buffer[i] = this.buffer[len - i - 1];\n        this.buffer[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n        int len = this.length;\n        if (len < 2) \n        {\n            return this;\n        }\n        for (int i = 0, j = len - 1; i < j; i++, j--) \n        {\n            char tmp = this.buffer[i];\n            this.buffer[i] = this.buffer[j];\n            this.buffer[j] = tmp;\n        }\n        return this;\n    }"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    String front = text.substring(0, offset);\n    this.text = front;\n    if (parent() != null)\n        parent().addChildren(this.siblingIndex() + 1, newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    text = text.substring(0, offset);\n    ((Node)this).replace(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String newText = text.substring(offset);\n    TextNode newNode = new TextNode(newText);\n    text = text.substring(0, offset);\n    this.text = text;\n    if (parent() != null)\n        parent().addChildren(siblingIndex() + 1, newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    text = text.substring(0, offset);\n    this.text = text;\n    if (parent() != null)\n        parent().addChildren(this.siblingIndex() + 1, newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String newText = text.substring(offset);\n    TextNode newNode = new TextNode(newText);\n    text = text.substring(0, offset);\n    ((TextNode) this).text = text;\n    if (parent() != null) {\n        parent().addChildren(siblingIndex() + 1, newNode);\n    }\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    ((Element)parent()).insertChildren(siblingIndex() + 1, newNode);\n    String front = text.substring(0, offset);\n    ((TextNode)this).text = front;\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    replace(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    TextNode newNode = new TextNode(text.substring(offset));\n    replace(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String newText = text.substring(offset);\n    text = text.substring(0, offset);\n    TextNode newNode = new TextNode(newText);\n    if (parent() != null) {\n        parent().addChildren(siblingIndex() + 1, newNode);\n    }\n    setWholeText(text);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String newText = text.substring(offset);\n    TextNode newNode = new TextNode(newText);\n    text = text.substring(0, offset);\n    ((TextNode) this).text = text;\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int max = helper.max(obj);\n        final int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int freqA = helper.freqA(obj);\n        final int freqB = helper.freqB(obj);\n        helper.setCardinality(obj, Math.max(freqA, freqB) - Math.min(freqA, freqB));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int freqA = helper.freqA(obj);\n        final int freqB = helper.freqB(obj);\n        helper.setCardinality(obj, freqA + freqB - Math.min(freqA, freqB));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        final int max = helper.max(obj);\n        final int min = helper.min(obj);\n        helper.setCardinality(obj, max - min);\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[WORD];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        putLong(value.longValue(), result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        putLong(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[WORD];\n    putLong(value, result, 0);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        return modify(str, set, true);\n    }\n\n    // Modify",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, false);\n}\n\n// Delete",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n            count++;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    char lastChar = ' ';\n    char ch = ' ';\n    for (int i = 0; i < sz; i++) \n    {\n        ch = chrs[i];\n        // Compare with contains() last for performance.\n        if (ch == lastChar && i != 0 && chars.contains(ch)) \n        {\n            continue;\n        }\n        buffer.append(ch);\n        lastChar = ch;\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    final char[] newArr = new char[count];\n    count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            newArr[count++] = c;\n        }\n    }\n    return new String(newArr);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    // compute the eigenvalue decomposition\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final double[] eigenValues = eigen.getRealEigenvalues();\n    final RealMatrix eigenVectors = eigen.getV();\n\n    // compute the square root of the eigenvalues\n    final double[] sqrtEigenValues = new double[eigenValues.length];\n    for (int i = 0; i < sqrtEigenValues.length; i++) {\n        sqrtEigenValues[i] = FastMath.sqrt(eigenValues[i]);\n    }\n\n    // compute the square root of the matrix\n    return eigenVectors.multiply(new DiagonalMatrix(sqrtEigenValues)).\n           multiplyTranspose(eigenVectors);\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check that the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // Check that the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // Compute the eigenvalue decomposition\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final double[] eigenvalues = eigen.getRealEigenvalues();\n    final RealMatrix eigenvectors = eigen.getV();\n\n    // Compute the square root of the eigenvalues\n    final double[] squareRoots = new double[eigenvalues.length];\n    for (int i = 0; i < eigenvalues.length; i++) {\n        squareRoots[i] = FastMath.sqrt(eigenvalues[i]);\n    }\n\n    // Compute the square root of the matrix\n    final RealMatrix squareRoot = new Array2DRowRealMatrix(eigenvectors.getRowDimension(),\n                                                           eigenvectors.getColumnDimension());\n    for (int i = 0; i < eigenvectors.getRowDimension(); i++) {\n        for (int j = 0; j < eigenvectors.getColumnDimension(); j++) {\n            squareRoot.setEntry(i, j, eigenvectors.getEntry(i, j) * squareRoots[j]);\n        }\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    final int n = getRowDimension();\n    final double[][] cholesky = new double[n][n];\n    final double[] diag = new double[n];\n    for (int i = 0; i < n; i++) {\n        final double[] choleskyI = cholesky[i];\n        for (int j = 0; j < i; j++) {\n            final double sum = 0.5 * (cholesky[j][i] + cholesky[i][j]);\n            choleskyI[j] = sum;\n            cholesky[j][i] = sum;\n        }\n        choleskyI[i] = FastMath.sqrt(0.5 * (getEntry(i, i) -\n                MatrixUtils.dotProduct(choleskyI, 0, i, choleskyI, 0, i)));\n        diag[i] = FastMath.sqrt(getEntry(i, i) - MatrixUtils.dotProduct(choleskyI, 0, i, choleskyI, 0, i));\n    }\n    return new Array2DRowRealMatrix(cholesky, false)\n            .scalarMultiply(diag[0])\n            .getSubMatrix(0, n - 1, 0, n - 1);\n}",
      "public RealMatrix getSquareRoot()  {\n    final int n = data.length;\n    final RealMatrix[] squareRoot = new RealMatrix[n];\n    for (int i = 0; i < n; i++) {\n        squareRoot[i] = MatrixUtils.createRealMatrix(n);\n    }\n\n    // Compute square root of the diagonal elements\n    for (int i = 0; i < n; i++) {\n        final double d = data[i][i];\n        squareRoot[i].setEntry(i, i, FastMath.sqrt(d));\n    }\n\n    // Compute square root of the off-diagonal elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            final double d = data[i][j];\n            final double s = squareRoot[i].getEntry(i, j) / squareRoot[i].getEntry(i, i);\n            squareRoot[i].setEntry(j, i, s);\n            squareRoot[i].setEntry(i, j, s);\n        }\n    }\n\n    return new Array2DRowRealMatrix(squareRoot);\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check that the matrix is symmetric and positive definite\n    checkSymmetricAndPositiveDefinite();\n\n    // Compute the Cholesky decomposition of the matrix\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n\n    // Return the square-root of the matrix\n    return cholesky.getL();\n}",
      "public RealMatrix getSquareRoot()  {\n    // check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    // check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    // compute the Cholesky decomposition of the matrix\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n    // compute the square-root of the matrix\n    final RealMatrix squareRoot = cholesky.getL().multiply(cholesky.getL().transpose());\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // The matrix is symmetric, so we can use the Cholesky decomposition\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n    if (!cholesky.isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final RealMatrix l = cholesky.getL();\n    // Compute the square root of the diagonal elements of L\n    final int n = l.getRowDimension();\n    final double[] squareRootDiagonal = new double[n];\n    for (int i = 0; i < n; i++) {\n        squareRootDiagonal[i] = FastMath.sqrt(l.getEntry(i, i));\n    }\n    // Compute the square root of the matrix\n    final RealMatrix squareRoot = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            squareRoot.setEntry(i, j, l.getEntry(i, j) / squareRootDiagonal[i] / squareRootDiagonal[j]);\n        }\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final int n = getRowDimension();\n    final RealMatrix[] u = new RealMatrix[n];\n    final RealMatrix[] v = new RealMatrix[n];\n    final double[] s = new double[n];\n    final EigenDecomposition decomposition = new EigenDecomposition(this);\n    decomposition.getEigenVectors(u);\n    decomposition.getRealEigenvalues(s);\n    decomposition.getEigenVectors(v);\n    final RealMatrix squareRoot = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            squareRoot.setEntry(i, j, FastMath.sqrt(s[i] * s[j]));\n        }\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    // compute the eigen decomposition of the matrix\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    // extract the square-root of the eigen vectors\n    final double[][] squareRoot = new double[eigen.getD().length][];\n    for (int i = 0; i < squareRoot.length; i++) {\n        squareRoot[i] = eigen.getV().getColumn(i).toArray();\n    }\n    return new Array2DRowRealMatrix(squareRoot, false);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final int n = getRowDimension();\n    final double[][] s = new double[n][n];\n    final double[] d = new double[n];\n    final double[] u = new double[n];\n    final double[] v = new double[n];\n    final double[] w = new double[n];\n    final double[] z = new double[n];\n    final double[] tmp = new double[n];\n    final double[] tmp2 = new double[n];\n    final double[] tmp3 = new double[n];\n    final double[] tmp4 = new double[n];\n    final double[] tmp5 = new double[n];\n    final double[] tmp6 = new double[n];\n    final double[] tmp7 = new double[n];\n    final double[] tmp8 = new double[n];\n    final double[] tmp9 = new double[n];\n    final double[] tmp10 = new double[n];\n    final double[] tmp11 = new double[n];\n    final double[] tmp12 = new double[n];\n    final double[] tmp13 = new double[n];\n    final double[] tmp14 = new double[n];\n    final double[] tmp15 = new double[n];\n    final double[] tmp16 = new double[n];\n    final double[] tmp17 = new double[n];\n    final double[] tmp18 = new double[n];\n    final double[] tmp19 = new double[n];\n    final double[] tmp20 = new double[n];\n    final double[] tmp21 = new double[n];\n    final double[] tmp22 = new double[n];\n    final double[] tmp23 = new double[n];\n    final double[] tmp24 = new double[n];\n    final double[] tmp25 = new double[n];\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn _parseString(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn _parseInt(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn _parseFloat(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _handleNull(ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _handleUnexpectedArray(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn _handleUnexpectedObject(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn _handleUnexpectedToken(p, ctxt);\n    \t\t}\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\t\treturn _deserializeFromString(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\t\treturn _deserializeFromNumber(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\t\treturn _deserializeFromDouble(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\t\treturn _deserializeEmbedded(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\t\treturn _deserializeFromNull(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.END_OBJECT) {\n    \t\t\t\treturn _deserializeFromEmpty(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.END_ARRAY) {\n    \t\t\t\treturn _deserializeFromEmpty(p, ctxt);\n    \t\t\t}\n    \t\t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\t\tp.setCurrentValue(this);\n    \t\t\treturn ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t\t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\t\treturn deserializeFromString(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\t\treturn deserializeFromNumber(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\t\treturn deserializeFromDouble(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\t\treturn Boolean.TRUE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\t\treturn Boolean.FALSE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\t\treturn getNullValue(ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t\t}\n    \t\t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\t\tp.setCurrentValue(getNullValue(ctxt));\n    \t\t\treturn (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t\t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\t\treturn _parseString(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\t\treturn _parseInteger(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\t\treturn _parseFloat(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\t\treturn Boolean.TRUE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\t\treturn Boolean.FALSE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\t\treturn _handleNull(ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\t\treturn _handleUnexpectedArray(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\t\treturn _handleUnexpectedObject(p, ctxt);\n    \t\t\t}\n    \t\t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\t\tp.setCurrentValue(this);\n    \t\t\treturn _deserializeOther(p, ctxt);\n    \t\t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn _parseString(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn _parseInteger(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn _parseFloat(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _handleNull(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _handleUnexpectedArray(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn _handleUnexpectedObject(p, ctxt);\n    \t\tcase END_ARRAY:\n    \t\t\treturn _handleEndArray(p, ctxt);\n    \t\tcase END_OBJECT:\n    \t\t\treturn _handleEndObject(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn _handleOther(p, ctxt, t);\n    \t\t}\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\t\treturn p.getIntValue();\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\t\treturn p.getFloatValue();\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\t\treturn p.getText();\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\t\treturn Boolean.TRUE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\t\treturn Boolean.FALSE;\n    \t\t\t}\n    \t\t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\t\treturn getNullValue();\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t\t}\n    \t\t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t\t}\n    \t\t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\t\tp.setCurrentValue(getNullValue());\n    \t\t\treturn _deserializeOther(p, ctxt, t);\n    \t\t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn deserialize(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn deserialize(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn deserialize(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn getNullValue(ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn deserialize(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn deserialize(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn vanillaDeserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn vanillaDeserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn vanillaDeserializeFromDouble(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\tp.setCurrentValue(getNullValue(ctxt));\n    \t\tObject value = ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t\treturn wrapPrimitive(ctxt, value);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn vanillaDeserializeFromString(p, ctxt);\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn vanillaDeserializeFromNumber(p, ctxt);\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn vanillaDeserializeFromDouble(p, ctxt);\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn vanillaDeserializeFromNull(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn vanillaDeserializeFromArray(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn vanillaDeserializeFromObject(p, ctxt);\n    \t\t}\n    \t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\tp.setCurrentValue(vanillaDeserialize(p, ctxt, t));\n    \t\treturn vanillaDeserialize(p, ctxt, t);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn vanillaDeserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn vanillaDeserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn vanillaDeserializeFromDouble(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn vanillaDeserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn vanillaDeserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn vanillaDeserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.END_OBJECT) {\n    \t\t\treturn vanillaDeserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.END_ARRAY) {\n    \t\t\treturn vanillaDeserializeFromArray(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(1);\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(sample1.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n == 0) {\n            throw new NoDataException(n);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(1);\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 1) {\n        throw new NoDataException(n);\n    }\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 1) {\n        throw new NoDataException(n);\n    }\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] newChunk = new Object[fullChunk.length];\n         System.arraycopy(fullChunk, 0, newChunk, 0, fullChunk.length);\n         return newChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int totalSize = _size + fullChunk.length;\n         Object[] result = new Object[totalSize];\n         System.arraycopy(_buffer, 0, result, 0, _size);\n         System.arraycopy(fullChunk, 0, result, _size, fullChunk.length);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = _size + fullChunk.length;\n        Object[] result = new Object[newSize];\n        System.arraycopy(_buffer, 0, result, 0, _size);\n        System.arraycopy(fullChunk, 0, result, _size, fullChunk.length);\n        return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] chunk = _buffer;\n         int offset = _size;\n         int len = fullChunk.length;\n         if (offset + len > chunk.length) {\n             chunk = new Object[Math.max(chunk.length << 1, offset + len)];\n         }\n         System.arraycopy(fullChunk, 0, chunk, offset, len);\n         _size += len;\n         return chunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] newChunk = new Object[fullChunk.length];\n         System.arraycopy(fullChunk, 0, newChunk, 0, fullChunk.length);\n         return newChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] chunk = _freeBuffer;\n         _freeBuffer = null;\n         int newSize = _size + fullChunk.length;\n         if (chunk == null || chunk.length < newSize) {\n             chunk = new Object[newSize];\n         }\n         System.arraycopy(_buffer, 0, chunk, 0, _size);\n         System.arraycopy(fullChunk, 0, chunk, _size, fullChunk.length);\n         _size = newSize;\n         return chunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     "
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    parsePatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    parsePatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    parsePatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    }\n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    }\n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    }\n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    }\n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    }\n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    }\n    else if (token == JsDocToken.STRING) \n    {\n        String typeName = stream.getString();\n        int lineno = stream.getLineno();\n        int charno = stream.getCharno();\n        while (match(JsDocToken.EOL) &&\n                typeName.charAt(typeName.length() - 1) == '.') \n        {\n            skipEOLs();\n            if (match(JsDocToken.STRING)) \n            {\n                next();\n                typeName += stream.getString();\n            }\n        }\n        return newStringNode(typeName, lineno, charno);\n    }\n    else if (token == JsDocToken.LP) \n    {\n        return parseFunctionType(token);\n    }\n    else if (token == JsDocToken.PIPE) \n    {\n        return parseUnionType(token);\n    }\n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(token);\n    }\n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(token);\n    }\n    return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else {\n        return parseTypeName(token);\n    }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final Set<Character> delimiterSet = delimiters == null ? new HashSet<>() : new HashSet<>(Arrays.asList(delimiters));\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (final char ch : buffer) {\n        if (delimiterSet.contains(ch)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            initials.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return StringUtils.swapCase(str);\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else if (lastWasGap) \n        {\n            buf[count++] = StringUtils.swapCase(ch);\n            lastWasGap = false;\n        }\n        else \n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final Set<Character> delimiterSet = delimiters == null ? null : new HashSet<Character>(delimiters.length);\n    for (final char delimiter : delimiters) {\n        if (delimiter != 0) {\n            delimiterSet.add(delimiter);\n        }\n    }\n    final char[] buf = str.toCharArray();\n    final StringBuilder initials = new StringBuilder((int)(buf.length * 1.3));\n    boolean capitalizeNext = true;\n    for (final char ch : buf) {\n        if (isDelimiter(ch, delimiterSet)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            initials.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            initials.append(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return swapCase(str);\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            continue;\n        }\n        if (capitalizeNext) \n        {\n            buf[count++] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean lastWasGap = true; // there is an edge case where two delimiters get placed together\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return swapCase(str);\n    }\n    final Set<Character> delimiterSet = new HashSet<Character>();\n    for (final char delimiter : delimiters) \n    {\n        delimiterSet.add(delimiter);\n    }\n    final String[] strs = StringUtils.split(str);\n    final StringBuilder buf = new StringBuilder((int)(str.length() * 1.3));\n    for (final String str2 : strs) \n    {\n        final char[] chars = str2.toCharArray();\n        if (chars.length > 0 && delimiterSet.contains(chars[0])) \n        {\n            buf.append(chars[0]);\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean lastWasGap = true; // there is an edge case where two delimiters are together\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buf[count++] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buf = new char[str.length()];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buf[count++] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        } else {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return swapCase(str);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        // TODO: implement this method\n        return null;\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = screenPoint.x - insets.left;\n    int y = screenPoint.y - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform some simple checks\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n\n    // get the chart's insets\n    Insets insets = getInsets();\n\n    // translate the screen coordinates to Java2D coordinates\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n\n    // return the result\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Insets insets = getInsets();\n        double x = (screenPoint.x - insets.left) / this.scaleX;\n        double y = (screenPoint.y - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform some checks\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n\n    // get the chart area\n    Rectangle2D chartArea = getScreenDataArea();\n\n    // calculate the Java2D coordinates\n    double x = (screenPoint.x - chartArea.getX()) / this.scaleX;\n    double y = (screenPoint.y - chartArea.getY()) / this.scaleY;\n\n    // return the result\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Insets insets = getInsets();\n        double x = (screenPoint.x - insets.left) / this.scaleX;\n        double y = (screenPoint.y - insets.top) / this.scaleY;\n        return new Point2D.Double(x, y);\n    }"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final ListOrderedSet<E> set = new ListOrderedSet<E>(new HashSet<E>(), list);\n    set.unique = false;\n    return set;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final ListOrderedSet<E> set = new ListOrderedSet<E>(new HashSet<E>(), list);\n    set.uniqueSet();\n    return set;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(list, new HashSet<E>());\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(list, new HashSet<E>());\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return listOrderedSet(list, new HashSet<E>());\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final ListOrderedSet<E> set = new ListOrderedSet<E>(new HashSet<E>(), list);\n    set.unique = false;\n    return set;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.clear();\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) {\n                result = more;\n            }\n            else {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) {\n                result = more;\n            }\n            else {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: check axis is range axis\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            }\n            else \n            {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // TODO: implement this method\n    return null;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / Math.log(10.0) + 1.0) / 9.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log10(val + 10.0) - 1.0) / 2.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 2.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val + 10.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log10(val + 10.0) - 1.0) / 2.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val + 1.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log10(val) + 1.0) / 2.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // If the graph is empty, then it has no return statements.\n    if (cfg.getEntry().getOutEdges().isEmpty()) {\n      return false;\n    }\n\n    // If the graph has only one node, then it has a return statement.\n    if (cfg.getEntry().getOutEdges().size() == 1) {\n      return true;\n    }\n\n    // If the graph has a loop, then it has a return statement.\n    if (cfg.getLoops().size() > 0) {\n      return true;\n    }\n\n    // If the graph has no loops, then we can check the exit node.\n    return cfg.getExit().getInEdges().stream()\n        .allMatch(IS_RETURN);\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check if the function has a return statement\n  if (!NodeUtil.isStatementFunction(cfg.getEntry().getValue())) {\n    return false;\n  }\n\n  // Check if the function is a constructor\n  if (NodeUtil.isConstructor(cfg.getEntry().getValue())) {\n    return true;\n  }\n\n  // Check if the function has a return statement in all possible paths\n  return checkAllPathsWithoutBackEdges(cfg,\n      new Predicate<DiGraphNode<Node, ControlFlowGraph.Branch>>() {\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO(user): This is a fast check that may spuriously report that a\n    // return statement is missing. We should consider a more precise check.\n    return cfg.getEntry().getOutEdges().stream()\n        .anyMatch(IS_RETURN);\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // If there are no return statements, then all paths return.\n    if (!cfg.getEntry().getOutEdges().stream().anyMatch(IS_RETURN)) {\n      return true;\n    }\n\n    // If there are no back edges, then all paths return.\n    if (!cfg.getEntry().getOutEdges().stream().anyMatch(GOES_THROUGH_TRUE_CONDITION_PREDICATE)) {\n      return true;\n    }\n\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (DiGraphNode<Node, Branch> node : cfg) {\n      Node n = node.getValue();\n      if (n.isFunction() && !n.isArrowFunction()) {\n        // TODO(user): Check for return statements in the function body\n        // instead of just the first statement.\n        if (n.getFirstChild() != null && !n.getFirstChild().isReturn()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): Implement this.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check if the function is known to return or if it is a constructor.\n  // If so, we can skip the check.\n  if (cfg.getEntry().getValue().isReturn() ||\n      cfg.getEntry().getValue().isConstructor()) {\n    return true;\n  }\n\n  // Check if all execution paths contain a return statement.\n  // We do this by finding a node that is reachable from the entry node\n  // but not from the exit node.\n  for (DiGraphNode<Node, Branch> node : cfg) {\n    if (node.getValue().isReturn()) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // We don't care about the actual value of the return statement,\n    // just that it exists.\n    final Predicate<Node> isReturn = new Predicate<Node>() {\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Check that all nodes have a return statement\n    for (Node node : cfg) {\n        if (node.isFunction()) {\n            continue;\n        }\n        if (node.isReturn()) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the function is known to return something, then we can skip\n  // checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isReturnType()) {\n    return true;\n  }\n\n  // If the function is known to never return, then we can skip\n  // checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isVoidType()) {\n    return false;\n  }\n\n  // If the function is known to always throw an exception, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isThrowType()) {\n    return false;\n  }\n\n  // If the function is known to always return a value, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isReturnValueType()) {\n    return true;\n  }\n\n  // If the function is known to always return a value, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isVoidType()) {\n    return false;\n  }\n\n  // If the function is known to always return a value, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isReturnType()) {\n    return true;\n  }\n\n  // If the function is known to always return a value, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isVoidType()) {\n    return false;\n  }\n\n  // If the function is known to always return a value, then we can\n  // skip checking for return statements.\n  if (cfg.getDirectedGraph().getEntry().getValue().getType()\n      .isReturnValueType()) {\n    return true;\n  }\n\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp zero = a[0].getField().getZero();\n    final Dfp one = a[0].getField().getOne();\n    final Dfp two = a[0].getField().getTwo();\n    final Dfp three = a[0].getField().newInstance(\"3\");\n    final Dfp five = a[0].getField().newInstance(\"5\");\n    final Dfp seven = a[0].getField().newInstance(\"7\");\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] x2 = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n    final Dfp[] a3 = new Dfp[2];\n    final Dfp[] a5 = new Dfp[2];\n    final Dfp[] a7 = new Dfp[2];\n    final Dfp[] x4 = new Dfp[2];\n    final Dfp[] x6 = new Dfp[2];\n    final Dfp[] x8 = new Dfp[2];\n    final Dfp[] x10 = new Dfp[2];\n    final Dfp[] x12 = new Dfp[2];\n    final Dfp[] x14 = new Dfp[2];\n    final Dfp[] x16 = new Dfp[2];\n    final Dfp[] x18 = new Dfp[2];\n    final Dfp[] x20 = new Dfp[2];\n    final Dfp[] x22 = new Dfp[2];\n    final Dfp[] x24 = new Dfp[2];\n    final Dfp[] x26 = new Dfp[2];\n    final Dfp[] x28 = new Dfp[2];\n    final Dfp[] x30 = new Dfp[2];\n    final Dfp[] x32 = new Dfp[2];\n    final Dfp[] x34 = new Dfp[2];\n    final Dfp[] x36 = new Dfp[2];\n    final Dfp[] x38 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] z = new Dfp[2];\n    final Dfp[] z2 = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n    final Dfp[] a3 = new Dfp[2];\n    final Dfp[] a4 = new Dfp[2];\n    final Dfp[] a5 = new Dfp[2];\n    final Dfp[] a6 = new Dfp[2];\n    final Dfp[] a7 = new Dfp[2];\n    final Dfp[] a8 = new Dfp[2];\n    final Dfp[] a9 = new Dfp[2];\n    final Dfp[] a10 = new Dfp[2];\n    final Dfp[] a11 = new Dfp[2];\n    final Dfp[] a12 = new Dfp[2];\n    final Dfp[] a13 = new Dfp[2];\n    final Dfp[] a14 = new Dfp[2];\n    final Dfp[] a15 = new Dfp[2];\n    final Dfp[] a16 = new Dfp[2];\n    final Dfp[] a17 = new Dfp[2];\n    final Dfp[] a18 = new Dfp[2];\n    final Dfp[] a19 = new Dfp[2];\n    final Dfp[] a20 = new Dfp[2];\n    final Dfp[] a21 = new Dfp[2];\n    final Dfp[] a22 = new Dfp[2];\n    final Dfp[] a23 = new Dfp[2];\n    final Dfp[] a24 = new Dfp[2];\n    final Dfp[] a25 = new Dfp[2];\n    final Dfp[] a26 = new Dfp[2];\n    final Dfp[] a27 = new Dfp[2];\n    final Dfp[] a28 = new Dfp[2];\n    final Dfp[] a29 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp z[] = new Dfp[2];\n    Dfp[] fact = new Dfp[2];\n    Dfp[] fact2 = new Dfp[2];\n    Dfp[] fact3 = new Dfp[2];\n    Dfp[] fact5 = new Dfp[2];\n    Dfp[] fact7 = new Dfp[2];\n    Dfp[] fact9 = new Dfp[2];\n    Dfp[] fact11 = new Dfp[2];\n    Dfp[] fact13 = new Dfp[2];\n    Dfp[] fact15 = new Dfp[2];\n    Dfp[] fact17 = new Dfp[2];\n    Dfp[] fact19 = new Dfp[2];\n    Dfp[] fact21 = new Dfp[2];\n    Dfp[] fact23 = new Dfp[2];\n    Dfp[] fact25 = new Dfp[2];\n    Dfp[] fact27 = new Dfp[2];\n    Dfp[] fact29 = new Dfp[2];\n    Dfp[] fact31 = new Dfp[2];\n    Dfp[] fact33 = new Dfp[2];\n    Dfp[] fact35 = new Dfp[2];\n    Dfp[] fact37 = new Dfp[2];\n    Dfp[] fact39 = new Dfp[2];\n    Dfp[] fact41 = new Dfp[2];\n    Dfp[] fact43 = new Dfp[2];\n    Dfp[] fact45 = new Dfp[2];\n    Dfp[] fact47 = new Dfp[2];\n    Dfp[] fact49 = new Dfp[2];\n    Dfp[] fact51 = new Dfp[2];\n    Dfp[] fact53 = new Dfp[2];\n    Dfp[] fact55 = new Dfp[2];\n    Dfp[] fact57 = new Dfp[2];\n    Dfp[] fact59 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] px = new Dfp[2];\n    final Dfp[] py = new Dfp[2];\n    final Dfp[] ppy = new Dfp[2];\n    final Dfp[] ppyy = new Dfp[2];\n    final Dfp[] ppyyy = new Dfp[2];\n    final Dfp[] ppyyyy = new Dfp[2];\n    final Dfp[] ppyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n    final Dfp[] ppyyyyyyyyyyyyyyyyyyyyyyyy = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp z[] = new Dfp[2];\n    Dfp c[] = new Dfp[2];\n    Dfp d[] = new Dfp[2];\n    Dfp e[] = new Dfp[2];\n    Dfp f[] = new Dfp[2];\n    Dfp g[] = new Dfp[2];\n    Dfp h[] = new Dfp[2];\n    Dfp i[] = new Dfp[2];\n    Dfp j[] = new Dfp[2];\n    Dfp k[] = new Dfp[2];\n    Dfp l[] = new Dfp[2];\n    Dfp m[] = new Dfp[2];\n    Dfp n[] = new Dfp[2];\n    Dfp o[] = new Dfp[2];\n    Dfp p[] = new Dfp[2];\n    Dfp q[] = new Dfp[2];\n    Dfp r[] = new Dfp[2];\n    Dfp s[] = new Dfp[2];\n    Dfp t[] = new Dfp[2];\n    Dfp u[] = new Dfp[2];\n    Dfp v[] = new Dfp[2];\n    Dfp w[] = new Dfp[2];\n    Dfp x1[] = new Dfp[2];\n    Dfp y1[] = new Dfp[2];\n    Dfp z1[] = new Dfp[2];\n    Dfp a1[] = new Dfp[2];\n    Dfp b1[] = new Dfp[2];\n    Dfp c1[] = new Dfp[2];\n    Dfp d1[] = new Dfp[2];\n    Dfp e1[] = new Dfp[2];\n    Dfp f1[] = new Dfp[2];\n    Dfp g1[] = new Dfp[2];\n    Dfp h1[] = new Dfp[2];\n    Dfp i1[] = new Dfp[2];\n    Dfp j1[] = new Dfp[2];\n    Dfp k1[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp fact[] = new Dfp[2];\n    Dfp py[] = new Dfp[2];\n    Dfp px[] = new Dfp[2];\n    Dfp x2[] = new Dfp[2];\n    Dfp a2[] = new Dfp[2];\n    Dfp a3[] = new Dfp[2];\n    Dfp a4[] = new Dfp[2];\n    Dfp a5[] = new Dfp[2];\n    Dfp a6[] = new Dfp[2];\n    Dfp a7[] = new Dfp[2];\n    Dfp a8[] = new Dfp[2];\n    Dfp a9[] = new Dfp[2];\n    Dfp a10[] = new Dfp[2];\n    Dfp a11[] = new Dfp[2];\n    Dfp a12[] = new Dfp[2];\n    Dfp a13[] = new Dfp[2];\n    Dfp a14[] = new Dfp[2];\n    Dfp a15[] = new Dfp[2];\n    Dfp a16[] = new Dfp[2];\n    Dfp a17[] = new Dfp[2];\n    Dfp a18[] = new Dfp[2];\n    Dfp a19[] = new Dfp[2];\n    Dfp a20[] = new Dfp[2];\n    Dfp a21[] = new Dfp[2];\n    Dfp a22[] = new Dfp[2];\n    Dfp a23[] = new Dfp[2];\n    Dfp a24[] = new Dfp[2];\n    Dfp a25[] = new Dfp[2];\n    Dfp a26[] = new Dfp[2];\n    Dfp a27[] = new Dfp[2];\n    Dfp a28[] = new Dfp[2];\n    Dfp a29[] = new Dfp[2];\n    Dfp a30[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] x2 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] py = new Dfp[2];\n    Dfp[] px = new Dfp[2];\n\n    split(a[0], x);\n    split(a[1], y);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, px);\n    x[0] = px[0];\n    x[1] = px[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n\n    //x[0] -= 1.0;\n    //resplit(x);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] c = new Dfp[2];\n    Dfp[] d = new Dfp[2];\n    Dfp[] e = new Dfp[2];\n    Dfp[] f = new Dfp[2];\n    Dfp[] g = new Dfp[2];\n    Dfp[] h = new Dfp[2];\n    Dfp[] i = new Dfp[2];\n    Dfp[] j = new Dfp[2];\n    Dfp[] k = new Dfp[2];\n    Dfp[] l = new Dfp[2];\n    Dfp[] m = new Dfp[2];\n    Dfp[] n = new Dfp[2];\n    Dfp[] o = new Dfp[2];\n    Dfp[] p = new Dfp[2];\n    Dfp[] q = new Dfp[2];\n    Dfp[] r = new Dfp[2];\n    Dfp[] s = new Dfp[2];\n    Dfp[] t = new Dfp[2];\n    Dfp[] u = new Dfp[2];\n    Dfp[] v = new Dfp[2];\n    Dfp[] w = new Dfp[2];\n    Dfp[] x1 = new Dfp[2];\n    Dfp[] x2 = new Dfp[2];\n    Dfp[] x3 = new Dfp[2];\n    Dfp[] x4 = new Dfp[2];\n    Dfp[] x5 = new Dfp[2];\n    Dfp[] x6 = new Dfp[2];\n    Dfp[] x7 = new Dfp[2];\n    Dfp[] x8 = new Dfp[2];\n    Dfp[] x9 = new Dfp[2];\n    Dfp[] x10 = new Dfp[2];\n    Dfp[] x11 = new Dfp[2];\n    Dfp[] x12 = new Dfp[2];\n    Dfp[] x13 = new Dfp[2];\n    Dfp[] x14 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] z = new Dfp[2];\n\n    Dfp[] x2 = new Dfp[2];\n    Dfp[] y2 = new Dfp[2];\n\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] b2 = new Dfp[2];\n\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] b4 = new Dfp[2];\n\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] b6 = new Dfp[2];\n\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] b8 = new Dfp[2];\n\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] b10 = new Dfp[2];\n\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] b12 = new Dfp[2];\n\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] b14 = new Dfp[2];\n\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] b16 = new Dfp[2];\n\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] b18 = new Dfp[2];\n\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] b20 = new Dfp[2];\n\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] b22 = new Dfp[2];\n\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] b24 = new Dfp[2];\n\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] b26 = new Dfp[2];\n\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] b28 = new Dfp[2];\n\n    Dfp[] a30 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] ys = new Dfp[2];\n    final Dfp[] y2 = new Dfp[2];\n    final Dfp[] y2s = new Dfp[2];\n    final Dfp[] y3 = new Dfp[2];\n    final Dfp[] y3s = new Dfp[2];\n    final Dfp[] y4 = new Dfp[2];\n    final Dfp[] y4s = new Dfp[2];\n    final Dfp[] y5 = new Dfp[2];\n    final Dfp[] y5s = new Dfp[2];\n    final Dfp[] y6 = new Dfp[2];\n    final Dfp[] y6s = new Dfp[2];\n    final Dfp[] y7 = new Dfp[2];\n    final Dfp[] y7s = new Dfp[2];\n    final Dfp[] y8 = new Dfp[2];\n    final Dfp[] y8s = new Dfp[2];\n    final Dfp[] y9 = new Dfp[2];\n    final Dfp[] y9s = new Dfp[2];\n    final Dfp[] y10 = new Dfp[2];\n    final Dfp[] y10s = new Dfp[2];\n    final Dfp[] y11 = new Dfp[2];\n    final Dfp[] y11s = new Dfp[2];\n    final Dfp[] y12 = new Dfp[2];\n    final Dfp[] y12s = new Dfp[2];\n    final Dfp[] y13 = new Dfp[2];\n    final Dfp[] y13s = new Dfp[2];\n    final Dfp[] y14 = new Dfp[2];\n    final Dfp[] y14s = new Dfp[2];\n    final Dfp[] y15 = new Dfp[2];\n    final Dfp[] y15s = new Dfp[2];\n    final Dfp[] y16 = new Dfp[2];\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Flat3Map<K, V> map = (Flat3Map<K, V>) parent;\n        final int index = map.indexOfKey(key);\n        if (index < 0) {\n            return false;\n        }\n        final int size = map.size;\n        for (int i = index + 1; i < size; i++) {\n            if (map.key[i].equals(key) && map.value[i].equals(value)) {\n                map.remove(i);\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        return entry.removeValue(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Flat3Map<K, V> parent = this.parent;\n        final int index = parent.indexOfKey(key);\n        if (index < 0) {\n            return false;\n        }\n        final FlatMapEntry<K, V> entry = new FlatMapEntry<K, V>(parent, index);\n        if (entry.getValue() == value) {\n            parent.remove(key, 1);\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        return super.removeMapping(key, value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Collection<V> coll = get((K) key);\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        return entry.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Collection<V> coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (removed && coll.isEmpty()) {\n            remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        return entry.removeValue(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        final V oldValue = entry.getValue();\n        if (value.equals(oldValue)) {\n            removeEntry(entry);\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        return entry.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    else if (node.getType() == Token.STRING) \n    {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node irNode = justTransform(n);\n    if (irNode.getType() == Token.NAME) {\n        irNode.setType(Token.STRING);\n    } else if (irNode.getType() == Token.STRING) {\n        irNode.setQuotedString();\n    }\n    return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node irNode = transform(n);\n  if (irNode.getType() == Token.NAME) {\n    irNode.setType(Token.STRING);\n  } else if (irNode.getType() == Token.STRING) {\n    irNode.setQuotedString();\n  }\n  return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node irNode = transform(n);\n  if (irNode.getType() == Token.NAME) {\n    irNode.setType(Token.STRING);\n  } else if (irNode.getType() == Token.STRING) {\n    irNode.setQuotedString();\n  }\n  return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node irNode = transform(n);\n  if (irNode.getType() == Token.NAME) {\n    irNode.setType(Token.STRING);\n  } else if (irNode.getType() == Token.STRING) {\n    irNode.setQuotedString();\n  }\n  return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node irNode = transform(n);\n    if (irNode.getType() == Token.NAME) \n    {\n        irNode.setType(Token.STRING);\n    } \n    else if (irNode.getType() == Token.STRING) \n    {\n        irNode.quoted = true;\n    }\n    return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node irNode = transform(n);\n  if (irNode.getType() == Token.NAME) {\n    irNode.setType(Token.STRING);\n  } else if (irNode.getType() == Token.STRING) {\n    irNode.setQuotedString();\n  }\n  return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node irNode = justTransform(n);\n    if (irNode.getType() == Token.NAME) \n    {\n        irNode.setType(Token.STRING);\n    }\n    else if (irNode.getType() == Token.STRING) \n    {\n        irNode.quoted = true;\n    }\n    return irNode;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node irNode = justTransform(n);\n  if (irNode.getType() == Token.NAME) {\n    irNode.setType(Token.STRING);\n  } else if (irNode.getType() == Token.STRING) {\n    irNode.setQuotedString();\n  }\n  return irNode;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n                result.add(new Double(base + v));\n            }\n            else if (v < 0.0) {\n                result.add(new Double(base + v));\n            }\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(base + v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            result.add(new Double(base + v));\n        }\n        else if (v < 0.0) {\n            result.add(new Double(base + v));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            result.add(new Double(base + v));\n        }\n        else if (v < 0.0) {\n            result.add(new Double(base + v));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(base + v));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(base + v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    int column = dataset.getColumnIndex(category);\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, column,\n                includedRows);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, column);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(base + v));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(base + v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            result.add(new Double(base + v));\n        }\n        else if (v < 0.0) {\n            result.add(new Double(base + v));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(r, category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            result.add(new Double(base + v));\n        }\n        else if (v < 0.0) {\n            result.add(new Double(base + v));\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new SoftReference<List<Element>>(childElementsListNoCache());\n    }\n    List<Element> childElements = shadowChildrenRef.get();\n    if (childElements == null) {\n        childElements = childElementsListNoCache();\n        shadowChildrenRef = new SoftReference<List<Element>>(childElements);\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsRef == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        childElementsRef = Collections.unmodifiableList(elements);\n    }\n    return childElementsRef;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsRef == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        childElementsRef = Collections.unmodifiableList(elements);\n    }\n    return childElementsRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                childElements.add((Element) child);\n        }\n        shadowChildrenRef = new SoftReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new SoftReference<>(childElements());\n    }\n    List<Element> elements = shadowChildrenRef.get();\n    if (elements == null) {\n        elements = childElements();\n        shadowChildrenRef = new SoftReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new WeakReference<>(childElements());\n    }\n    List<Element> children = shadowChildrenRef.get();\n    if (children == null) {\n        children = childElements();\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return children;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsRef == null) {\n        List<Element> childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                childElements.add((Element) child);\n        }\n        childElementsRef = childElements;\n    }\n    return childElementsRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new SoftReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsRef == null) {\n        childElementsRef = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsRef.add((Element) child);\n            }\n        }\n    }\n    return childElementsRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new SoftReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    final int n = buckets.length;\n    return (hash % n);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return Math.abs(hash % n);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n        final int hash = key.hashCode();\n        final int n = buckets.length;\n        return Math.abs(hash % n);\n    }",
      "private int getHash(final Object key)  {\n        final int hash = key.hashCode();\n        return (hash % buckets.length);\n    }",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    int n = buckets.length;\n    return (hash % n);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    final int n = buckets.length;\n    return (hash % n);\n}",
      "private int getHash(final Object key)  {\n        int hash = key.hashCode();\n        int n = buckets.length;\n        return (n - 1) & hash;\n    }",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = Math.abs(hash);\n    hash = hash % buckets.length;\n    return hash;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c) {\n                d[r][c] = m.getEntry(r, c);\n            } else if (r == c && r >= k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c) {\n                d[r][c] = m.getEntry(r, c);\n            } else if (r == c && k > 0) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k)\n                d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r > c + k)\n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew)\n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if(left.skew == Skew.LEFT_HIGH)\n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            }\n            else if(left.skew == Skew.BALANCED)\n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            }\n            else\n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s)\n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew)\n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if(left.skew == Skew.LEFT_HIGH)\n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            }\n            else if(left.skew == Skew.BALANCED)\n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            }\n            else\n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s)\n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case LEFT_HIGH:\n        if (left.skew == Skew.LEFT_HIGH) {\n            rotateCW();\n            skew = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n            return true;\n        } else if (left.skew == Skew.BALANCED) {\n            rotateCW();\n            skew = Skew.RIGHT_HIGH;\n            right.skew = Skew.LEFT_HIGH;\n            return false;\n        } else {\n            final Skew s = left.right.skew;\n            left.rotateCCW();\n            rotateCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if(left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if(left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            }\n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            }\n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } else if (left.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) \n        {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) \n            {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find the first small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) \n        {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) \n            {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) / norm < EPSILON) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) / norm < 1e-10) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length) {\n        if (FastMath.abs(matrixT[idx][idx - 1]) <= eps * norm) {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find the first small sub-diagonal element and return its index\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Form shift\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= norm * EPS) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) / norm < 1e-10) {\n                idx = i;\n                break;\n            }\n        }\n        if (idx == i) {\n            break;\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int l = startIdx;\n    for (int i = startIdx + 1; i < matrixT.length; i++) {\n        final double absElement = FastMath.abs(matrixT[i][i - 1]);\n        if (absElement <= eps * norm) {\n            return l;\n        }\n        l = i;\n    }\n    return l;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    for (int i = 0; i < size; i++) {\n        if (startsWith(str, i)) {\n            final int start = i;\n            while (++i < size) {\n                if (startsWith(str, i)) {\n                    break;\n                }\n            }\n            final int len = i - start;\n            deleteImpl(start, i, len);\n            i -= len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    for (int i = 0; i < size; i++) {\n        if (startsWith(str, i)) {\n            final int start = i;\n            while (++i < size) {\n                if (startsWith(str, i)) {\n                    break;\n                }\n            }\n            final int len = i - start;\n            deleteImpl(start, i, len);\n            i -= len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int pos = 0;\n    while (pos < size) {\n        int found = indexOf(str, pos);\n        if (found < 0) {\n            break;\n        }\n        deleteImpl(found, found + str.length(), str.length());\n        pos = found + str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    for (int i = 0; i < size; i++) {\n        if (str.equals(substring(i, i + len))) {\n            final int start = i;\n            while (++i < size) {\n                if (str.equals(substring(i, i + len))) {\n                    break;\n                }\n            }\n            final int len = i - start;\n            deleteImpl(start, i, len);\n            i -= len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    for (int i = 0; i < size; i++) {\n        if (str.equals(subSequence(i, i + len))) {\n            final int start = i;\n            while (++i < size) {\n                if (str.equals(subSequence(i, i + len))) {\n                    break;\n                }\n            }\n            final int len = i - start;\n            deleteImpl(start, i, len);\n            i -= len;\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) \n  {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n  skipEOLs();\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    Vector3D axis = new Vector3D(q1, q2, q3);\n    double norm = axis.getNorm();\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return axis.scalarMultiply(1.0 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (b != SPACE) {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else if (b != SPACE) {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else if (b != SPACE) {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (b != SPACE) {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else if (b != SPACE) {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (b != PLUS_SIGN && b != ESCAPE_CHAR) {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (b != SPACE) {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (b != PLUS_SIGN && b != ESCAPE_CHAR) {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Utils.digit16(bytes[++i]);\n                    final int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else if (b != SPACE) {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        int size = partial.size();\n        if (size < 2) {\n            return true;\n        }\n        int last = partial.getFieldType(size - 1).getDurationType().getUnitMillis();\n        for (int i = size - 2; i >= 0; i--) {\n            int thisLast = partial.getFieldType(i).getDurationType().getUnitMillis();\n            if (thisLast != last) {\n                return false;\n            }\n            last = thisLast;\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int[] index = new int[8];\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        int field = partial.getFieldType(i).getField(partial.getChronology()).getType();\n        if (index[field] == 0) {\n            index[field] = i;\n        } else if (index[field] != i) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int[] fields = partial.getFieldTypes();\n    int[] values = partial.getValues();\n    for (int i = 0; i < fields.length; i++) {\n        int field = fields[i];\n        int value = values[i];\n        if (i > 0) {\n            int previousField = fields[i - 1];\n            int previousValue = values[i - 1];\n            if (field == previousField + 1 && value == previousValue + 1) {\n                continue;\n            }\n            if (field == previousField - 1 && value == previousValue - 1) {\n                continue;\n            }\n        }\n        return false;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        if (partial.size() < 2) {\n            return true;\n        }\n        int size = partial.size();\n        for (int i = 0; i < size; i++) {\n            if (partial.getFieldType(i) != partial.getFieldType(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int[] ranges = new int[partial.size()];\n    int max = -1;\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        int fieldIndex = partial.getFieldType(i).getField(partial.getChronology()).getRangeValue();\n        ranges[i] = fieldIndex;\n        if (fieldIndex > max) {\n            max = fieldIndex;\n        }\n    }\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        int fieldIndex = partial.getFieldType(i).getField(partial.getChronology()).getRangeValue();\n        if (fieldIndex != ranges[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int[] fields = partial.getFieldTypes();\n    int[] values = partial.getValuesArray();\n    for (int i = 0; i < fields.length; i++) {\n        if (i > 0 && fields[i] != fields[i - 1] + 1) {\n            return false;\n        }\n        if (i < fields.length - 1 && values[i] != values[i + 1] - 1) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        int size = partial.size();\n        if (size < 2) {\n            return true;\n        }\n        int lastField = partial.getFieldType(size - 1).getDurationType().getField(partial.getChronology()).getRangeValue();\n        for (int i = size - 2; i >= 0; i--) {\n            int field = partial.getFieldType(i).getDurationType().getField(partial.getChronology()).getRangeValue();\n            if (field != lastField) {\n                return false;\n            }\n            lastField = field;\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    int i = 0;\n    while (i < size - 1) {\n        if (partial.getFieldType(i).getDurationType() != partial.getFieldType(i + 1).getDurationType()) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial must not be null\");\n        }\n        int size = partial.size();\n        if (size == 0) {\n            return true;\n        }\n        for (int i = 0; i < size; i++) {\n            if (partial.getFieldType(i) != partial.getFieldType(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int[] fields = new int[partial.size()];\n    int[] ranges = new int[partial.size()];\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        int field = partial.getFieldType(i).getField(partial.getChronology()).getFieldIndex();\n        fields[i] = field;\n        ranges[i] = partial.getFieldType(i).getDurationType().getUnitMillis();\n    }\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        int field = fields[i];\n        int range = ranges[i];\n        if (field == -1 || range == 0) {\n            return false;\n        }\n        for (int j = i + 1; j < isize; j++) {\n            int field2 = fields[j];\n            int range2 = ranges[j];\n            if (field2 == -1 || range2 == 0) {\n                return false;\n            }\n            if (field == field2 - 1 && range == range2) {\n                fields[i] = field2;\n                ranges[i] = range2;\n                ranges[j] = 0;\n            }\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    Preconditions.checkArgument(param.isName());\n    strings.add(Node.newString(Token.NAME, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext())\n    {\n        strings.add(new Node(Token.STRING, param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext()) \n    {\n        Node string = new Node(Token.STRING);\n        string.setString(param.getString());\n        strings.add(string);\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    Node string = new Node(Token.STRING);\n    string.setString(param.getString());\n    strings.add(string);\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(Token.NAME, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        strings.add(Node.newString(Token.NAME, param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    Preconditions.checkArgument(param.isName());\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param = params.getFirstChild(); param != null; param = param.getNext()) \n  {\n    strings.add(Node.newString(Token.NAME, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(new Node(Token.STRING, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext())\n    {\n        strings.add(Node.newString(Token.NAME, param.getString()));\n    }\n    return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // used by capitalize() and uncapitalize()\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = WordUtils.uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // used by characters to determine if a character is uppercase\n    final boolean[] newDelims = new boolean[delimLen];\n    if (delimiters != null) \n    {\n        for (int i = 0; i < delimLen; i++) \n        {\n            newDelims[i] = Character.isUpperCase(delimiters[i]);\n        }\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters, newDelims)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // used by capitalize() and uncapitalize()\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = WordUtils.uncapitalize(str, delimiters);\n    return str;\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"ISO-8601\")) {\n        return \"ISO8601\";\n    }\n    if (id.startsWith(\"ISO8601\")) {\n        return \"ISO8601\";\n    }\n    if (id.startsWith(\"ISO_8601\")) {\n        return \"ISO8601\";\n    }\n    if (id.startsWith(\"ISO_UTC\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"ISO\")) {\n        return \"ISO\";\n    }\n    if (id.startsWith(\"UTC\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"GMT\")) {\n        return \"GMT\";\n    }\n    if (id.startsWith(\"Z\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"+00:00\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"+0000\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"+00\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"-00:00\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"-0000\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"-00\")) {\n        return \"Z\";\n    }\n    if (id.startsWith(\"UTC+\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"UTC-\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"GMT+\")) {\n        return \"GMT\";\n    }\n    if (id.startsWith(\"GMT-\")) {\n        return \"GMT\";\n    }\n    if (id.startsWith(\"+\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"-\")) {\n        return \"UTC\";\n    }\n    if (id.startsWith(\"UT\")) {\n        return \"UTC\";\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.length() == 6 && id.charAt(0) == '+' && id.charAt(5) == '+') {\n        String prefix = id.substring(1, 3);\n        String suffix = id.substring(3, 5);\n        String newPrefix = prefixMap.get(prefix);\n        if (newPrefix != null) {\n            return newPrefix + suffix;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = ID_MAP.get(id);\n    if (newId == null) {\n        newId = ID_MAP.get(id.toLowerCase(Locale.ENGLISH));\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String convertedId = ID_MAP.get(id);\n    if (convertedId == null) {\n        convertedId = convertId(id);\n        ID_MAP.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.length() == 3) {\n        return id;\n    }\n    if (id.length() == 4) {\n        String newId = id.substring(0, 3);\n        if (id.charAt(3) == 'x') {\n            newId += 'X';\n        }\n        return newId;\n    }\n    if (id.length() == 5) {\n        String newId = id.substring(0, 3);\n        if (id.charAt(3) == 'x') {\n            newId += 'X';\n        }\n        newId += id.charAt(4);\n        return newId;\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.length() == 3) {\n        id = \"0\" + id;\n    }\n    if (id.length() == 4) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 6) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 8) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 10) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 12) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 14) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 16) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 18) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 20) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 22) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 24) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 26) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 28) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 30) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 32) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 34) {\n        id = \"19\" + id;\n    }\n    if (id.length() == 36) {\n        id = \"19\" + id;\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.length() == 3) {\n        return id.substring(0, 1).toUpperCase(Locale.ENGLISH) + id.substring(1);\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String convertedId = convertedIds.get(id);\n    if (convertedId == null) {\n        convertedId = convertId(id);\n        convertedIds.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.startsWith(\"GMT\") && id.length() == 3) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 4) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 5) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 6) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 7) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 8) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 9) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 10) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 11) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 12) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 13) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"GMT\") && id.length() == 14) {\n        return \"Etc/GMT\" + id.substring(3);\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id.length() == 2) {\n        String convertedId = ID_CONVERSIONS.get(id);\n        if (convertedId != null) {\n            return convertedId;\n        }\n    }\n    return id;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int n = params.length;\n    final int m = getObservedData().length;\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < m; i++) {\n        final double weight = getWeight().getEntry(i, i);\n        final double[] row = jacobian.getRow(i);\n        for (int j = 0; j < n; j++) {\n            weightedJacobian.addToEntry(j, j, weight * row[j]);\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int n = params.length;\n    final int m = getObservedData().length;\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightMatrix = getWeightMatrix();\n    if (weightMatrix.getRowDimension() != m) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), m);\n    }\n    if (weightMatrix.getColumnDimension() != m) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), m);\n    }\n\n    // Compute the weighted Jacobian.\n    final double[][] wj = new double[n][n];\n    for (int i = 0; i < m; i++) {\n        final double weight = weightMatrix.getEntry(i, i);\n        final double[] jacobi = jacobian.getRow(i);\n        for (int j = 0; j < n; j++) {\n            wj[j][i] = weight * jacobi[j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(wj, false);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian.getRowDimension(),\n                                                                 jacobian.getColumnDimension());\n    final double[] weights = getWeights();\n    for (int i = 0; i < jacobian.getRowDimension(); ++i) {\n        for (int j = 0; j < jacobian.getColumnDimension(); ++j) {\n            weightedJacobian.setEntry(i, j, weights[i] * jacobian.getEntry(i, j));\n        }\n    }\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int n = params.length;\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(n, n);\n    final double[] weights = getWeights();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            weightedJacobian.setEntry(i, j, jacobian.getEntry(i, j) * weights[i]);\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int n = params.length;\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != n) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), n);\n    }\n    if (weightMatrix.getColumnDimension() != n) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), n);\n    }\n\n    final double[][] jacobianData = jacobian.getData();\n    final double[][] weightData = weightMatrix.getData();\n    final double[][] weightedJacobianData = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        final double[] jacobianRow = jacobianData[i];\n        final double[] weightRow = weightData[i];\n        final double[] weightedJacobianRow = weightedJacobianData[i];\n        for (int j = 0; j < n; j++) {\n            weightedJacobianRow[j] = jacobianRow[j] * weightRow[j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(weightedJacobianData, false);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian.getRowDimension(),\n                                                                 jacobian.getColumnDimension());\n    for (int i = 0; i < jacobian.getRowDimension(); i++) {\n        for (int j = 0; j < jacobian.getColumnDimension(); j++) {\n            weightedJacobian.setEntry(i, j, jacobian.getEntry(i, j) * Math.sqrt(residualsWeights[i]));\n        }\n    }\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian.getRowDimension(), jacobian.getColumnDimension());\n    final double[] residualsWeights = computeResidualsWeights(params);\n    for (int i = 0; i < residualsWeights.length; i++) {\n        final double weight = residualsWeights[i];\n        for (int j = 0; j < jacobian.getColumnDimension(); j++) {\n            weightedJacobian.addToEntry(i, j, weight * jacobian.getEntry(i, j));\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian.getRowDimension(), jacobian.getColumnDimension());\n    for (int i = 0; i < jacobian.getRowDimension(); i++) {\n        for (int j = 0; j < jacobian.getColumnDimension(); j++) {\n            weightedJacobian.setEntry(i, j, jacobian.getEntry(i, j) * getWeight().getEntry(i, j));\n        }\n    }\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int nR = getTarget().length; // Number of observed data.\n    final RealMatrix weightMatrix = getWeight();\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    final int nC = weightedJacobian.getRowDimension();\n\n    // Compute the weighted Jacobian.\n    final double[][] wj = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n        final double weight = residualsWeights[i];\n        final double[] row = weightedJacobian.getRow(i);\n        for (int j = 0; j < nC; ++j) {\n            wj[j][i] = weight * row[j];\n        }\n    }\n\n    // Compute the normal equation.\n    final double[][] a = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n        final double[] row = wj[i];\n        for (int j = 0; j < nC; ++j) {\n            a[j][i] = row[j];\n        }\n    }\n\n    return MatrixUtils.createRealMatrix(a);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int n = params.length;\n    final int m = getObservedValue().length;\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < m; i++) {\n        final double weight = getWeight().getEntry(i, i);\n        final double[] row = jacobian.getRow(i);\n        for (int j = 0; j < n; j++) {\n            weightedJacobian.setEntry(j, i, weight * row[j]);\n        }\n    }\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.getNullValue();\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = create();\n        }\n    }\n\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.getLeast();\n        }\n    }\n\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[leastIndex]) < 0) \n        {\n            leastIndex = i;\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    // Find the least element in the array.\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n\n    // Set any uninitialized values.\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n        }\n    }\n\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = createValue();\n        }\n        if (i == 0 || comparator.compare(values[i], values[leastIndex]) < 0) \n        {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.get();\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    // find the least value\n    int leastIndex = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            continue;\n        }\n        if (leastIndex == -1 || comparator.compare(values[i], values[leastIndex]) < 0) {\n            leastIndex = i;\n        }\n    }\n\n    // set any uninitialized values\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[leastIndex].clone();\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = createValue();\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.getLeast();\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = factory.create();\n        }\n        if (i == 0 || comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        return parentPointer.createChild(context, nodeTest, false, null);\n    }\n    // else Compiler.AXIS_ATTRIBUTE\n    if (!(step.getNodeTest() instanceof NodeNameTest)) {\n        throw new UnsupportedOperationException(\n            \"Not supported node test for attributes: \"\n                + step.getNodeTest());\n    }\n    return parentPointer.createAttribute(context, ((NodeNameTest) step.getNodeTest()).getNodeName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        childPointer = parentPointer.createChild(context, nodeTest, false, null);\n    }\n    // else { it is self::node() }\n    if (childPointer == null) {\n        childPointer = parentPointer.createChild(context, step.getNodeTest(), false, null);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        return parentPointer.createChild(context, nodeTest, false, null);\n    }\n    // else Compiler.AXIS_ATTRIBUTE\n    if (!(step.getNodeTest() instanceof NodeNameTest)) {\n        throw new UnsupportedOperationException(\n            \"Not supported node test for attributes: \"\n                + step.getNodeTest());\n    }\n    return parentPointer.createAttribute(context, ((NodeNameTest) step.getNodeTest()).getNodeName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // We are dealing with a property owner\n    NodePointer childPointer = parentPointer.getPropertyPointer();\n    // Check whether the step is simple\n    if (isSimpleStep(step)) {\n        // We have a simple step\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            // We have a simple step with a name test\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            if (name.getPrefix() != null) {\n                // We have a simple step with a name test and a prefix\n                String namespaceURI = context.getJXPathContext()\n                        .getNamespaceURI(name.getPrefix());\n                nodeTest = new NodeNameTest(name, namespaceURI);\n            }\n            childPointer = childPointer.createChild(context, name, index, value);\n        }\n        // else { it is self::node() }\n    }\n    // else { it is a complex step }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // check if the step is a simple step\n    if (isSimpleStep(step)) {\n        // get the node test\n        NodeTest nodeTest = step.getNodeTest();\n        // check if the node test is a node name test\n        if (nodeTest instanceof NodeNameTest) {\n            // get the node name\n            QName nodeName = ((NodeNameTest) nodeTest).getNodeName();\n            // check if the node name is a wildcard\n            if (!nodeName.isWildcard()) {\n                // get the namespace URI\n                String namespaceURI = parentPointer.getNamespaceURI(nodeName);\n                // create a new node pointer\n                return new PropertyOwnerPointer(parentPointer, nodeName, namespaceURI);\n            }\n        }\n    }\n    // otherwise, create a null pointer\n    return createNullPointer(parentPointer);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        childPointer = parentPointer.createChild(context, qname, 0);\n    }\n    // else { it is self::node() }\n    if (childPointer == null) {\n        childPointer = parentPointer.createChild(context, qname, 0);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        childPointer = parentPointer.createChild(context, qname, -1);\n    }\n    // else { it is self::node() }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // create the child pointer\n    NodePointer childPointer = parentPointer.getPropertyPointer();\n    if (childPointer == null) {\n        childPointer = parentPointer.createPropertyPointer(context);\n    }\n    // process the predicates\n    Expression[] predicates = step.getPredicates();\n    if (predicates != null) {\n        childPointer = doStepPredicates(context, childPointer, predicates);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        NodeTest nodeTest = step.getNodeTest();\n        QName qname = ((NodeNameTest) nodeTest).getNodeName();\n        String prefix = qname.getPrefix();\n        if (prefix != null) {\n            String namespaceURI = context.getJXPathContext()\n                    .getNamespaceURI(prefix);\n            nodeTest = new NodeNameTest(qname, namespaceURI);\n        }\n        return parentPointer.createChild(context, nodeTest, false, null);\n    }\n    // else { it is self::node() }\n    return parentPointer.createChild(context, step.getNodeTest(), false, null);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Handle special case of first predicate in a property owner\n    if (step.getAxis() == Compiler.AXIS_CHILD\n            && step.getPredicates().length > 0\n            && step.getPredicates()[0] instanceof NumberTest) {\n        NumberTest numberTest = (NumberTest) step.getPredicates()[0];\n        if (numberTest.getNumber() == 1) {\n            return parentPointer.getPropertyPointer();\n        }\n    }\n    return createChildPointerForStep(parentPointer, step, null);\n}"
    ],
    [
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}"
    ],
    [
      "private boolean setNextObject()  {\n    // TODO: Implement this method\n    return false;\n}",
      "private boolean setNextObject()  {\n    nextObjectSet = false;\n    while (iterators.size() > 0) \n    {\n        final Iterator<? extends E> iterator = iterators.get(0);\n        if (iterator.hasNext()) \n        {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        else \n        {\n            iterators.remove(0);\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    // Check if there are any more objects to iterate over\n    if (anyHasNext(iters)) \n    {\n        // Get the next object from the iterator with the least value\n        final int leastIndex = least();\n        nextObject = values.get(leastIndex);\n        nextObjectSet = true;\n        return true;\n    }\n    // If there are no more objects to iterate over then return false\n    else \n    {\n        nextObjectSet = false;\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n    // TODO\n    // Implement this method\n    // You may need to use the anyHasNext method\n    // You may need to use the anyValueSet method\n    // You may need to use the least method\n    // You may need to use the set method\n    // You may need to use the setPredicate method\n    // You may need to use the getPredicate method\n    // You may need to use the getKey method\n    // You may need to use the getValue method\n    // You may need to use the remove method\n    // You may need to use the hasNext method\n    // You may need to use the hasPrevious method\n    // You may need to use the next method\n    // You may need to use the previous method\n    // You may need to use the readable field\n    // You may need to use the last field\n    // You may need to use the parent field\n    // You may need to use the iterator field\n    // You may need to use the insertOrder field\n    // You may need to use the map field\n    // You may need to use the valueSet field\n    // You may need to use the readable field\n    // You may need to use the last field\n    // You may need to use the parent field\n    // You may need to use the iterator field\n    // You may need to use the insertOrder field\n    // You may need to use the map field\n    // You may need to use the valueSet field\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext())\n    {\n        nextObject = iterator.next();\n        nextObjectSet = true;\n        if (predicate.evaluate(nextObject))\n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    nextObject = null;\n    nextObjectSet = false;\n    while (iterator.hasNext()) \n    {\n        final E obj = iterator.next();\n        if (predicate.evaluate(obj)) \n        {\n            nextObject = obj;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext())\n    {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject))\n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    // If there is already a next object then return true\n    if (nextObjectSet) \n    {\n        return true;\n    }\n    \n    // If there are no more objects then return false\n    if (!anyHasNext(iters)) \n    {\n        return false;\n    }\n    \n    // Find the least object\n    int leastIndex = least();\n    \n    // Set nextObject to the least object\n    nextObject = values.get(leastIndex);\n    nextObjectSet = true;\n    \n    // Return true\n    return true;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // perform the QR step\n    final int n = matrix.getRowDimension();\n    final double[][] matrixT = new double[n][n];\n    final double[][] matrixP = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixT[i][j] = matrix.getEntry(i, j);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixP[i][j] = 0.0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        matrixP[i][i] = 1.0;\n    }\n\n    // the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    for (int i = 0; i < n; i++) {\n        final int im = initQRStep(i, i, 0.0, hVec);\n        performDoubleQRStep(i, im, i, 0.0, hVec);\n    }\n\n    // sort the eigenvalues (and vectors) in increase order\n    for (int i = 0; i < n; i++) {\n        int k = i;\n        double p = realEigenvalues[i];\n        for (int j = i + 1; j < n; j++) {\n            if (realEigenvalues[j] > p) {\n                k = j;\n                p = realEigenvalues[j];\n            }\n        }\n        if (k != i) {\n            realEigenvalues[k] = realEigenvalues[i];\n            realEigenvalues[i] = p;\n            for (int j = 0; j < n; j++) {\n                p = matrixP[j][i];\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                z = 0.0;\n                for (int k = 0; k <= FastMath.min(i, j); k++) {\n                    z = z + matrixP[i][k] * matrixT[k][j];\n                }\n                matrixP[i][j] = z;\n            }\n        }\n    }\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform to Schur form\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If p is nearly zero, the eigenvector is no good.\n        if (FastMath.abs(p) < Precision.EPSILON * norm) {\n            continue;\n        }\n\n        // If q is near zero, we have a real eigenvalue.\n        if (FastMath.abs(q) < Precision.EPSILON * norm) {\n            // Real eigenvalue.\n            p = matrixT[idx][idx];\n            // Compute the eigenvector.\n            for (int j = 0; j < n; j++) {\n                z = 0.0;\n                for (int i = 0; i <= FastMath.min(idx, n - 1); i++) {\n                    z = z + matrixP[j][i] * matrixT[i][idx];\n                }\n                matrixP[j][idx] = z;\n            }\n        } else {\n            // Complex eigenvalue.\n            // Compute the eigenvector.\n            for (int j = 0; j < n; j++) {\n                z = 0.0;\n                for (int i = 0; i <= FastMath.min(idx, n - 1); i++) {\n                    z = z + matrixP[j][i] * matrixT[i][idx];\n                }\n                matrixP[j][idx] = z;\n            }\n        }\n    }\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // Perform the QR algorithm\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n\n    // Find the eigenvectors from the Schur form\n    findEigenVectorsFromSchur(schur);\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getRowDimension();\n    final double[][] matrixT = new double[n][n];\n    final double[][] matrixP = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixT[i][j] = matrix.getEntry(i, j);\n            matrixP[i][j] = 0;\n        }\n    }\n    final SchurTransformer schur = new SchurTransformer(matrixT);\n    schur.transform();\n    return schur;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if (isBitSet(value.ordinal(), values)) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[j + i * Long.SIZE]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[j + i * Long.SIZE]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[j + i * Long.SIZE]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1L << value.ordinal() % Long.SIZE)) != 0) {\n                result.add(value);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if (0 != (values[value.ordinal() / Long.SIZE] & (1L << (value.ordinal() % Long.SIZE)))) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if ((values[value.ordinal() / Long.SIZE] & (1 << (value.ordinal() % Long.SIZE))) != 0) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        for (int i = value.ordinal() / Long.SIZE; i < values.length; i++) {\n            if ((values[i] & (1L << (value.ordinal() % Long.SIZE))) != 0) {\n                result.add(value);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if (((1L << value.ordinal()) & values[value.ordinal() / Long.SIZE]) != 0) {\n            result.add(value);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        long localInstant = getZone().convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(localInstant, false);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis\n    long localInstant = getBase().getZone().getMillisKeepLocal(oldInstant, getZone());\n    // Convert back to UTC millis\n    return getZone().getMillisKeepLocal(newZone, localInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    long localInstant = newZone.convertUTCToLocal(oldInstant);\n    long offset = getZone().getOffsetFromLocal(localInstant);\n    localInstant -= offset;\n    if (offset != newZone.getOffset(localInstant)) {\n        throw new IllegalInstantException(localInstant, newZone.getID());\n    }\n    return newZone.convertLocalToUTC(localInstant, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    \n    long localInstant = originalZone.convertUTCToLocal(oldInstant);\n    long newLocalInstant = newZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant - newLocalInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == DateTimeZone.UTC) {\n            return oldInstant;\n        }\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        return newZone.convertUTCToLocal(getZone().convertLocalToUTC(oldInstant));\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    return newZone.convertLocalToUTC(originalZone.convertUTCToLocal(oldInstant), false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // this.getZone() is the zone of this instant\n    // newZone is the new zone\n    // oldInstant is the UTC millis to convert\n    // oldInstant - this.getZone().getOffset(oldInstant) is the local millis in this zone\n    // newZone.getOffsetFromLocal(oldInstant - this.getZone().getOffset(oldInstant)) is the local millis in the new zone\n    // oldInstant - this.getZone().getOffset(oldInstant) + newZone.getOffsetFromLocal(oldInstant - this.getZone().getOffset(oldInstant)) is the UTC millis in the new zone\n    return oldInstant - this.getZone().getOffset(oldInstant) + newZone.getOffsetFromLocal(oldInstant - this.getZone().getOffset(oldInstant));\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        newZone = DateTimeUtils.getZone(newZone);\n        DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n        if (newZone == originalZone) {\n            return oldInstant;\n        }\n        \n        long localMillis = originalZone.convertUTCToLocal(oldInstant);\n        long newLocalMillis = newZone.convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(localMillis, false, newLocalMillis);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        long newLocalMillis = getMillisOfDay();\n        long newInstant = newZone.convertUTCToLocal(oldInstant);\n        if (newLocalMillis != getMillisOfDay()) {\n            newInstant += getZone().getOffset(oldInstant) - newZone.getOffset(newInstant);\n        }\n        return newInstant;\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == getOffset(oldInstant)) {\n            return oldInstant;\n        }\n        return newZone.getMillisKeepLocal(getOffset(oldInstant), oldInstant);\n        }"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: handle millisecond and second units\n    // TODO: handle day and month units\n    // TODO: handle year units\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int milliseconds = calendar.get(Calendar.MILLISECOND);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds + 1);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds + 1);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        Date dd = calendar.getTime();\n        if (dd.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds);\n            dd = calendar.getTime();\n        }\n        return dd;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int milliseconds = calendar.get(Calendar.MILLISECOND);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds + 1);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds + 1);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n        calendar.set(years, months, days, hours, minutes + 1, seconds);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.HOUR)) {\n        calendar.set(years, months, days, hours + 1, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.DAY)) {\n        calendar.set(years, months, days + 1, hours, minutes, seconds);\n        return calendar.getTime();\n    }\n    else if (t.equals(DateTickUnitType.MONTH)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            months = months + 1;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int milliseconds = calendar.get(Calendar.MILLISECOND);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        milliseconds += unit.getSize();\n        if (milliseconds >= 1000) {\n            milliseconds -= 1000;\n            seconds += 1;\n        }\n        if (seconds >= 60) {\n            seconds -= 60;\n            minutes += 1;\n        }\n        if (minutes >= 60) {\n            minutes -= 60;\n            hours += 1;\n        }\n        if (hours >= 24) {\n            hours -= 24;\n            days += 1;\n        }\n        if (days >= calendar.getActualMaximum(Calendar.DATE)) {\n            days -= calendar.getActualMaximum(Calendar.DATE);\n            months += 1;\n        }\n        if (months >= 12) {\n            months -= 12;\n            years += 1;\n        }\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, milliseconds - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // work out the year, month, day, hour, minute, second\n    int years = 0;\n    int months = 0;\n    int days = 0;\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n    int milliseconds = 0;\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        seconds = calendar.get(Calendar.SECOND);\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, value);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, value - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DATE);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = calendar.get(Calendar.MINUTE);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // 1. get the calendar for the unit\n    Calendar calendar = unit.getCalendar();\n    calendar.setTime(date);\n\n    // 2. get the unit type\n    DateTickUnitType t = unit.getUnitType();\n\n    // 3. handle the different types of units\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        // milliseconds - add 1 to the millisecond value\n        calendar.set(Calendar.MILLISECOND, \n                calendar.get(Calendar.MILLISECOND) + 1);\n        Date result = calendar.getTime();\n        if (result.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, \n                    calendar.get(Calendar.MILLISECOND) - 1);\n            result = calendar.getTime();\n        }\n        return result;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        // seconds - add 1 to the second value\n        calendar.set(Calendar.SECOND, \n                calendar.get(Calendar.SECOND) + 1);\n        Date result = calendar.getTime();\n        if (result.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, \n                    calendar.get(Calendar.SECOND) - 1);\n            result = calendar.getTime();\n        }\n        return result;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n        // minutes - add 1 to the minute value\n        calendar.set(Calendar.MINUTE, \n                calendar.get(Calendar.MINUTE) + 1);\n        Date result = calendar.getTime();\n        if (result.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, \n                    calendar.get(Calendar.MINUTE) - 1);\n            result = calendar.getTime();\n        }\n        return result;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int milliseconds = calendar.get(Calendar.MILLISECOND);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds + 1);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        calendar.set(years, months, days, hours, minutes, seconds + 1);\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            milliseconds = 0;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            milliseconds = 500;\n        }\n        else {\n            milliseconds = 999;\n        }\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        Date dd = calendar.getTime();\n        if (dd.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds);\n            dd = calendar.getTime();\n        }\n        return dd;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // this method is used to calculate the first date in a tick unit\n    // (e.g. the first second in a minute)\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int years = calendar.get(Calendar.YEAR);\n    int months = calendar.get(Calendar.MONTH);\n    int days = calendar.get(Calendar.DATE);\n    int hours = calendar.get(Calendar.HOUR_OF_DAY);\n    int minutes = calendar.get(Calendar.MINUTE);\n    int seconds = calendar.get(Calendar.SECOND);\n    int milliseconds = calendar.get(Calendar.MILLISECOND);\n    DateTickUnitType t = unit.getUnitType();\n    if (t.equals(DateTickUnitType.MILLISECOND)) {\n        milliseconds += unit.getSize();\n        calendar.set(years, months, days, hours, minutes, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n        Date mm = calendar.getTime();\n        if (mm.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MILLISECOND, milliseconds - 1);\n            mm = calendar.getTime();\n        }\n        return mm;\n    }\n    else if (t.equals(DateTickUnitType.SECOND)) {\n        seconds += unit.getSize();\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date dd = calendar.getTime();\n        if (dd.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds - 1);\n            dd = calendar.getTime();\n        }\n        return dd;\n    }\n    else if (t.equals(DateTickUnitType.MINUTE)) {\n        minutes += unit.getSize();\n        calendar.set(years, months, days, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n}\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> variableResolver = getVariableResolver();\n    if (variableResolver == null) {\n        return null;\n    }\n    final String value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> variableResolver = getVariableResolver();\n    if (variableResolver != null) {\n        final String varValue = variableResolver.lookup(variableName);\n        if (varValue != null) {\n            return varValue;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup != null) {\n        final String value = lookup.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup != null) {\n        final String value = lookup.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup != null) {\n        final String value = lookup.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> variableResolver = getVariableResolver();\n    if (variableResolver != null) {\n        final String varValue = variableResolver.lookup(variableName);\n        if (varValue != null) {\n            return varValue;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup != null) {\n        final String value = lookup.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup != null) {\n        final String value = lookup.lookup(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) \n    {\n        return str;\n    }\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) \n    {\n        final char c = chars[i];\n        final char soundex = SoundexUtils.getSoundex(c);\n        if (soundex != 0) \n        {\n            key.append(soundex);\n        }\n    }\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder soundex = new StringBuilder(4);\n    final char firstChar = str.charAt(0);\n    soundex.append(Character.toUpperCase(firstChar));\n    for (int i = 1; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (c == 'H' || c == 'W') {\n            if (i + 1 < str.length() && str.charAt(i + 1) == '2') {\n                i++;\n            }\n        } else if (c == 'X') {\n            if (i + 1 < str.length() && str.charAt(i + 1) == '0') {\n                i++;\n            }\n        } else {\n            final char soundexChar = SoundexUtils.getSoundexChar(c);\n            if (soundexChar != '\\0') {\n                if (soundexChar != firstChar) {\n                    soundex.append(soundexChar);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Character not mapped: \" + c);\n            }\n        }\n    }\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Use the same clean rules as Nysiis\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // Translate first characters of name:\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n\n    // Translate last characters of name:\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        if (PAT_VOWELS.matcher(String.valueOf(c)).matches()) {\n            key.append(c);\n        } else {\n            final String s = String.valueOf(c);\n            final String replacement = PAT_MAP.get(s);\n            if (replacement != null) {\n                key.append(replacement);\n            } else {\n                throw new IllegalArgumentException(\"Character not mapped: \" + s);\n            }\n        }\n    }\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        final char soundex = SoundexUtils.getSoundex(c);\n        if (soundex != 0) {\n            key.append(soundex);\n        }\n    }\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Use the same clean rules as Nysiis\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    // Translate first characters of name:\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n\n    // Translate last characters of name:\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        final char prev = chars[i - 1];\n        if (c != prev) {\n            final char soundex = SOUNDEX_MAP[c];\n            if (soundex != 0) {\n                key.append(soundex);\n            }\n        }\n    }\n\n    // Pad with '0's if necessary\n    while (key.length() < 4) {\n        key.append('0');\n    }\n\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n\n    // Use the same clean rules as Nysiis\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) \n    {\n        return str;\n    }\n\n    // Translate first characters of name:\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n\n    // Translate last characters of name:\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) \n    {\n        final char c = chars[i];\n        if (PAT_VOWELS.matcher(c + \"\").matches()) \n        {\n            key.append(c);\n        } \n        else \n        {\n            final String s = MAP.get(c);\n            if (s == null) \n            {\n                throw new IllegalArgumentException(\"No mapping for character '\" + c + \"'\");\n            }\n            key.append(s);\n        }\n}\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        final char soundex = SoundexUtils.getMapping(c);\n        if (soundex != 0) {\n            key.append(soundex);\n        }\n    }\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder soundex = new StringBuilder(4);\n    soundex.append(str.charAt(0));\n    final int[] code = new int[str.length()];\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (c == 'H' || c == 'W' || c == 'X') {\n            code[i] = 0;\n        } else if (c == 'F' || c == 'M' || c == 'P') {\n            code[i] = 1;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'Y') {\n            code[i] = 2;\n        } else if (c == 'B' || c == 'P' || c == 'F' || c == 'V') {\n            code[i] = 3;\n        } else if (c == 'C' || c == 'G' || c == 'J' || c == 'K' || c == 'Q' || c == 'S' || c == 'X' || c == 'Z') {\n            code[i] = 4;\n        } else if (c == 'D' || c == 'T') {\n            code[i] = 5;\n        } else if (c == 'L') {\n            code[i] = 6;\n        } else if (c == 'M' || c == 'N') {\n            code[i] = 7;\n        } else if (c == 'R') {\n            code[i] = 8;\n        } else if (c == 'S') {\n            code[i] = 9;\n        } else {\n            throw new IllegalArgumentException(\"Character \" + c + \" is not mapped\");\n        }\n    }\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        if (c == 'H' || c == 'W') {\n            key.append(c);\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            key.append('0');\n        } else if (c == 'B' || c == 'P' || c == 'F' || c == 'V') {\n            key.append('1');\n        } else if (c == 'C' || c == 'G' || c == 'J' || c == 'K' || c == 'Q' || c == 'S' || c == 'X' || c == 'Z') {\n            key.append('2');\n        } else if (c == 'D' || c == 'T') {\n            key.append('3');\n        } else if (c == 'L') {\n            key.append('4');\n        } else if (c == 'M' || c == 'N') {\n            key.append('5');\n        } else if (c == 'R') {\n            key.append('6');\n        } else if (c == 'Y') {\n            key.append('7');\n        } else {\n            throw new IllegalArgumentException(\"Character '\" + c + \"' is not mapped\");\n        }\n    }\n    return key.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    // Use the same clean rules as Nysiis\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    // Translate first characters of name:\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n    // Translate last characters of name:\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        if (PAT_VOWELS.matcher(String.valueOf(c)).matches()) {\n            key.append(c);\n        } else {\n            final String s = MAP.get(String.valueOf(c));\n            if (s != null) {\n                key.append(s);\n            } else {\n                throw new IllegalArgumentException(\"Character '\" + c + \"' is not mapped\");\n            }\n        }\n    }\n    return key.toString();\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // first common types:\n    if (clz == String.class || clz == Object.class || clz == CharSequence.class) {\n        return StringType.getType(config);\n    } else if (clz == UUID.class) {\n        return UUIDType.getType(config);\n    } else if (clz == Integer.class) {\n        return IntType.getType(config);\n    } else if (clz == Long.class) {\n        return LongType.getType(config);\n    } else if (clz == Date.class) {\n        return DateType.getType(config);\n    } else if (clz == Calendar.class) {\n        return CalendarType.getType(config);\n    } else if (clz == Boolean.class) {\n        return BooleanType.getType(config);\n    } else if (clz == Byte.class) {\n        return ByteType.getType(config);\n    } else if (clz == Character.class) {\n        return CharacterType.getType(config);\n    } else if (clz == Short.class) {\n        return ShortType.getType(config);\n    } else if (clz == Float.class) {\n        return FloatType.getType(config);\n    } else if (clz == Double.class) {\n        return DoubleType.getType(config);\n    } else if (clz == URI.class) {\n        return URIType.getType(config);\n    } else if (clz == URL.class) {\n        return URLType.getType(config);\n    } else if (clz == Class.class) {\n        return ClassType.getType(config);\n    } else if (clz == Locale.class) {\n        return LocaleType.getType(config);\n    } else if (clz == Currency.class) {\n        return CurrencyType.getType(config);\n    } else if (clz == byte[].class) {\n        return ByteArrayType.getType(config);\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return TypeFactory.stringType();\n    }\n    if (clz == Integer.class) {\n        return TypeFactory.intType();\n    }\n    if (clz == Boolean.class) {\n        return TypeFactory.booleanType();\n    }\n    if (clz == Long.class) {\n        return TypeFactory.longType();\n    }\n    if (clz == Double.class) {\n        return TypeFactory.doubleType();\n    }\n    if (clz == Character.class) {\n        return TypeFactory.charType();\n    }\n    if (clz == Byte.class) {\n        return TypeFactory.byteType();\n    }\n    if (clz == Short.class) {\n        return TypeFactory.shortType();\n    }\n    if (clz == Float.class) {\n        return TypeFactory.floatType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return TypeFactory.stringType();\n    }\n    if (clz == Integer.class) {\n        return TypeFactory.integerType();\n    }\n    if (clz == Boolean.class) {\n        return TypeFactory.booleanType();\n    }\n    if (clz == Long.class) {\n        return TypeFactory.longType();\n    }\n    if (clz == Double.class) {\n        return TypeFactory.doubleType();\n    }\n    if (clz == Character.class) {\n        return TypeFactory.charType();\n    }\n    if (clz == Byte.class) {\n        return TypeFactory.byteType();\n    }\n    if (clz == Short.class) {\n        return TypeFactory.shortType();\n    }\n    if (clz == Float.class) {\n        return TypeFactory.floatType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First: primitives\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return Integer.TYPE;\n        }\n        if (clz == Boolean.TYPE) {\n            return Boolean.TYPE;\n        }\n        if (clz == Long.TYPE) {\n            return Long.TYPE;\n        }\n        if (clz == Double.TYPE) {\n            return Double.TYPE;\n        }\n        if (clz == Character.TYPE) {\n            return Character.TYPE;\n        }\n        if (clz == Byte.TYPE) {\n            return Byte.TYPE;\n        }\n        if (clz == Short.TYPE) {\n            return Short.TYPE;\n        }\n        if (clz == Float.TYPE) {\n            return Float.TYPE;\n        }\n    }\n    // Then: common reference types\n    if (clz == String.class) {\n        return String.class;\n    }\n    if (clz == Integer.class) {\n        return Integer.class;\n    }\n    if (clz == Boolean.class) {\n        return Boolean.class;\n    }\n    if (clz == Long.class) {\n        return Long.class;\n    }\n    if (clz == Double.class) {\n        return Double.class;\n    }\n    if (clz == Character.class) {\n        return Character.class;\n    }\n    if (clz == Byte.class) {\n        return Byte.class;\n    }\n    if (clz == Short.class) {\n        return Short.class;\n    }\n    if (clz == Float.class) {\n        return Float.class;\n    }\n    // And finally: URI, URL, Class\n    if (clz == URI.class) {\n        return URI.class;\n    }\n    if (clz == URL.class) {\n        return URL.class;\n    }\n    if (clz == Class.class) {\n        return Class.class;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        return _findWellKnownSimplePrimitive(clz);\n    }\n    if (clz == String.class) {\n        return TypeFactory.stringType();\n    }\n    if (clz == Integer.class) {\n        return TypeFactory.integerType();\n    }\n    if (clz == Boolean.class) {\n        return TypeFactory.booleanType();\n    }\n    if (clz == Long.class) {\n        return TypeFactory.longType();\n    }\n    if (clz == Double.class) {\n        return TypeFactory.doubleType();\n    }\n    if (clz == Character.class) {\n        return TypeFactory.characterType();\n    }\n    if (clz == Byte.class) {\n        return TypeFactory.byteType();\n    }\n    if (clz == Short.class) {\n        return TypeFactory.shortType();\n    }\n    if (clz == Float.class) {\n        return TypeFactory.floatType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return TypeFactory.stringType();\n    }\n    if (clz == Integer.class) {\n        return TypeFactory.intType();\n    }\n    if (clz == Boolean.class) {\n        return TypeFactory.booleanType();\n    }\n    if (clz == Long.class) {\n        return TypeFactory.longType();\n    }\n    if (clz == Double.class) {\n        return TypeFactory.doubleType();\n    }\n    if (clz == Character.class) {\n        return TypeFactory.charType();\n    }\n    if (clz == Byte.class) {\n        return TypeFactory.byteType();\n    }\n    if (clz == Short.class) {\n        return TypeFactory.shortType();\n    }\n    if (clz == Float.class) {\n        return TypeFactory.floatType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        return _wellKnownPrimitiveTypes.get(clz);\n    }\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Character.class) {\n        return CharType.instance;\n    }\n    if (clz == Byte.class) {\n        return ByteType.instance;\n    }\n    if (clz == Short.class) {\n        return ShortType.instance;\n    }\n    if (clz == Float.class) {\n        return FloatType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        return _findWellKnownPrimitive(clz);\n    }\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isExprResult()) \n  {\n    return null;\n  }\n\n  Node expr = n.getFirstChild();\n  if (!expr.isAssign()) \n  {\n    return null;\n  }\n\n  Node lhs = expr.getFirstChild();\n  if (!lhs.isGetProp()) \n  {\n    return null;\n  }\n\n  Node obj = lhs.getFirstChild();\n  if (!obj.isThis()) \n  {\n    return null;\n  }\n\n  String propName = lhs.getLastChild().getString();\n  Node rhs = expr.getLastChild();\n  return new PrototypeMemberDeclaration(propName, rhs);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult()) {\n    n = n.getFirstChild();\n  }\n\n  if (n.isAssign() && n.getFirstChild().isGetProp()) {\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext();\n    if (lhs.getFirstChild().isName() &&\n        lhs.getFirstChild().getString().equals(\"prototype\") &&\n        rhs.isObjectLit()) {\n      return new PrototypeMemberDeclaration(lhs.getFirstChild(), rhs);\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isExprResult()) {\n    return null;\n  }\n\n  Node expr = n.getFirstChild();\n  if (!expr.isAssign()) {\n    return null;\n  }\n\n  Node lhs = expr.getFirstChild();\n  if (!lhs.isGetProp()) {\n    return null;\n  }\n\n  Node obj = lhs.getFirstChild();\n  if (!obj.isName() || !\"prototype\".equals(lhs.getLastChild().getString())) {\n    return null;\n  }\n\n  Node rhs = lhs.getNext();\n  if (!rhs.isName()) {\n    return null;\n  }\n\n  return new PrototypeMemberDeclaration(obj, lhs, rhs);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult()) {\n    n = n.getFirstChild();\n  }\n\n  if (n.isAssign()) {\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (lhs.isGetProp() && rhs.isFunction()) {\n      return new PrototypeMemberDeclaration(lhs.getFirstChild().getQualifiedName(), rhs);\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isGetProp()) {\n        Node obj = n.getFirstChild();\n        Node prop = n.getLastChild();\n        if (obj.isThis() && prop.isString()) {\n            return new PrototypeMemberDeclaration(prop.getString(), n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult()) {\n        n = n.getFirstChild();\n    }\n\n    if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        Node rhs = n.getLastChild();\n\n        if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n            String className = getPrototypeClassName(lhs).getQualifiedName();\n            if (className != null) {\n                String propName = lhs.getFirstChild().getString();\n                return new PrototypeMemberDeclaration(className, propName, rhs);\n            }\n        }\n    }\n\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isExprResult()) {\n        return null;\n    }\n    Node expr = n.getFirstChild();\n    if (!expr.isAssign()) {\n        return null;\n    }\n    Node lhs = expr.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n    Node obj = lhs.getFirstChild();\n    if (!obj.isThis()) {\n        return null;\n    }\n    Node prop = lhs.getLastChild();\n    if (!prop.isString()) {\n        return null;\n    }\n    Node rhs = expr.getLastChild();\n    return new PrototypeMemberDeclaration(prop.getString(), rhs);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign()) {\n    Node assign = n.getFirstChild();\n    if (assign.getFirstChild().isGetProp() &&\n        assign.getFirstChild().getFirstChild().isThis()) {\n      Node prop = assign.getFirstChild().getLastChild();\n      if (prop.isQualifiedName()) {\n        return new PrototypeMemberDeclaration(prop.getQualifiedName(),\n            assign.getLastChild());\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isExprResult()) {\n    return null;\n  }\n\n  Node expr = n.getFirstChild();\n  if (!expr.isAssign()) {\n    return null;\n  }\n\n  Node lhs = expr.getFirstChild();\n  if (!lhs.isGetProp()) {\n    return null;\n  }\n\n  Node obj = lhs.getFirstChild();\n  if (!obj.isName() || !\"prototype\".equals(lhs.getLastChild().getString())) {\n    return null;\n  }\n\n  Node rhs = lhs.getNext();\n  if (!rhs.isName()) {\n    return null;\n  }\n\n  return new PrototypeMemberDeclaration(obj.getString(), rhs.getString());\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isGetProp() && n.getLastChild().getString().equals(\"prototype\")) \n    {\n        Node obj = n.getFirstChild();\n        if (obj.isName() && !NodeUtil.isLValue(obj)) \n        {\n            return new PrototypeMemberDeclaration(obj.getString(), n);\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDim = mat.getRowDimension();\n    final int colDim = mat.getColumnDimension();\n    final double[][] d = new double[n * rowDim][m * colDim];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < rowDim; i++) {\n                for (int j = 0; j < colDim; j++) {\n                    d[r * rowDim + i][c * colDim + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[n*rows][m*cols];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < rows; r++) {\n                for (int c = 0; c < cols; c++) {\n                    data[i*rows + r][j*cols + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix out = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < mat.getRowDimension(); r++) {\n                for (int c = 0; c < mat.getColumnDimension(); c++) {\n                    out.setEntry(i * mat.getRowDimension() + r, j * mat.getColumnDimension() + c, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix out = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat, i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int nRows = mat.getRowDimension();\n    int nCols = mat.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(nRows * n, nCols * m);\n    for (int r = 0; r < nRows; r++) {\n        for (int c = 0; c < nCols; c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    out.setEntry(r * n + i, c * m + j, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDim = mat.getRowDimension();\n    final int colDim = mat.getColumnDimension();\n    final double[][] d = new double[n * rowDim][m * colDim];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < rowDim; i++) {\n                for (int j = 0; j < colDim; j++) {\n                    d[r * rowDim + i][c * colDim + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int nRows = mat.getRowDimension();\n    int nCols = mat.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(n * nRows, m * nCols);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < nRows; r++) {\n                for (int c = 0; c < nCols; c++) {\n                    out.setEntry(i * nRows + r, j * nCols + c, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix out = mat.copy();\n    for (int i = 1; i < n; i++) \n    {\n        out = out.add(mat);\n    }\n    for (int i = 1; i < m; i++) \n    {\n        out = out.add(mat.transpose());\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n * mat.getRowDimension(); r++) {\n        for (int c = 0; c < m * mat.getColumnDimension(); c++) {\n            d[r][c] = mat.getEntry(r % mat.getRowDimension(), c % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix out = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < mat.getRowDimension(); r++) {\n                for (int c = 0; c < mat.getColumnDimension(); c++) {\n                    out.setEntry(i * mat.getRowDimension() + r, j * mat.getColumnDimension() + c, mat.getEntry(r, c));\n                }\n            }\n        }\n    }\n    return out;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < 0) {\n        bytesInflated += Integer.MAX_VALUE + 1L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesConsumed = inf.getBytesRead();\n    if (bytesConsumed < bytesRead) {\n        return bytesConsumed;\n    }\n    return bytesRead - (bytesConsumed - bytesRead);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > Integer.MAX_VALUE) {\n        bytesInflated = (int) bytesInflated - Integer.MAX_VALUE;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < bytesRead) {\n        return bytesInflated;\n    }\n    return bytesRead - (bytesInflated - bytesRead);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > Integer.MAX_VALUE) {\n        bytesInflated = (bytesInflated - Integer.MAX_VALUE) + current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesConsumed = inf.getBytesRead();\n    if (bytesConsumed < bytesRead) {\n        return bytesConsumed;\n    }\n    if (bytesConsumed > bytesRead) {\n        return bytesRead;\n    }\n    return bytesRead - 0x100000000L;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesConsumed = inf.getBytesRead();\n    if (bytesConsumed < bytesRead) {\n        return bytesConsumed;\n    }\n    return bytesRead - (bytesConsumed - bytesRead);\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesConsumed = inf.getBytesRead();\n    final long bytesRemaining = current.entry.getCompressedSize() - bytesConsumed;\n    final long bytesReadMinusConsumed = bytesRead - bytesConsumed;\n    if (bytesReadMinusConsumed <= bytesRemaining) {\n        return bytesConsumed;\n    }\n    final long bytesReadMinusConsumedMinusRemaining = bytesReadMinusConsumed - bytesRemaining;\n    if (bytesReadMinusConsumedMinusRemaining <= Integer.MAX_VALUE) {\n        return bytesConsumed + bytesReadMinusConsumedMinusRemaining;\n    }\n    return bytesConsumed + bytesReadMinusConsumed - Integer.MAX_VALUE;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < 0) {\n        bytesInflated += Integer.MAX_VALUE + 1L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesReadFromStream;\n    final long bytesInflated = inf.getBytesRead();\n    if (bytesInflated >= bytesRead) {\n        return bytesInflated;\n    }\n    return bytesRead - (bytesRead - bytesInflated);\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    }\n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else if (object instanceof Optional<?>) {\n        return !((Optional<?>) object).isPresent();\n    } else if (object instanceof OptionalInt<?>) {\n        return !((OptionalInt<?>) object).isPresent();\n    } else if (object instanceof OptionalLong<?>) {\n        return !((OptionalLong<?>) object).isPresent();\n    } else if (object instanceof OptionalDouble<?>) {\n        return !((OptionalDouble<?>) object).isPresent();\n    } else if (object instanceof OptionalBoolean<?>) {\n        return !((OptionalBoolean<?>) object).isPresent();\n    } else if (object instanceof OptionalChar<?>) {\n        return !((OptionalChar<?>) object).isPresent();\n    } else if (object instanceof OptionalByte<?>) {\n        return !((OptionalByte<?>) object).isPresent();\n    } else if (object instanceof OptionalShort<?>) {\n        return !((OptionalShort<?>) object).isPresent();\n    } else if (object instanceof OptionalFloat<?>) {\n        return !((OptionalFloat<?>) object).isPresent();\n    } else if (object instanceof OptionalDouble<?>) {\n        return !((OptionalDouble<?>) object).isPresent();\n    } else if (object instanceof OptionalInt<?>) {\n        return !((OptionalInt<?>) object).isPresent();\n    } else if (object instanceof OptionalLong<?>) {\n        return !((OptionalLong<?>) object).isPresent();\n    } else if (object instanceof OptionalDouble<?>) {\n        return !((OptionalDouble<?>) object).isPresent();\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else if (object instanceof Optional<?>) {\n        return !((Optional<?>) object).isPresent();\n    } else if (object instanceof OptionalInt<?>) {\n        return !((OptionalInt<?>) object).isPresent();\n    } else if (object instanceof OptionalLong<?>) {\n        return !((OptionalLong<?>) object).isPresent();\n    } else if (object instanceof OptionalDouble<?>) {\n        return !((OptionalDouble<?>) object).isPresent();\n    } else if (object instanceof OptionalBoolean<?>) {\n        return !((OptionalBoolean<?>) object).isPresent();\n    } else if (object instanceof OptionalChar<?>) {\n        return !((OptionalChar<?>) object).isPresent();\n    } else if (object instanceof OptionalByte<?>) {\n        return !((OptionalByte<?>) object).isPresent();\n    } else if (object instanceof OptionalShort<?>) {\n        return !((OptionalShort<?>) object).isPresent();\n    } else if (object instanceof OptionalFloat<?>) {\n        return !((OptionalFloat<?>) object).isPresent();\n    } else if (object instanceof OptionalIntArray<?>) {\n        return !((OptionalIntArray<?>) object).isPresent();\n    } else if (object instanceof OptionalLongArray<?>) {\n        return !((OptionalLongArray<?>) object).isPresent();\n    } else if (object instanceof OptionalDoubleArray<?>) {\n        return !((OptionalDoubleArray<?>) object).isPresent();\n    } else if (object instanceof OptionalBooleanArray<?>) {\n}\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else if (object instanceof Optional<?>) {\n        return !((Optional<?>) object).isPresent();\n    } else if (object instanceof OptionalInt<?>) {\n        return !((OptionalInt<?>) object).isPresent();\n    } else if (object instanceof OptionalLong<?>) {\n        return !((OptionalLong<?>) object).isPresent();\n    } else if (object instanceof OptionalDouble<?>) {\n        return !((OptionalDouble<?>) object).isPresent();\n    } else if (object instanceof CharSequence) {\n        return ((CharSequence) object).length() == 0;\n    } else if (object instanceof Boolean) {\n        return !((Boolean) object).booleanValue();\n    } else if (object instanceof Number) {\n        return ((Number) object).doubleValue() == 0;\n    } else if (object instanceof Characte) {\n        return ((Character) object).charValue() == 0;\n    } else if (object instanceof Map.Entry<?, ?>) {\n        return !((Map.Entry<?, ?>) object).setValue(object).equals(object);\n    } else if (object instanceof AtomicInteger) {\n        return ((AtomicInteger) object).get() == 0;\n    } else if (object instanceof AtomicLong) {\n        return ((AtomicLong) object).get() == 0;\n    } else if (object instanceof AtomicBoolean) {\n        return !((AtomicBoolean) object).get();\n    } else if (object instanceof OptionalInt<?>) {\n        return !((OptionalInt<?>) object).isPresent();\n}\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof CharSequence) {\n        return ((CharSequence) object).length() == 0;\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.sizeIsEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    while (im <= iu - 2) {\n        boolean notlast = im != (iu - 2);\n        double p = matrixT[im][im - 1];\n        double q = matrixT[im + 1][im - 1];\n        double r = notlast ? matrixT[im + 2][im - 1] : 0.0;\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (im != il) {\n                matrixT[im][im - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[im][im - 1] = -matrixT[im][im - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            // Row modification\n            for (int j = im; j < n; j++) {\n                p = matrixT[im][j] + q * matrixT[im + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[im + 2][j];\n                    matrixT[im + 2][j] = matrixT[im + 2][j] - p * z;\n                }\n                matrixT[im][j] = matrixT[im][j] - p * shift.x;\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            hVec[0] = matrixT[k][k - 1];\n            hVec[1] = matrixT[k + 1][k - 1];\n            hVec[2] = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                hVec[0] = hVec[0] / shift.x;\n                hVec[1] = hVec[1] / shift.x;\n                hVec[2] = hVec[2] / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n        if (hVec[0] < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            hVec[0] = hVec[0] + s;\n            shift.x = hVec[0] / s;\n            shift.y = hVec[1] / s;\n            double z = hVec[2] / s;\n            hVec[1] = hVec[1] / hVec[0];\n            hVec[2] = hVec[2] / hVec[0];\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    while (im <= iu - 1) {\n        boolean notlast = im != (iu - 1);\n        if (im != il) {\n            hVec[0] = matrixT[im][im - 1];\n            hVec[1] = matrixT[im + 1][im - 1];\n            hVec[2] = notlast ? matrixT[im + 2][im - 1] : 0.0;\n            shift.x = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                hVec[0] = hVec[0] / shift.x;\n                hVec[1] = hVec[1] / shift.x;\n                hVec[2] = hVec[2] / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n        if (hVec[0] < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (im != il) {\n                matrixT[im][im - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[im][im - 1] = -matrixT[im][im - 1];\n            }\n            hVec[0] = hVec[0] + s;\n            shift.x = hVec[0] / s;\n            shift.y = hVec[1] / s;\n            double z = hVec[2] / s;\n            hVec[1] = hVec[1] / hVec[0];\n            hVec[2] = hVec[2] / hVec[0];\n\n            // Row modification\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n}\n}\n}\n}\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes = new ArrayList<TextNode>();\n        for (Node node: childNodes) {\n            if (node instanceof TextNode) {\n                textNodes.add((TextNode) node);\n            }\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> list = new ArrayList<TextNode>();\n    for (Node node: childNodes) {\n        if (node instanceof TextNode)\n            list.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(list);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> list = new ArrayList<TextNode>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                list.add(tn);\n        }\n    }\n    return Collections.unmodifiableList(list);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node node: childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child: childNodes) {\n        if (child instanceof TextNode) {\n            TextNode textNode = (TextNode) child;\n            if (!textNode.isBlank())\n                textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child: childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inIncludeSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"Zero instance must not be null\");\n        }\n        int size = start.size();\n        int[] values = new int[size];\n        for (int i = 0; i < size; i++) {\n            DateTimeFieldType fieldType = start.getFieldType(i);\n            values[i] = end.get(fieldType) - start.get(fieldType);\n        }\n        return zeroInstance.getValue(values);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        startValues[i] = start.get(i);\n        endValues[i] = end.get(i);\n    }\n    return zeroInstance.get(startValues, endValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            int[] values = chrono.get(zeroInstance, startMillis, endMillis);\n            int size = values.length;\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                sum += values[i];\n            }\n            return sum;\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            int size = start.size();\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                int amount = end.getValue(i) - start.getValue(i);\n                if (amount < 0) {\n                    amount += start.getFieldType(i).getMaximumTextLength();\n                }\n                sum += amount;\n            }\n            return sum;\n        }\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        DateTimeFieldType type = start.getFieldType(i);\n        int startValue = start.get(type);\n        int endValue = end.get(type);\n        int amount = endValue - startValue;\n        if (amount < 0) {\n            amount += type.getMaximumValue();\n        }\n        values[i] = amount;\n    }\n    return zeroInstance.getValue(values);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            int[] values = chrono.get(zeroInstance, startMillis, endMillis);\n            int size = values.length;\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                sum += values[i];\n            }\n            return sum;\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            int size = start.size();\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                int startValue = start.getValue(i);\n                int endValue = end.getValue(i);\n                int amount = endValue - startValue;\n                if (amount < 0) {\n                    amount += start.getFieldType(i).getMaximumTextLength();\n                }\n                sum += amount;\n            }\n            return sum;\n        }\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    // check if the partials are contiguous\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    // check if the partials are contiguous\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != zeroInstance.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePeriod objects must have the same set of fields\");\n        }\n    }\n    // check if the partials are contiguous\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (end.getFieldType(i) != zeroInstance.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePeriod objects must have the same set of fields\");\n        }\n    }\n    // check if the partials are contiguous\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    // check if the partials are contiguous\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n}\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return zeroInstance.getValue(values);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] values = zeroInstance.getValues();\n    int len = values.length;\n    int[] startValues = start.getValues(len);\n    int[] endValues = end.getValues(len);\n    for (int i = 0; i < len; i++) {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        if (startValue != endValue) {\n            return endValue - startValue;\n        }\n    }\n    return 0;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return zeroInstance.getValue(values);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            int[] values = chrono.get(zeroInstance, startMillis, endMillis);\n            int size = zeroInstance.size();\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                sum += values[i];\n            }\n            return sum;\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            int size = start.size();\n            int sum = 0;\n            for (int i = 0; i < size; i++) {\n                sum += start.getValue(i) - end.getValue(i);\n            }\n            return sum;\n        }\n    }"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    BlockContainer container = getLegendContainer();\n    if (container != null) {\n        List blocks = container.getBlocks();\n        if (index >= 0 && index < blocks.size()) {\n            Block block = (Block) blocks.get(index);\n            if (block instanceof LegendTitle) {\n                result = (LegendTitle) block;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getTitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    BlockContainer container = getLegendContainer();\n    if (container != null) {\n        List blocks = container.getBlocks();\n        if (index >= 0 && index < blocks.size()) {\n            Block block = (Block) blocks.get(index);\n            if (block instanceof LegendTitle) {\n                result = (LegendTitle) block;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.legendCollection.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legendCollection.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legendCollection.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legendCollection.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legendCollection.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    BlockContainer container = getLegendContainer();\n    if (container != null) {\n        List blocks = container.getBlocks();\n        if (index >= 0 && index < blocks.size()) {\n            Block block = (Block) blocks.get(index);\n            if (block instanceof LegendTitle) {\n                result = (LegendTitle) block;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    BlockContainer container = getBlockContainer();\n    if (container != null) {\n        List blocks = container.getBlocks();\n        if (index >= 0 && index < blocks.size()) {\n            Block block = (Block) blocks.get(index);\n            if (block instanceof LegendTitle) {\n                result = (LegendTitle) block;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legendCollection.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legendCollection.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legendCollection.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legendCollection.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final StringTokenizer framesTokens = new StringTokenizer(getStackTrace(t), SystemUtils.LINE_SEPARATOR);\n    while (framesTokens.hasMoreTokens()) \n    {\n        frames.add(framesTokens.nextToken());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final String[] trace = ExceptionUtils.getStackFrames(t);\n    for (int i = 0; i < trace.length; i++) {\n        frames.add(trace[i]);\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    list.add(t.toString());\n    final String[] frames = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < frames.length; i++) {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getRootCauseStackTrace(t);\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) \n    {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final String[] trace = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < trace.length; i++) {\n        frames.add(trace[i]);\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final StringTokenizer framesTokenizer = new StringTokenizer(ExceptionUtils.getStackTrace(t), SystemUtils.LINE_SEPARATOR);\n    while (framesTokenizer.hasMoreTokens()) \n    {\n        frames.add(framesTokenizer.nextToken());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = ExceptionUtils.getStackFrames(t);\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String[] frames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : frames) {\n        if (frame.startsWith(\"at \")) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String[] frames = getStackFrames(getStackTrace(t));\n    for (int i = 0; i < frames.length; i++) {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final String[] trace = ExceptionUtils.getStackFrames(t);\n    for (int i = 0; i < trace.length; i++) {\n        frames.add(trace[i]);\n    }\n    return frames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext();\n        arg != null; arg = arg.getNext()) \n    {\n        if (mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node arg = call.getFirstChild().getNext();\n    for (; arg != null; arg = arg.getNext()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext();\n       arg != null;\n       arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node firstArg = call.getFirstChild().getNext();\n    for (Node arg = firstArg; arg != null; arg = arg.getNext()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext();\n         arg != null;\n         arg = arg.getNext()) {\n      if (mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n        if (mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (!isWhitespace(ch)) {\n            // error invalid char between token and next delimiter\n            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                    \") invalid char between token and delimiter\");\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } \n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        } \n        else \n        {\n            token.content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                // token finish mark reached: ignore whitespace till delimiter\n                while (true) {\n                    ch = reader.read();\n                    if (isWhitespace(ch)) {\n                        continue;\n                    } else if (isEndOfFile(ch)) {\n                        // end of file return EOF()\n                        token.type = EOF;\n                        token.isReady = true; // there is data at EOF\n                        return token;\n                    } else if (isDelimiter(ch)) {\n                        token.type = TOKEN;\n                        return token;\n                    } else {\n                        // error invalid char between token and next delimiter\n                        throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                \") invalid char between token and delimiter\");\n                    }\n                }\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        }\n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        }\n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        }\n        else \n        {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } \n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        } \n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        } \n        else if (isEscape(ch)) \n        {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) \n            { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } \n            else \n            {\n                token.content.append((char) unescaped);\n            }\n        } \n        else \n        {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (!isWhitespace(ch)) {\n            // error invalid char between token and next delimiter\n            throw new IOException(\"(line \" + startLineNumber + \") invalid char between token and delimiter\");\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        }\n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        }\n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        }\n        else \n        {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        }\n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        }\n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            return token;\n        }\n        else \n        {\n            token.content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension - 1; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[dimension - 1] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension - 1; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n    counts[dimension - 1] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension - 1; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n    counts[dimension - 1] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension - 1; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index -= counts[i] * uniCounterOffset[i];\n    }\n    counts[dimension - 1] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                // Test clonability\n                @SuppressWarnings(\"unchecked\") // cloning is safe\n                final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final Exception ex) {\n                throw new CloneFailedException(ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            }\n        } else {\n            return null;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n}\n}\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" cannot be cloned\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" cannot be cloned\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" cannot be cloned\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n}\n}\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                // clone method is protected so use reflection to force access\n                final Method cloneMethod = obj.getClass().getDeclaredMethod(\"clone\");\n                return (T) cloneMethod.invoke(obj);\n            } catch (final Exception ex) {\n                throw new CloneFailedException(\"Cloning failed.\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            }\n        } else {\n            return null;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            }\n        } else {\n            throw new CloneFailedException(\"Object does not implement Cloneable.\");\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Clone operation failed.\", ex);\n            }\n        } else {\n            return null;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" not accessible\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" threw an exception during cloning\", ex);\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" does not implement Cloneable\", ex);\n            }\n        } else {\n            throw new CloneFailedException(\"Object of type \" + obj.getClass().getName() + \" is not cloneable\");\n        }\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (Node paramNode = type.getParametersNode().getFirstChild();\n       paramNode != null; paramNode = paramNode.getNext()) {\n    if (paramNode.getString().equals(paramName)) {\n      return getSymbolForName(null, paramNode.getString());\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (Node param : type.getParameters()) {\n    if (param.getString().equals(paramName)) {\n      return getSymbolForName(null, paramName);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    // NOTE: these template type names may override a list\n    // of inherited ones from an overridden function.\n    if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n        ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n        for (String key : info.getTemplateTypeNames()) {\n            builder.add(typeRegistry.createTemplateType(key));\n        }\n        templateTypeNames = builder.build();\n    }\n\n    ImmutableList<TemplateType> keys = templateTypeNames;\n    if (ownerType != null) {\n        ImmutableList<TemplateType> ownerTypeKeys =\n                ownerType.getTemplateTypeMap().getTemplateKeys();\n        if (!ownerTypeKeys.isEmpty()) {\n            ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n            builder.addAll(templateTypeNames);\n            builder.addAll(ownerTypeKeys);\n            keys = builder.build();\n        }\n    }\n\n    if (!keys.isEmpty()) {\n        typeRegistry.setTemplateTypeNames(keys);\n    }\n    return this;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  Node param = type.getParametersNode();\n  if (param == null) {\n    return null;\n  }\n\n  for (Node child = param.getFirstChild(); child != null;\n       child = child.getNext()) {\n    if (child.getString().equals(paramName)) {\n      return getSymbolForName(null, child.getString());\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (Node param : type.getParameters()) {\n    if (param.getString().equals(paramName)) {\n      return getSymbolForName(null, paramName);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    for (Node param : type.getParameters()) {\n        if (param.getString().equals(paramName)) {\n            return getSymbolForName(null, paramName);\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    // NOTE: these template type names may override a list\n    // of inherited ones from an overridden function.\n    if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n        ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n        for (String key : info.getTemplateTypeNames()) {\n            builder.add(typeRegistry.createTemplateType(key));\n        }\n        templateTypeNames = builder.build();\n    }\n\n    ImmutableList<TemplateType> keys = templateTypeNames;\n    if (ownerType != null) {\n        ImmutableList<TemplateType> ownerTypeKeys =\n                ownerType.getTemplateTypeMap().getTemplateKeys();\n        if (!ownerTypeKeys.isEmpty()) {\n            ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n            builder.addAll(templateTypeNames);\n            builder.addAll(ownerTypeKeys);\n            keys = builder.build();\n        }\n    }\n\n    if (!keys.isEmpty()) {\n        typeRegistry.setTemplateTypeNames(keys);\n    }\n    return this;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n\n    Node param = type.getParametersNode();\n    if (param == null) {\n      return null;\n    }\n\n    for (Node child = param.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.getString().equals(paramName)) {\n        return getSymbolForName(null, child.getString());\n      }\n    }\n\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    for (Node param : type.getParameters()) {\n        if (param.getString().equals(paramName)) {\n            return getSymbolForName(param);\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) \n  {\n    return null;\n  }\n  Node paramNode = type.getParametersNode();\n  if (paramNode == null) \n  {\n    return null;\n  }\n  for (Node child = paramNode.getFirstChild(); child != null; child = child.getNext()) \n  {\n    if (child.getString().equals(paramName)) \n    {\n      return getSymbolForName(null, child.getString());\n    }\n  }\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, 1d);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getEntry(j, j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, 1d);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getEntry(j, j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, 1d);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getEntry(j, j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int n = matrix.getColumnDimension();\n    final int m = matrix.getRowDimension();\n    final double[] means = new double[n];\n    final double[][] data = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        means[i] = matrix.getColumn(i).getMean();\n        for (int j = 0; j < m; j++) {\n            data[i][j] = matrix.getEntry(j, i) - means[i];\n        }\n    }\n    RealMatrix covariance = new BlockRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            double cov = 0;\n            for (int k = 0; k < m; k++) {\n                cov += data[i][k] * data[j][k];\n            }\n            if (biasCorrected) {\n                cov /= m - 1;\n            } else {\n                cov /= m;\n            }\n            covariance.setEntry(i, j, cov);\n            covariance.setEntry(j, i, cov);\n        }\n    }\n    return covariance;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix covariance = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double cov = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    final double xi = matrix.getEntry(k, i);\n                    final double xj = matrix.getEntry(k, j);\n                    cov += xi * xj;\n                }\n                covariance.setEntry(i, j, cov);\n                if (biasCorrected) {\n                    covariance.setEntry(j, i, cov);\n                }\n            }\n        }\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix covariance = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double sum = 0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    double diff = matrix.getEntry(k, i) - matrix.getEntry(k, j);\n                    sum += diff * diff;\n                }\n                covariance.setEntry(i, j, sum / (matrix.getRowDimension() - (biasCorrected ? 1 : 0)));\n                covariance.setEntry(j, i, covariance.getEntry(i, j));\n            }\n        }\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int n = matrix.getColumnDimension();\n    final int m = matrix.getRowDimension();\n    final double[][] data = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            data[i][j] = data[j][i] = 0;\n        }\n        for (int j = i; j < n; j++) {\n            data[i][j] = data[j][i] = matrix.getEntry(i, j);\n        }\n    }\n    return computeCovarianceMatrix(data, biasCorrected);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, 1d);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getEntry(j, j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            double sigma = FastMath.sqrt(matrix.getEntry(i, i));\n            outMatrix.setEntry(i, i, 1d);\n            for (int j = 0; j < i; j++) {\n                double entry = matrix.getEntry(i, j) /\n                       (sigma * FastMath.sqrt(matrix.getEntry(j, j)));\n                outMatrix.setEntry(i, j, entry);\n                outMatrix.setEntry(j, i, entry);\n            }\n        }\n        return outMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getColumnDimension();\n    int m = matrix.getRowDimension();\n    if (n < 2 || m < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_COVARIATES,\n                                               n, m);\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < m; k++) {\n                sum += matrix.getEntry(k, i) * matrix.getEntry(k, j);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (m - biasCorrected ? 1 : 0));\n            covarianceMatrix.setEntry(j, i, sum / (m - biasCorrected ? 1 : 0));\n        }\n    }\n    return covarianceMatrix;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"count must be <= 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"Count must be less than 64\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Count must be greater than 0\");\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        final long bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    final long bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) \n    {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n    if (count == 0) \n    {\n        return 0;\n    }\n    if (bitsCachedSize < count) \n    {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) \n    {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } \n    else \n    {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"count must be <= 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, data.length, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, virtualSize, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, virtualSize, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, data.length, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, virtualSize, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, virtualSize, n);\n    OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n    while (iter.hasNext()) \n    {\n        iter.advance();\n        OpenIntToFieldHashMap<T>.Iterator iter2 = v.entries.iterator();\n        while (iter2.hasNext()) \n        {\n            iter2.advance();\n            res.setEntry(iter.key(), iter2.key(), iter.value().multiply(iter2.value()));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, virtualSize, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int n = v.getDimension();\n    FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, data.length, n);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < n; j++) {\n            res.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return res;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  while (target != null) {\n    if (target.isLabel()) {\n      if (label.equals(target.getString())) {\n        return true;\n      }\n    }\n    target = target.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target == null) {\n    return false;\n  }\n  switch (target.getType()) {\n    case Token.BLOCK:\n    case Token.FOR:\n    case Token.DO:\n    case Token.WHILE:\n    case Token.SWITCH:\n      return label.equals(target.getFirstChild().getString());\n    case Token.LABEL:\n      return label.equals(target.getLastChild().getString());\n    default:\n      return false;\n  }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  return parent.isLabel() && label.equals(parent.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    if (parent.isLabel() && parent.getFirstChild().getString().equals(label)) {\n        return true;\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent.isLabel()) {\n    return label.equals(parent.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target == null) {\n    return false;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return matchLabel(target.getParent(), label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    if (parent == null) {\n        return false;\n    }\n    if (parent.isLabel()) {\n        return label.equals(parent.getString());\n    }\n    return matchLabel(parent, label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYItemEntity entity = getEntity(series, item);\n    if (entity == null) \n    {\n        return null;\n    }\n    return entity.getURL();\n}",
      "public String getURL(int series, int item)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYItemEntity entity = getEntity(series, item);\n    if (entity != null) {\n        return entity.getURL();\n    }\n    else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYItemEntity entity = getItemEntity(series, item);\n    if (entity == null) {\n        return null;\n    }\n    XYDataset dataset = getDataset();\n    return entity.getURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYItemEntity entity = getItemEntity(series, item);\n    if (entity != null) {\n        return entity.getURL();\n    }\n    else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    // get the URL generator for the series\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator != null) \n    {\n        // generate the URL\n        return generator.generateURL(getDataset(), series, item);\n    }\n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int offset = _calcOffset(calcHash(str));\n    final int[] hashArea = _hashArea;\n    int len = hashArea[offset+3];\n\n    if (len == 1) {\n        if (str.equals(_names[offset >> 2])) {\n            return offset;\n        }\n    } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n        return -1;\n    }\n    // secondary?\n    int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n    len = hashArea[offset2+3];\n\n    if (len == 1) {\n        if (str.equals(_names[offset2 >> 2])) {\n            return offset2;\n        }\n    } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n        return -1;\n    }\n    return _findSecondary(offset, str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    int result = 0;\n    while (i < len) \n    {\n        char c = str.charAt(i++);\n        if (c < '0' || c > '9') \n        {\n            return -1;\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    while (i < len) \n    {\n        char c = str.charAt(i++);\n        if (c == ' ') \n        {\n            continue;\n        }\n        if (c == '[') \n        {\n            return i;\n        }\n        if (c == ']') \n        {\n            return -1;\n        }\n        return -1;\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int offset = 0;\n    int len = str.length();\n    int i = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c == ' ') {\n            offset++;\n        } else if (c == '[') {\n            break;\n        } else {\n            return -1;\n        }\n        i++;\n    }\n    return offset;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len > 10) {\n        return Integer.parseInt(str);\n    }\n    int i = 0;\n    int num = 0;\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        num = (num * 10) + (c - '0');\n    }\n    return num;\n}\n\n/*\n    /**********************************************************\n    /* Public API, accessing symbols\n    /**********************************************************",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len > 10) {\n        return Integer.parseInt(str);\n    }\n    int offset = 0;\n    char c = str.charAt(offset++);\n    if (c == '-') {\n        if (len == 1 || len > 11) {\n            return Integer.parseInt(str);\n        }\n        c = str.charAt(offset++);\n    } else {\n        if (len > 10) {\n            return Integer.parseInt(str);\n        }\n    }\n    if (c > '9' || c < '0') {\n        return Integer.parseInt(str);\n    }\n    int num = c - '0';\n    if (offset < len) {\n        c = str.charAt(offset++);\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        num = (num * 10) + (c - '0');\n        if (offset < len) {\n            c = str.charAt(offset++);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            // Let's just loop if we have more than 3 digits:\n            if (offset < len) {\n                do {\n                    c = str.charAt(offset++);\n                    if (c > '9' || c < '0') {\n                        return Integer.parseInt(str);\n                    }\n                    num = (num * 10) + (c - '0');\n                } while (offset < len);\n            }\n        }\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c == ' ') {\n            continue;\n        }\n        if (c == '[') {\n            break;\n        }\n        return -1;\n    }\n    if (i >= len) {\n        return -1;\n    }\n    int index = 0;\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c == ' ') {\n            continue;\n        }\n        if (c == ']') {\n            break;\n        }\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        index = (index * 10) + (c - '0');\n    }\n    if (i >= len) {\n        return -1;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int offset = 0;\n    int len = str.length();\n    if (len > 9) {\n        return Integer.parseInt(str);\n    }\n    char c = str.charAt(0);\n    if (c == '-') {\n        if (len == 1 || len > 10) {\n            return Integer.parseInt(str);\n        }\n        c = str.charAt(offset++);\n    } else {\n        if (len > 9) {\n            return Integer.parseInt(str);\n        }\n    }\n    if (c > '9' || c < '0') {\n        return Integer.parseInt(str);\n    }\n    int num = c - '0';\n    if (offset < len) {\n        c = str.charAt(offset++);\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        num = (num * 10) + (c - '0');\n        if (offset < len) {\n            c = str.charAt(offset++);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            // Let's just loop if we have more than 3 digits:\n            if (offset < len) {\n                do {\n                    c = str.charAt(offset++);\n                    if (c > '9' || c < '0') {\n                        return Integer.parseInt(str);\n                    }\n                    num = (num * 10) + (c - '0');\n                } while (offset < len);\n            }\n        }\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c == ' ') {\n            continue;\n        }\n        if (c == '[') {\n            return i;\n        }\n        return -1;\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len > 10) {\n        return Integer.parseInt(str);\n    }\n    char c = str.charAt(0);\n    int num = c - '0';\n    if (len > 1) {\n        c = str.charAt(1);\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        num = (num * 10) + (c - '0');\n        if (len > 2) {\n            c = str.charAt(2);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            if (len > 3) {\n                c = str.charAt(3);\n                if (c > '9' || c < '0') {\n                    return Integer.parseInt(str);\n                }\n                num = (num * 10) + (c - '0');\n                if (len > 4) {\n                    c = str.charAt(4);\n                    if (c > '9' || c < '0') {\n                        return Integer.parseInt(str);\n                    }\n                    num = (num * 10) + (c - '0');\n                    if (len > 5) {\n                        c = str.charAt(5);\n                        if (c > '9' || c < '0') {\n                            return Integer.parseInt(str);\n                        }\n                        num = (num * 10) + (c - '0');\n                        if (len > 6) {\n                            c = str.charAt(6);\n                            if (c > '9' || c < '0') {\n                                return Integer.parseInt(str);\n                            }\n                            num = (num * 10) + (c - '0');\n                            if (len > 7) {\n                                c = str.charAt(7);\n}\n}\n}\n}\n}\n}\n}\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        final Object[] out = new Object[k];\n\n        for (int i = 0; i < k; i++) {\n            out[i] = c.toArray()[nextPermutation(c.size(), k)[i]];\n        }\n\n        return out;\n\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                k);\n    }\n\n    final Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[i];\n    }\n\n    return out;\n\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        final Object[] out = new Object[k];\n\n        for (int i = 0; i < k; i++) {\n            out[i] = c.toArray()[nextPermutation(c.size(), k)];\n        }\n\n        return out;\n\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        int[] index = new int[c.size()];\n        for (int i = 0; i < index.length; i++) {\n            index[i] = i;\n        }\n        MathArrays.shuffle(index, getRandomGenerator());\n\n        // Return a new array containing the first \"k\" entries of \"index\".\n        Object[] out = new Object[k];\n        for (int i = 0; i < k; i++) {\n            out[i] = c.toArray()[index[i]];\n        }\n        return out;\n\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        int[] index = new int[c.size()];\n        for (int i = 0; i < c.size(); i++) {\n            index[i] = i;\n        }\n        MathArrays.shuffle(index, getRandomGenerator());\n\n        // Return a new array containing the first \"k\" entries of \"index\".\n        return MathArrays.copyOf(index, k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        Object[] index = c.toArray();\n        MathArrays.shuffle(index, getRandomGenerator());\n\n        // Return a new array containing the first \"k\" entries of \"index\".\n        return MathArrays.copyOf(index, k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                                   k);\n        }\n\n        final Object[] out = new Object[k];\n\n        for (int i = 0; i < k; i++) {\n            out[i] = c.toArray()[nextPermutation(c.size(), k)];\n        }\n\n        return out;\n\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[i];\n    }\n\n    return out;\n\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = new int[c.size()];\n    for (int i = 0; i < index.length; i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                k);\n    }\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(nextPermutation(c.size(), k), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n                           new Node(Token.GETPROP,\n                                    new Node(Token.THIS, srcref),\n                                    new Node(Token.STRING, methodName, srcref)),\n                           argumentNode);\n  callNode.setLineno(srcref.getLineno());\n  callNode.setCharno(srcref.getCharno());\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Token.CALL, new Node(Token.GETPROP,\n            new Node(Token.THIS, srcref),\n            new Node(Token.STRING, methodName, srcref)));\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n                           new Node(Token.GETPROP,\n                                    new Node(Token.THIS, srcref),\n                                    new Node(Token.STRING, methodName, srcref)),\n                           argumentNode);\n  callNode.setLength(argumentNode.getLength() + 2);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), methodName, srcref);\n    Node callNode = new Node(Token.CALL, methodNameNode);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, srcref),\n          new Node(Token.STRING, methodName, srcref)),\n      argumentNode);\n  callNode.setLength(argumentNode.getLength() + 2);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), methodName, srcref);\n    Node callNode = new Node(Token.CALL, methodNameNode);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node methodNameNode = NodeUtil.newQualifiedNameNode(\n      compiler.getCodingConvention(), methodName, srcref);\n  Node callNode = new Node(Token.CALL, methodNameNode);\n  callNode.addChildToBack(argumentNode);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), methodName, srcref);\n    Node callNode = new Node(Token.CALL, methodNameNode);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNameNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), methodName, srcref);\n    Node callNode = new Node(Token.CALL, methodNameNode);\n    callNode.setLineno(srcref.getLineno());\n    callNode.setCharno(srcref.getCharno());\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, new Node(Token.GETPROP,\n      new Node(Token.THIS, srcref),\n      new Node(Token.STRING, methodName, srcref), srcref));\n  callNode.addChildToBack(argumentNode);\n  return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create comparators for increasing and decreasing orders.\n    final Comparator<Pair<Double, Integer>> comp\n        = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs of values and their indices.\n    final List<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list.\n    final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs (value, index)\n    final List<Pair<Double, Integer>> list = new ArrayList<>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list\n    final Comparator<Pair<Double, Integer>> comp\n        = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    // Sort.\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    final Pair<Double, Integer>[] list = new Pair[len];\n    for (int i = 0; i < len; i++) {\n        list[i] = new Pair<Double, Integer>(doubles[i], indices[i]);\n    }\n    final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    // Sort.\n    final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int size = doubles.length;\n    final int[] indices = new int[size];\n    for (int i = 0; i < size; i++) {\n        indices[i] = i;\n    }\n    final Pair<Double, Integer>[] list = new Pair[size];\n    for (int i = 0; i < size; i++) {\n        list[i] = new Pair<>(doubles[i], indices[i]);\n    }\n    MathArrays.sortInPlace(list, OrderDirection.DECREASING);\n    for (int i = 0; i < size; i++) {\n        indices[i] = list[i].getValue();\n    }\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformingSet(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        double total = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            total += value;\n            minimum = Math.min(minimum, total);\n            maximum = Math.max(maximum, total);\n        }\n        if (result == null) {\n            result = new Range(minimum, maximum);\n        }\n        else {\n            result = result.add(minimum, maximum);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null)\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    for (int series = 0; series < seriesCount; series++)\n    {\n        int itemCount = dataset.getItemCount(series);\n        double total = 0.0;\n        for (int item = 0; item < itemCount; item++)\n        {\n            total += dataset.getValue(series, item).doubleValue();\n            lvalue = total;\n            uvalue = total;\n            minimum = Math.min(minimum, lvalue);\n            maximum = Math.max(maximum, uvalue);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double total = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            total += dataset.getValue(series, item).doubleValue();\n            lvalue = total;\n            uvalue = total;\n            minimum = Math.min(minimum, lvalue);\n            maximum = Math.max(maximum, uvalue);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double total = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            total += value;\n            lvalue = total;\n            uvalue = total;\n            minimum = Math.min(minimum, lvalue);\n            maximum = Math.max(maximum, uvalue);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double current = 0.0;\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) {\n            current += dataset.getValue(series, item).doubleValue();\n            minimum = Math.min(minimum, current);\n            maximum = Math.max(maximum, current);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            runningTotal += dataset.getValue(series, item).doubleValue();\n            lvalue = runningTotal;\n            uvalue = runningTotal;\n            minimum = Math.min(minimum, lvalue);\n            maximum = Math.max(maximum, uvalue);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    // if the dataset implements DomainInfo, life is easy\n    if (dataset instanceof DomainInfo) {\n        DomainInfo info = (DomainInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            double total = 0.0;\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getValue(series, item);\n                if (!Double.isNaN(value)) {\n                    total += value;\n                }\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n        result = new Range(minimum, maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item).doubleValue();\n            runningTotal += value;\n            if (result == null) {\n                result = new Range(value, value);\n            }\n            else {\n                result.add(value, value);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // find the minimum and maximum values in the dataset\n    Range result = DatasetUtilities.findRangeBounds(dataset);\n    // if there are no data items, return a null range\n    if (result == null) {\n        return null;\n    }\n    // calculate the running total for each series\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            runningTotal += dataset.getValue(series, item);\n            result.add(runningTotal);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    // if the dataset implements DomainInfo, life is easy\n    if (dataset instanceof DomainInfo) {\n        DomainInfo info = (DomainInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        int totalMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (totalMillis > 23 * DateTimeConstants.MILLIS_PER_HOUR + 59 * DateTimeConstants.MILLIS_PER_MINUTE ||\n            totalMillis < -23 * DateTimeConstants.MILLIS_PER_HOUR - 59 * DateTimeConstants.MILLIS_PER_MINUTE) {\n            throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        return new SimpleTimeZone(totalMillis, \"SimpleTimeZone\" + totalMillis);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Invalid offset hour of day: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Invalid offset minute of day: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0) {\n        if (minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Invalid offset hour and minute of day: \" + hoursOffset + \":\" + minutesOffset);\n        }\n    } else {\n        if (minutesOffset > 0) {\n            throw new IllegalArgumentException(\"Invalid offset hour and minute of day: \" + hoursOffset + \":\" + minutesOffset);\n        }\n    }\n    long totalMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (totalMillis > 23 * DateTimeConstants.MILLIS_PER_HOUR + 59 * DateTimeConstants.MILLIS_PER_MINUTE) {\n        throw new IllegalArgumentException(\"Invalid offset hour and minute of day: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    return new FixedDateTimeZone(\"\", \"UTC\" + (hoursOffset >= 0 ? \"+\" : \"\") + (hoursOffset * 100 + minutesOffset) + \":00\", totalMillis, totalMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Invalid hours: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Invalid minutes: \" + minutesOffset);\n        }\n        if (hoursOffset >= 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes must be positive when hours is positive: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        long totalMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (totalMillis > 23 * DateTimeConstants.MILLIS_PER_HOUR + 59 * DateTimeConstants.MILLIS_PER_MINUTE) {\n            throw new IllegalArgumentException(\"Total offset is too large: \" + totalMillis);\n        }\n        return new SimpleTimeZone(totalMillis, \"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + Math.abs(hoursOffset) + \":\" + (minutesOffset >= 0 ? \"+\" : \"\") + Math.abs(minutesOffset));\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Invalid hours: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Invalid minutes: \" + minutesOffset);\n        }\n        if (hoursOffset < 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes must be positive when hours are negative\");\n        }\n        if (hoursOffset != 0 && minutesOffset == 0) {\n            throw new IllegalArgumentException(\"Minutes must be non-zero when hours are non-zero\");\n        }\n        int totalMillis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n        if (totalMillis < -24 * 60 * 60 * 1000 || totalMillis > 24 * 60 * 60 * 1000 - 1) {\n            throw new IllegalArgumentException(\"Total offset is too large: \" + totalMillis);\n        }\n        return new SimpleDateTimeZone(totalMillis, \"UTC\" + (totalMillis >= 0 ? \"+\" : \"-\") + hoursOffset + \":\" + minutesOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes must be positive when hours is positive: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        long totalMillis = (hoursOffset * 60L + minutesOffset) * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (totalMillis < -1439 || totalMillis > 1439) {\n            throw new IllegalArgumentException(\"Total offset is too large: \" + totalMillis);\n        }\n        return forOffsetMillis(totalMillis);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n        }\n        if (hoursOffset >= 0) {\n            if (minutesOffset < 0) {\n                throw new IllegalArgumentException(\"Minutes must be positive when hours is positive\");\n            }\n            if (minutesOffset >= 60) {\n                throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n            }\n        } else {\n            if (minutesOffset > 0) {\n                throw new IllegalArgumentException(\"Minutes must be negative when hours is negative\");\n            }\n            if (minutesOffset <= -60) {\n                throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n            }\n        }\n        int totalMillis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n        if (totalMillis >= 24 * 60 * 60 * 1000 || totalMillis <= -24 * 60 * 60 * 1000) {\n            throw new IllegalArgumentException(\"Total offset is too large: \" + totalMillis);\n        }\n        return forOffsetMillis(totalMillis);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Invalid offset: hours must be positive, minutes must be non-negative\");\n        }\n        long offsetMillis = (hoursOffset * DateTimeConstants.MILLIS_PER_HOUR) + (minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n        if (offsetMillis > 23 * DateTimeConstants.MILLIS_PER_HOUR + 59 * DateTimeConstants.MILLIS_PER_MINUTE ||\n                offsetMillis < -23 * DateTimeConstants.MILLIS_PER_HOUR - 59 * DateTimeConstants.MILLIS_PER_MINUTE) {\n            throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        return new SimpleTimeZone(offsetMillis, \"SimpleTimeZone\" + (offsetMillis >= 0 ? \"+\" : \"-\") + hoursOffset + \":\" + minutesOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes must be positive when hours is positive: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        if (hoursOffset == 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes must be positive when hours is zero: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        if (hoursOffset < 0 && minutesOffset > 0) {\n            throw new IllegalArgumentException(\"Minutes must be negative when hours is negative: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        if (hoursOffset == 0 && minutesOffset > 0) {\n            throw new IllegalArgumentException(\"Minutes must be negative when hours is zero: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        int totalMillis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n        if (totalMillis < -23 * 60 * 60 * 1000 || totalMillis > 23 * 60 * 60 * 1000) {\n            throw new IllegalArgumentException(\"Total offset is too large: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        return forOffsetMillis(totalMillis);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours is positive: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be negative when hours is negative: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    int totalMillis = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (totalMillis < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || totalMillis > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Total offset is too large: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    return new SimpleDateTimeZone(totalMillis, \"UTC\" + hoursOffset + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Invalid hours: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Invalid minutes: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        long totalMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        if (totalMillis < -1439 || totalMillis > 1439) {\n            throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        return forOffsetMillis(totalMillis);\n    }"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder in = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Unbalanced, queue is empty\");\n        }\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n        in.append(c);\n    }\n    return in.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder in = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Unbalanced '\" + open + \"' in: \" + queue);\n        }\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n        in.append(c);\n    }\n    return in.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Unbalanced '\" + open + \"' in: \" + queue);\n        }\n        char c = consume();\n        sb.append(c);\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder in = new StringBuilder();\n    int depth = 0;\n    while (hasMore)\n    {\n        char c = next();\n        if (c == open)\n            depth++;\n        else if (c == close)\n            depth--;\n        if (depth > 0)\n            in.append(c);\n        else if (depth == 0)\n            break;\n    }\n    return in.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            break;\n        }\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth < 0) \n            {\n                break;\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Unbalanced, queue is empty\");\n        }\n        char c = consume();\n        sb.append(c);\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (hasMore) {\n        char c = next();\n        sb.append(c);\n        if (c == open)\n            depth++;\n        else if (c == close)\n            depth--;\n        if (depth == 0)\n            break;\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder in = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            Validate.fail(\"Unbalanced '\" + open + \"' in: \" + queue);\n        }\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n        in.append(c);\n    }\n    return in.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (true) \n    {\n        if (isEmpty()) \n        {\n            break;\n        }\n        char c = consume();\n        sb.append(c);\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth < 0) \n            {\n                break;\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    // used by the parsers, so only light on the args\n    StringBuilder in = new StringBuilder();\n    char lastChar = 0;\n    char lastLastChar = 0;\n    boolean inSingleQuote = false;\n    boolean inDoubleQuote = false;\n    while (!isEmpty()) {\n        char c = lastChar;\n        lastLastChar = lastChar;\n        lastChar = next();\n        if (inSingleQuote) {\n            if (c == '\\'') inSingleQuote = false;\n        } else if (inDoubleQuote) {\n            if (c == '\"') inDoubleQuote = false;\n        } else if (c == open) {\n            in.append(c);\n        } else if (c == close) {\n            if (lastLastChar == open) {\n                in.append(c);\n            } else {\n                break;\n            }\n        } else if (c == '\\\\') {\n            if (lastChar == '\\n' || lastChar == '\\r') {\n                in.append(c);\n            } else {\n                in.append(c).append(next());\n            }\n        } else if (c == '\\'' && lastChar != '\\\\') {\n            inSingleQuote = true;\n        } else if (c == '\"' && lastChar != '\\\\') {\n            inDoubleQuote = true;\n        } else {\n            in.append(c);\n        }\n    }\n    return in.toString();\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix XtX = X.transpose().multiply(X);\n        final QRDecomposition qr = new QRDecomposition(XtX);\n        final RealMatrix R = qr.getR();\n        final int p = R.getColumnDimension();\n        final RealMatrix Rp = R.getSubMatrix(0, p - 1, 0, p - 1);\n        return Rp.transpose().multiply(Rp);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate XtX\n        final RealMatrix XtX = X.transpose().multiply(X);\n\n        // Perform QR decomposition\n        final QRDecomposition qr = new QRDecomposition(XtX);\n\n        // Get R matrix\n        final RealMatrix R = qr.getR();\n\n        // Get p\n        final int p = R.getColumnDimension();\n\n        // Create matrix to store the top p rows of R\n        final RealMatrix Rp = MatrixUtils.createRealMatrix(p, p);\n\n        // Copy the top p rows of R to Rp\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                Rp.setEntry(i, j, R.getEntry(i, j));\n            }\n        }\n\n        // Calculate (RtR)^-1\n        final RealMatrix RtRInv = new LUDecomposition(Rp).getSolver().getInverse();\n\n        // Calculate (XtX)^-1\n        final RealMatrix XtXInv = new LUDecomposition(XtX).getSolver().getInverse();\n\n        // Calculate beta variance-covariance matrix\n        final RealMatrix betaVariance = XtXInv.multiply(RtRInv);\n\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate (X'X)^-1\n        final RealMatrix xTx = calculateXTX();\n        final QRDecomposition qr = new QRDecomposition(xTx);\n        final RealMatrix r = qr.getR();\n        final int p = r.getColumnDimension();\n        final RealMatrix betaVariance = r.getSubMatrix(0, p - 1, 0, p - 1);\n        return betaVariance.scalarMultiply(1.0 / (n - k));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix X = getX();\n        final RealMatrix XTransposeX = X.transpose().multiply(X);\n        final QRDecomposition qr = new QRDecomposition(XTransposeX);\n        final RealMatrix R = qr.getR();\n        final int p = getBeta().getDimension();\n        final RealMatrix RTransposeR = R.getSubMatrix(0, p - 1, 0, p - 1);\n        return RTransposeR.inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate X'X\n        final RealMatrix xTransposeX = calculateXTransposeX();\n        // Perform QR decomposition on X'X\n        final QRDecomposition qr = new QRDecomposition(xTransposeX);\n        // Calculate R'R\n        final RealMatrix rTransposeR = qr.getR().transpose().multiply(qr.getR());\n        // Calculate (R'R)^-1\n        final RealMatrix rTransposeRInverse = rTransposeR.inverse();\n        // Calculate (X'X)^-1\n        final RealMatrix xTransposeXInverse = xTransposeX.inverse();\n        // Calculate (X'X)^-1 * R'R\n        final RealMatrix betaVariance = rTransposeRInverse.multiply(xTransposeXInverse);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = n - k;\n        final RealMatrix XtX = getXtX();\n        final RealMatrix XtXp = XtX.getSubMatrix(0, p - 1, 0, p - 1);\n        final RealMatrix R = qr.getR();\n        final RealMatrix Rp = R.getSubMatrix(0, p - 1, 0, p - 1);\n        return Rp.multiply(XtXp).multiply(Rp.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate (X'X)^-1\n        final RealMatrix xTransposeX = calculateXTransposeX();\n        // Calculate R\n        final RealMatrix r = qr.getR();\n        // Calculate R'R\n        final RealMatrix rTransposeR = r.transpose().multiply(r);\n        // Calculate (R'R)^-1\n        final RealMatrix rTransposeRInverse = rTransposeR.inverse();\n        // Calculate (X'X)^-1 * R'R\n        return xTransposeX.multiply(rTransposeRInverse);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create augmented identity matrix\n        final int p = qr.getR().getColumnDimension();\n        final int n = qr.getR().getRowDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return qr.getR().multiply(augI).multiply(qr.getR().transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getN();\n        final int n = getN();\n        final int m = getM();\n        final double[][] beta = new double[p][p];\n        final double[][] hat = calculateHat().getData();\n        final double[][] r = qr.getR().getData();\n\n        // Compute the variance-covariance matrix\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                beta[i][j] = 0;\n                for (int k = 0; k < n; k++) {\n                    beta[i][j] += hat[i][k] * hat[j][k] * r[k][k];\n                }\n            }\n        }\n\n        return new Array2DRowRealMatrix(beta);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create augmented identity matrix\n        RealMatrix Q = qr.getQ();\n        final int p = qr.getR().getColumnDimension();\n        final int n = Q.getColumnDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return Q.multiply(augI).multiply(Q.transpose());\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset < 0) \n    {\n        return \"GMT-\" + (hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n    }\n    else \n    {\n        return \"GMT+\" + (hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    String hourStr = Integer.toString(hours);\n    String minStr = Integer.toString(minutes);\n    if (hours < 10) {\n        hourStr = \"0\" + hourStr;\n    }\n    if (minutes < 10) {\n        minStr = \"0\" + minStr;\n    }\n    StringBuffer buf = new StringBuffer(hourStr);\n    buf.append(':');\n    buf.append(minStr);\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return (offset >= 0 ? \"+\" : \"-\") +\n            (hours < 10 ? \"0\" : \"\") + hours +\n            (minutes < 10 ? \":0\" : \":\") + minutes;\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset < 0) {\n        return \"-\" + String.format(\"%02d:%02d\", hours, minutes);\n    } else {\n        return \"+\" + String.format(\"%02d:%02d\", hours, minutes);\n    }\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return (offset < 0 ? \"-\" : \"+\") +\n           (hours < 10 ? \"0\" : \"\") + hours +\n           (minutes < 10 ? \":0\" : \":\") + minutes;\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) \n    {\n        buf.append('-');\n    }\n    else \n    {\n        buf.append('+');\n    }\n    if (hours < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(hours);\n    if (minutes != 0) \n    {\n        buf.append(':');\n        if (minutes < 10) \n        {\n            buf.append('0');\n        }\n        buf.append(minutes);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    String sign = (offset >= 0 ? \"+\" : \"-\");\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return (offset < 0 ? \"-\" : \"+\") +\n            (hours < 10 ? \"0\" : \"\") + hours +\n            (minutes < 10 ? \":0\" : \":\") + minutes;\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset < 0) {\n        return \"-\" + String.format(\"%02d\", hours) + \":\" + String.format(\"%02d\", minutes);\n    } else {\n        return \"+\" + String.format(\"%02d\", hours) + \":\" + String.format(\"%02d\", minutes);\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset < 0) {\n        return \"-\" + (hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n    } else {\n        return \"+\" + (hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n    }\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.rowKeys.indexOf(key);\n    if (result < 0) {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (key instanceof Comparable) {\n        result = this.store.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (key instanceof Comparable) {\n        result = this.keys.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (key instanceof Comparable) {\n        result = this.store.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (key instanceof Comparable) {\n        result = this.store.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    if (this.rowKeys != null) {\n        return this.rowKeys.indexOf(key);\n    }\n    else if (this.columnKeys != null) {\n        return this.columnKeys.indexOf(key);\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (this.rowKeys != null) {\n        result = this.rowKeys.indexOf(key);\n    }\n    if (result == -1 && this.columnKeys != null) {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (this.store.containsKey(key)) {\n        result = this.store.get(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    if (this.rowKeys != null) {\n        result = this.rowKeys.indexOf(key);\n    }\n    if (result == -1 && this.columnKeys != null) {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.rowKeys.indexOf(key);\n    if (result == -1) {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  LinkedFlowScope current = this;\n  while (current != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : current.myFlowSlots.entrySet()) {\n      if (!result.containsKey(entry.getKey())) {\n        result.put(entry.getKey(), entry.getValue());\n      }\n    }\n    current = current.parent;\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : myFlowSlots.entrySet()) {\n        slots.put(entry.getKey(), entry.getValue());\n    }\n    for (Map.Entry<String, StaticSlot<JSType>> entry : otherFlowSlots.entrySet()) {\n        slots.put(entry.getKey(), entry.getValue());\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n    for (StaticSlot<JSType> slot : getSlots()) {\n      result.put(slot.getName(), slot);\n    }\n    return result;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  for (LinkedFlowScope scope = this; scope != null; scope = scope.parent) {\n    for (StaticSlot<JSType> slot : scope.myFlowSlots.values()) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new LinkedHashMap<>();\n  for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n    if (slot.getType() != null) {\n      result.put(slot.getName(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (StaticSlot<JSType> slot : getDeclaredVariables()) {\n      slots.put(slot.getName(), slot);\n    }\n    for (LinkedFlowScope parent = this; parent != null; parent = parent.parent) {\n      for (StaticSlot<JSType> slot : parent.myFlowSlots.values()) {\n        if (!slots.containsKey(slot.getName())) {\n          slots.put(slot.getName(), slot);\n        }\n      }\n    }\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        result.put(slot.getName(), slot);\n    }\n    return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new LinkedHashMap<>();\n  for (MapBasedScope scope : this.scopes) {\n    for (StaticSlot<JSType> slot : scope.getDeclaredSlotMap().values()) {\n      result.put(slot.getName(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (LinkedFlowScope scope = this; scope != null; scope = scope.parent) {\n    for (StaticSlot<JSType> slot : scope.myFlowSlots.values()) {\n      result.put(slot.getName(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = Maps.newHashMap();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : myFlowSlots.entrySet()) {\n    result.put(entry.getKey(), entry.getValue());\n  }\n  for (Map.Entry<String, StaticSlot<JSType>> entry : otherFlowSlots.entrySet()) {\n    result.put(entry.getKey(), entry.getValue());\n  }\n  return result;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        RealMatrix m = createMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }"
    ],
    [
      "public static double atanh(double a)  {\n    // atanh(z) = 1/2 * ln((1+z)/(1-z))\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (a == 0.0) {\n            return 0.0;\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }",
      "public static double atanh(double a)  {\n    // atanh(z) = (log((1+z)/(1-z)))/2\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    //inverse hyperbolic tangent is also known as area under the hyperbolic tangent curve from a to 1\n    //area under the curve is given by (1-x)/(1+x)\n    return (1-a)/(1+a);\n}",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (a == 0.0) {\n            return a;\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (a == 0.0) {\n            return 0.0;\n        }\n        if (Double.doubleToLongBits(a) == 0x8000000000000000L) {\n            return Double.NaN;\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }",
      "public static double atanh(double a)  {\n    // --- No need to check a, as FastMath.atanh does it ---\n    return FastMath.atanh(a);\n}",
      "public static double atanh(double a)  {\n        if (a < -1.0 || a > 1.0) {\n            throw new OutOfRangeException(a, -1.0, 1.0);\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                               normalizedSum);\n    }\n    double sum = 0;\n    final int length = values.length;\n    final double[] result = new double[length];\n    for (int i = 0; i < length; i++) {\n        final double value = values[i];\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    final double scale = normalizedSum / sum;\n    for (int i = 0; i < length; i++) {\n        final double value = values[i];\n        if (!Double.isNaN(value)) {\n            result[i] = value * scale;\n        } else {\n            result[i] = value;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isNaN(value)) {\n            continue;\n        }\n        sum += value;\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM, sum);\n    }\n\n    final double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        final double value = values[i];\n        if (Double.isNaN(value)) {\n            result[i] = value;\n        } else {\n            result[i] = value / sum * normalizedSum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZATION_TARGET_NAN_OR_INF,\n                                                   normalizedSum);\n        }\n\n        double sum = 0;\n        int n = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n                n++;\n            }\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                              sum);\n        }\n\n        double[] result = new double[values.length];\n        sum = normalizedSum / sum;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                result[i] = values[i] * sum;\n            } else {\n                result[i] = values[i];\n            }\n        }\n\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            n++;\n        }\n    }\n    if (n == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          normalizedSum);\n    }\n    if (Double.isInfinite(sum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM,\n                                               normalizedSum);\n    }\n    double[] result = new double[values.length];\n    System.arraycopy(values, 0, result, 0, values.length);\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                                   normalizedSum);\n        }\n        double sum = 0;\n        int n = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n                n++;\n            }\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                              sum);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            n++;\n        }\n    }\n\n    if (n == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZATION_TARGET_NAN_OR_INF,\n                                               normalizedSum);\n    }\n\n    double[] result = new double[values.length];\n    System.arraycopy(values, 0, result, 0, values.length);\n\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                               normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_ARRAY_WITH_SUM,\n                                          sum);\n    }\n    final double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = values[i];\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            n++;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZATION_TARGET_NOT_REAL,\n                                               normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    double[] result = new double[values.length];\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            result[n++] = values[i];\n        }\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_CANNOT_BE_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_ARRAY_WITH_ZERO_SUM);\n    }\n\n    for (int i = 0; i < n; i++) {\n        result[i] = result[i] / sum * normalizedSum;\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NOT_REAL,\n                normalizedSum);\n    }\n    double sum = 0;\n    final int length = values.length;\n    final double[] result = new double[length];\n    for (int i = 0; i < length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            sum += values[i];\n            result[i] = values[i] / sum * normalizedSum;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM);\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    MutableDateTimeParserBucket bucket = new MutableDateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    MutableDateTimeParserBucket bucket = new MutableDateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    MutableDateTimeParserBucket bucket = new MutableDateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector beta = XTOIXInverse.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXIY = XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return XTOIXIY.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXIY = XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return XTOIXIY.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXIY = XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return XTOIXIY.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXInverseXTOI = XTOIXInverse.multiply(getX().transpose().multiply(OI));\n        return XTOIXInverseXTOI.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXInverseXTOIX = XTOIXInverse.multiply(XTOIX);\n        RealMatrix XTOIXInverseXTOIXOI = XTOIXInverseXTOIX.multiply(OI);\n        RealMatrix XTOIXInverseXTOIXOIXTOIX = XTOIXInverseXTOIXOI.multiply(getX().transpose());\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOI = XTOIXInverseXTOIXOIXTOIX.multiply(OI);\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOIXTOIX = XTOIXInverseXTOIXOIXTOIXOI.multiply(getX().transpose());\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOIXTOIXOI = XTOIXInverseXTOIXOIXTOIXOIXTOIX.multiply(OI);\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOIXTOIXOIXTOIX = XTOIXInverseXTOIXOIXTOIXOIXTOIXOI.multiply(getX().transpose());\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOIXTOIXOIXTOIXOI = XTOIXInverseXTOIXOIXTOIXOIXTOIXOIXTOIX.multiply(OI);\n        RealMatrix XTOIXInverseXTOIXOIXTOIXOIXTOIXOIXTOIXOIXTOIX = XTOIXInverseXTOIXOIXTOIXOIXTOIXOIXTOIXOI.multiply(getX().transpose());\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXIY = XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return XTOIXIY.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    // not using getElementsByAttribute(ID) as that returns a live list\n    if (id == null)\n        return null;\n\n    // first check self\n    if (id.equals(this.id()))\n        return this;\n\n    // then check children\n    for (int i = 0; i < this.childrenSize(); i++) {\n        Element child = this.child(i);\n        Elements elements = child.getElementsByAttribute(ID, id);\n        if (!elements.isEmpty())\n            return elements.get(0);\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n    if (id.equals(this.id()))\n        return this;\n    for (Element child : this.children()) {\n        Element found = child.getElementById(id);\n        if (found != null)\n            return found;\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    if (id.equals(this.id()))\n        return this;\n\n    Elements els = this.getAllElements();\n    for (Element el : els)\n    {\n        if (id.equals(el.id()))\n            return el;\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n        return null;\n\n    if (id.equals(this.id())) \n        return this;\n\n    for (Element child : this.children()) \n    {\n        Elements elements = child.getElementsByAttribute(\"id\", id);\n        if (!elements.isEmpty()) \n            return elements.first();\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    // first check if this element has the ID\n    if (id.equals(this.id()))\n        return this;\n\n    // then iterate through all children\n    for (Element child : this.children()) \n    {\n        Element found = child.getElementById(id);\n        if (found != null)\n            return found;\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n        if (id == null)\n            return null;\n\n        if (id.equals(this.id()))\n            return this;\n\n        for (Element child : this.children()) {\n            Elements elements = child.getElementsByAttribute(\"id\", id);\n            if (!elements.isEmpty())\n                return elements.first();\n        }\n\n        return null;\n    }",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    // first check key\n    Elements elements = this.getElementsByAttribute(\"id\", id);\n    if (elements.size() > 0)\n        return elements.get(0);\n\n    // then search children\n    for (Element child : this.children()) \n    {\n        Element byId = child.getElementById(id);\n        if (byId != null)\n            return byId;\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    // first check if this element has the ID\n    if (this.hasAttr(\"id\") && this.id().equals(id))\n        return this;\n\n    // otherwise, find it in the children\n    for (Element child : this.children()) {\n        Elements elements = child.getElementsByAttribute(\"id\", id);\n        if (!elements.isEmpty())\n            return elements.first();\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n        return null;\n    else if (id.equals(this.id()))\n        return this;\n    else\n    {\n        Elements els = this.getAllElements();\n        for (Element el : els) \n        {\n            if (id.equals(el.id()))\n                return el;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    // handle the case where this element has the ID\n    if (id.equals(id()))\n        return this;\n\n    // handle the case where the ID is not in this element\n    if (!hasChildNodes())\n        return null;\n\n    // recursively search children\n    for (int i = 0; i < childNodeSize(); i++)\n    {\n        Node child = childNode(i);\n        if (child instanceof Element)\n        {\n            Element el = (Element) child;\n            Element found = el.getElementById(id);\n            if (found != null)\n                return found;\n        }\n    }\n\n    return null;\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern);\n    for (int i = customPatterns.size() - 1; i >= 0; i--) \n    {\n        buf.insert(customPatterns.get(i).indexOf(START_FE), customPatterns.get(i));\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    int lastPos = 0;\n    int currPos = 0;\n    for (final String customPattern : customPatterns) \n    {\n        buf.append(pattern, lastPos, currPos);\n        buf.append(customPattern);\n        lastPos = currPos;\n    }\n    buf.append(pattern, lastPos, pattern.length());\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder buf = new StringBuilder(pattern);\n    for (final String customPattern : customPatterns) {\n        final int start = buf.indexOf(customPattern);\n        if (start == -1) {\n            throw new IllegalArgumentException(\"Unable to find pattern: \" + customPattern);\n        }\n        final int end = start + customPattern.length();\n        buf.replace(start, end, customPattern);\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    int lastPos = 0;\n    for (int i = 0; i < customPatterns.size(); ++i) \n    {\n        final String customPattern = customPatterns.get(i);\n        final int start = pattern.indexOf(customPattern, lastPos);\n        if (start >= 0) \n        {\n            buf.append(pattern.substring(lastPos, start));\n            buf.append(customPattern);\n            lastPos = start + customPattern.length();\n        }\n    }\n    buf.append(pattern.substring(lastPos));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern);\n    for (int i = 0; i < customPatterns.size(); i++) \n    {\n        final String customPattern = customPatterns.get(i);\n        final int start = buf.indexOf(CUSTOM_PATTERN_START, i);\n        if (start >= 0) \n        {\n            buf.replace(start, start + CUSTOM_PATTERN_START.length(), customPattern);\n            i += customPattern.length();\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length() * 2);\n    int lastPos = 0;\n    int start = 0;\n    int end = 0;\n    while (end < pattern.length()) {\n        end = pattern.indexOf(START_FE, start);\n        if (end >= 0) {\n            buf.append(pattern.substring(start, end));\n            start = end;\n            end = pattern.indexOf(END_FE, start);\n            if (end >= 0) {\n                final String customPattern = pattern.substring(start + 1, end);\n                final String format = customPatterns.get(customPattern);\n                buf.append(format);\n                start = end + 1;\n            }\n        }\n    }\n    if (start < pattern.length()) {\n        buf.append(pattern.substring(start));\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern);\n    int pos = 0;\n    for (final String customPattern : customPatterns) {\n        pos = buf.indexOf(customPattern, pos);\n        buf.insert(pos, \"{\");\n        buf.insert(pos + customPattern.length() + 1, \"}\");\n        pos += customPattern.length() + 2;\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder buf = new StringBuilder(pattern.length() * 2);\n    int pos = 0;\n    int patLen = pattern.length();\n    int customLen = customPatterns.size();\n    for (int i = 0; i < customLen; i++) {\n        buf.append(pattern, pos, startPos[i]);\n        buf.append(customPatterns.get(i));\n        pos = endPos[i];\n    }\n    buf.append(pattern, pos, patLen);\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length() + 256);\n    int pos = 0;\n    while (pos < pattern.length()) {\n        final int start = pos;\n        while (pos < pattern.length() && pattern.charAt(pos) != '{') {\n            pos++;\n        }\n        if (pos > start) {\n            buf.append(pattern.substring(start, pos));\n        }\n        if (pos < pattern.length()) {\n            pos++;\n            final int startFormat = pos;\n            while (pos < pattern.length() && pattern.charAt(pos) != '}') {\n                pos++;\n            }\n            if (pos > startFormat) {\n                buf.append('\\'');\n                buf.append(pattern.substring(startFormat, pos));\n                buf.append('\\'');\n            }\n        }\n    }\n    if (customPatterns != null) {\n        for (final String customPattern : customPatterns) {\n            buf.append(customPattern);\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern);\n    int insertPos = buf.indexOf(FORMAT_INSERT);\n    for (int i = 0; i < customPatterns.size(); i++) \n    {\n        final String customPattern = customPatterns.get(i);\n        buf.replace(insertPos, insertPos + FORMAT_INSERT.length(), customPattern);\n        insertPos += customPattern.length();\n    }\n    return buf.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    Type fromRawType = $Gson$Types.getRawType(from);\n    Type toRawType = $Gson$Types.getRawType(to);\n    if (!fromRawType.equals(toRawType)) {\n      return false;\n    }\n\n    Type[] fromActualTypeArguments = from.getActualTypeArguments();\n    Type[] toActualTypeArguments = to.getActualTypeArguments();\n    if (fromActualTypeArguments.length != toActualTypeArguments.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromActualTypeArguments.length; i++) {\n      Type fromType = fromActualTypeArguments[i];\n      Type toType = toActualTypeArguments[i];\n      if (fromType instanceof TypeVariable<?>) {\n        String fromName = ((TypeVariable<?>) fromType).getName();\n        Type toType1 = typeVarMap.get(fromName);\n        if (toType1 == null || !typeEquals(toType1, toType, typeVarMap)) {\n          return false;\n        }\n      } else if (!typeEquals(fromType, toType, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      Type fromTypeArg = fromTypeArgs[i];\n      Type toTypeArg = toTypeArgs[i];\n      if (fromTypeArg instanceof TypeVariable<?>) {\n        fromTypeArg = typeVarMap.get(fromTypeArg.toString());\n      }\n      if (toTypeArg instanceof TypeVariable<?>) {\n        toTypeArg = typeVarMap.get(toTypeArg.toString());\n      }\n      if (!typeEquals(fromTypeArg, toTypeArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        String varName = ((TypeVariable<?>) fromArg).getName();\n        if (typeVarMap.containsKey(varName)) {\n          fromArg = typeVarMap.get(varName);\n        }\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        String varName = ((TypeVariable<?>) toArg).getName();\n        if (typeVarMap.containsKey(varName)) {\n          toArg = typeVarMap.get(varName);\n        }\n      }\n\n      if (!typeEquals(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        Type mappedType = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n        if (mappedType == null || !typeEquals(mappedType, toArg, typeVarMap)) {\n          return false;\n        }\n      } else if (!typeEquals(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    // If the types are not equal, check if the raw types are the same.\n    if (!$Gson$Types.getRawType(from).equals($Gson$Types.getRawType(to))) {\n      return false;\n    }\n\n    // If the types are not equal, check if the type variables are the same.\n    TypeVariable<?>[] fromTypeVars = from.getActualTypeArguments();\n    TypeVariable<?>[] toTypeVars = to.getActualTypeArguments();\n    if (fromTypeVars.length != toTypeVars.length) {\n      return false;\n    }\n\n    // If the types are not equal, check if the type variables are the same.\n    for (int i = 0; i < fromTypeVars.length; i++) {\n      TypeVariable<?> fromTypeVar = fromTypeVars[i];\n      TypeVariable<?> toTypeVar = toTypeVars[i];\n      if (!fromTypeVar.equals(toTypeVar)) {\n        return false;\n      }\n\n      // If the type variables are not equal, check if the type variables are\n      // equivalent under the provided type variable mapping.\n      Type fromType = typeVarMap.get(fromTypeVar.getName());\n      Type toType = typeVarMap.get(toTypeVar.getName());\n      if (fromType == null || toType == null) {\n        return false;\n      }\n\n      // If the type variables are not equal, check if the types are the same.\n      if (!fromType.equals(toType)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // First check the raw types\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check the parameter counts\n    int fromParamCount = from.getActualTypeArguments().length;\n    int toParamCount = to.getActualTypeArguments().length;\n    if (fromParamCount != toParamCount) {\n      return false;\n    }\n\n    // Check each parameter\n    for (int i = 0; i < fromParamCount; i++) {\n      Type fromParam = from.getActualTypeArguments()[i];\n      Type toParam = to.getActualTypeArguments()[i];\n\n      // Check if either is a type variable\n      if (fromParam instanceof TypeVariable<?> || toParam instanceof TypeVariable<?>) {\n        // If either is a type variable, check if the other is assignable to it\n        if (!typeVarMap.containsKey(fromParam.toString())) {\n          typeVarMap.put(fromParam.toString(), toParam);\n        } else if (!typeVarMap.get(fromParam.toString()).equals(toParam)) {\n          return false;\n        }\n      } else {\n        // If neither is a type variable, check if they are equal\n        if (!fromParam.equals(toParam)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    // Check if the raw types are the same\n    if (!$Gson$Types.getRawType(from).equals($Gson$Types.getRawType(to))) {\n      return false;\n    }\n\n    // Check if the type variables are the same\n    TypeVariable<?>[] fromTypeVars = from.getActualTypeArguments();\n    TypeVariable<?>[] toTypeVars = to.getActualTypeArguments();\n    if (fromTypeVars.length != toTypeVars.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeVars.length; i++) {\n      Type fromType = fromTypeVars[i];\n      Type toType = toTypeVars[i];\n      if (!typeVarMap.containsKey(fromType.toString())) {\n        typeVarMap.put(fromType.toString(), toType);\n      } else if (!typeVarMap.get(fromType.toString()).equals(toType)) {\n        return false;\n      }\n    }\n\n    // Check if the type arguments are the same\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      Type fromType = fromTypeArgs[i];\n      Type toType = toTypeArgs[i];\n      if (fromType instanceof TypeVariable<?>) {\n        if (!typeVarMap.containsKey(fromType.toString())) {\n          return false;\n        }\n        fromType = typeVarMap.get(fromType.toString());\n      }\n      if (toType instanceof TypeVariable<?>) {\n        if (!typeVarMap.containsKey(toType.toString())) {\n          return false;\n        }\n        toType = typeVarMap.get(toType.toString());\n      }\n      if (!typeEquals(fromType, toType, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Check if the raw types are the same\n    if (!clazz.equals(\n        $Gson$Types.getRawType(to))) {\n      return false;\n    }\n\n    // Check if the type arguments are the same\n    Type[] fromArgs = ptype.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        // This is a type variable, so we need to look it up in the map\n        fromArg = typeVarMap.get(fromArg.toString());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        // This is a type variable, so we need to look it up in the map\n        toArg = typeVarMap.get(toArg.toString());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> it = (Iterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> it = (Iterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> it = (Iterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> it = (Iterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Iterator<E> it = (Iterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) node.getAnnotation();\n    return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    Color color = (Color) graph.getNodeAnnotation(node);\n    for (N n : graph.getNodes()) \n    {\n        if (color.equals(graph.getNodeAnnotation(n))) \n        {\n            superNode = n;\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) graph.getNode(node).getAnnotation();\n    return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Complete this function\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    Color color = (Color) node.getAnnotation();\n    if (colorToNodeMap[color.value] == null) \n    {\n        colorToNodeMap[color.value] = node;\n    }\n    else \n    {\n        superNode = colorToNodeMap[color.value];\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[((Color) node.getAnnotation()).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) graph.getNodeAnnotation(node);\n    return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[((Color) node.getAnnotation()).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[((Color) node.getAnnotation()).value];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < x.length; i++) {\n        sum += f.value(x[i]) * w[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < x.length; i++) {\n        sum += f.value(x[i]) * w[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < x.length; i++) {\n        sum += f.value(x[i]) * w[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < x.length; i++) {\n        sum += f.value(x[i]) * w[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Validate inputs\n  Preconditions.checkArgument(expr.isString(),\n      \"Expression must be a string\");\n  Preconditions.checkArgument(parent.isExprResult(),\n      \"Parent must be an expression result\");\n\n  // Gather replacements\n  List<Node> replacements = Lists.newArrayList();\n  for (Node child : expr.children()) {\n    if (child.isString()) {\n      replacements.add(child);\n    }\n  }\n\n  // Replace the expression\n  changeProxy.replaceWith(parent, expr, replacements);\n\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Validate inputs\n  Preconditions.checkArgument(expr.isString());\n  Preconditions.checkArgument(parent.isExprResult());\n\n  // Replace the expression\n  Node replacement = IR.string(ShortEncoding.encode(expr.getString()));\n  replacement.copyInformationFromForTree(expr);\n  parent.replaceChild(expr, replacement);\n\n  return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Validate inputs\n  Preconditions.checkArgument(expr.isString(),\n      \"Expected a string expression\");\n  Preconditions.checkArgument(parent.isExprResult(),\n      \"Expected a string expression to be the sole child of an EXPR_RESULT\");\n\n  // Replace the expression with a short encoded string\n  Node replacement = IR.string(ShortEncoding.encode(expr.getString()));\n  replacement.copyInformationFromForTree(expr);\n  parent.replaceChild(expr, replacement);\n\n  return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO(user): Implement this function\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String value = expr.getString();\n    if (value.length() > MAX_STRING_LENGTH) {\n      // Replace the expression with a short encoded string.\n      Node replacement = IR.string(\n          encodeString(value, MAX_STRING_LENGTH)).srcref(expr);\n      parent.replaceChild(expr, replacement);\n      compiler.reportCodeChange();\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Validate inputs\n  Preconditions.checkArgument(expr.isString());\n  Preconditions.checkArgument(parent.isExprResult());\n\n  // Gather replacements\n  List<Node> replacements = Lists.newArrayList();\n  for (Node rhs : getRhsSubexpressions(expr)) {\n    replacements.addAll(getSideEffectNodes(rhs));\n  }\n\n  if (replacements.isEmpty()) {\n    replacements.add(IR.empty());\n  } else {\n    Node expr = collapseReplacements(replacements);\n    replacements.clear();\n    replacements.add(expr);\n  }\n\n  changeProxy.replaceWith(parent, expr, replacements);\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Validate inputs\n  switch (parent.getType()) {\n    case Token.BLOCK:\n    case Token.SCRIPT:\n    case Token.FOR:\n    case Token.LABEL:\n      break;\n    default:\n      throw new IllegalArgumentException(\n          \"Unsupported parent node type in replaceWithRhs \" +\n          Token.name(parent.getType()));\n  }\n\n  switch (expr.getType()) {\n    case Token.STRING:\n    case Token.NAME:\n      break;\n    default:\n      throw new IllegalArgumentException(\n          \"Unsupported node type in replaceWithRhs \" +\n          Token.name(expr.getType()));\n  }\n\n  // Gather replacements\n  List<Node> replacements = Lists.newArrayList();\n  for (Node rhs : getRhsSubexpressions(expr)) {\n    replacements.addAll(getSideEffectNodes(rhs));\n  }\n\n  if (parent.isFor()) {\n    // Tweak replacements array s.t. it is a single expression node.\n    if (replacements.isEmpty()) {\n      replacements.add(IR.empty());\n    } else {\n      Node expr = collapseReplacements(replacements);\n      replacements.clear();\n      replacements.add(expr);\n    }\n  }\n\n  changeProxy.replaceWith(parent, expr, replacements);\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO(user): Implement this function\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String originalString = expr.getString();\n    String encodedString = encodeString(originalString);\n    if (encodedString != null) {\n      Node replacement = IR.string(encodedString).srcref(expr);\n      parent.replaceChild(expr, replacement);\n      compiler.reportCodeChange();\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO(user): Implement\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[data.length];\n    System.arraycopy(data, 0, out, 0, data.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[data.length];\n    System.arraycopy(data, 0, out, 0, data.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[data.length];\n    System.arraycopy(data, 0, out, 0, data.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  // Check if there is a description in the JsDoc.\n  String desc = info.getDescription();\n  if (desc != null && !desc.isEmpty()) {\n    builder.setDescription(desc);\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // If the node has a JSDoc, use its description if present.\n    String description = info.getDescription();\n    if (description != null) {\n      builder.setDescription(description);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // check if there is a description in the JsDoc\n    String description = info.getDescription();\n    if (description != null && !description.isEmpty()) {\n      builder.setDescription(description);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  // If there is no JsDoc, there is nothing to do.\n  if (node.getJSDocInfo() == null) {\n    return false;\n  }\n  \n  // Get the description from the JsDoc.\n  String description = node.getJSDocInfo().getDescription();\n  \n  // If there is no description, there is nothing to do.\n  if (description == null) {\n    return false;\n  }\n  \n  // Set the description in the message builder.\n  builder.setDescription(description);\n  \n  // Return true to indicate that the message has JsDoc with a valid description\n  // in the @desc annotation.\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // If there is a @desc annotation, use it to initialize the message's\n    // description.\n    if (info.hasDescription()) {\n      builder.setDescription(info.getDescription());\n      return true;\n    }\n\n    // If there is a @desc annotation, use it to initialize the message's\n    // description.\n    if (info.hasEnumParameterType()) {\n      for (String enumValue : info.getEnumParameterType()) {\n        builder.putEnumValues(enumValue);\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // If the JSDoc has a description, use it to initialize the message's\n    // description.\n    if (info.hasDescription()) {\n      builder.setDescription(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node == null || !node.isFromExterns()) {\n    return false;\n  }\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  builder.setLinterName(LinterName.JSC_LINT);\n  builder.setLineNumber(node.getLineno());\n  builder.setCharno(node.getCharno());\n  builder.setFileName(node.getStaticSourceFile().getName());\n  builder.setDescription(info.getDescription());\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  // Check if the node has JsDoc\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) \n  {\n    return false;\n  }\n\n  // Check if the JsDoc has a description\n  String desc = info.getDescription();\n  if (desc == null) \n  {\n    return false;\n  }\n\n  // Check if the description is valid\n  if (desc.isEmpty()) \n  {\n    return false;\n  }\n\n  // Initialize the meta data\n  builder.setDescription(desc);\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  // If there is a description in the JsDoc, add it to the message.\n  String desc = info.getDescription();\n  if (desc != null && !desc.isEmpty()) {\n    builder.setDescription(desc);\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.getDescription() != null) {\n      builder.setDescription(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double cov = 0;\n        for(int i=0; i<xArray.length; i++) {\n            cov += (xArray[i] - xArray.mean()) * (yArray[i] - yArray.mean());\n        }\n        if (biasCorrected) {\n            cov /= (xArray.length - 1);\n        } else {\n            cov /= xArray.length;\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumXSquare = 0;\n    double sumYSquare = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += xArray[i] * yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXSquare += xArray[i] * xArray[i];\n        sumYSquare += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double varianceX = sumXSquare / xArray.length - meanX * meanX;\n    double varianceY = sumYSquare / xArray.length - meanY * meanY;\n    double covariance = sum / xArray.length - meanX * meanY;\n    if (biasCorrected) {\n        return covariance * (xArray.length - 1) / (xArray.length - 2);\n    } else {\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumXSquare = 0;\n        double sumYSquare = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += 1;\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXSquare += xArray[i] * xArray[i];\n            sumYSquare += yArray[i] * yArray[i];\n        }\n        double meanX = sumX / sum;\n        double meanY = sumY / sum;\n        double varianceX = sumXSquare / sum - meanX * meanX;\n        double varianceY = sumYSquare / sum - meanY * meanY;\n        double covariance = (sumXSquare - sumX * meanX) * (sumYSquare - sumY * meanY) /\n                (sum * varianceX * varianceY);\n        if (biasCorrected) {\n            covariance /= (sum - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n        }\n        double cov = sum / (xArray.length - biasCorrected);\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumX2 = 0;\n        double sumY2 = 0;\n        double sumXY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += 1;\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double cov = (sum * sumXY - sumX * sumY) /\n                (Math.sqrt(sum * sumX2 - sumX * sumX) * Math.sqrt(sum * sumY2 - sumY * sumY));\n        if (biasCorrected) {\n            return cov * (xArray.length - 1) / (xArray.length - 2);\n        } else {\n            return cov;\n        }\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IllegalArgumentException();\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = IOUtils.readFully(in, skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IllegalArgumentException();\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(in, value);\n    if (skipped != value) {\n        throw new IOException(\"Could not skip required number of bytes\");\n    }\n    current.bytesReadFromStream += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException();\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = IOUtils.readFully(in, skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(in, value);\n    current.bytesReadFromStream += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = IOUtils.skip(in, value);\n    current.bytesReadFromStream += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = IOUtils.readFully(in, skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IllegalArgumentException();\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException();\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = IOUtils.readFully(in, skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = IOUtils.readFully(in, skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IllegalArgumentException();\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      long fp = 0;\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          fp = FP.fingerprint(\n              ((PlaceholderReference) part).getName().toUpperCase());\n        } else {\n          fp = FP.fingerprint(part.toString().toUpperCase());\n        }\n      }\n      return Long.toHexString(fp);\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Compute a 63-bit fingerprint of the message parts.\n    long fp = 0;\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            // Fingerprint the placeholder reference's name.\n            fp = FP.fingerprint(part.toString(), fp);\n        } \n        else \n        {\n            // Fingerprint the part's string value.\n            fp = FP.fingerprint(part.toString(), fp);\n        }\n    }\n\n    // Convert the fingerprint to a compact alphanumeric string.\n    return FP.fingerprintToString(fp);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Generate fingerprint of message parts\n    long fp = 0;\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            fp = FP.fingerprint(part.toString(), 0, part.toString().length());\n        } \n        else \n        {\n            fp = FP.fingerprint(part.toString(), 0, part.toString().length());\n        }\n    }\n    // Convert fingerprint to compact uppercase alphanumeric text\n    return Long.toUnsignedString(fp, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      // The fingerprint of the empty message is 0.\n      if (messageParts.isEmpty()) {\n        return \"0\";\n      }\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          sb.append(CaseFormat.LOWER_CAMEL.to(\n              CaseFormat.UPPER_UNDERSCORE,\n              ((PlaceholderReference) part).getName()));\n        } else {\n          sb.append(part);\n        }\n      }\n      String tcValue = sb.toString();\n      long fp = FP.fingerprint(tcValue.getBytes(Charsets.UTF_8));\n      return Long.toHexString(fp).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fp = 0;\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            fp ^= FP.fingerprint(\n                ((PlaceholderReference) part).getName().getBytes(UTF_8));\n        } else {\n            fp ^= FP.fingerprint(part.toString().getBytes(UTF_8));\n        }\n    }\n    return Long.toHexString(fp);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fp = 0;\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            fp ^= FP.fingerprint(\n                ((PlaceholderReference) part).getName().toUpperCase());\n        } else {\n            fp ^= FP.fingerprint(part.toString().toUpperCase());\n        }\n    }\n    return Long.toHexString(fp).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      byte[] bytes = new byte[8];\n      long fp = 0;\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          fp = FP.fingerprint(\n              ((PlaceholderReference) part).getName().getBytes(Charsets.UTF_8));\n        } else {\n          fp = FP.fingerprint(part.toString().getBytes(Charsets.UTF_8));\n        }\n        bytes[0] = (byte) (fp & 0xff);\n        bytes[1] = (byte) ((fp >> 8) & 0xff);\n        bytes[2] = (byte) ((fp >> 16) & 0xff);\n        bytes[3] = (byte) ((fp >> 24) & 0xff);\n        bytes[4] = (byte) ((fp >> 32) & 0xff);\n        bytes[5] = (byte) ((fp >> 40) & 0xff);\n        bytes[6] = (byte) ((fp >> 48) & 0xff);\n        bytes[7] = (byte) ((fp >> 56) & 0xff);\n        fp = 0;\n      }\n      return BaseEncoding.base64Url().omitPadding().encode(bytes);\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Use the same hash function as Google Closure Compiler's MessageId.\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Fingerprinting is a bit tricky because we don't want to generate\n    // the same fingerprint for two messages that are equivalent except\n    // for the order of their parts.\n    //\n    // We use a simple approach: we concatenate the message parts,\n    // then compute the 64-bit Fingerprint of the resulting string.\n    //\n    // The resulting fingerprint is then converted to a compact\n    // uppercase alphanumeric string.\n    //\n    // The resulting string is guaranteed to be unique for two messages\n    // that are equivalent except for the order of their parts.\n    //\n    // Note that this approach has a few limitations:\n    //\n    // 1. It doesn't work well with very long messages, because the\n    //    resulting fingerprint is 64 bits, which is not enough to\n    //    represent a large number of possible messages.\n    //\n    // 2. It doesn't work well with messages that contain many repeated\n    //    parts, because the resulting fingerprint is sensitive to the\n    //    order of the repeated parts.\n    //\n    // In practice, we don't expect to encounter these limitations in\n    // the wild, because we don't expect to have very long messages or\n    // many repeated parts.\n    //\n    // If we do encounter these limitations in the future, we may need\n    // to revisit this approach and use a more sophisticated fingerprinting\n    // algorithm.\n    //\n    // For example, we could use a more sophisticated fingerprinting\n    // algorithm, such as the one used by the Google Closure Compiler.\n    //\n    // Another approach would be to use a hash function that is more\n    // resistant to collisions, such as the one used by the Google Closure\n    // Library.\n    //\n    // We could also use a combination of both approaches, by using a\n    // sophisticated fingerprinting algorithm to generate a 64-bit\n    // fingerprint, and then converting that fingerprint to a compact\n    // uppercase alphanumeric string using a simple algorithm.\n    //\n    // The choice of approach will depend on the specific requirements\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      long fingerprint = 0;\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          fingerprint = FP.fingerprint(\n              ((PlaceholderReference) part).getName().getBytes(Charsets.UTF_8),\n              0,\n              ((PlaceholderReference) part).getName().length(),\n              fingerprint);\n        } else {\n          fingerprint = FP.fingerprint(\n              part.toString().getBytes(Charsets.UTF_8),\n              0,\n              part.toString().length(),\n              fingerprint);\n        }\n      }\n      return Long.toHexString(fingerprint).toUpperCase();\n    }"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = size - minDistanceFromEnd;\n    long maxPosition = size - maxDistanceFromEnd;\n    long sigLength = sig.length;\n    long maxPositionToCheck = maxPosition - sigLength;\n    while (currentPosition <= maxPositionToCheck) {\n        randomAccessFile.seek(currentPosition);\n        byte[] buffer = new byte[sigLength];\n        randomAccessFile.readFully(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n        currentPosition++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = size() - minDistanceFromEnd;\n    long maxPosition = size() - maxDistanceFromEnd;\n    long maxPositionToSearch = size() - minDistanceFromEnd;\n    long positionToSearch = currentPosition;\n    while (currentPosition < maxPositionToSearch) {\n        raf.seek(currentPosition);\n        int sigPos = 0;\n        int readByte = raf.read();\n        while (sigPos < sig.length && readByte == sig[sigPos]) {\n            sigPos++;\n            readByte = raf.read();\n        }\n        if (sigPos == sig.length) {\n            return true;\n        }\n        currentPosition++;\n        if (currentPosition > maxPosition) {\n            break;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    // check if we are at the end of the file\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = file.length() - minDistanceFromEnd;\n        long end = file.length() - maxDistanceFromEnd;\n        if (end < 0) {\n            end = 0;\n        }\n        while (pos >= end) {\n            file.seek(pos);\n            if (Arrays.equals(sig, readSig())) {\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // we want to search backwards from the end of the file\n    // to the maxDistanceFromEnd\n    long fileLength = raf.length();\n    long currentPosition = fileLength - minDistanceFromEnd;\n    long maxPosition = fileLength - maxDistanceFromEnd;\n\n    while (currentPosition >= maxPosition) {\n        raf.seek(currentPosition);\n        if (readFully(raf, sig) == sig.length) {\n            return true;\n        }\n        currentPosition--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long maxOffset = size - maxDistanceFromEnd;\n        long minOffset = size - minDistanceFromEnd;\n        if (minOffset < 0) {\n            minOffset = 0;\n        }\n        long offset = minOffset;\n        while (offset <= maxOffset) {\n            raf.seek(offset);\n            if (Arrays.equals(raf.readNBytes(sig.length), sig)) {\n                return true;\n            }\n            offset++;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long position = size - minDistanceFromEnd;\n        long maxPosition = size - maxDistanceFromEnd;\n        if (maxPosition < 0) {\n            maxPosition = 0;\n        }\n        while (position >= maxPosition) {\n            raf.seek(position);\n            if (matchesSignature(sig)) {\n                return true;\n            }\n            position--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long curPos = size - minDistanceFromEnd;\n        long maxPos = size - maxDistanceFromEnd;\n        while (curPos <= maxPos) {\n            raf.seek(curPos);\n            int sigPos = 0;\n            while (sigPos < sig.length) {\n                if (raf.readByte() != sig[sigPos++]) {\n                    curPos += sig.length - sigPos;\n                    break;\n                }\n            }\n            if (sigPos == sig.length) {\n                return true;\n            }\n            curPos++;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentDistance = minDistanceFromEnd;\n    long currentOffset = size - currentDistance;\n    while (currentDistance <= maxDistanceFromEnd) {\n        raf.seek(currentOffset);\n        if (Arrays.equals(raf.readNBytes(sig.length), sig)) {\n            return true;\n        }\n        currentDistance++;\n        currentOffset--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = minDistanceFromEnd;\n    while (distance <= maxDistanceFromEnd) {\n        raf.seek(size - distance - sig.length);\n        for (int i = 0; i < sig.length; i++) {\n            if (sig[i] != raf.readByte()) {\n                distance++;\n                break;\n            }\n            if (i == sig.length - 1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getRangeAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    // First: do we have a Stream? If not, need to create one:\n    InputStream in = _in;\n\n    if (in == null) {\n        in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd);\n    } else {\n        /* Also, if we have any read but unused input (usually true),\n         * need to merge that input in:\n         */\n        if (_inputPtr < _inputEnd) {\n            in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd);\n        }\n    }\n    return in;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    // First: do we have a Stream? If not, need to create one:\n    InputStream in = _in;\n\n    if (in == null) {\n        in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd);\n    } else {\n        /* Also, if we have any read but unused input (usually true),\n         * need to merge that input in:\n         */\n        if (_inputPtr < _inputEnd) {\n            in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd);\n        }\n    }\n    return in;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnKey(section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnKey(section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnKey(section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < this.sectionKeys.size()) \n    {\n        result = (Comparable) this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section' index: \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) {\n        result = this.source.getColumnKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) {\n        result = this.source.getRowKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnKey(section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.source != null) \n    {\n        if (this.extract == TableOrder.BY_ROW) \n        {\n            result = this.source.getRowKey(section);\n        }\n        else if (this.extract == TableOrder.BY_COLUMN) \n        {\n            result = this.source.getColumnKey(section);\n        }\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section' index: \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) \n    {\n        result = this.source.getRowKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) \n    {\n        result = this.source.getColumnKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) \n    {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section' index: \" + section);\n    }\n    if (this.extract == TableOrder.BY_ROW) \n    {\n        result = this.source.getRowKey(section);\n    }\n    else if (this.extract == TableOrder.BY_COLUMN) \n    {\n        result = this.source.getColumnKey(section);\n    }\n    return result;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNumericNode();\n                if (n != null) {\n                    return n.isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue().isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue().isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue().isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNumericNode();\n                if (n != null) {\n                    if (n.isPojo()) {\n                        return ((POJONode) n).getPojo() instanceof Double && Double.isNaN(((Double) ((POJONode) n).getPojo()).doubleValue());\n                    }\n                    if (n.isBinary()) {\n                        return ((BinaryNode) n).binaryValue() instanceof Double && Double.isNaN(((Double) ((BinaryNode) n).binaryValue()).doubleValue());\n                    }\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNumericNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNumericNode();\n                if (n != null) {\n                    return n.isNaN();\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    }\n    if (p == PEEKED_BUFFERED) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    }\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n\n    if (p == PEEKED_BUFFERED) {\n      peekedString = nextQuotedValue(peekedString.charAt(0));\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    }\n\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_BUFFERED) {\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    peeked = PEEKED_BUFFERED;\n    return peekedString;\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    }\n    if (p == PEEKED_BUFFERED) {\n        String result = peekedString;\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        peeked = PEEKED_BUFFERED;\n        return peekedString;\n    }\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  if (p == PEEKED_BUFFERED) {\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n      peekedString = nextQuotedValue(peekedString.charAt(0));\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n      peekedString = nextQuotedValue(peekedString.charAt(0));\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n\n  if (p == PEEKED_BUFFERED) {\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 0) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equalShapes(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equalShapes(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equalShapes(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) \n  {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) \n    {\n      lastNameIndex = index;\n    } \n    else \n    {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) \n  {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) \n    {\n      lastNameIndex = index;\n    } \n    else \n    {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n      lastSymbolName = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolNameIndex = index;\n      } else {\n        lastSymbolNameIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolNameIndex);\n      }\n    }\n    return lastSymbolNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastName) {\n    lastName = symbolName;\n    Integer index = nameMap.get(symbolName);\n    if (index != null) {\n      lastNameIndex = index;\n    } else {\n      lastNameIndex = nameMap.size();\n      nameMap.put(symbolName, lastNameIndex);\n    }\n  }\n  return lastNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            double result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a long below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            double result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a long below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString);\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            double result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a long below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            double result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a long below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double result = Double.parseDouble(peekedString);\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        // Check style of call\n        // if (str == null) {\n        //     return null;\n        // }\n        // if (repeat <= 0) {\n        //     return \"\";\n        // }\n        // if (str.length() == 0) {\n        //     return str;\n        // }\n\n        int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(str.charAt(0), repeat);\n        }\n\n        // inputLength == 0 || repeat == 0\n        int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return padding(repeat, str.charAt(0));\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return padding(repeat, str.charAt(0));\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return padding(repeat, str.charAt(0));\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return padding(repeat, str.charAt(0));\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        // Argument validation is done by repeat(String, int, int)\n        return repeat(str, 0, repeat, false);\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.GnuLongName:\n            return new GnuLongNameExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.ZipItMacintosh:\n            return new ZipItMacintoshExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.PkwareMacBinaryMainAttr:\n            return new PkwareMacBinaryMainAttrExtraField();\n        case NID.PkwareMacBinaryForkAttr:\n            return new PkwareMacBinaryForkAttrExtraField();\n        case NID.PkwareMacBinaryForkCompat:\n            return new PkwareMacBinaryForkCompatExtraField();\n        case NID.PkwareMacBinaryUnixExecAttr:\n            return new PkwareMacBinaryUnixExecAttrExtraField();\n        case NID.PkwareMacBinaryPosixCdromExtra:\n            return new PkwareMacBinaryPosixCdromExtraField();\n        case NID.PkwareMacBinaryDosBinaryExtra:\n            return new PkwareMacBinaryDosBinaryExtraField();\n        case NID.PkwareMacBinaryDosBinaryCompat:\n            return new PkwareMacBinaryDosBinaryCompatExtraField();\n        case NID.PkwareMacBinaryDosBinaryPosixCdromExtra:\n            return new PkwareMacBinaryDosBinaryPosixCdromExtraField();\n        case NID.PkwareMacBinaryDosBinaryUnixExecAttr:\n            return new PkwareMacBinaryDosBinaryUnixExecAttrExtraField();\n        case NID.PkwareMacBinaryDosBinaryMacOsExtra:\n            return new PkwareMacBinaryDosBinaryMacOsExtraField();\n        case NID.PkwareMacBinaryDosBinaryTandemExtra:\n            return new PkwareMacBinaryDosBinaryTandemExtraField();\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<? extends ZipExtraField> clazz = getExtraFieldClass(headerId);\n    return clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.Gnu:\n            return new GnuLongNameExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.InfoZipUnix:\n            return new InfoZipUnixExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.JarComment:\n            return new JarCommentExtraField();\n        case NID.PkwareMacBinary:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareMacBinaryOld:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareTruncated:\n            return new PkzipTruncatedExtraField();\n        case NID.X509Certificate:\n            return new X509CertificateExtraField();\n        case NID.X509CertificateBag:\n            return new X509CertificateBagExtraField();\n        case NID.X509Crl:\n            return new X509CrlExtraField();\n        case NID.X509CrlBag:\n            return new X509CrlBagExtraField();\n        case NID.X509IssuerName:\n            return new X509IssuerNameExtraField();\n        case NID.X509IssuerSerial:\n            return new X509IssuerSerialExtraField();\n        case NID.X509SubjectName:\n            return new X509SubjectNameExtraField();\n        case NID.X509SubjectPublicKey:\n            return new X509SubjectPublicKeyExtraField();\n        case NID.X509SkipCerts:\n            return new X509SkipCertsExtraField();\n        case NID.X509TrustedCerts:\n            return new X509TrustedCertsExtraField();\n        case NID.X509NameConversion:\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.ExtendedTimestamp:\n            return new ExtendedTimestampExtraField();\n        case NID.Unix:\n            return new UnixExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.InfoZipUnix:\n            return new InfoZipUnixExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.JarComment:\n            return new JarCommentExtraField();\n        case NID.PkwareMacBinary:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareTradLZW:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareImplode:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareDCLImplode:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareDeflate:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareEnhDCLImplode:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareBZip2:\n            return new PkzipCompatibleExtraField();\n        case NID.PkwareBZip2Huffman:\n            return new PkzipCompatibleExtraField();\n        case NID.X509CertId:\n            return new X509CertificatePair();\n        case NID.X509CertVal:\n            return new X509CertificateValidationData();\n        case NID.StrongEncrypt:\n            return new StrongEncryptHeader();\n        case NID.RecordMangling:\n            return new RecordManglingExtraField();\n        case NID.RFC1952:\n            return new RFC1952ExtraField();\n        case NID.RFC3686:\n            return new RFC3686ExtraField();\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField result = null;\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            result = new NtfsExtraField();\n            break;\n        case NID.ExtendedTimestamp:\n            result = new ExtendedTimestampExtraField();\n            break;\n        case NID.Unix:\n            result = new UnixExtraField();\n            break;\n        case NID.InfoZipUnixVarSize:\n            result = new InfoZipUnixVarSizeExtraField();\n            break;\n        case NID.JarMarker:\n            result = new JarMarkerExtraField();\n            break;\n        case NID.JarComment:\n            result = new JarCommentExtraField();\n            break;\n        case NID.PkwareMacBinary:\n            result = new PkzipCompactExtraField();\n            break;\n        case NID.PkwareTradLZW:\n            result = new PkzipTraditionalLZWExtraField();\n            break;\n        case NID.PkwareImplode:\n            result = new PkzipImplodingExtraField();\n            break;\n        case NID.PkwareDeflate:\n            result = new PkzipDeflatingExtraField();\n            break;\n        case NID.PkwareEnhancedDeflate:\n            result = new PkzipEnhancedDeflatingExtraField();\n            break;\n        case NID.PkwareBzip2:\n            result = new PkzipBzip2ExtraField();\n            break;\n        case NID.X509Certificate:\n            result = new X509CertificateExtraField();\n            break;\n        case NID.OpensslSignature:\n            result = new OpensslSignatureExtraField();\n            break;\n        case NID.GenericCrypto:\n            result = new GenericCryptoExtraField();\n            break;\n        case NID.Rar5CompressedData:\n            result = new Rar5CompressedDataExtraField();\n            break;\n        case NID.Rar5EncryptedData:\n            result = new Rar5EncryptedDataExtraField();\n            break;\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.Gnu:\n            return new GnuLongNameExtraField();\n        case NID.InfoZipUnix:\n            return new UnixExtraField();\n        case NID.ExtendedTimestamp:\n            return new ExtendedTimestampExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.Unknown:\n            return new UnrecognizedExtraField();\n        default:\n            return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.Gpt:\n            return new GptExtraField();\n        case NID.Unix:\n            return new UnixExtraField();\n        case NID.ExtendedTimestamp:\n            return new ExtendedTimestampExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.InfoZipUnix:\n            return new InfoZipUnixExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.JarComment:\n            return new JarCommentExtraField();\n        case NID.PkwareTruncated:\n            return new PkwareTruncatedExtraField();\n        case NID.ZipItMacintosh:\n            return new ZipItMacintoshExtraField();\n        case NID.ZipItWindows:\n            return new ZipItWindowsExtraField();\n        case NID.X509Certificate:\n            return new X509CertificateExtraField();\n        case NID.NtSecurity:\n            return new NtSecurityExtraField();\n        case NID.OpenVMS:\n            return new OpenVMSExtraField();\n        case NID.PatchDescriptor:\n            return new PatchDescriptorExtraField();\n        case NID.GenericFlag:\n            return new GenericExtraField();\n        default:\n            return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<? extends ZipExtraField> clazz =\n            EXTRA_FIELD_CLASSES.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.ExtendedTimestamp:\n            return new ExtendedTimestampExtraField();\n        case NID.Unix:\n            return new UnixExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.InfoZipUnix:\n            return new InfoZipUnixExtraField();\n        case NID.ZipItMacintosh:\n            return new ZipItMacintoshExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.PkwareMacBinary:\n            return new PkzipCompactExtraField();\n        case NID.PkwareTruncated:\n            return new PkzipTruncatedExtraField();\n        case NID.PkwareGeneralPurpose:\n            return new PkzipGeneralPurposeExtraField();\n        case NID.PkwareUnix:\n            return new PkzipUnixExtraField();\n        case NID.PkwareCentralDirectory:\n            return new PkzipCentralDirectoryExtraField();\n        case NID.PkwareHeader:\n            return new PkzipHeaderExtraField();\n        case NID.PkwareLegacy:\n            return new PkzipLegacyExtraField();\n        case NID.PkwareOS2:\n            return new PkzipOS2ExtraField();\n        case NID.PkwareNTFS:\n            return new PkzipNTFSExtraField();\n        case NID.X509Certificate:\n            return new X509CertificateExtraField();\n        case NID.X509Issuer:\n            return new X509IssuerExtraField();\n        case NID.X509Subject:\n            return new X509SubjectExtraField();\n        case NID.X509SKI:\n            return new X509SKIExtraField();\n        case NID.X509CertType:\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    switch (headerId.getValue()) {\n        case NID.Ntfs:\n            return new NtfsExtraField();\n        case NID.GnuLongName:\n            return new GnuLongNameExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.InfoZipUnix:\n            return new InfoZipUnixExtraField();\n        case NID.JarMarker:\n            return new JarMarkerExtraField();\n        case NID.JarComment:\n            return new JarCommentExtraField();\n        case NID.PkwareGeneralPurposeBit:\n            return new PkwareGeneralPurposeBitExtraField();\n        case NID.PkwareTradLZWCompression:\n            return new PkwareTradLZWCompressionExtraField();\n        case NID.PkwareEnhancedCompression:\n            return new PkwareEnhancedCompressionExtraField();\n        case NID.X509Certificate:\n            return new X509CertificateExtraField();\n        case NID.IBMGPFS:\n            return new IBMGPFSExtraField();\n        case NID.IBMPSF:\n            return new IBMPSFExtraField();\n        case NID.MacOS:\n            return new MacOSExtraField();\n        case NID.OpenVMS:\n            return new OpenVMSExtraField();\n        case NID.FileAttributes:\n            return new FileAttributesExtraField();\n        case NID.PatchDescriptor:\n            return new PatchDescriptorExtraField();\n        case NID.UniversalTime:\n            return new UniversalTimeExtraField();\n        case NID.InfoZipUnixVarSize:\n            return new InfoZipUnixVarSizeExtraField();\n        case NID.AsiExtraField:\n            return new AsiExtraField();\n        case NID.NtfsFileTimes:\n            return new NtfsFileTimesExtraField();\n        case NID.ExtendedTimestamp:\n            return new ExtendedTimestampExtraField();\n        case NID.JarCommentDigest:\n            return new JarCommentDigestExtraField();\n}\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for(int i=0; i<sz; i++) {\n            if(chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for(int i=0; i<sz; i++) {\n            if(chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Number value = (Number) entry.getValue();\n        clonedMap.put(key, value);\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object entry = map.get(key);\n        Object toAdd = entry;\n        if (entry instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) entry;\n            toAdd = pc.clone();\n        }\n        clonedMap.put(key, toAdd);\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Map value = (Map) map.get(key);\n        clonedMap.put(key, cloneMarkerMap(value));\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            clonedMap.put(key, pc.clone());\n        }\n        else {\n            clonedMap.put(key, value);\n        }\n    }\n    return clonedMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clonedMap = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object entry = map.get(key);\n        Object clonedEntry = null;\n        if (entry instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) entry;\n            clonedEntry = pc.clone();\n        }\n        else {\n            clonedEntry = entry;\n        }\n        clonedMap.put(key, clonedEntry);\n    }\n    return clonedMap;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws ZipException {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws ZipException {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws ZipException {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements at once\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // insert all elements in one go\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements in one go\n        setOrder.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        for (final E e : toAdd) {\n            setOrder.add(index, e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        for (final E e : toAdd) {\n            setOrder.add(index, e);\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound > bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = c - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(str.substring(tokenStart, newTokenStart));\n                tokenStart = newTokenStart;\n            }\n        }\n        list.add(str.substring(tokenStart, c));\n        tokenStart = c;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                tokenStart = c - 1;\n            } else {\n                list.add(str.substring(tokenStart, c));\n                tokenStart = c;\n            }\n            currentType = type;\n        }\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(str.substring(tokenStart, newTokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(str.substring(tokenStart, pos));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            while (newTokenStart >= tokenStart && Character.isLetter(str.charAt(newTokenStart))) {\n                if (Character.isUpperCase(str.charAt(newTokenStart))) {\n                    break;\n                }\n                newTokenStart--;\n            }\n            if (newTokenStart < tokenStart) {\n                tokenStart = newTokenStart;\n                list.add(str.substring(tokenStart, pos));\n                currentType = type;\n                tokenStart = pos;\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, pos));\n        tokenStart = pos;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int i = 1; i < sz; i++) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = findTokenStart(str, i);\n            if (newTokenStart >= tokenStart) {\n                addToken(str, list, tokenStart, newTokenStart);\n                tokenStart = newTokenStart;\n            }\n        }\n        addToken(str, list, tokenStart, i);\n        tokenStart = i;\n        currentType = type;\n    }\n    if (tokenStart <= sz) {\n        addToken(str, list, tokenStart, sz);\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < sz; i++) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int breakStart = i - 1;\n            while (breakStart > tokenStart && Character.isLetter(str.charAt(breakStart - 1))) {\n                breakStart--;\n            }\n            if (breakStart > tokenStart) {\n                list.add(str.substring(tokenStart, breakStart));\n                tokenStart = breakStart;\n            }\n        }\n        list.add(str.substring(tokenStart, i));\n        tokenStart = i;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type != currentType) {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                tokenStart = c;\n            } else {\n                list.add(str.substring(tokenStart, c));\n                tokenStart = c;\n            }\n            currentType = type;\n        }\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            while (newTokenStart >= tokenStart && Character.isLetter(str.charAt(newTokenStart))) {\n                if (Character.isUpperCase(str.charAt(newTokenStart))) {\n                    break;\n                }\n                newTokenStart--;\n            }\n            if (newTokenStart < tokenStart) {\n                tokenStart = newTokenStart;\n                list.add(str.substring(tokenStart, pos));\n                currentType = type;\n                tokenStart = pos;\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, pos));\n        tokenStart = pos;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            while (newTokenStart >= tokenStart && Character.isLetter(str.charAt(newTokenStart))) {\n                if (!Character.isUpperCase(str.charAt(newTokenStart))) {\n                    break;\n                }\n                newTokenStart--;\n            }\n            if (newTokenStart < tokenStart) {\n                tokenStart = newTokenStart;\n                list.add(str.substring(tokenStart, pos));\n                currentType = type;\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, pos));\n        tokenStart = pos;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = 1; i < sz; i++) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = findNextTokenStart(str, i);\n            if (newTokenStart > i) {\n                if (tokenStart < newTokenStart) {\n                    list.add(str.substring(tokenStart, newTokenStart));\n                }\n                tokenStart = newTokenStart;\n            }\n        }\n        if (tokenStart < i) {\n            list.add(str.substring(tokenStart, i));\n        }\n        tokenStart = i;\n        currentType = type;\n    }\n    if (tokenStart < sz) {\n        list.add(str.substring(tokenStart, sz));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, null, 2004, 2004);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n              Integer.MAX_VALUE, false));\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.cloneTree(),\n          new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n              Integer.MAX_VALUE, false));\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.cloneTree(),\n          subtree.positive);\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          subtree.negative.cloneTree());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.negate(),\n          new MeasuredNode(new Node(Token.SCRIPT), 1000000, false));\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          new MeasuredNode(new Node(Token.SCRIPT), 1000000, false),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      return new MinimizedCondition(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT).srcref(n), 1000000000, false));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          unoptimized(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    }\n    case Token.HOOK: {\n      Node cond = n.getFirstChild();\n      Node thenNode = cond.getNext();\n      Node elseNode = thenNode.getNext();\n      MinimizedCondition thenSubtree =\n          unoptimized(thenNode.detachFromParent());\n      MinimizedCondition elseSubtree =\n          unoptimized(elseNode.detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n              thenSubtree.positive,\n              elseSubtree.positive),\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), 1000000, false));\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.cloneTree(),\n          subtree.positive);\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          new MeasuredNode(new Node(Token.SCRIPT), 1000000, false),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      return new MinimizedCondition(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          unoptimized(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    }\n    case Token.HOOK: {\n      Node cond = n.getFirstChild();\n      Node thenNode = cond.getNext();\n      Node elseNode = thenNode.getNext();\n      MinimizedCondition thenSubtree =\n          unoptimized(thenNode.detachFromParent());\n      MinimizedCondition elseSubtree =\n          unoptimized(elseNode.detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n              thenSubtree.positive.cloneTree(),\n              elseSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n              thenSubtree.negative.cloneTree(),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          subtree.negative.cloneTree());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.negate(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          unoptimized(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      return new MinimizedCondition(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), 1000000, false));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          unoptimized(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    }\n    case Token.HOOK: {\n      Node cond = n.getFirstChild();\n      Node thenNode = cond.getNext();\n      Node elseNode = thenNode.getNext();\n      MinimizedCondition thenSubtree =\n          unoptimized(thenNode.detachFromParent());\n      MinimizedCondition elseSubtree =\n          unoptimized(elseNode.detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n              thenSubtree.positive.cloneTree(),\n              elseSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          subtree.positive.cloneTree().addNot(),\n          subtree.negative.cloneTree());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          subtree.negative.negate(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n      return new MinimizedCondition(\n          Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n          Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n      ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n          leftSubtree.negative.negate(),\n          rightSubtree.negative.negate(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      return new MinimizedCondition(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    }\n    case Token.HOOK: {\n      Node cond = n.getFirstChild();\n      Node thenNode = cond.getNext();\n      Node elseNode = thenNode.getNext();\n      MinimizedCondition thenSubtree =\n          computeMinimizedCondition(thenNode.detachFromParent());\n      MinimizedCondition elseSubtree =\n          computeMinimizedCondition(elseNode.detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n              thenSubtree.positive.cloneTree(),\n              elseSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexical()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope parentScope = scope.getParentScope();\n        if (parentScope.isLexical()) {\n            return parentScope.getDepth() + 1;\n        } else {\n            return getLexicalScopeDepth(parentScope) + 1;\n        }\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexical()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParent();\n    while (parent != null && !parent.isLexical()) {\n      parent = parent.getParent();\n    }\n    return parent.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexical()) {\n        return scope.getDepth();\n    } else if (scope.isProperty()) {\n        return scope.getDepth() + getLexicalScopeDepth(scope.getParent());\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope == null) \n  {\n    return 0;\n  }\n  else if (scope.isLexical()) \n  {\n    return scope.getDepth();\n  }\n  else if (scope.isPropertyScope()) \n  {\n    return getLexicalScopeDepth(scope.getParent()) + 1;\n  }\n  else \n  {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexical()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parentScope = scope.getParentScope();\n    if (parentScope == null) {\n      return 0;\n    } else {\n      return getLexicalScopeDepth(parentScope) + 1;\n    }\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope == null) {\n    return 0;\n  }\n\n  if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParent()) + 1;\n  }\n\n  return 1;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexical()) {\n    return scope.getDepth();\n  } else if (scope.isProperty()) {\n    Symbol symbol = scope.getSymbol();\n    if (symbol.getType() == null) {\n      return 0;\n    }\n    ObjectType type = symbol.getType().toObjectType();\n    ObjectType proto = type.getParentScope();\n    if (proto == null) {\n      return 0;\n    }\n    Symbol protoSymbol = getSymbolForInstancesOf(proto.getConstructor());\n    if (protoSymbol == null) {\n      return 0;\n    }\n    SymbolScope protoScope = protoSymbol.getPropertyScope();\n    if (protoScope == null) {\n      return 0;\n    }\n    return getLexicalScopeDepth(protoScope) + protoScope.getDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isPropertyScope()) {\n    SymbolScope parentScope = scope.getParentScope();\n    if (parentScope.isPropertyScope()) {\n      return getLexicalScopeDepth(parentScope) + 1;\n    } else {\n      return 1;\n    }\n  } else {\n    return scope.getDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isPropertyScope()) \n  {\n    SymbolScope parent = scope.getParent();\n    if (parent != null && parent.isPropertyScope()) \n    {\n      return getLexicalScopeDepth(parent) + 1;\n    }\n  }\n  return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexical()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        return scope.getDepth() + getLexicalScopeDepth(scope.getParent());\n    } else {\n        return 0;\n    }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.isTrue(enumClass.isEnum(), \"The class must be an enum.\");\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.isTrue(enumClass.isEnum(), \"Class must be an enum\");\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp x = a;\n    Dfp y = new Dfp(x);\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp x = a;\n    Dfp y = new Dfp(x);\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp x = a;\n        Dfp y = new Dfp(x);\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(a);\n            x = x.multiply(a);\n            x = x.negate();\n            y = y.add(x.divide(i));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp x = a;\n        Dfp y = a;\n        Dfp c = a;\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp x = a;\n        Dfp y = a;\n        Dfp c = a;\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        Dfp y = a.getOne();\n        Dfp x = a;\n        Dfp c = a;\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp zero = a.getField().getZero();\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n\n        Dfp x = a;\n        Dfp y = one;\n        Dfp c = x;\n        Dfp fact = one;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.multiply(c);\n            fact = fact.divide((i-1)*i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm().getReal();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(x.getField().getZero(), inverse * z.getReal(), -inverse * y.getReal());\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z.getReal(), 0, inverse * x.getReal());\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y.getReal(), -inverse * x.getReal(), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm().getReal();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y + z.getReal() * z);\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getZero(), inverse * z.getReal(), inverse * -y.getReal(), inverse * x.getReal());\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x + z.getReal() * z);\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getZero(), -inverse * z.getReal(), inverse * x.getReal(), inverse * y.getReal());\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x + y.getReal() * y);\n    return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getZero(), inverse * y.getReal(), -inverse * x.getReal(), inverse * z.getReal());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm().getReal();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(field, 0, inverse * z.getReal(), -inverse * y.getReal());\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(field, -inverse * z.getReal(), 0, inverse * x.getReal());\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(field, inverse * y.getReal(), -inverse * x.getReal(), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        final T inverse  = 1 / FastMath.sqrt(y.multiply(y).add(z.multiply(z)));\n        return new FieldVector3D<T>(0, inverse.multiply(z), -inverse.multiply(y));\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        final T inverse  = 1 / FastMath.sqrt(x.multiply(x).add(z.multiply(z)));\n        return new FieldVector3D<T>(-inverse.multiply(z), 0, inverse.multiply(x));\n    }\n    final T inverse  = 1 / FastMath.sqrt(x.multiply(x).add(y.multiply(y)));\n    return new FieldVector3D<T>(inverse.multiply(y), -inverse.multiply(x), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        final T inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(field, 0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        final T inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(field, -inverse * z, 0, inverse * x);\n    }\n    final T inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(field, inverse * y, -inverse * x, 0);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (this.overlaps(other)) {\n        final T min = this.getMin().compareTo(other.getMin()) <= 0 ? this.getMin() : other.getMin();\n        final T max = this.getMax().compareTo(other.getMax()) >= 0 ? this.getMax() : other.getMax();\n        return new Range<>(min, max);\n    }\n    throw new IllegalArgumentException(\"Ranges do not overlap\");\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other.contains(this)) {\n        return this;\n    }\n    if (this.contains(other)) {\n        return other;\n    }\n    throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!intersectsWith(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return new Range<>(\n            getComparator(),\n            getStart().max(other.getStart()),\n            getEnd().min(other.getEnd()));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return new Range<>(\n            max(this.min, other.min),\n            min(this.max, other.max)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (this.isConnected(other)) {\n        return this;\n    }\n    return new Range<>(this.getMinimum().max(other.getMinimum()), this.getMaximum().min(other.getMaximum()));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!intersectsWith(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T start = (other.getMinimum().compareTo(getMinimum()) > 0) ? other.getMinimum() : getMinimum();\n    final T end = (other.getMaximum().compareTo(getMaximum()) < 0) ? other.getMaximum() : getMaximum();\n    return new Range<>(start, end);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other.isBefore(this)) {\n        throw new IllegalArgumentException(\"other must overlap this\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    final T min = this.min.compareTo(other.min) > 0 ? other.min : this.min;\n    final T max = this.max.compareTo(other.max) < 0 ? other.max : this.max;\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other.isConnected(this)) {\n        if (other.contains(this)) {\n            return this;\n        }\n        if (contains(other)) {\n            return other;\n        }\n        return new Range<>(this.getMinimum().max(other.getMinimum()), this.getMaximum().min(other.getMaximum()));\n    }\n    throw new IllegalArgumentException(\"Ranges must overlap\");\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!intersectsWith(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return new Range<>(other.getMinimum(), getMaximum());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n    }\n    if (isEqual(other)) {\n        return this;\n    }\n    return new Range<>(this.min.max(other.min), this.max.min(other.max));\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createGenerator(new UTF8Writer(ctxt, out), ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createGenerator(new UTF8Writer(ctxt, out), ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createGenerator(new UTF8Writer(ctxt, out), ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createGenerator(new UTF8Writer(ctxt, out), ctxt);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  }\n  else if (type.isUnionType()) \n  {\n    UnionType union = (UnionType) type;\n    List<JSType> alternatives = Lists.newArrayList();\n    for (JSType alternative : union.getAlternates()) \n    {\n      if (alternative.isNoResolvedType()) \n      {\n        alternatives.add(alternative);\n      }\n    }\n    if (alternatives.isEmpty()) \n    {\n      return type;\n    }\n    else if (alternatives.size() == 1) \n    {\n      return alternatives.get(0);\n    }\n    else \n    {\n      return registry.createUnionType(alternatives);\n    }\n  }\n  else \n  {\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnionType()) {\n    UnionType unionType = (UnionType) type;\n    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n    for (JSType alt : unionType.getAlternates()) {\n      if (alt.isNoResolvedType()) {\n        continue;\n      }\n      builder.add(alt);\n    }\n    if (builder.build().isEmpty()) {\n      return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return unionType.getRestrictedUnion(builder.build());\n  }\n\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return null;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnionType()) {\n    UnionType unionType = (UnionType) type;\n    List<JSType> alternatives = Lists.newArrayList();\n    for (JSType alternative : unionType.getAlternates()) {\n      if (alternative.isNoResolvedType()) {\n        return alternative;\n      }\n    }\n  }\n\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())\n    return type;\n  else\n    return NoResolvedType.getInstance();\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnionType()) {\n    UnionType unionType = (UnionType) type;\n    List<JSType> alternates = Lists.newArrayList();\n    for (JSType alternate : unionType.getAlternates()) {\n      if (alternate.isNoResolvedType()) {\n        alternates.add(alternate);\n      }\n    }\n\n    if (alternates.size() == 0) {\n      return type;\n    } else if (alternates.size() == 1) {\n      return alternates.get(0);\n    } else {\n      return registry.createUnionType(alternates);\n    }\n  }\n\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isUnknownType() || type.isNoType()) {\n    return type;\n  }\n\n  if (type.isObjectType()) {\n    ObjectType objType = type.toMaybeObjectType();\n    if (objType.isNoResolvedType()) {\n      return objType;\n    }\n  }\n\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isNoResolvedType()) {\n      return unionType;\n    }\n  }\n\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())\n    return type;\n  if (type.isUnionType())\n  {\n    UnionType ut = (UnionType) type;\n    List<JSType> types = ut.getAlternates();\n    List<JSType> filteredTypes = new ArrayList<JSType>();\n    for (JSType t : types)\n    {\n      if (t.isNoResolvedType())\n        continue;\n      filteredTypes.add(t);\n    }\n    if (filteredTypes.size() == 0)\n      return type;\n    return new UnionType(registry, filteredTypes);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType())\n    {\n        return type;\n    }\n    else if (type.isUnionType())\n    {\n        UnionType ut = (UnionType) type;\n        List<JSType> types = new ArrayList<>();\n        for (JSType t : ut.getAlternates())\n        {\n            types.add(filterNoResolvedType(t));\n        }\n        return getUnionType(types);\n    }\n    else if (type.isTemplatizedType())\n    {\n        TemplatizedType tt = (TemplatizedType) type;\n        return getTemplatizedType(filterNoResolvedType(tt.getReferencedType()), tt.getTemplateTypeMap());\n    }\n    else\n    {\n        return type;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return null;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      // If we did create a more precise scope, blindScope has a child and\n      // it is frozen. We can't just throw it away to return it. So we\n      // must create a child instead.\n      return blindScope == restrictedScope ?\n          blindScope : blindScope.createChildFlowScope();\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        // If we did create a more precise scope, blindScope has a child and\n        // it is frozen. We can't just throw it away to return it. So we\n        // must create a child instead.\n        return blindScope == restrictedScope ?\n                blindScope : blindScope.createChildFlowScope();\n    }\n    return blindScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    // javascript/jscomp/parsing/JsDocInfoParser.java\n    Node function = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (match(JsDocToken.LP)) {\n      // The type parameters are optional.\n      function.addChildToBack(parseTypeParameters(next()));\n      skipEOLs();\n      if (!match(JsDocToken.THIS)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n      }\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      Node typeName = parseTypeName(next());\n      if (typeName == null) {\n        return null;\n      }\n      function.addChildToBack(typeName);\n      skipEOLs();\n      if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n      }\n      next();\n      skipEOLs();\n      Node params = parseParametersType(next());\n      if (params == null) {\n        return null;\n      }\n      function.addChildToBack(params);\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n      skipEOLs();\n      Node result = parseResultType(next());\n      if (result == null) {\n        return null;\n      }\n      function.addChildToBack(result);\n      skipEOLs();\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n      return function;\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    // Parse type parameters\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n\n    // Parse '('\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // Parse 'this'\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    // Parse ':'\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    // Parse type name\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return null;\n    }\n\n    // Parse parameters\n    skipEOLs();\n    Node parameters = parseParameters(next());\n    if (parameters == null) {\n        return null;\n    }\n\n    // Parse ')'\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // Parse result type\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n\n    return newNode(Token.FUNCTION, typeParameters, parameters, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.FUNCTION)) \n    {\n        return null;\n    }\n    next();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    // TypeParameters\n    skipEOLs();\n    token = next();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters != null) \n    {\n        functionType.addChildToBack(typeParameters);\n    }\n\n    // '('\n    skipEOLs();\n    token = next();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // 'this' ':' TypeName\n    skipEOLs();\n    token = next();\n    if (!match(JsDocToken.THIS)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    skipEOLs();\n    token = next();\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    skipEOLs();\n    token = next();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n\n    // ParametersType\n    skipEOLs();\n    token = next();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    // ')'\n    skipEOLs();\n    token = next();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // ResultType\n    skipEOLs();\n    token = next();\n    Node resultType = parseResultType(token);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node function = newNode(Token.FUNCTION);\n  if (match(JsDocToken.TYPE_PARAMETERS)) {\n    function.addChildToBack(parseTypeParameters());\n  }\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  if (match(JsDocToken.THIS)) {\n    next();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    function.addChildToBack(parseTypeName(next()));\n  }\n  function.addChildToBack(parseParametersType());\n  function.addChildToBack(parseResultType(next()));\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return function;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToBack(typeParameters);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n\n  Node thisType = parseTypeName(next());\n  if (thisType == null) {\n    return null;\n  }\n  functionType.addChildToBack(thisType);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Preconditions.checkArgument(token == JsDocToken.FUNCTION);\n\n  skipEOLs();\n  token = next();\n  if (token == JsDocToken.ELLIPSIS) {\n    // We support double dots for backwards compatibility.\n    next();\n  }\n\n  skipEOLs();\n  Node typeParameters = parseTypeParameters(next());\n  if (typeParameters == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type.parameters\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  token = next();\n  if (token == JsDocToken.THIS) {\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.COLON) {\n      next();\n      skipEOLs();\n      token = next();\n    }\n  }\n\n  Node paramsType = parseParametersType(token);\n  if (paramsType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  token = next();\n\n  Node resultType = parseResultType(token);\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n  }\n\n  return newNode(Token.FUNCTION, typeParameters, paramsType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.FUNCTION);\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    skipEOLs();\n    token = next();\n\n    // TypeParameters\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters != null) {\n      functionType.addChildToFront(typeParameters);\n    }\n\n    // ParametersType\n    Node parametersType = parseParametersType(token);\n    if (parametersType != null) {\n      functionType.addChildToBack(parametersType);\n    }\n\n    // ResultType\n    Node resultType = parseResultType(token);\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.FUNCTION)) {\n      return null;\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node paramsType = parseParametersType(next());\n    if (paramsType == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return newNode(Token.FUNCTION, typeName, paramsType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.FUNCTION);\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.LT) {\n      functionType.addChildToBack(parseTypeParameters(token));\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    skipEOLs();\n    if (match(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      functionType.addChildToBack(parseTypeName(next()));\n      skipEOLs();\n    }\n\n    Node paramsType = parseParametersType(next());\n    if (paramsType == null) {\n      return null;\n    }\n    functionType.addChildToBack(paramsType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    skipEOLs();\n    functionType.addChildToBack(parseResultType(next()));\n\n    return functionType;\n  }"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addContributingStatistics(stat);\n    }\n    return aggregate.createAggregate();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues result = new StatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        result.addValue(stat);\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.add(stat);\n    }\n    return aggregate.createStatisticalSummaryValues();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stats : statistics) {\n        aggregate.addContributingStatistics(stats);\n    }\n    return aggregate.createAggregate();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues result = new StatisticalSummaryValues();\n    for (SummaryStatistics stats : statistics) {\n        result.add(stats);\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Initialize with first statistics\n    SummaryStatistics first = statistics.iterator().next();\n    StatisticalSummaryValues stats = new StatisticalSummaryValues(first.getN(), first.getSum(), first.getSumsq());\n\n    // Add remaining statistics\n    for (SummaryStatistics stat : statistics) {\n        stats.add(stat);\n    }\n\n    return stats;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues values = new StatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        values.add(stat.getStatisticalSummary());\n    }\n    return values;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues aggStats = new StatisticalSummaryValues();\n    for (SummaryStatistics stats : statistics) {\n        aggStats.add(stats);\n    }\n    return aggStats;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues result = new StatisticalSummaryValues();\n    for (SummaryStatistics stats : statistics) {\n        result.add(stats);\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues stats = new StatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) {\n        StatisticalSummaryValues contributingStats = stat.createContributingStatistics();\n        stats.add(contributingStats);\n    }\n    return stats;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            final double difference = sample1[i] - sample2[i] - meanDifference;\n            variance += difference * difference;\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_SAMPLES, n, 2, false);\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n    }\n    return sum / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            final double diff = sample1[i] - sample2[i];\n            variance += diff * diff;\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            final double diff = sample1[i] - sample2[i];\n            variance += diff * diff;\n        }\n        variance /= (n - 1);\n        return variance;\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_OF_SAMPLES, n, 2, false);\n    }\n    double variance = 0;\n    for (int i = 0; i < n; i++) {\n        variance += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n    }\n    return variance / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            final double difference = sample1[i] - sample2[i];\n            variance += difference * difference;\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            final double difference = sample1[i] - sample2[i];\n            sum += difference * difference;\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            variance += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]) / (n - 1);\n        }\n        return variance;\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, true);\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n    }\n    return sum / (n - 1);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) \n    {\n        Number value = dataset.getValue(item);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) \n    {\n        Number value = dataset.getValue(item);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) \n    {\n        Number value = dataset.getValue(item);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) \n    {\n        Number value = dataset.getValue(item);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = source.subSequence(pos, pos + peekedNameLength).toString();\n      pos += peekedNameLength;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = peekedString;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\"');\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\\'');\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = peekedString;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\\'');\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\"');\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = source.subSequence(pos, pos + peekedNameLength).toString();\n      pos += peekedNameLength;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = source.subSequence(pos + 1, nameEnd).toString();\n      pos = nameEnd + 1;\n      pathNames[stackSize - 1] = result;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      return nextQuotedValue('\\'');\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      return nextQuotedValue('\"');\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextUnquotedValue();\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextUnquotedValue();\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextUnquotedValue();\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = peekedString;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\"');\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = nextQuotedValue('\\'');\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = source.subSequence(pos + 1, pos + 1 + peekedNameLength).toString();\n        pos += 1 + peekedNameLength;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = nextQuotedValue('\"');\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = nextQuotedValue('\\'');\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = IOUtils.readFully(in, b, off, len);\n        count(read);\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        int read = IOUtils.readFully(in, b, off, len);\n        count(read);\n        return read;\n    } \n    else if (currentCompressedChunk != null) \n    {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) \n        {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew()) {\n    Node arg = node.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  } else if (parent.isGetProp() && parent.getFirstChild() == node) {\n    Node arg = node.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  } else {\n    return null;\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew() || parent.isGetProp()) {\n    Node arg = NodeUtil.getArgumentForCallOrNew(parent, argIndex);\n    if (arg != null) {\n      return arg;\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew()) {\n    Node arg = parent.getChildAtIndex(argIndex);\n    if (arg != null) {\n      return arg;\n    }\n  } else if (parent.isGetProp() && parent.getFirstChild() == node) {\n    Node arg = parent.getNext();\n    if (arg != null) {\n      return arg;\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  Node parent = site.node.getParent();\n  if (parent.isCall() || parent.isNew()) {\n    arg = parent.getChildAtIndex(argIndex);\n  } else if (parent.isGetProp() && parent.getFirstChild().isThis()) {\n    arg = parent.getNext();\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew()) {\n    return node.getChildAtIndex(argIndex);\n  } else if (parent.isGetProp()) {\n    Node grandParent = parent.getParent();\n    if (grandParent.isCall() || grandParent.isNew()) {\n      return node.getNext();\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n      // TODO(johnlenz): handle the case where the argument is a\n      // computed property.\n      Node arg = node.getChildAtIndex(argIndex);\n      if (arg != null) {\n        return arg;\n      }\n    } else if (node.isGetProp()) {\n      // TODO(johnlenz): handle the case where the argument is a\n      // computed property.\n      Node arg = node.getNext();\n      if (arg != null && argIndex == 0) {\n        return arg;\n      }\n    }\n    return null;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node node = site.node;\n  Node parent = node.getParent();\n  if (parent.isCall() || parent.isNew() || parent.isGetProp()) {\n    Node arg = node.getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  Node parent = site.node.getParent();\n  if (parent.isCall() || parent.isNew()) {\n    arg = parent.getChildAtIndex(argIndex);\n  } else if (parent.isGetProp() && parent.getFirstChild().isThis()) {\n    arg = parent.getNext();\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  if (site.node.isCall() || site.node.isNew()) {\n    arg = site.node.getChildAtIndex(argIndex);\n  } else if (site.node.isGetProp()) {\n    arg = site.node.getNext();\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall()) {\n        Node parent = site.node.getParent();\n        Node child = parent.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            child = child.getNext();\n        }\n        arg = child;\n    } else if (site.node.isGetProp()) {\n        Node parent = site.node.getParent();\n        Node child = parent.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            child = child.getNext();\n        }\n        arg = child;\n    }\n    return arg;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) \n    {\n        if (type.getDeprecationReason() != null) \n        {\n            return type.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) \n    {\n        return null;\n    }\n    JSType deprecatedType = type.restrictByNotNullOrUndefined();\n    if (deprecatedType.isFunctionType()) \n    {\n        JSDocInfo info = deprecatedType.toMaybeFunctionType().getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n            return \"\";\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) \n    {\n        if (type.getDeprecationReason() != null) \n        {\n            return type.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) \n    {\n        JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) \n    {\n        JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isFunctionType()) \n  {\n    JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) \n    {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) \n  {\n    return null;\n  }\n  if (type.isDeprecated()) \n  {\n    if (type.getDeprecationReason() != null) \n    {\n      return type.getDeprecationReason();\n    }\n    return \"\";\n  }\n  if (type.isObject()) \n  {\n    ObjectType objType = type.toMaybeObjectType();\n    if (objType != null && objType.getConstructor() != null) \n    {\n      return getTypeDeprecationInfo(objType.getConstructor().getType());\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) \n    {\n        return null;\n    }\n\n    if (type.isDeprecated()) \n    {\n        if (type.getDeprecationReason() != null) \n        {\n            return type.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n\n    if (type.isFunctionType()) \n    {\n        return getTypeDeprecationInfo(type.toMaybeFunctionType().getReturnType());\n    }\n\n    if (type.isObjectType()) \n    {\n        return getTypeDeprecationInfo(type.toMaybeObjectType().getImplicitPrototype());\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) \n    {\n        JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String value = TIME_ZONE_DISPLAY_CACHE.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_DISPLAY_CACHE.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = cache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = cache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = TIME_ZONE_NAME_CACHE.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_NAME_CACHE.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = cache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String value = TIME_ZONE_DISPLAY_CACHE.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_DISPLAY_CACHE.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = TIME_ZONE_NAMES.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_NAMES.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String value = TIME_ZONE_DISPLAY_CACHE.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_DISPLAY_CACHE.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String text = TIME_ZONE_NAME_CACHE.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_NAME_CACHE.put(key, text);\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneNameKey key = new TimeZoneNameKey(tz, daylight, style, locale);\n    String value = TIME_ZONE_FORMAT_CACHE.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        TIME_ZONE_FORMAT_CACHE.put(key, value);\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int index = this.columnKeys.indexOf(key);\n    if (index >= 0) {\n        return index;\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getColumnIndex(Comparable key)  {\n    // perform the search\n    int index = Collections.binarySearch(this.columnKeys, key);\n\n    // if the key was not found, return -1\n    if (index < 0) {\n        return -1;\n    }\n    // otherwise, return the index\n    else {\n        return index;\n    }\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.columnKeys.indexOf(key);\n    if (index >= 0) {\n        return index;\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: Implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) {\n        for (int i = 0; i < this.columnKeys.size(); i++) {\n            Comparable k = (Comparable) this.columnKeys.get(i);\n            if (k.equals(key)) {\n                result = i;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    if (this.columnKeys.isEmpty()) {\n        throw new UnknownKeyException(\"No column keys.\");\n    }\n\n    // find the index\n    int index = this.columnKeys.indexOf(key);\n    if (index < 0) {\n        throw new UnknownKeyException(\"Column key (\" + key + \") not recognised.\");\n    }\n\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: Implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.columnKeys.indexOf(key);\n    if (index < 0) {\n        throw new UnknownKeyException(\"Column key (\" + key + \") not recognised.\");\n    }\n    return index;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    return checkPoint(tree, point, tolerance);\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= getMin()) {\n        return (getMin() - point <= tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n    }\n    if (point >= getMax()) {\n        return (point - getMax() <= tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getInf()) {\n        return Location.OUTSIDE;\n    } else if (point > getSup()) {\n        return Location.OUTSIDE;\n    } else if (point <= getInf() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= getSup() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getMin()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getMax()) {\n            return Location.OUTSIDE;\n        }\n        if (point <= getMin() + tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (point >= getMax() - tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point <= getInf()) {\n            return (point >= getInf() - tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n        } else {\n            return (point <= getSup() + tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    return checkPoint(tree, point, tolerance);\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point <= getMin()) {\n            return (getMin() - point <= tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n        }\n        if (point >= getMax()) {\n            return (point - getMax() <= tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Double.isNaN(point)) {\n        return Location.OUTSIDE;\n    }\n    final double lower = getLower();\n    final double upper = getUpper();\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else if (point > upper) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        return checkPoint(tree, point, tolerance);\n    }"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000.0, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000.0, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000.0, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            minRatio = entry;\n            minRatioPositions = new ArrayList<Integer>();\n            minRatioPositions.add(i);\n        } else if (Precision.equals(entry, 0d, maxUlps)) {\n            minRatioPositions.add(i);\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n}\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n}\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            minRatio = entry;\n            minRatioPositions = new ArrayList<Integer>();\n            minRatioPositions.add(i);\n        } else if (Precision.equals(entry, 0d, maxUlps)) {\n            minRatioPositions.add(i);\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n}\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            minRatio = entry;\n            minRatioPositions = new ArrayList<Integer>();\n            minRatioPositions.add(i);\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n}\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            if (Precision.compareTo(entry, min, maxUlps) < 0) \n            {\n                min = entry;\n                col = i;\n            }\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            if (Precision.compareTo(entry, min, maxUlps) < 0) \n            {\n                min = entry;\n                col = i;\n            }\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && entry < min) \n        {\n            min = entry;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            if (Precision.compareTo(entry, min, maxUlps) < 0) {\n                min = entry;\n                col = i;\n            }\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && Precision.compareTo(entry, min, maxUlps) < 0) \n        {\n            min = entry;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double min = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            if (Precision.compareTo(entry, min, maxUlps) < 0) \n            {\n                min = entry;\n                col = i;\n            }\n        }\n    }\n    return col;\n}"
    ]
  ]
}