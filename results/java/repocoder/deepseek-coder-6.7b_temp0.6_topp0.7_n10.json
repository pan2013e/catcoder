{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.5261306532663318,
    "pass@1": 0.34874371859296477,
    "compile@3": 0.6076633165829143,
    "pass@3": 0.401465661641541,
    "compile@5": 0.6328068916008616,
    "pass@5": 0.4220507298396746
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        return task.getPercentComplete();\n    }\n    else \n    {\n        throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey);\n    }\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        return task.getPercentComplete();\n    }\n    else \n    {\n        throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey);\n    }\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        return task.getPercentComplete();\n    }\n    else \n    {\n        throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey);\n    }\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // get the row index\n    int row = getRowIndex(rowKey);\n    // get the task series\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    // get the task\n    Task task = series.get(columnKey.toString());\n    // if the task exists, return the percent complete\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    // if the task doesn't exist, return null\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: Implement this method.\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        return task.getPercentComplete();\n    }\n    else \n    {\n        throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey);\n    }\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // Implement your code here\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    final int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    final int index = indexOf(str);\n    if (index < 0) \n    {\n        return this;\n    }\n    deleteImpl(index, index + str.length(), str.length());\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n\n    final int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index != INDEX_NOT_FOUND) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str);\n        if (index != INDEX_NOT_FOUND) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  throws MatrixDimensionMismatchException {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() != 1) {\n        if (m.getRowDimension() != m.getColumnDimension()) {\n            throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), 1, 1);\n        }\n        final double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else {\n        final double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  throws MatrixDimensionMismatchException {\n        if (m.getColumnDimension() != 1) {\n            if (m.getRowDimension() != m.getColumnDimension()) {\n                throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), 1, 1);\n            }\n            final double[] d = new double[m.getRowDimension()];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[r] = m.getEntry(r, 0);\n            }\n            return MatrixUtils.createRealDiagonalMatrix(d);\n        } else {\n            final double[] d = new double[m.getRowDimension()];\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                d[r] = m.getEntry(r, 0);\n            }\n            return new Array2DRowRealMatrix(d);\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[] d = new double[m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d);\n    } \n    else \n    {\n        final double[] d = new double[m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            d[c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final double[] d;\n    if (nRows == 1 && nCols > 1) {\n        d = new double[nCols];\n        for (int c = 0; c < nCols; c++) {\n            d[c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else if (nRows == nCols) {\n        d = new double[nRows];\n        for (int r = 0; r < nRows; r++) {\n            d[r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else {\n        throw new IllegalArgumentException(\"Matrix must be a column or square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  throws MatrixDimensionMismatchException {\n    final int n = m.getRowDimension();\n    final int p = m.getColumnDimension();\n    if (n != p && n != 1) {\n        throw new MatrixDimensionMismatchException(n, p, 1, 1);\n    }\n    if (n == 1) {\n        final double[] d = new double[p];\n        for (int i = 0; i < p; i++) {\n            d[i] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else {\n        final double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  throws MatrixDimensionMismatchException {\n    if (m.getColumnDimension() == 1) {\n        final double[] v = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            v[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(v);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), 1, 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    if (n == 1) {\n        return new Array2DRowRealMatrix(new double[] {m.getEntry(0, 0)});\n    } else {\n        final double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  throws MatrixDimensionMismatchException {\n    final int n = m.getRowDimension();\n    final double[] d = new double[n];\n    if (m.getColumnDimension() == 1) { // m is a column matrix\n        for (int r = 0; r < n; r++) {\n            d[r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else if (m.getRowDimension() == n) { // m is a n-by-n matrix\n        for (int r = 0; r < n; r++) {\n            d[r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), n, n);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n;\n    if (m.getColumnDimension() == 1) \n    {\n        n = m.getRowDimension();\n        double[] v = new double[n];\n        for (int i = 0; i < n; i++) \n        {\n            v[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(v);\n    } \n    else \n    {\n        n = m.getColumnDimension();\n        double[][] d = new double[n][n];\n        for (int i = 0; i < n; i++) \n        {\n            d[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[] v = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            v[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(v);\n    } \n    else \n    {\n        final double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id.substring(3));\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id.substring(3));\n            return forOffsetMillis(offset);\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id.substring(3));\n            return forOffsetMillis(offset);\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            DateTimeZone zone = cProvider.getZone(convId);\n            if (zone != null) {\n                return zone;\n            }\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            DateTimeZone zone = cProvider.getZone(convId);\n            if (zone != null) {\n                return zone;\n            }\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (\"UTC\".equals(id)) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id.substring(3));\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x != 0) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x > 0) {\n                return this;\n            }\n\n            if (nans == INFINITE && x < 0) {\n                result = newInstance(this);\n                result.sign = (byte) -1;\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        for (int i = 0; i < a.mant.length; i++) {\n            result.mant[i] = a.mant[i] * x;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp += x;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = new Dfp(this);\n        int rh = 0;\n        for (int i = 0; i < result.mant.length; i++) {\n            final int r = result.mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp += x;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        int rh = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rh + mant[i] * x;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        if (rh != 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            Dfp result = newInstance(getZero());\n            result.nans = INFINITE;\n            return dotrap(rh, OVERFLOW_TRAP, result, result);\n        }\n\n        return this;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final long r = (long)mant[i] * x + rh;\n            rh = (int)(r / RADIX);\n            result.mant[i] = (int)(r - rh * RADIX);\n        }\n        result.exp += rh;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        int rh = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rh + mant[i]*x;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        if (rh != 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            Dfp result = newInstance(getZero());\n            result.nans = INFINITE;\n            return dotrap(DfpField.FLAG_OVERFLOW, MULTIPLY_TRAP, x, result);\n        }\n\n        return this;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n        result.exp += x;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x != x) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x < 0) {\n                result = newInstance(this);\n                result.sign = (byte) -1;\n                return result;\n            }\n\n            if (x > 0) {\n                result = newInstance(this);\n                result.sign = (byte) 1;\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x;\n            final int rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n            if (i < mant.length-1) {\n                mant[i+1] += rh;\n            }\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final long r = (long)mant[i]*x + rh;\n            rh = (int)(r / RADIX);\n            result.mant[i] = (int)(r - rh * RADIX);\n        }\n        result.exp += rh;\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = r - rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            result = dotrap(rl, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  ",
      "private Node createExternFunction(Node exportedFunction)  ",
      "private Node createExternFunction(Node exportedFunction)  ",
      "private Node createExternFunction(Node exportedFunction)  In the context provided, the function `createExternFunction` is being created to create an empty function with the same type as the original function, but with no function body. It does this by iterating over the children of the exported function and adding each child (which should be a parameter) to the function as a parameter.\n\nPlease provide the code for the function `createExternObjectLit` as well.",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function();\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n            function.addChildToBack(\n                IR.param(\n                    IR.stringKey(child.getString()),\n                    IR.number(index++)));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function();\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n            function.addChildToBack(\n                IR.param(\n                    IR.stringKey(child.getString()),\n                    IR.number(index++)));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  ",
      "private Node createExternFunction(Node exportedFunction)  The code snippet you need to complete is the `createExternFunction` method. It should create a function node with the same type and parameters as the input function node, but without a body.\n\nPlease note that this is a simplified version of the code. The actual implementation may need to handle more complex cases, such as functions with default parameters or getters and setters.\n\nAlso, the `IR.function()`, `IR.param()`, `IR.stringKey()`, and `IR.number()` methods are not real methods and are placeholders for the actual methods you would use to create a function node and its parameters in your specific codebase. You would need to replace these with the actual methods you have available.\n\nThe `JSDocInfo` class is also a placeholder and should be replaced with the actual class you use for handling JSDoc comments in your codebase.\n\nThe `Node` class is a placeholder for the actual class you use to represent nodes in your codebase. The actual class may have different methods and properties, but the ones used here should be similar.\n\nThe `Node` class should have methods for getting and setting the type of the node, adding children to the node, and getting the next node in the list of children. The actual methods you use may vary depending on your specific codebase.",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function();\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isStringKey()) {\n            function.addChildToBack(\n                IR.param(\n                    IR.stringKey(child.getString()),\n                    IR.number(index++)));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  "
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        int len = covariance.length;\n        double[] sigma = new double[len];\n        for (int i = 0; i < len; i++) {\n            sigma[i] = Math.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covarianceMatrix = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        int n = covarianceMatrix.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        int n = covariance.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covarianceMatrix = computeCovariances(params,\n                                                         covarianceSingularityThreshold);\n        int n = covarianceMatrix.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    int n = covariance.length;\n    double[] sigma = new double[n];\n    for (int i = 0; i < n; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariance = computeCovariances(params,\n                                               covarianceSingularityThreshold);\n    int len = covariance.length;\n    double[] sigma = new double[len];\n    for (int i = 0; i < len; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        int n = covariance.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covarianceMatrix = computeCovariances(params,\n                                                     covarianceSingularityThreshold);\n    int length = covarianceMatrix.length;\n    double[] sigma = new double[length];\n    for (int i = 0; i < length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    int n = covariances.length;\n    double[] sigmas = new double[n];\n    for (int i = 0; i < n; i++) {\n        sigmas[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        int n = covariance.length;\n        double[] sigma = new double[n];\n        for (int i = 0; i < n; i++) {\n            sigma[i] = Math.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CircularReferenceException(\"Circular reference detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new CircularReferenceException(\"Circular reference detected for variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CircularReferenceException(\"Circular reference detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CircularReferenceException(\"Circular reference detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CircularReferenceException(\"Circular reference detected in variable substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) \n        {\n            throw new CircularReferenceException(\"Circular reference detected: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CircularReferenceException(\"Circular reference detected: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            visit(root, visited, result);\n        }\n    }\n    if (sorted) {\n        Collections.reverse(result);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) {\n        if (!result.contains(root)) {\n            result.add(root);\n        }\n        getDependenciesOfHelper(root, result);\n    }\n    if (sorted) {\n        return sortDependencies(result);\n    } else {\n        return result;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Collect all symbols required by the roots.\n    Set<String> requiredSymbols = Sets.newHashSet();\n    for (INPUT root : roots) {\n      requiredSymbols.addAll(root.getRequires());\n    }\n\n    // Find all inputs that require any of the required symbols.\n    List<INPUT> candidates = Lists.newArrayList();\n    for (INPUT input : inputs) {\n      for (String required : input.getRequires()) {\n        if (requiredSymbols.contains(required)) {\n          candidates.add(input);\n          break;\n        }\n      }\n    }\n\n    // Sort the candidates.\n    if (sorted) {\n      new SortedDependencies<INPUT>(candidates);\n      return candidates;\n    } else {\n      return candidates;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Create a new list to hold the dependencies\n    List<INPUT> dependencies = new ArrayList<>();\n\n    // Create a set to hold the visited nodes\n    Set<INPUT> visited = new HashSet<>();\n\n    // Create a stack to hold the nodes to be visited\n    Stack<INPUT> stack = new Stack<>();\n\n    // Add the roots to the stack\n    for (INPUT root : roots) {\n        stack.push(root);\n    }\n\n    // While there are nodes to be visited\n    while (!stack.isEmpty()) {\n        INPUT node = stack.pop();\n\n        // If the node has not been visited yet\n        if (!visited.contains(node)) {\n            visited.add(node);\n\n            // Add the node to the dependencies\n            dependencies.add(node);\n\n            // Add the dependencies of the node to the stack\n            for (INPUT dependency : node.getDependencies()) {\n                stack.push(dependency);\n            }\n        }\n    }\n\n    // If the dependencies should be sorted\n    if (sorted) {\n        // Sort the dependencies\n        dependencies.sort(Comparator.naturalOrder());\n    }\n\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) \n    {\n        if (!result.contains(root)) \n        {\n            result.addAll(getDependenciesOf(root));\n        }\n    }\n    if (sorted) \n    {\n        sort(result);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // The dependency graph of inputs has a cycle iff sortedList is a proper\n    // subset of inputs. Also, it has a cycle iff the subgraph\n    // (inputs - sortedList) has a cycle. It's fairly easy to prove this\n    // by the lemma that a graph has a cycle iff it has a subgraph where\n    // no nodes have out-degree 0. I'll leave the proof of this as an exercise\n    // to the reader.\n    if (sorted && sortedList.containsAll(roots)) {\n      return sortedList;\n    }\n\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) {\n      result.add(root);\n      result.addAll(getDependenciesOf(root));\n    }\n\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencies(result));\n    }\n\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            visit(root, visited, result);\n        }\n    }\n    if (sorted) {\n        return sort(result);\n    } else {\n        return result;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            visit(root, visited, result);\n        }\n    }\n\n    if (sorted) {\n        return sort(result);\n    } else {\n        return result;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) {\n        result.addAll(getDependenciesOf(root));\n    }\n    if (sorted) {\n        result = sort(result);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Initialize the graph\n    List<INPUT> inputs = new ArrayList<>(roots);\n    Map<INPUT, Set<INPUT>> dependencies = new HashMap<>();\n    Map<INPUT, Set<INPUT>> dependents = new HashMap<>();\n\n    // Populate the graph\n    for (INPUT input : inputs) {\n        dependencies.put(input, new HashSet<>());\n        dependents.put(input, new HashSet<>());\n        for (String require : input.getRequires()) {\n            INPUT dependency = provideMap.get(require);\n            if (dependency != null) {\n                dependencies.get(input).add(dependency);\n                dependents.get(dependency).add(input);\n            }\n        }\n    }\n\n    // Remove the roots from the inputs\n    inputs.removeAll(roots);\n\n    // Remove the dependencies of the roots\n    for (INPUT root : roots) {\n        for (INPUT dependency : new ArrayList<>(dependencies.get(root))) {\n            dependencies.get(dependency).remove(root);\n            inputs.remove(dependency);\n        }\n    }\n\n    // If sorted is true, sort the inputs in topological order\n    if (sorted) {\n        return topologicallySort(inputs, dependencies, dependents);\n    }\n\n    // Otherwise, return the inputs in their original order\n    return inputs;\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = a.toString().toCharArray();\n\n    for (int i = 0; i < buf.length; i++) {\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = a.toString().toCharArray();\n\n    for (int i = 0; i < buf.length; i++) {\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = a.toString().toCharArray();\n\n    for (int i = 0; i < buf.length; i++) {\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n        Element parent = this.parent();\n        if (parent == null || parent instanceof Document) {\n            if (this.id().isEmpty()) {\n                return this.tag();\n            } else {\n                return \"#\" + this.id();\n            }\n        } else {\n            String parentSelector = parent.cssSelector();\n            int siblingIndex = this.elementSiblingIndex() + 1;\n            StringBuilder sb = new StringBuilder(parentSelector);\n            sb.append(\" > \").append(this.tag());\n            if (!this.className().isEmpty()) {\n                sb.append(\".\").append(this.className());\n            }\n            if (siblingIndex > 1) {\n                sb.append(\":nth-child(\").append(siblingIndex).append(\")\");\n            }\n            return sb.toString();\n        }\n    }",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    Element parent = this.parent();\n    if (parent != null && !(parent instanceof Document)) \n    {\n        selector.append(parent.cssSelector());\n        selector.append(\" > \");\n    }\n    if (!this.tag().isEmpty()) \n    {\n        selector.append(this.tag());\n    }\n    if (!this.id().isEmpty()) \n    {\n        selector.append(\"#\");\n        selector.append(this.id());\n    }\n    else \n    {\n        Set<String> classes = this.classNames();\n        for (String cls : classes) \n        {\n            selector.append(\".\");\n            selector.append(cls);\n        }\n        int siblingIndex = this.elementSiblingIndex();\n        if (siblingIndex > 0) \n        {\n            selector.append(\":nth-child(\");\n            selector.append(siblingIndex + 1);\n            selector.append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        if (!id().isEmpty()) {\n            return \"#\" + id();\n        }\n        Element parent = parent();\n        if (parent == null) {\n            return tag();\n        }\n        StringBuilder selector = new StringBuilder(parent.cssSelector());\n        selector.append(\" > \").append(tag());\n        if (!className().isEmpty()) {\n            selector.append(\".\").append(className());\n        }\n        int pos = calculatePosition(parent.root(), this);\n        if (pos > 1) {\n            selector.append(\":nth-child(\").append(pos).append(\")\");\n        }\n        return selector.toString();\n    }",
      "public String cssSelector()  {\n    if (!id().isEmpty()) {\n        return \"#\" + id();\n    }\n\n    StringBuilder selector = new StringBuilder();\n    Element parent = parent();\n    while (parent != null && !(parent instanceof Document)) {\n        selector.insert(0, parent.tag() + \":nth-child(\" + parent.childElements().indexOf(this) + \")\" + \">\");\n        parent = parent.parent();\n    }\n    if (!tag().equals(\"html\")) {\n        selector.append(tag());\n    }\n    for (String className : classNames()) {\n        selector.append(\".\").append(className);\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        StringBuilder sb = new StringBuilder();\n        Element e = this;\n        while (e.parent() != null && !(e.parent() instanceof Document)) {\n            String tag = e.tagName();\n            String id = e.id();\n            if (!tag.isEmpty()) {\n                sb.insert(0, tag + \":\");\n            }\n            if (!id.isEmpty()) {\n                sb.insert(0, \"#\" + id + \":\");\n            }\n            int pos = calculatePosition(e.parent(), e);\n            if (pos > 1) {\n                sb.insert(0, getPseudoClass() + \"(\" + pos + \")\");\n            }\n            sb.insert(0, \">\");\n            e = e.parent();\n        }\n        return sb.toString();\n    }",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    Element element = this;\n    while (element != null && !(element instanceof Document)) {\n        String tag = element.tagName();\n        selector.insert(0, \" > \" + tag);\n        if (!element.id().isEmpty()) {\n            selector.insert(0, \"#\" + element.id());\n            break;\n        }\n        element = element.parent();\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        Element parent = parent();\n        if (parent == null || parent instanceof Document) {\n            if (id().isEmpty()) {\n                return tag();\n            } else {\n                return \"#\" + id();\n            }\n        } else {\n            if (id().isEmpty()) {\n                return parent.cssSelector() + \" > \" + tag();\n            } else {\n                return parent.cssSelector() + \" > #\" + id();\n            }\n        }\n    }",
      "public String cssSelector()  {\n    if (!attributes().get(\"id\").isEmpty()) {\n        return \"#\" + attributes().get(\"id\");\n    }\n\n    StringBuilder sb = new StringBuilder();\n    Element parent = parent();\n    while (parent != null && !(parent instanceof Document)) {\n        sb.insert(0, parent.tag() + \":nth-child(\" + calculatePosition(root(), parent) + \")\");\n        if (parent.parent() != null && !(parent.parent() instanceof Document)) {\n            sb.insert(0, \">\");\n        }\n        parent = parent.parent();\n    }\n\n    Set<String> classes = classNames();\n    if (!classes.isEmpty()) {\n        sb.append(\".\").append(String.join(\".\", classes));\n    }\n\n    return sb.toString();\n}",
      "public String cssSelector()  {\n        if (!id().isEmpty()) {\n            return \"#\" + id();\n        }\n\n        Element parent = parent();\n        if (parent == null || parent instanceof Document) {\n            return tag();\n        }\n\n        StringBuilder sb = new StringBuilder(parent.cssSelector());\n        sb.append(\">\").append(tag());\n\n        Set<String> classes = classNames();\n        if (!classes.isEmpty()) {\n            for (String clazz : classes) {\n                sb.append(\".\").append(clazz);\n            }\n        }\n\n        Evaluator evaluator = Evaluator.getPseudoEvaluator(this);\n        if (evaluator != null) {\n            sb.append(evaluator.toString());\n        }\n\n        return sb.toString();\n    }",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    Element parent = this.parent();\n    while (parent != null && !(parent instanceof Document)) \n    {\n        String tag = parent.tagName();\n        selector.insert(0, tag + \" > \");\n        parent = parent.parent();\n    }\n\n    String id = this.id();\n    if (!id.isEmpty()) \n    {\n        selector.insert(0, \"#\" + id);\n    }\n\n    String tag = this.tagName();\n    Set<String> classes = this.classNames();\n    for (String cls : classes) \n    {\n        selector.append(\".\").append(cls);\n    }\n\n    Evaluator nthChild = this.getPseudoClass(Evaluator.IsNthChild.class);\n    if (nthChild != null) \n    {\n        selector.append(\":nth-child(\").append(((IsNthChild)nthChild).getA()).append(\")\");\n    }\n\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost += 2; // for the '!'\n    }\n    else if (n.getNodeType() == Node.AND_NODE || n.getNodeType() == Node.OR_NODE) \n    {\n        cost += 2; // for the parentheses\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost++;\n    }\n    for (Node child : n.getChildren()) \n    {\n        cost += estimateCostOneLevel(child);\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost++;\n    }\n    for (int i = 0; i < n.getNumChildren(); i++) \n    {\n        cost += estimateCostOneLevel(n.getChild(i));\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == NodeType.NOT) \n    {\n        cost += estimateCostOneLevel(n.getFirstChild());\n    }\n    else if (n.getNodeType() == NodeType.PAREN) \n    {\n        cost += estimateCostOneLevel(n.getFirstChild());\n    }\n    else \n    {\n        for (Node child : n.getChildren()) \n        {\n            cost += estimateCostOneLevel(child);\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost += 2; // for the \"!\"\n    }\n    else if (n.getNodeType() == Node.OR_NODE || n.getNodeType() == Node.AND_NODE) \n    {\n        for (int i = 0; i < n.getNumChildren(); i++) \n        {\n            cost += estimateCostOneLevel(n.getChild(i));\n        }\n    } \n    else if (n.getNodeType() == Node.PAREN_NODE) \n    {\n        cost += 2; // for the parentheses\n        cost += estimateCostOneLevel(n.getChild(0));\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == NodeType.NOT) \n    {\n        cost += estimateCostOneLevel(n.getChild(0));\n    }\n    else if (n.getNodeType() == NodeType.AND || n.getNodeType() == NodeType.OR) \n    {\n        for (int i = 0; i < n.getChildCount(); i++) \n        {\n            cost += estimateCostOneLevel(n.getChild(i));\n        }\n    }\n    else if (n.getNodeType() == NodeType.PAREN) \n    {\n        cost += estimateCostOneLevel(n.getChild(0));\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.OP_NOT) \n    {\n        cost++;\n    }\n    for (Node child : n.getChildren()) \n    {\n        cost += estimateCostOneLevel(child);\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost += 2; // for the \"!\"\n    }\n    else if (n.getNodeType() == Node.AND_NODE || n.getNodeType() == Node.OR_NODE) \n    {\n        cost += 2; // for the parentheses\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost += 2; // for the '!'\n    }\n    else if (n.getNodeType() == Node.AND_NODE || n.getNodeType() == Node.OR_NODE) \n    {\n        cost += 2; // for the '(' and ')'\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getNodeType() == Node.NOT_NODE) \n    {\n        cost++;\n    }\n    for (int i = 0; i < n.getNumChildren(); i++) \n    {\n        cost += estimateCostOneLevel(n.getChild(i));\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = length() - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char tmp;\n    while (j > i) \n    {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = length() - 1;\n    char tmp;\n    while (j > i) \n    {\n        tmp = charAt(j);\n        setCharAt(j, charAt(i));\n        setCharAt(i, tmp);\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = length() - 1;\n    char tmp;\n    while (j > i) {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = length() - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  ",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = length() - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char tmp;\n    while (j > i) \n    {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char tmp;\n    while (j > i) \n    {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n        String text = getWholeText();\n        if (offset >= text.length()) {\n            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is greater than text length \" + text.length());\n        }\n        String after = text.substring(offset);\n        String before = text.substring(0, offset);\n        TextNode newNode = new TextNode(after);\n        TextNode thisNode = new TextNode(before);\n        this.parent.insertAfter(this, newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n    // Your code here\n}",
      "public TextNode splitText(int offset)  {\n        String text = getWholeText();\n        if (offset >= text.length())\n            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is out of bounds for text node of length \" + text.length());\n        String textAfter = text.substring(offset);\n        String textBefore = text.substring(0, offset);\n        TextNode newNode = new TextNode(textAfter);\n        setWholeText(textBefore);\n        appendSibling(newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n        String text = this.text();\n        if (offset >= text.length()) {\n            throw new IllegalArgumentException(\"Offset is greater than the length of the text\");\n        }\n        String left = text.substring(0, offset);\n        String right = text.substring(offset);\n        TextNode newNode = new TextNode(right);\n        this.text(left);\n        this.parent.addChild(this.nextSibling, newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n        String text = getWholeText();\n        if (offset >= text.length()) {\n            throw new IllegalArgumentException(\"Offset is greater than the length of the text node\");\n        }\n        String newText = text.substring(offset);\n        TextNode newNode = new TextNode(newText);\n        text(text.substring(0, offset));\n        addSibling(newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n    // TODO: implement this method\n    return null;\n}",
      "public TextNode splitText(int offset)  {\n    // your code here\n}",
      "public TextNode splitText(int offset)  {\n        String text = getWholeText();\n        if (offset >= text.length())\n            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is greater than text length \" + text.length());\n        String text1 = text.substring(0, offset);\n        String text2 = text.substring(offset);\n        TextNode newNode = new TextNode(text2);\n        setWholeText(text1);\n        appendChild(newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n        String text = getWholeText();\n        if (offset >= text.length()) {\n            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is out of range for text node with length \" + text.length());\n        }\n        String after = text.substring(offset);\n        TextNode newNode = new TextNode(after);\n        setWholeText(text.substring(0, offset));\n        addSibling(newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n        String text = this.text();\n        if (offset >= text.length()) {\n            throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is out of range for text node of length \" + text.length());\n        }\n        String after = text.substring(offset);\n        this.text(text.substring(0, offset));\n        TextNode newNode = new TextNode(after);\n        this.parent.addChild(this.nextSibling, newNode);\n        return newNode;\n    }"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final Collection<O> result = new ArrayList<O>();\n    for (final O obj : helper) {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        int diff = max - min;\n        while (diff-- > 0) {\n            result.add(obj);\n        }\n    }\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final ArrayList<O> list = new ArrayList<O>();\n    for (final O obj : helper) {\n        int min = helper.min(obj);\n        int max = helper.max(obj);\n        int difference = max - min;\n        while (difference-- > 0) {\n            list.add(obj);\n        }\n    }\n    return list;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helperA = new SetOperationCardinalityHelper<O>(a, b);\n    final SetOperationCardinalityHelper<O> helperB = new SetOperationCardinalityHelper<O>(b, a);\n    final Collection<O> result = new ArrayList<O>();\n\n    for (final O obj : helperA) \n    {\n        final int cardinalityA = helperA.getCardinality(obj);\n        final int cardinalityB = helperB.getCardinality(obj);\n        final int difference = Math.max(cardinalityA, cardinalityB) - Math.min(cardinalityA, cardinalityB);\n\n        for (int i = 0; i < difference; i++) \n        {\n            result.add(obj);\n        }\n    }\n\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    Collection<O> result = new ArrayList<O>();\n\n    for(O element : unionCollection)\n    {\n        int countA = 0, countB = 0;\n\n        for(O e : a)\n        {\n            if(e.equals(element))\n                countA++;\n        }\n\n        for(O e : b)\n        {\n            if(e.equals(element))\n                countB++;\n        }\n\n        int maxCount = Math.max(countA, countB);\n        int minCount = Math.min(countA, countB);\n\n        int diff = maxCount - minCount;\n\n        while(diff-- > 0)\n            result.add(element);\n    }\n\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n        final ArrayList<O> list = new ArrayList<O>();\n        for (final O obj : helper) {\n            int min = helper.min(obj);\n            int max = helper.max(obj);\n            int diff = max - min;\n            for (int i = 0; i < diff; i++) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helperA = new SetOperationCardinalityHelper<O>(a, null);\n    final SetOperationCardinalityHelper<O> helperB = new SetOperationCardinalityHelper<O>(b, null);\n    final ArrayList<O> list = new ArrayList<O>();\n\n    for (final O obj : helperA) \n    {\n        int cardinalityA = helperA.getCardinality(obj);\n        int cardinalityB = helperB.getCardinality(obj);\n        int difference = Math.max(cardinalityA, cardinalityB) - Math.min(cardinalityA, cardinalityB);\n\n        for (int i = 0; i < difference; i++) \n        {\n            list.add(obj);\n        }\n    }\n\n    return list;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helperA = new SetOperationCardinalityHelper<O>(a, null);\n    final SetOperationCardinalityHelper<O> helperB = new SetOperationCardinalityHelper<O>(b, null);\n    final Collection<O> result = new ArrayList<O>();\n\n    for (final O obj : helperA) \n    {\n        final int cardinalityA = helperA.getCardinality(obj);\n        final int cardinalityB = helperB.getCardinality(obj);\n        final int difference = Math.max(cardinalityA, cardinalityB) - Math.min(cardinalityA, cardinalityB);\n\n        for (int i = 0; i < difference; i++) \n        {\n            result.add(obj);\n        }\n    }\n\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> unionCollection = union(a, b);\n    Collection<O> intersectionCollection = intersection(a, b);\n    Collection<O> result = new ArrayList<O>();\n\n    for (O element : unionCollection) \n    {\n        int countA = 0, countB = 0;\n        for (O elementA : a) \n        {\n            if (element.equals(elementA)) \n            {\n                countA++;\n            }\n        }\n        for (O elementB : b) \n        {\n            if (element.equals(elementB)) \n            {\n                countB++;\n            }\n        }\n\n        int difference = Math.max(countA, countB) - Math.min(countA, countB);\n        if (difference > 0) \n        {\n            for (int i = 0; i < difference; i++) \n            {\n                result.add(element);\n            }\n        }\n    }\n\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helperA = new SetOperationCardinalityHelper<O>(a, null);\n    final SetOperationCardinalityHelper<O> helperB = new SetOperationCardinalityHelper<O>(b, null);\n    final Collection<O> result = new ArrayList<O>();\n\n    for (final O obj : helperA) \n    {\n        int minCardinality = helperB.getCardinality(obj);\n        int maxCardinality = helperA.getCardinality(obj);\n\n        if (minCardinality == 0 && maxCardinality > 0) \n        {\n            for (int i = 0; i < maxCardinality; i++) \n            {\n                result.add(obj);\n            }\n        } \n        else if (maxCardinality > 0 && minCardinality > 0 && maxCardinality > minCardinality) \n        {\n            for (int i = 0; i < (maxCardinality - minCardinality); i++) \n            {\n                result.add(obj);\n            }\n        }\n    }\n\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helperA = new SetOperationCardinalityHelper<O>(a, null);\n    final SetOperationCardinalityHelper<O> helperB = new SetOperationCardinalityHelper<O>(b, null);\n    final Collection<O> result = new ArrayList<O>();\n    for (final O obj : helperA) \n    {\n        final int cardinalityA = helperA.getCardinality(obj);\n        final int cardinalityB = helperB.getCardinality(obj);\n        final int difference = Math.max(cardinalityA, cardinalityB) - Math.min(cardinalityA, cardinalityB);\n        for (int i = 0; i < difference; i++) \n        {\n            result.add(obj);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[WORD];\n        final byte[] bytes = value.toByteArray();\n        int length = bytes.length;\n        if (length > 8) {\n            throw new IllegalArgumentException(\"BigInteger too big to fit in 8 bytes\");\n        }\n        System.arraycopy(bytes, 0, result, 8 - length, length);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] temp = value.toByteArray();\n    if (temp.length > 8) {\n        throw new IllegalArgumentException(\"BigInteger too big: \" + value);\n    }\n    System.arraycopy(temp, 0, bytes, 8 - temp.length, temp.length);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[WORD];\n    byte[] val = value.toByteArray();\n    int len = val.length;\n    if (len > 8) {\n        throw new IllegalArgumentException(\"BigInteger too big: \" + value);\n    }\n    // pad with leading zeroes\n    for (int i = 0; i < 8 - len; i++) {\n        result[i] = 0;\n    }\n    // copy bytes, big endian style\n    for (int i = 0; i < len; i++) {\n        result[8 - len + i] = val[len - i - 1];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    BigInteger val = value;\n    for (int i = 7; i >= 0; i--) {\n        result[i] = val.byteValue();\n        val = val.shiftRight(8);\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] valBytes = value.toByteArray();\n    int length = valBytes.length;\n    if (length > 8) {\n        throw new IllegalArgumentException(\"BigInteger too big to fit in 8 bytes\");\n    }\n    System.arraycopy(valBytes, 0, bytes, 8 - length, length);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n    int length = temp.length;\n    if (length > 8) {\n        throw new IllegalArgumentException(\"BigInteger too large to fit in 8 bytes\");\n    }\n    System.arraycopy(temp, 0, result, 8 - length, length);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = value.toByteArray();\n        if (bytes[0] == 0) {\n            byte[] result = new byte[8];\n            System.arraycopy(bytes, 1, result, 3, 7);\n            return result;\n        } else {\n            byte[] result = new byte[8];\n            System.arraycopy(bytes, 0, result, 1, bytes.length);\n            return result;\n        }\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    BigInteger val = value;\n    if (val.signum() < 0) {\n        val = val.add(BigInteger.ONE.shiftLeft(64));\n    }\n    result[7] = val.and(BigInteger.valueOf(0xFF)).byteValue();\n    val = val.shiftRight(8);\n    for (int i = 6; i >= 0; i--) {\n        result[i] = val.and(BigInteger.valueOf(0xFF)).byteValue();\n        val = val.shiftRight(8);\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    BigInteger bigInt = value;\n    if (bigInt.signum() < 0) {\n        bigInt = bigInt.add(BigInteger.ONE.shiftLeft(64));\n    }\n    result[0] = (byte) (bigInt.and(BigInteger.valueOf(0xff))).intValue();\n    bigInt = bigInt.shiftRight(8);\n    for (int i = 1; i < 8; i++) {\n        result[i] = (byte) (bigInt.and(BigInteger.valueOf(0xff))).intValue();\n        bigInt = bigInt.shiftRight(8);\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] valBytes = value.toByteArray();\n    int length = valBytes.length;\n    if (length > 8) \n    {\n        throw new IllegalArgumentException(\"BigInteger too large to fit in 8 bytes\");\n    } \n    else if (length < 0) \n    {\n        throw new IllegalArgumentException(\"BigInteger too small to fit in 8 bytes\");\n    } \n    else \n    {\n        System.arraycopy(valBytes, 0, bytes, 8 - length, length);\n    }\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Compute the square root using Cholesky decomposition\n    CholeskyDecomposition chol = new CholeskyDecomposition(this);\n    return chol.getSolver().getInverse();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveSemidefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Perform the Cholesky decomposition\n    CholeskyDecomposition chol = new CholeskyDecomposition(getMatrix());\n    return chol.getSolver().getInverse();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveSemiDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    // Implement square root calculation here\n}",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric() || !isPositiveSemiDefinite()) {\n            throw new MathUnsupportedOperationException();\n        }\n\n        // Perform the Cholesky decomposition\n        CholeskyDecomposition chol = new CholeskyDecomposition(this);\n        return chol.getSolver().getInverse();\n    }",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    // Implementation of the square root of a matrix using the Cholesky decomposition\n    RealMatrix choleskyDecomposition = new CholeskyDecomposition(this).getL();\n    return choleskyDecomposition;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveSemiDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Perform the decomposition\n    QRDecomposition qr = new QRDecomposition(this);\n\n    // Get the square root by taking the square root of the diagonal elements\n    // and the rest as zero\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(this.getRowDimension(), this.getColumnDimension());\n    for (int i = 0; i < this.getRowDimension(); i++) {\n        sqrtMatrix.setEntry(i, i, Math.sqrt(this.getEntry(i, i)));\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Perform the Cholesky decomposition\n    CholeskyDecomposition chol = new CholeskyDecomposition(this);\n    return chol.getSolver().getInverse();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Perform the decomposition\n    QRDecomposition qrDecomposition = new QRDecomposition(this);\n\n    // Compute the square root by taking the square root of the diagonal\n    // elements of the R matrix and the square root of the diagonal elements\n    // of the inverse of the Q matrix\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(qrDecomposition.getR().getRowDimension(),\n                                                         qrDecomposition.getR().getColumnDimension());\n    RealMatrix sqrtQ = MatrixUtils.createRealMatrix(qrDecomposition.getQ().getRowDimension(),\n                                                    qrDecomposition.getQ().getColumnDimension());\n\n    for (int i = 0; i < sqrtMatrix.getRowDimension(); i++) {\n        for (int j = 0; j < sqrtMatrix.getColumnDimension(); j++) {\n            if (i == j) {\n                sqrtMatrix.setEntry(i, j, Math.sqrt(qrDecomposition.getR().getEntry(i, j)));\n                sqrtQ.setEntry(i, j, Math.sqrt(qrDecomposition.getQ().getEntry(i, j)));\n            } else {\n                sqrtMatrix.setEntry(i, j, 0);\n                sqrtQ.setEntry(i, j, 0);\n            }\n        }\n    }\n\n    return sqrtQ.multiply(sqrtMatrix);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Compute the Cholesky decomposition of the matrix\n    CholeskyDecomposition chol = new CholeskyDecomposition(this);\n\n    // The square root of the matrix is the upper triangular part of the Cholesky decomposition\n    return chol.getU();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n\n    // Implement the method here using the QR decomposition\n    QRDecomposition qrDecomposition = new QRDecomposition(this);\n    RealMatrix Q = qrDecomposition.getQ();\n    RealMatrix R = qrDecomposition.getR();\n\n    // The square root of a matrix is the matrix square root times the \n    // matrix square root of the inverse of the matrix square root.\n    // This can be computed using the QR decomposition.\n    RealMatrix sqrtMatrix = Q.multiply(R.getInverse());\n    return sqrtMatrix;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n             // String may be ok however:\n             // slightly redundant (since String was passed above), but\n             return _deserializeFromEmpty(p, ctxt);\n         }\n         if (t == JsonToken.START_OBJECT) {\n             t = p.nextToken();\n         }\n         if (t != JsonToken.FIELD_NAME) {\n             if (t == JsonToken.END_OBJECT) {\n                 return ctxt.reportInputMismatch(this,\n                         \"Cannot deserialize a Map.Entry out of empty JSON Object\");\n             }\n             return ctxt.handleUnexpectedToken(handledType(), p);\n         }\n\n         final KeyDeserializer keyDes = _keyDeserializer;\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n         final String keyStr = p.getCurrentName();\n         Object key = keyDes.deserializeKey(keyStr, ctxt);\n         Object value = null;\n         // And then the value...\n         t = p.nextToken();\n         try {\n             // Note: must handle null explicitly here; value deserializers won't\n             if (t == JsonToken.VALUE_NULL) {\n                 value = valueDes.getNullValue(ctxt);\n             } else if (typeDeser == null) {\n                 value = valueDes.deserialize(p, ctxt);\n             } else {\n                 value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n             }\n         } catch (Exception e) {\n             wrapAndThrow(e, Map.Entry.class, keyStr);\n         }\n         return new SimpleEntry<>(key, value);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t    if (t == JsonToken.VALUE_NULL) {\n    \t        return _nullProvider.getNullValue(ctxt);\n    \t    }\n    \t    if (t == JsonToken.VALUE_STRING) {\n    \t        final String string = p.getText();\n    \t        return _deserializeFromString(string, ctxt);\n    \t    }\n    \t    if (t == JsonToken.VALUE_NUMBER_INT) {\n    \t        final Number number = p.getNumberValue();\n    \t        return _deserializeFromNumber(number, ctxt);\n    \t    }\n    \t    if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t        final Number number = p.getNumberValue();\n    \t        return _deserializeFromNumber(number, ctxt);\n    \t    }\n    \t    if (t == JsonToken.VALUE_TRUE) {\n    \t        return Boolean.TRUE;\n    \t    }\n    \t    if (t == JsonToken.VALUE_FALSE) {\n    \t        return Boolean.FALSE;\n    \t    }\n    \t    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t        return p.getEmbeddedObject();\n    \t    }\n    \t    // Can't handle other types...\n    \t    return ctxt.handleUnexpectedToken(handledType(), p);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         // [databind#631]: Assign current value, to be accessible by custom deserializers\n         p.setCurrentValue(result);\n         // Ok: must point to START_OBJECT or FIELD_NAME\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             return ctxt.handleUnexpectedToken(getMapClass(), p);\n         }\n         _readAndBind(p, ctxt, result);\n         return result;\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     ",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn p.getText();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn p.getIntValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn p.getFloatValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn p.getEmbeddedObject();\n    \t\t}\n    \t\t// should not happen in standard (de-facto) JSON\n    \t\tthrow ctxt.mappingException(handledType(),\n    \t\t\t\t\"Unexpected token (%s), expected VALUE_STRING or NUMBER: %s\");\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            // String may be ok however:\n            // slightly redundant (since String was passed above), but\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        if (t != JsonToken.FIELD_NAME) {\n            if (t == JsonToken.END_OBJECT) {\n                return ctxt.reportInputMismatch(this,\n                        \"Cannot deserialize a Map.Entry out of empty JSON Object\");\n            }\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n\n        final KeyDeserializer keyDes = _keyDeserializer;\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        final String keyStr = p.getCurrentName();\n        Object key = keyDes.deserializeKey(keyStr, ctxt);\n        Object value = null;\n        // And then the value...\n        t = p.nextToken();\n        try {\n            // Note: must handle null explicitly here; value deserializers won't\n            if (t == JsonToken.VALUE_NULL) {\n                value = valueDes.getNullValue(ctxt);\n            } else if (typeDeser == null) {\n                value = valueDes.deserialize(p, ctxt);\n            } else {\n                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n            }\n        } catch (Exception e) {\n            wrapAndThrow(e, Map.Entry.class, keyStr);\n        }\n        return new AbstractMap.SimpleEntry<>(key, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     ",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn _nullProvider.getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn _deserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn _deserializeFromInt(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn _deserializeFromFloat(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn _deserializeFromEmbedded(p, ctxt);\n    \t\t}\n    \t\treturn _deserializeFromObject(p, ctxt);\n    \t}\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         if (t == JsonToken.VALUE_NULL) {\n             return _nullProvider.getNullValue(ctxt);\n         }\n         if (t == JsonToken.VALUE_STRING) {\n             return _deserializeFromString(p, ctxt);\n         }\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n             return _deserializeFromNumber(p, ctxt);\n         }\n         if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n             return _deserializeFromNumber(p, ctxt);\n         }\n         if (t == JsonToken.VALUE_TRUE) {\n             return Boolean.TRUE;\n         }\n         if (t == JsonToken.VALUE_FALSE) {\n             return Boolean.FALSE;\n         }\n         if (t == JsonToken.START_ARRAY) {\n             return _deserializeFromArray(p, ctxt);\n         }\n         if (t == JsonToken.START_OBJECT) {\n             return _deserializeFromObject(p, ctxt);\n         }\n         return ctxt.handleUnexpectedToken(handledType(), p);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     "
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunk.length);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunk.length;\n         int nextLen = fullChunk.length; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunk.length);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunk.length;\n         int nextLen = fullChunk.length; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLength = fullChunk.length;\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunkLength);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunkLength;\n         int nextLen = fullChunkLength; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunk.length);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunk.length;\n         int nextLen = fullChunk.length; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Node<Object[]> next = new Node<Object[]>(fullChunk, fullChunk.length);\n         if (_bufferHead == null) { // first chunk\n             _bufferHead = _bufferTail = next;\n         } else { // have something already\n             _bufferTail.linkNext(next);\n             _bufferTail = next;\n         }\n         _bufferedEntryCount += fullChunk.length;\n         int nextLen = fullChunk.length; // start with last chunk size\n         // double the size for small chunks\n         if (nextLen < SMALL_CHUNK_SIZE) {\n             nextLen += nextLen;\n         } else { // but by +25% for larger (to limit overhead)\n             nextLen += (nextLen >> 2);\n         }\n         return _constructArray(nextLen);\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  ",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  [DOCSTRING]\n\nThis function takes a string pattern as input and returns a DateTimeFormatter object that uses the provided pattern for formatting and parsing. The pattern is similar to the patterns used by java.text.SimpleDateFormat, but with some additional symbols and a few differences.\n\nParameters:\n- pattern (str): The pattern string to use for formatting and parsing.\n\nReturns:\n- DateTimeFormatter: A DateTimeFormatter object that uses the provided pattern.\n\nRaises:\n- IllegalArgumentException: If the pattern is invalid.\n\nExample:\n\nDateTimeFormatter formatter = DateTimeFormat.createFormatterForPattern(\"yyyy-MM-dd\");\nString formattedDate = formatter.print(new DateTime());\n\nThis will create a DateTimeFormatter that formats dates in the \"yyyy-MM-dd\" format.",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  [CONTEXT]\nThe DateTimeFormatterBuilder class is used to build a DateTimeFormatter. It is a chainable builder pattern, where you append elements to the builder, and then call toFormatter to get a DateTimeFormatter. The elements are appended in the order they are added.\n\nThe DateTimeFormatter class is the main class for formatting and parsing dates and times. It is created from a DateTimeFormatterBuilder.\n\nThe ISODateTimeFormat class provides a set of predefined formatters for common ISO formats.\n\nThe DateTimeFormat class provides a set of predefined formatters for common date and time formats.\n\nThe pattern syntax is mostly compatible with java.text.SimpleDateFormat - time zone names cannot be parsed and a few more symbols are supported. All ASCII letters are reserved as pattern letters, which are defined as follows:\n\nSymbol  Meaning                      Presentation  Examples\n------  -------                      ------------  -------\nG       era                          text          AD\nC       century of era (>=0)         number        20\nY       year of era (>=0)            year          1996\n\nx       weekyear                     year          1996\nw       week of weekyear             number        27\ne       day of week                  number        2\nE       day of week                  text          Tuesday; Tue\n\ny       year                         year          1996\nD       day of year                  number        189\nM       month of year                month         July; Jul; 07\nd       day of month                 number        10\n[/CONTEXT]",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  [CONTEXT]\nThe DateTimeFormatterBuilder class is used to build a DateTimeFormatter. The DateTimeFormatter class is used to format and parse date-time objects. The DateTimeFormat class is used to create DateTimeFormatters from patterns and styles. The ISODateTimeFormat class is used to create DateTimeFormatters from ISO patterns.\n\nThe DateTimeFormatterBuilder class has a method toFormatter() that converts the elements of the DateTimeFormatterBuilder into a DateTimeFormatter. The DateTimeFormatter class has methods to print and parse date-time objects. The DateTimeFormat class and ISODateTimeFormat class have factory methods to create DateTimeFormatters from patterns and styles.\n\nThe DateTimeFormat class and ISODateTimeFormat class have methods to create DateTimeFormatters from patterns and styles. The DateTimeFormat class has methods to create formatters from patterns and styles, and the ISODateTimeFormat class has methods to create formatters from ISO patterns.\n\nThe DateTimeFormat class and ISODateTimeFormat class have methods to create DateTimeFormatters from patterns and styles. The DateTimeFormat class has methods to create formatters from patterns and styles, and the ISODateTimeFormat class has methods to create formatters from ISO patterns.\n\nThe DateTimeFormat class and ISODateTimeFormat class have methods to create DateTimeFormatters from patterns and styles. The DateTimeFormat class has methods to create formatters from patterns and styles, and the ISODateTimeFormat class has methods to create formatters from ISO patterns.\n\nThe DateTimeFormat class and ISODateTimeFormat class have methods to create DateTimeFormatters from patterns and styles. The DateTimeFormat class has methods to create formatters from patterns and styles, and the ISODateTimeFormat class has methods to create formatters from ISO patterns.\n\nThe DateTimeFormat class and ISODateTimeFormat class have methods to create DateTimeFormatters from patterns and styles. The DateTimeFormat class has methods to create formatters from patterns and styles, and the ISODateTimeFormat class has methods to create formatters from ISO patterns."
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return new Node(Node.Kind.ASTERISK);\n      case NULL:\n        return new Node(Node.Kind.NULL);\n      case UNDEFINED:\n        return new Node(Node.Kind.UNDEFINED);\n      case TYPE_NAME:\n        return parseTypeNameAnnotation(token);\n      case FUNCTION_TYPE:\n        return parseFunctionTypeAnnotation(token);\n      case UNION_TYPE:\n        return parseUnionTypeAnnotation(token);\n      case RECORD_TYPE:\n        return parseRecordTypeAnnotation(token);\n      case ARRAY_TYPE:\n        return parseArrayTypeAnnotation(token);\n      default:\n        throw new IllegalArgumentException(\"Unexpected token: \" + token);\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case TYPE_NAME:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION_TYPE:\n            typeNode = parseFunctionTypeAnnotation(token);\n            break;\n        case UNION_TYPE:\n            typeNode = parseUnionTypeAnnotation(token);\n            break;\n        case RECORD_TYPE:\n            typeNode = parseRecordTypeAnnotation(token);\n            break;\n        case ARRAY_TYPE:\n            typeNode = parseArrayTypeAnnotation(token);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid token: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) \n    {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case TYPE_NAME:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION_TYPE:\n            typeNode = parseFunctionTypeAnnotation(token);\n            break;\n        case UNION_TYPE:\n            typeNode = parseUnionTypeAnnotation(token);\n            break;\n        case RECORD_TYPE:\n            typeNode = parseRecordTypeAnnotation(token);\n            break;\n        case ARRAY_TYPE:\n            typeNode = parseArrayTypeAnnotation(token);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unexpected token: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) \n    {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case IDENTIFIER:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION:\n            typeNode = parseFunctionTypeAnnotation();\n            break;\n        case UNION:\n            typeNode = parseUnionTypeAnnotation();\n            break;\n        case RECORD:\n            typeNode = parseRecordTypeAnnotation();\n            break;\n        case ARRAY:\n            typeNode = parseArrayTypeAnnotation();\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid token: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) \n    {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case TYPE_NAME:\n            typeNode = parseTypeName();\n            break;\n        case FUNCTION_TYPE:\n            typeNode = parseFunctionType();\n            break;\n        case UNION_TYPE:\n            typeNode = parseUnionType();\n            break;\n        case RECORD_TYPE:\n            typeNode = parseRecordType();\n            break;\n        case ARRAY_TYPE:\n            typeNode = parseArrayType();\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid token: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case ASTERISK:\n            return new Node(Node.Kind.ANY_TYPE);\n        case NULL:\n            return new Node(Node.Kind.NULL_TYPE);\n        case UNDEFINED:\n            return new Node(Node.Kind.UNDEFINED_TYPE);\n        case TYPE_NAME:\n            return parseTypeName();\n        case FUNCTION_TYPE:\n            return parseFunctionType();\n        case UNION_TYPE:\n            return parseUnionType();\n        case RECORD_TYPE:\n            return parseRecordType();\n        case ARRAY_TYPE:\n            return parseArrayType();\n        default:\n            throw new IllegalArgumentException(\"Unexpected token: \" + token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case TYPE_NAME:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION_TYPE:\n            typeNode = parseFunctionType();\n            break;\n        case UNION_TYPE:\n            typeNode = parseUnionType();\n            break;\n        case RECORD_TYPE:\n            typeNode = parseRecordType();\n            break;\n        case ARRAY_TYPE:\n            typeNode = parseArrayType();\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid token: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) \n    {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ANY_TYPE);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL_TYPE);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED_TYPE);\n            break;\n        case IDENTIFIER:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION:\n            typeNode = parseFunctionTypeAnnotation();\n            break;\n        case UNION:\n            typeNode = parseUnionTypeAnnotation();\n            break;\n        case RECORD:\n            typeNode = parseRecordTypeAnnotation();\n            break;\n        case ARRAY:\n            typeNode = parseArrayTypeAnnotation();\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid token type: \" + token);\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) \n    {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ANY_TYPE);\n            break;\n        case NULL:\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.NULL_TYPE);\n            break;\n        default:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n    }\n    return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node typeNode = null;\n    switch (token) {\n        case ASTERISK:\n            typeNode = new Node(Node.Kind.ASTERISK);\n            break;\n        case NULL:\n            typeNode = new Node(Node.Kind.NULL);\n            break;\n        case UNDEFINED:\n            typeNode = new Node(Node.Kind.UNDEFINED);\n            break;\n        case TYPE_NAME:\n            typeNode = parseTypeNameAnnotation(token);\n            break;\n        case FUNCTION_TYPE:\n            typeNode = parseFunctionTypeAnnotation(token);\n            break;\n        case UNION_TYPE:\n            typeNode = parseUnionTypeAnnotation(token);\n            break;\n        case RECORD_TYPE:\n            typeNode = parseRecordTypeAnnotation(token);\n            break;\n        case ARRAY_TYPE:\n            typeNode = parseArrayTypeAnnotation(token);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unexpected token: \" + token);\n    }\n    return typeNode;\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    deferredName = null;\n    return this;\n  }"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        if (!Double.isNaN(total)) \n        {\n            minimum = Math.min(minimum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n                minimum = Math.min(minimum, total);\n            }\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        if (!Double.isNaN(total)) \n        {\n            minimum = Math.min(minimum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n                minimum = Math.min(minimum, total);\n            }\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n                minimum = Math.min(minimum, total);\n            }\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        if (!Double.isNaN(total)) \n        {\n            minimum = Math.min(minimum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        if (!Double.isNaN(total)) \n        {\n            minimum = Math.min(minimum, total);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  The function findMinimumStackedRangeValue(CategoryDataset dataset) calculates the minimum value in the dataset range, assuming that values in each category are \"stacked\". It initializes the minimum value to 0.0 and iterates over each category in the dataset. For each category, it iterates over each series in the category and adds the value of the series to a total. It then updates the minimum value if the total is less than the current minimum. If the dataset contains any valid data, it returns the minimum value as a Double. Otherwise, it returns null.\n\nThe function is designed to handle CategoryDataset objects, which are used to represent datasets with categorical data. The function uses the getColumnCount() and getRowCount() methods to determine the number of categories and series in the dataset, respectively. The getValue(int, int) method is used to retrieve the value of each series in a category.\n\nThe function throws an IllegalArgumentException if the input dataset is null."
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    final int len = str.length();\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            sb.append(Character.toUpperCase(ch));\n            inWord = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean lastDelim = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastDelim = true;\n        } else if (lastDelim) {\n            sb.append(Character.toUpperCase(ch));\n            lastDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final StringBuilder sb = new StringBuilder();\n    boolean inWord = false;\n    final int len = str.length();\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            sb.append(ch);\n            inWord = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean afterDelimiter = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            afterDelimiter = true;\n        } else if (afterDelimiter) {\n            sb.append(ch);\n            afterDelimiter = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean lastDelim = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastDelim = true;\n        } else if (lastDelim) {\n            sb.append(ch);\n            lastDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean lastDelim = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastDelim = true;\n        } else if (lastDelim) {\n            sb.append(Character.toUpperCase(ch));\n            lastDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean prevDelim = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            prevDelim = true;\n        } else if (prevDelim) {\n            sb.append(Character.toUpperCase(ch));\n            prevDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean prevIsDelimiter = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            prevIsDelimiter = true;\n        } else if (prevIsDelimiter) {\n            sb.append(Character.toUpperCase(ch));\n            prevIsDelimiter = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean lastDelim = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastDelim = true;\n        } else if (lastDelim) {\n            sb.append(Character.toUpperCase(ch));\n            lastDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean prevIsDelimiter = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            prevIsDelimiter = true;\n        } else if (prevIsDelimiter) {\n            sb.append(Character.toUpperCase(ch));\n            prevIsDelimiter = false;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null screenPoint\");\n    }\n\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"null not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null screenPoint not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null point not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null screenPoint not permitted\");\n    }\n\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null argument not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null screenPoint not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null screenPoint\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null screenPoint not permitted\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null screenPoint\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition pos = new ParsePosition(0);\n        BigFraction fraction = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return fraction;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition pos = new ParsePosition(0);\n        BigFraction fraction = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return fraction;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition pos = new ParsePosition(0);\n        BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> tempList = new ArrayList<E>(new HashSet<E>(list));\n    list.clear();\n    list.addAll(tempList);\n    return new ListOrderedSet<E>(new HashSet<E>(tempList), tempList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    List<E> tempList = new ArrayList<>(new HashSet<>(list));\n    // Create a new ListOrderedSet with the unique list\n    return new ListOrderedSet<>(new HashSet<>(), tempList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> uniqueList = new ArrayList<E>(new HashSet<E>(list));\n    return new ListOrderedSet<E>(new HashSet<E>(uniqueList), uniqueList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> tempList = new ArrayList<E>(list);\n    list.clear();\n    Set<E> tempSet = new HashSet<E>(tempList);\n    return new ListOrderedSet<E>(tempSet, tempList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> uniqueList = new ArrayList<E>(new HashSet<E>(list));\n    return new ListOrderedSet<E>(new HashSet<E>(uniqueList), uniqueList);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> tempList = new ArrayList<>(new HashSet<>(list));\n    return new ListOrderedSet<>(new HashSet<>(tempList), tempList);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) \n    {\n        NumberAxis numberAxis = (NumberAxis) axis;\n        double lowerBound = Double.POSITIVE_INFINITY;\n        double upperBound = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < subplotCount(); i++) \n        {\n            Range range = getSubplot(i).getDataRange(numberAxis);\n            if (range != null) \n            {\n                double lower = range.getLowerBound();\n                double upper = range.getUpperBound();\n                if (lower < lowerBound) \n                {\n                    lowerBound = lower;\n                }\n                if (upper > upperBound) \n                {\n                    upperBound = upper;\n                }\n            }\n        }\n        return new Range(lowerBound, upperBound);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    List subplots = getSubplots();\n    if (subplots != null) \n    {\n        for (int i = 0; i < subplots.size(); i++) \n        {\n            ValueAxisPlot subplot = (ValueAxisPlot) subplots.get(i);\n            Range temp = subplot.getDataRange(axis);\n            if (temp != null) \n            {\n                if (result == null) \n                {\n                    result = new Range(temp);\n                } \n                else \n                {\n                    result.union(temp);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis instanceof NumberAxis) \n    {\n        result = new Range(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);\n    } \n    else if (axis instanceof DateAxis) \n    {\n        result = new Range(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Unsupported axis type: \" + axis.getClass().getName());\n    }\n\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // find the subplots\n    List subplots = getSubplots();\n\n    // initialize the range to null\n    Range result = null;\n\n    // iterate over the subplots\n    for (int i = 0; i < subplots.size(); i++) \n    {\n        // get the subplot\n        Plot subplot = (Plot) subplots.get(i);\n\n        // get the data range for the subplot\n        Range subplotRange = subplot.getDataRange(axis);\n\n        // if the subplot range is not null, and the result is null,\n        // or the subplot range intersects with the result, update the result\n        if (subplotRange != null) \n        {\n            if ((result == null) || (result.intersects(subplotRange))) \n            {\n                result = subplotRange;\n            }\n        }\n    }\n\n    // return the result\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis numberAxis = (NumberAxis) axis;\n        Number min = Number.MAX_VALUE;\n        Number max = Number.MIN_VALUE;\n        for (Plot plot : this.subplots) {\n            if (plot instanceof ValueAxisPlot) {\n                Range range = ((ValueAxisPlot) plot).getDataRange(axis);\n                if (range != null) {\n                    min = range.getLowerBound().doubleValue() < min.doubleValue() ? range.getLowerBound() : min;\n                    max = range.getUpperBound().doubleValue() > max.doubleValue() ? range.getUpperBound() : max;\n                }\n            }\n        }\n        if (min.doubleValue() <= max.doubleValue()) {\n            return new Range(min, max);\n        }\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // get the subplots\n    Plot[] subplots = getSubplots();\n    if (subplots == null) {\n        return null;\n    }\n\n    // get the range axis\n    ValueAxis rangeAxis = getRangeAxis();\n    if (rangeAxis == null) {\n        return null;\n    }\n\n    // get the data range from the subplots\n    Range dataRange = null;\n    for (int i = 0; i < subplots.length; i++) {\n        if (subplots[i] instanceof ValueAxisPlot) {\n            Range subplotRange = ((ValueAxisPlot) subplots[i]).getDataRange(rangeAxis);\n            if (subplotRange != null) {\n                if (dataRange == null) {\n                    dataRange = new Range(subplotRange);\n                } else {\n                    dataRange.combine(subplotRange);\n                }\n            }\n        }\n    }\n\n    return dataRange;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis instanceof NumberAxis) {\n        result = new Range(Double.NaN, Double.NaN);\n    } else {\n        result = new Range(null, null);\n    }\n\n    List subplots = getSubplots();\n    for (int i = 0; i < subplots.size(); i++) {\n        Plot subplot = (Plot) subplots.get(i);\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null) {\n            if (result.isNaN()) {\n                result = new Range(subplotRange);\n            } else {\n                result.add(subplotRange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis instanceof NumberAxis) \n    {\n        result = new Range(Double.NaN, Double.NaN);\n    } \n    else \n    {\n        result = new Range(null, null);\n    }\n\n    for (int i = 0; i < subplotCount(); i++) \n    {\n        ValueAxisPlot subplot = getSubplot(i);\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null) \n        {\n            if (result.isNaN()) \n            {\n                result = new Range(subplotRange);\n            } \n            else \n            {\n                result.expandToInclude(subplotRange);\n            }\n        }\n    }\n\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    // Your code goes here\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n    Range result = null;\n    if (axis instanceof NumberAxis) {\n        result = new Range(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);\n        for (Plot plot : getSubplots()) {\n            if (plot instanceof ValueAxisPlot) {\n                Range range = ((ValueAxisPlot) plot).getDataRange(axis);\n                if (range != null) {\n                    result = result.combine(range);\n                }\n            }\n        }\n    } else {\n        // non-numeric axis, just get the data range from the first subplot\n        if (!getSubplots().isEmpty()) {\n            Plot subplot = getSubplots().get(0);\n            if (subplot instanceof ValueAxisPlot) {\n                result = ((ValueAxisPlot) subplot).getDataRange(axis);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = -Math.log10(1.0 - val); //invert adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = -Math.log(val) / Math.log(0.1); //invert adjustPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / 0.09; //invert adjustPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = -Math.log(val) / Math.log(0.1); //invert adjustPow10\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = -Math.log10(1.0 - val); //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg.getNodes()) \n    {\n        if (n.isBlock()) \n        {\n            boolean hasReturn = false;\n            for (Node child : n.children()) \n            {\n                if (child.isReturn()) \n                {\n                    hasReturn = true;\n                    break;\n                }\n            }\n            if (!hasReturn) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.nodes()) \n    {\n        if (!isReturnBlock(node) && !isReturnExpressBlock(node) && !isReturnExpression(node)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) \n    {\n        if (node.isBlock() || node.isLoop()) \n        {\n            boolean hasReturn = false;\n            for (Node child : node.children()) \n            {\n                if (child.isReturn()) \n                {\n                    hasReturn = true;\n                    break;\n                }\n            }\n            if (!hasReturn) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg.getNodes()) \n    {\n        if (n.isReturn() || n.isGoto() || n.isThrow()) \n        {\n            continue;\n        }\n\n        for (Node succ : cfg.getSuccessors(n)) \n        {\n            if (!(succ.isReturn() || succ.isGoto() || succ.isThrow())) \n            {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg.nodes()) \n    {\n        if (!n.isReturn() && !n.isThrow()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg.nodes()) \n    {\n        if (!isReturnBlock(n) && !isReturnExpressBlock(n) && !isReturnExpression(n)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) \n    {\n        if (node.isBlock()) \n        {\n            boolean hasReturn = false;\n            for (Node child : node.children()) \n            {\n                if (child.isReturn()) \n                {\n                    hasReturn = true;\n                    break;\n                }\n            }\n            if (!hasReturn) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Set<Node> allNodes = cfg.getAllNodes();\n    for (Node node : allNodes) \n    {\n        if (node.isReturn()) \n        {\n            continue;\n        }\n        Node parent = node.getParent();\n        if (parent == null) \n        {\n            return false;\n        }\n        Node grandParent = parent.getParent();\n        if (grandParent == null) \n        {\n            return false;\n        }\n        if (!grandParent.isIf()) \n        {\n            return false;\n        }\n        Node condition = grandParent.getFirstChild();\n        if (condition != node) \n        {\n            return false;\n        }\n        Node trueBranch = grandParent.getNext();\n        if (trueBranch.getFirstChild() != node) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg.getNodes()) \n    {\n        if (n.isBlock()) \n        {\n            boolean foundReturn = false;\n            for (Node child : n.children()) \n            {\n                if (child.isReturn()) \n                {\n                    foundReturn = true;\n                    break;\n                }\n            }\n            if (!foundReturn) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) \n    {\n        if (node.isReturn()) \n        {\n            continue;\n        }\n        for (Node child : node.children()) \n        {\n            if (!fastAllPathsReturnCheck(cfg, child)) \n            {\n                return false;\n            }\n        }\n        return false;\n    }\n    return true;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].divide(a[0].add(a[1]));\n    result[1] = a[1].divide(a[0].add(a[1]));\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] result = new Dfp[2];\n\n    // Compute x = (a[0] + 1) / (a[0] - 1)\n    Dfp x = a[0].add(1);\n    x = x.divide(a[0].subtract(1));\n\n    // Compute the series expansion\n    Dfp y  = a[0].getOne();\n    Dfp py = a[0].getOne();\n    Dfp f  = a[0].getOne();\n    Dfp fi = a[0].getOne();\n    Dfp x2 = x.multiply(x);\n    for (int i = 0; i < 10000; i++) {\n        f = f.multiply(x2);\n        fi = fi.add(a[0].getOne());\n        y = y.add(x.divide(fi));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    // Compute the result\n    result[0] = y;\n    result[1] = a[1].multiply(x).subtract(a[0].multiply(y));\n    result[1] = result[1].divide(f);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] result = new Dfp[2];\n\n        result[0] = a[0].divide(a[0].add(a[1]));\n        result[1] = a[1].divide(a[0].add(a[1]));\n\n        return result;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  ",
      "protected static Dfp[] logInternal(final Dfp a[])  ",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] result = new Dfp[2];\n\n        Dfp x = a[0].add(a[1]);\n        x = x.add(a[0].subtract(a[1]));\n        x = x.divide(a[0].multiply(a[0]).subtract(a[0].multiply(a[1])));\n\n        result[0] = a[0].multiply(x);\n        result[1] = a[1].multiply(x);\n\n        return result;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].divide(a[0].add(a[1]));\n    result[1] = a[1].multiply(a[0]).subtract(a[0].multiply(a[1]));\n    result[1] = result[1].divide(a[0].multiply(a[0]).add(a[0].multiply(a[1])));\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] result = new Dfp[2];\n\n        result[0] = a[0].divide(a[0].add(a[1]));\n        result[1] = a[1].divide(a[0].add(a[1]));\n\n        return result;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] result = new Dfp[2];\n\n        Dfp x = a[0].add(a[1]);\n        x = x.divide(a[0].subtract(a[1]));\n        x = x.divide(a[0].add(a[1]));\n\n        Dfp y  = a[0].getOne();\n        Dfp py = a[0].getOne();\n        Dfp f  = a[0].getOne();\n        Dfp fi = a[0].getOne();\n\n        for (int i = 0; i < 10000; i++) {\n            x = x.multiply(a[0]);\n            y = y.add(x.divide(f));\n            fi = fi.add(a[0].getOne());\n            f = f.multiply(fi);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        result[0] = y.multiply(a[0].getTwo());\n        result[1] = y.multiply(a[1]);\n\n        return result;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n\n        Dfp[] result = new Dfp[2];\n\n        result[0] = a[0].divide(a[0].add(a[1]));\n        result[1] = a[1].divide(a[0].add(a[1]));\n\n        return result;\n    }"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) \n        {\n            Collection<V> values = decorated().get(key);\n            if (values.remove(value)) \n            {\n                if (values.isEmpty()) \n                {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!decorated().containsKey(key)) {\n            return false;\n        }\n        final Collection<V> values = decorated().get(key);\n        if (values.remove(value)) {\n            if (values.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) \n        {\n            final Collection<V> values = decorated().get(key);\n            if (values.remove(value)) \n            {\n                if (values.isEmpty()) \n                {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!containsKey(key)) {\n            return false;\n        }\n        final Collection<V> values = decorated().get(key);\n        if (values == null || !values.remove(value)) {\n            return false;\n        }\n        if (values.isEmpty()) {\n            decorated().remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) {\n            final Collection<V> values = decorated().get(key);\n            if (values.remove(value)) {\n                if (values.isEmpty()) {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!decorated().containsKey(key)) {\n            return false;\n        }\n        final Collection<V> values = decorated().get(key);\n        final boolean removed = values.remove(value);\n        if (values.isEmpty()) {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!decorated().containsKey(key)) \n        {\n            return false;\n        }\n        final Collection<V> collection = decorated().get(key);\n        final boolean removed = collection.remove(value);\n        if (collection.isEmpty()) \n        {\n            decorated().remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) \n        {\n            Collection<V> values = decorated().get(key);\n            if (values.remove(value)) \n            {\n                if (values.isEmpty()) \n                {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) {\n            Collection<V> values = decorated().get(key);\n            if (values != null && values.remove(value)) {\n                if (values.isEmpty()) {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (decorated().containsKey(key)) {\n            Collection<V> collection = decorated().get(key);\n            if (collection.remove(value)) {\n                if (collection.isEmpty()) {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setText(\"\\\"\" + node.getText() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n        Node node = justTransform(n);\n        if (node.getType() == Token.NAME) \n        {\n            node.setType(Token.STRING);\n            node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n        Node node = justTransform(n);\n        if (node.getType() == Token.NAME) {\n            node.setType(Token.STRING);\n            node.setValue('\"' + node.getValue() + '\"');\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n        Node node = transform(n);\n        if (node.getType() == Token.NAME) {\n            node.setType(Token.STRING);\n            node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n        Node node = justTransform(n);\n        if (node.getType() == Token.NAME) \n        {\n            node.setType(Token.STRING);\n            node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    } \n    else if (node.getType() == Token.STRING) \n    {\n        node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = justTransform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setValue('\"' + node.getValue() + '\"');\n    } \n    else if (node.getType() == Token.STRING) \n    {\n        node.setValue(node.getValue().substring(1, node.getValue().length() - 1));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n        Node node = transform(n);\n        if (node.getType() == Token.NAME) \n        {\n            node.setType(Token.STRING);\n            node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n        Node node = transform(n);\n        if (node.getType() == Token.NAME) \n        {\n            node.setType(Token.STRING);\n            node.setValue(\"\\\"\" + node.getValue() + \"\\\"\");\n        }\n        return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setText(String.format(\"\\\"%s\\\"\", node.getText()));\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number value = dataset.getValue(row, category);\n            if (value != null) {\n                double v = value.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double posBase = base;\n        double negBase = base;\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                if (v > 0) {\n                    posBase += v;\n                    result.add(new Double(posBase));\n                }\n                else {\n                    negBase += v;\n                    result.add(new Double(negBase));\n                }\n            }\n            else {\n                result.add(new Double(posBase));\n            }\n        }\n        return result;\n    }\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null || childElementsList.size() != childNodes.size()) {\n        childElementsList = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsList.add((Element) child);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null || childElementsList.size() != childNodes.size()) {\n        childElementsList = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElementsList.add((Element) node);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null) {\n        childElementsList = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsList.add((Element) child);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null) {\n        childElementsList = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsList.add((Element) child);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null || childElementsList.size() != childNodes.size()) {\n        childElementsList = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                childElementsList.add((Element) child);\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsListCache == null) {\n        childElementsListCache = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElementsListCache.add((Element) child);\n            }\n        }\n    }\n    return childElementsListCache;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null || childElementsList.size() != childNodes.size()) {\n        childElementsList = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElementsList.add((Element) node);\n            }\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsList == null || childElementsList.size() != childNodes.size()) {\n        childElementsList = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                childElementsList.add((Element) child);\n        }\n    }\n    return childElementsList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElementsListCache == null || childElementsListCacheVersion != childNodesVersion) {\n        childElementsListCache = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElementsListCache.add((Element) node);\n            }\n        }\n        childElementsListCacheVersion = childNodesVersion;\n    }\n    return childElementsListCache;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n        int hashCode = key.hashCode();\n        return hashCode & (buckets.length - 1);\n    }",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    int hashIndex = hashCode & (buckets.length - 1);\n    return hashIndex;\n}",
      "private int getHash(final Object key)  {\n        int hashCode = key.hashCode();\n        return hashCode & (buckets.length - 1);\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    int index = hashCode & (buckets.length - 1);\n    return index;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    int hashIndex = hashCode & (buckets.length - 1);\n    return hashIndex;\n}",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode()) % buckets.length;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final int rowCount = m.getRowDimension();\n        final int colCount = m.getColumnDimension();\n        final RealMatrix out = m.copy();\n        for (int i = 0; i < rowCount; i++) {\n            for (int j = 0; j < colCount; j++) {\n                if (i > j + k) {\n                    out.setEntry(i, j, 0);\n                }\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final int rowCount = m.getRowDimension();\n        final int columnCount = m.getColumnDimension();\n        final RealMatrix out = m.copy();\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                if (row > col + k) {\n                    out.setEntry(row, col, 0);\n                }\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final int rowCount = m.getRowDimension();\n        final int columnCount = m.getColumnDimension();\n        final RealMatrix out = m.copy();\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                if (row > col + k) {\n                    out.setEntry(row, col, 0);\n                }\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final int rowCount = m.getRowDimension();\n        final int columnCount = m.getColumnDimension();\n        final RealMatrix out = m.copy();\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                if (row > col + k) {\n                    out.setEntry(row, col, 0);\n                }\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if(r <= c + k)\n                    d[r][c] = m.getEntry(r, c);\n                else\n                    d[r][c] = 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if(r <= c+k)\n                    d[r][c] = m.getEntry(r, c);\n                else\n                    d[r][c] = 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final int rowCount = m.getRowDimension();\n        final int colCount = m.getColumnDimension();\n        final RealMatrix out = m.copy();\n        for (int i = 0; i < rowCount; i++) {\n            for (int j = 0; j < colCount; j++) {\n                if (i > j + k) {\n                    out.setEntry(i, j, 0);\n                }\n            }\n        }\n        return out;\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if(r <= c+k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        if (left.skew == Skew.LEFT_HIGH) {\n            rotateCW();\n            skew       = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        } else {\n            final Skew s = left.right.skew;\n            left.rotateCCW();\n            rotateCW();\n            switch(s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return true;\n    case RIGHT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } else {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew       = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double max = Math.abs(matrixT[startIdx][startIdx - 1]);\n    while (idx < matrixT.length - 1 && max * norm > epsilon) \n    {\n        idx++;\n        double current = Math.abs(matrixT[idx][idx - 1]);\n        if (current < max) \n        {\n            max = current;\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0 && FastMath.abs(matrixT[idx][idx - 1]) <= norm * epsilon) {\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        final double absVal = FastMath.abs(matrixT[idx][idx - 1]);\n        if (absVal <= epsilon * norm) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double absVal = FastMath.abs(matrixT[startIdx][startIdx - 1]);\n    while (idx < n - 1 && absVal <= norm * epsilon) \n    {\n        idx++;\n        absVal = FastMath.abs(matrixT[idx][idx - 1]);\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  ",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        double sum = 0;\n        for (int i = idx - 1; i < startIdx; i++) {\n            sum += Math.abs(matrixT[i][i + 1]);\n        }\n        if (sum <= norm * epsilon) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  ",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        double sum = Math.abs(matrixT[idx][idx - 1]) + Math.abs(matrixT[idx - 1][idx - 2]);\n        if (sum <= norm * epsilon) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double minAbs = Double.MAX_VALUE;\n    for (int i = startIdx; i < n - 1; i++) \n    {\n        double absVal = Math.abs(matrixT[i + 1][i]) / norm;\n        if (absVal < minAbs) \n        {\n            minAbs = absVal;\n            idx = i + 1;\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  "
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getJSDoc() != null) \n    {\n        JsDocInfo jsDocInfo = node.getJSDoc();\n        if (jsDocInfo.getReturn() != null) \n        {\n            irNode.setReturnJsDoc(jsDocInfo.getReturn());\n        }\n        for (JsDocParam param : jsDocInfo.getParams()) \n        {\n            irNode.addParamJsDoc(param);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    parsedComments.add(node.getJsDoc());\n    JSDocInfo jsDocInfo = jsDocParser.getJSDocInfo();\n    if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n        jsDocInfo.setAssociatedNode(irNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getJsDoc() != null) {\n        JsDocInfo jsDocInfo = createJsDocInfo(node.getJsDoc(), irNode);\n        irNode.setJsDocInfo(jsDocInfo);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    parsedComments.add(node.getJsDoc());\n    JSDocInfo jsDocInfo = jsDocParser.getJSDocInfo();\n    if (jsDocInfo != null) {\n        irNode.setJSDocInfo(jsDocInfo);\n        jsDocInfo.setAssociatedNode(irNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getJsDoc() != null) \n    {\n        JsDocInfo jsDocInfo = node.getJsDoc();\n        if (jsDocInfo.getType() != null) \n        {\n            irNode.setType(jsDocInfo.getType());\n        }\n        if (jsDocInfo.getParams() != null) \n        {\n            irNode.setParams(jsDocInfo.getParams());\n        }\n        if (jsDocInfo.getReturns() != null) \n        {\n            irNode.setReturns(jsDocInfo.getReturns());\n        }\n        if (jsDocInfo.getThrows() != null) \n        {\n            irNode.setThrows(jsDocInfo.getThrows());\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    if (jsDocParser.hasJSDocInfo()) {\n        JsDocInfo jsDocInfo = jsDocParser.getJSDocInfo();\n        if (jsDocInfo.hasTag(\"param\") || jsDocInfo.hasTag(\"return\")) {\n            irNode.setJSDocInfo(jsDocInfo);\n            jsDocInfo.setAssociatedNode(irNode);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    parsedComments.add(node.getJsDoc());\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n        fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n        irNode.setJSDocInfo(fileOverviewInfo);\n        fileOverviewInfo.setAssociatedNode(irNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode.isBlock()) {\n      // We don't support JSDoc on blocks yet.\n      return irNode;\n    }\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    parsedComments.add(node.getJsDoc());\n    JSDocInfo jsDocInfo = jsDocParser.getJSDocInfo();\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n      jsDocInfo.setAssociatedNode(irNode);\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode.getJSDocInfo() == null) {\n        irNode.setJSDocInfo(new JSDocInfo());\n    }\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getComment(), irNode);\n    jsDocInfo.setJsDocParser(jsDocParser);\n    jsDocInfo.setAssociatedNode(irNode);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(node.getJsDoc(), irNode);\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) \n    {\n        fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n        irNode.setJSDocInfo(fileOverviewInfo);\n        fileOverviewInfo.setAssociatedNode(irNode);\n    }\n    return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementTypeList\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementtypelist\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList != null) {\n      arrayType.addChildToFront(elementTypeList);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementTypeList\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    token = next();\n    if (token != JsDocToken.RB) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementtypelist\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementTypeList\");\n    }\n    arrayType.addChildToFront(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LS);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementTypeList\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementTypeList\");\n    }\n\n    arrayType.addChildToFront(elementTypeList);\n\n    token = next();\n    if (token != JsDocToken.RB) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList != null) {\n        arrayType.addChildToFront(elementTypeList);\n    }\n\n    if (match(JsDocToken.RB)) {\n        next();\n        return arrayType;\n    }\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.ARRAY);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList != null) {\n      arrayType.addChildToFront(elementTypeList);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = getNorm();\n    if (norm == 0) {\n      throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double angle = getAngle();\n    if (angle == 0) {\n        return new Vector3D(0, 0, 1);\n    } else {\n        return getVectorPart().scalarMultiply(1 / Math.sin(angle / 2));\n    }\n}",
      "public Vector3D getAxis()  {\n    double angle = getAngle();\n    if (angle == 0) {\n        return Vector3D.ZERO;\n    }\n    double sinAngle = FastMath.sin(0.5 * angle);\n    return new Vector3D(q1 / sinAngle, q2 / sinAngle, q3 / sinAngle);\n}",
      "public Vector3D getAxis()  {\n    double angle = getAngle();\n    if (angle == 0) {\n        // Any vector will do\n        return new Vector3D(1, 0, 0);\n    } else {\n        return new Vector3D(q1, q2, q3).divide(FastMath.sin(angle / 2));\n    }\n}",
      "public Vector3D getAxis()  {\n    double angle = getAngle();\n    if (angle == 0) {\n        // any vector will do\n        return new Vector3D(1, 0, 0);\n    }\n    Vector3D axis = new Vector3D(q1, q2, q3);\n    return axis.scalarMultiply(1 / FastMath.sin(angle / 2));\n}",
      "public Vector3D getAxis()  {\n    double angle = getAngle();\n    if (angle == 0) {\n        return new Vector3D(1, 0, 0);\n    }\n    double norm = FastMath.sin(angle / 2);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            // every other octet is appended except for '+'\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            // every other octet is appended except for '+'\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b != '+') \n        {\n            buffer.write(b);\n        } \n        else \n        {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != '+') {\n            // every other octet is appended except for '+'\n            buffer.write(b);\n        } else {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b != '+') \n        {\n            // every other octet is appended except for '+'\n            buffer.write(b);\n        } \n        else \n        {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b != '+') \n        {\n            buffer.write(b);\n        } \n        else \n        {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } else if (b != CR && b != LF) {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        if (partial.getField(i).getRange().getMaximum() != partial.getField(i + 1).getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (field1.getRange().getMaximum() != field2.getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        if (partial.getField(i).getRange().getMaximum() != partial.getField(i + 1).getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (!field1.getRange().isConnected(field2.getRange())) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (field1.getRange().getMaximum() != field2.getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (field1.getRange().getMaximum() != field2.getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (!field1.getRange().isMaximumIncluded() || !field2.getRange().isMinimumIncluded()) \n        {\n            return false;\n        }\n        if (field1.getMaximumValue(partial, partial.getValues()) != field2.getMinimumValue(partial, partial.getValues())) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (field1.getRange().getMaximum() != field2.getRange().getMinimum()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  ",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (!field1.getRange().isConnected(field2.getRange())) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        strings.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        strings.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        strings.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        strings.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        result.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        result.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        result.add(Node.createString(param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        strings.add(Node.string(param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        strings.add(new Node(Token.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        Preconditions.checkState(param.isName());\n        strings.add(Node.makeString(param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) \n        {\n            return null;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n        {\n            id = id.substring(3);\n            int offset = parseOffset(id);\n            if (offset == 0L) \n            {\n                return \"UTC\";\n            } \n            else \n            {\n                id = printOffset(offset);\n                return \"Etc/\" + id;\n            }\n        }\n        return null;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convId = cConvertedIDs.get(id);\n    if (convId == null) \n    {\n        convId = id;\n    }\n    return convId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            id = printOffset(offset);\n            return \"Etc/\" + id;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        int offset = parseOffset(id.substring(3));\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            return printOffset(offset);\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        int offset = parseOffset(id);\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            return printOffset(offset);\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convId = iConvertedIDs.get(id);\n    if (convId == null) \n    {\n        convId = id;\n    }\n    return convId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        int offset = parseOffset(id.substring(3));\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            return printOffset(offset);\n        }\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) \n        {\n            return null;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n        {\n            int offset = parseOffset(id);\n            if (offset == 0L) \n            {\n                return \"UTC\";\n            } \n            else \n            {\n                return printOffset(offset);\n            }\n        }\n        return null;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            id = printOffset(offset);\n            return \"Etc/\" + id;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) \n    {\n        id = id.substring(3);\n        int offset = parseOffset(id);\n        if (offset == 0L) \n        {\n            return \"UTC\";\n        } \n        else \n        {\n            id = printOffset(offset);\n            return \"Etc/\" + id;\n        }\n    }\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final int nR = getNumberOfResiduals();\n        final int nC = getNumberOfParameters();\n\n        if (nR != getResidualDimension()) {\n            throw new DimensionMismatchException(nR, getResidualDimension());\n        }\n        if (nC != getParameterDimension()) {\n            throw new DimensionMismatchException(nC, getParameterDimension());\n        }\n\n        final double[][] jacobian = new double[nR][nC];\n        final double[] residuals = computeResiduals(params);\n\n        // Compute the Jacobian matrix.\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                final double[] perturbedParams = params.clone();\n                perturbedParams[j] += getEpsilon();\n                final double[] perturbedResiduals = computeResiduals(perturbedParams);\n                for (int k = 0; k < nR; k++) {\n                    jacobian[k][j] = (perturbedResiduals[k] - residuals[k]) / getEpsilon();\n                }\n            }\n        }\n\n        final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian);\n        final RealMatrix weightMatrix = getWeight();\n\n        // Compute the weighted Jacobian: W^(1/2) J.\n        return weightedJacobian.multiply(weightMatrix.power(0.5));\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix.\n        RealMatrix jacobian = computeJacobian(params);\n\n        // Compute the square root of the weight matrix.\n        RealMatrix sqrtWeightMatrix = getWeight().power(0.5);\n\n        // Multiply the Jacobian by the square root of the weight matrix.\n        return sqrtWeightMatrix.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Initialize Jacobian matrix\n        RealMatrix jacobian = computeJacobian(params);\n        RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != jacobian.getRowDimension()) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), jacobian.getRowDimension());\n        }\n        if (weightMatrix.getColumnDimension() != jacobian.getColumnDimension()) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), jacobian.getColumnDimension());\n        }\n\n        // Compute weighted Jacobian: W^1/2 * J\n        RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian.getRowDimension(), jacobian.getColumnDimension());\n        for (int i = 0; i < jacobian.getRowDimension(); i++) {\n            for (int j = 0; j < jacobian.getColumnDimension(); j++) {\n                double weight = Math.sqrt(weightMatrix.getEntry(i, i));\n                weightedJacobian.setEntry(i, j, weight * jacobian.getEntry(i, j));\n            }\n        }\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final int nR = getNumberOfResiduals();\n        final int nP = getNumberOfParameters();\n        final RealMatrix jacobian = computeJacobian(params);\n        if (jacobian.getRowDimension() != nR || jacobian.getColumnDimension() != nP) {\n            throw new DimensionMismatchException(jacobian.getRowDimension(), nR);\n        }\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR || weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        final RealMatrix sqrtWeightMatrix = weightMatrix.scalarMultiply(0.5).choleskyDecomposition().getSolver().getInverse();\n        return sqrtWeightMatrix.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix.\n        final RealMatrix jacobian = computeJacobian(params);\n\n        // Compute the square root of the weight matrix.\n        final RealMatrix sqrtWeight = getWeight().power(0.5);\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightedJacobian = sqrtWeight.multiply(jacobian);\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        int nR = getNumberOfResiduals();\n        int nC = params.length;\n\n        // Jacobian matrix.\n        double[][] jacobian = new double[nR][nC];\n        computeJacobian(params, jacobian, 0, nR);\n\n        // Weight matrix.\n        RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        // Compute weighted Jacobian.\n        double[][] weightedJacobian = new double[nR][nC];\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                weightedJacobian[i][j] = residualsWeights[i] * jacobian[i][j];\n            }\n        }\n\n        return MatrixUtils.createRealMatrix(weightedJacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final int nR = getNumberOfResiduals();\n        final int nC = params.length;\n\n        // Jacobian matrix.\n        final double[][] jacobian = new double[nR][nC];\n        computeJacobian(params, jacobian);\n\n        // Weight matrix.\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        // Weighted Jacobian.\n        final double[][] weightedJacobian = new double[nR][nC];\n        for (int i = 0; i < nR; i++) {\n            final double weight = residualsWeights[i];\n            for (int j = 0; j < nC; j++) {\n                weightedJacobian[i][j] = weight * jacobian[i][j];\n            }\n        }\n\n        return MatrixUtils.createRealMatrix(weightedJacobian);\n    }\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix.\n        RealMatrix jacobian = computeJacobian(params);\n        if (jacobian.getRowDimension() != nR) {\n            throw new DimensionMismatchException(jacobian.getRowDimension(), nR);\n        }\n        if (jacobian.getColumnDimension() != nC) {\n            throw new DimensionMismatchException(jacobian.getColumnDimension(), nC);\n        }\n\n        // Compute the square root of the weight matrix.\n        RealMatrix sqrtWeight = getWeight().power(0.5);\n        if (sqrtWeight.getRowDimension() != nR) {\n            throw new DimensionMismatchException(sqrtWeight.getRowDimension(), nR);\n        }\n        if (sqrtWeight.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(sqrtWeight.getColumnDimension(), nR);\n        }\n\n        // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n        return sqrtWeight.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final int nR = getNumberOfResiduals();\n        final int nC = getNumberOfParameters();\n\n        // Jacobian matrix.\n        final double[][] jacobian = new double[nR][nC];\n        computeJacobian(params, jacobian);\n\n        // Weight matrix.\n        final double[][] weightMatrix = getWeight().getData();\n\n        // Compute weighted Jacobian.\n        final double[][] weightedJacobian = new double[nR][nC];\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                weightedJacobian[i][j] = Math.sqrt(weightMatrix[i][i]) * jacobian[i][j];\n            }\n        }\n\n        return MatrixUtils.createRealMatrix(weightedJacobian);\n    }\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final int nR = getNumberOfResiduals();\n        final int nC = getNumberOfParameters();\n\n        // Initialize Jacobian matrix.\n        double[][] jacobian = new double[nR][nC];\n\n        // Compute Jacobian matrix.\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                // Compute finite difference.\n                double[] paramsPlus = params.clone();\n                paramsPlus[j] += FD_EPS;\n                double[] f1 = computeObjectiveValue(paramsPlus);\n\n                double[] paramsMinus = params.clone();\n                paramsMinus[j] -= FD_EPS;\n                double[] f2 = computeObjectiveValue(paramsMinus);\n\n                // Compute finite difference approximation.\n                for (int k = 0; k < nR; k++) {\n                    jacobian[i][j] += (f1[k] - f2[k]) / (2 * FD_EPS);\n                }\n            }\n        }\n\n        // Check dimension.\n        if (jacobian.length != nR || jacobian[0].length != nC) {\n            throw new DimensionMismatchException(jacobian.length, nR);\n        }\n\n        // Return weighted Jacobian.\n        return new Array2DRowRealMatrix(jacobian, false);\n    }"
    ],
    [
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.next();\n        }\n        if (least == -1 || comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n\n    int least = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = next();\n        }\n        if (least == -1 || comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    Integer index = null;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            index = i;\n            break;\n        }\n    }\n    if (index == null) {\n        return least(comparator);\n    }\n    return index;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    Integer minIndex = null;\n    E minValue = null;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            minIndex = i;\n            break;\n        }\n        if (minValue == null || comparator.compare(values[i], minValue) < 0) {\n            minValue = values[i];\n            minIndex = i;\n        }\n    }\n    if (minIndex != null) {\n        values[minIndex] = null;\n    }\n    return minIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    Integer minIndex = null;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            minIndex = i;\n            break;\n        }\n    }\n    if (minIndex == null) {\n        return -1;\n    }\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] != null && (minIndex == null || comparator.compare(values[i], values[minIndex]) < 0)) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = comparator.next();\n        }\n        if (least == -1 || comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = new Integer(i);\n        }\n        if (least == -1 || comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = comparator.next();\n        }\n        if (least == -1 || comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    Integer index = null;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            index = i;\n            break;\n        }\n    }\n    if (index == null) {\n        for (int i = 0; i < values.length; i++) {\n            for (int j = i + 1; j < values.length; j++) {\n                if (comparator.compare(values[i], values[j]) > 0) {\n                    index = i;\n                    break;\n                }\n            }\n            if (index != null) {\n                break;\n            }\n        }\n    }\n    return index;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    Integer index = null;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            index = i;\n            break;\n        }\n    }\n    if (index == null) \n    {\n        for (int i = 0; i < values.length; i++) \n        {\n            for (int j = i + 1; j < values.length; j++) \n            {\n                if (comparator.compare(values[i], values[j]) > 0) \n                {\n                    index = i;\n                    break;\n                }\n            }\n            if (index != null) \n            {\n                break;\n            }\n        }\n    }\n    else \n    {\n        values[index] = null;\n    }\n    return index;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n            childPointer = parentPointer.createChild(null, name, 0);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        if (step.getAxis() == Compiler.AXIS_CHILD) \n        {\n            childPointer = parentPointer.createChild(\n                parentPointer.getJXPathContext(), \n                ((NodeNameTest) step.getNodeTest()).getNodeName(), \n                ((NodeNameTest) step.getNodeTest()).getNodeName().getLocalPart(), \n                null);\n        } \n        else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) \n        {\n            childPointer = parentPointer.createAttribute(\n                parentPointer.getJXPathContext(), \n                ((NodeNameTest) step.getNodeTest()).getNodeName());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        QName name = step.getNodeTest().getNodeName();\n        int index = step.getNodeTest().getIndex();\n\n        if (parentPointer instanceof NullPointer) {\n            throw new JXPathNullPointerException(\n                    \"NullPointer cannot create child pointers\");\n        }\n\n        if (parentPointer.isAttribute()) {\n            throw new JXPathIllegalArgumentException(\n                    \"Cannot create child pointers for attributes\");\n        }\n\n        if (parentPointer.getPropertyName().equals(name.toString())) {\n            // This is a special case where we are trying to create a child\n            // pointer for the same property name as the parent pointer.\n            // This is a bit tricky, because the parent pointer is not\n            // a PropertyOwnerPointer, but it is a NodePointer. We need\n            // to create a new PropertyOwnerPointer around the parent pointer\n            // and then call createChild on it.\n            childPointer = new PropertyOwnerPointer(parentPointer);\n        } else {\n            childPointer = parentPointer;\n        }\n\n        return childPointer.createChild(\n                parentPointer.getJXPathContext(), name, index);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.createPath(context);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        QName name = step.getNodeTest().getNodeName();\n        if (name == null) {\n            throw new JXPathException(\"Node name is null\");\n        }\n        int index = step.getIndex();\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        childPointer = parentPointer.createChild(null, name, index);\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        QName name = step.getNodeTest().getNodeName();\n        int index = step.getIndex();\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        try {\n            childPointer = parentPointer.createChild(null, name, index);\n        } catch (JXPathAbstractFactoryException e) {\n            throw new JXPathException(e.getMessage());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer;\n        QName name = step.getNodeName();\n        if (isLangAttribute(name)) {\n            childPointer = parentPointer.createAttribute(name);\n        } else {\n            childPointer = parentPointer.createChild(name);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        int index = step.getIndex();\n        QName name = step.getNodeName();\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        try {\n            childPointer = parentPointer.createChild(parentPointer.getJXPathContext(), name, index);\n        } catch (JXPathAbstractFactoryException e) {\n            // Property does not exist - return a null pointer\n            childPointer = new NullPointer(parentPointer.getJXPathContext(), parentPointer, name);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        if (step.getAxis() == Compiler.AXIS_SELF) {\n            childPointer = parentPointer;\n        } else {\n            childPointer = parentPointer.createPath(parentPointer.getJXPathContext());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  throws JXPathException {\n        NodePointer childPointer;\n        QName name = step.getNodeName();\n        int index = step.getIndex();\n        if (index == WHOLE_COLLECTION) {\n            index = 0;\n        }\n        try {\n            childPointer = parentPointer.createChild(\n                    parentPointer.getJXPathContext(), name, index);\n        } catch (JXPathAbstractFactoryException e) {\n            throw new JXPathException(\"Could not create child node for path: \"\n                    + parentPointer.asPath() + \"/\" + name + \"[\" + (index + 1)\n                    + \"]\", e);\n        }\n        return childPointer;\n    }"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Locale locale = definingCalendar.getLocale();\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) \n    {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Locale locale = definingCalendar.getLocale();\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache = getCache(field);\n        Locale locale = definingCalendar.getLocale();\n        Strategy strategy = cache.get(locale);\n        if (strategy == null) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n            cache.put(locale, strategy);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Locale locale = definingCalendar.getLocale();\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) \n    {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache = getCache(field);\n        Locale locale = definingCalendar.getLocale();\n        Strategy strategy = cache.get(locale);\n        if(strategy == null) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n            cache.put(locale, strategy);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Locale locale = definingCalendar.getLocale();\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) \n    {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Locale locale = definingCalendar.getLocale();\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Locale locale = definingCalendar.getLocale();\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache = getCache(field);\n        Locale locale = definingCalendar.getLocale();\n        Strategy strategy = cache.get(locale);\n        if (strategy == null) {\n            strategy = new TextStrategy(field, definingCalendar, locale);\n            cache.put(locale, strategy);\n        }\n        return strategy;\n    }"
    ],
    [
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (nextNode == null) {\n            throw new NoSuchElementException();\n        }\n        if (modifications != expectedModifications) {\n            throw new ConcurrentModificationException();\n        }\n        lastReturnedNode = nextNode;\n        previousNode = nextNode;\n        nextNode = nextGreater(nextNode, orderType);\n        if (nextNode != null) {\n            rval = true;\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean hasNext = false;\n        if (currentIterator == null) {\n            if (root == null) { // NOPMD\n                // do nothing, hasNext will be false\n            } else {\n                if (transformer == null) {\n                    findNext(root);\n                } else {\n                    findNext(transformer.transform(root));\n                }\n                root = null;\n            }\n        } else {\n            findNextByIterator(currentIterator);\n        }\n        return hasNext;\n    }",
      "private boolean setNextObject()  {\n    if (currentIterator == null) {\n        return false;\n    }\n    if (currentIterator.hasNext()) {\n        nextObject = currentIterator.next();\n        return true;\n    } else {\n        // if the current iterator has no next, then move on to the next iterator\n        currentIterator = null;\n        return setNextObject();\n    }\n}",
      "private boolean setNextObject()  {\n        if (nextNode == null) {\n            throw new NoSuchElementException();\n        }\n        if (modifications != expectedModifications) {\n            throw new ConcurrentModificationException();\n        }\n        lastReturnedNode = nextNode;\n        previousNode = nextNode;\n        nextNode = nextGreater(nextNode, orderType);\n        return true;\n    }",
      "private boolean setNextObject()  {\n        if (hasNext()) \n        {\n            nextObject = next();\n            return true;\n        } \n        else \n        {\n            nextObject = null;\n            return false;\n        }\n    }",
      "private boolean setNextObject()  {\n    boolean rval = false;\n    if (currentNode == null) {\n        if (nextNode != null) {\n            currentNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            rval = true;\n        }\n    } else {\n        if (nextNode == null || compare(currentNode.getKey(), nextNode.getKey()) < 0) {\n            currentNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            rval = true;\n        } else {\n            currentNode = previousNode;\n            previousNode = nextSmaller(previousNode, orderType);\n            rval = true;\n        }\n    }\n    return rval;\n}",
      "private boolean setNextObject()  {\n    if (hasNext()) \n    {\n        nextObject = navigateNext();\n        return true;\n    } \n    else \n    {\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n        if (currentNode == null) {\n            currentNode = leastNode(rootNode[orderType.ordinal()], orderType);\n        } else {\n            currentNode = nextGreater(currentNode, orderType);\n        }\n        if (currentNode == null) {\n            currentObject = null;\n            return false;\n        } else {\n            currentObject = currentNode.getValue(orderType);\n            return true;\n        }\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (currentIterator != null && currentIterator.hasNext()) {\n            currentObject = currentIterator.next();\n            rval = true;\n        } else {\n            // we've finished with this iterator, so get the next one\n            currentIterator = iteratorQueue.poll();\n            if (currentIterator != null) {\n                rval = setNextObject();\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (nextNode == null) \n        {\n            throw new NoSuchElementException();\n        } \n        else if (modifications != expectedModifications) \n        {\n            throw new ConcurrentModificationException();\n        }\n        lastReturnedNode = nextNode;\n        previousNode = nextNode;\n        nextNode = nextGreater(nextNode, orderType);\n        if (nextNode != null)\n        {\n            rval = true;\n        }\n        return rval;\n    }"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n        // ...\n    }\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        return transformer;\n    }"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) \n    {\n        final int index = i / Long.SIZE;\n        final int bit = 1 << (i % Long.SIZE);\n        if ((index < values.length) && ((values[index] & bit) != 0)) \n        {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) \n    {\n        int bitIndex = i % Long.SIZE;\n        int longIndex = i / Long.SIZE;\n        if ((values[longIndex] & (1 << bitIndex)) != 0) \n        {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < constants.length; i++) \n    {\n        int bitIndex = i % Long.SIZE;\n        int longIndex = i / Long.SIZE;\n        if ((values[longIndex] >> bitIndex & 1) == 1) \n        {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        final E[] constants = enumClass.getEnumConstants();\n        for (int i = 0; i < constants.length; i++) {\n            if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n                result.add(constants[i]);\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    final int maxOrdinal = constants.length - 1;\n    for (int i = 0; i <= maxOrdinal; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    final int length = constants.length;\n    for (int i = 0; i < length; i++) {\n        if ((values[i / Long.SIZE] & (1 << (i % Long.SIZE))) != 0) {\n            result.add(constants[i]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n            value >>>= 1;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    if (newZone == this) {\n        return oldInstant;\n    }\n    long oldLocal = convertUTCToLocal(oldInstant);\n    return convertLocalToUTC(oldLocal, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = getZone();\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n\n    long localInstant = originalZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long oldLocalInstant = oldZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(oldLocalInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long oldLocalInstant = oldZone.convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(oldLocalInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long oldLocalInstant = oldZone.convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(oldLocalInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long localInstant = oldZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = getZone();\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long localInstant = originalZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long oldLocalInstant = oldZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(oldLocalInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = getZone();\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long localInstant = originalZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone oldZone = getZone();\n    if (newZone == oldZone) {\n        return oldInstant;\n    }\n    long localInstant = oldZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false, oldInstant);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // your code here\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n    return new Date(calendar.getTimeInMillis());\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (current > value) {\n        value += count;\n    } else {\n        value = count;\n    }\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // Implement your solution here\n    int count = unit.getMultiple();\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // get the current date in the unit\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int current = calendar.get(unit.getCalendarField());\n\n    // calculate the next standard date\n    Date nextDate = unit.addToDate(date, this.timeZone);\n    while (nextDate.before(date) || nextDate.after(getMaximumDate())) \n    {\n        nextDate = unit.addToDate(nextDate, this.timeZone);\n    }\n\n    return nextDate;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    Date nextDate = unit.addToDate(date, this.timeZone);\n    while (nextDate.before(date)) \n    {\n        nextDate = unit.addToDate(nextDate, this.timeZone);\n    }\n    return nextDate;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        final Object value = variableResolver.lookup(variableName);\n        if (value != null) \n        {\n            return value.toString();\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver != null) {\n        final Object value = resolver.lookup(variableName);\n        if (value != null) {\n            return value.toString();\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        final Object value = variableResolver.lookup(variableName);\n        if (value != null) \n        {\n            return value.toString();\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver != null) {\n        final Object value = resolver.lookup(variableName);\n        if (value != null) {\n            return value.toString();\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver != null) {\n        final Object value = resolver.lookup(variableName);\n        if (value != null) {\n            return value.toString();\n        }\n    }\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    final char[] chars = str.toCharArray();\n    final char firstLetter = chars[0];\n    final StringBuilder soundex = new StringBuilder();\n    soundex.append(firstLetter);\n\n    int count = 1;\n    for (int i = 1; i < chars.length; i++) {\n        final char letter = chars[i];\n        final char mappedLetter = soundexMapping[letter - 'A'];\n        if (mappedLetter != '0') {\n            if (count < 4) {\n                soundex.append(mappedLetter);\n                count++;\n            }\n        }\n    }\n\n    while (soundex.length() < 4) {\n        soundex.append('0');\n    }\n\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder result = new StringBuilder(str.length());\n        result.append(str.charAt(0));\n\n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n        for (int i = 1; i < len; i++) {\n            final char c = chars[i];\n            final char mapped = soundexMapping[c - 'A'];\n            if (mapped == '0') {\n                continue;\n            }\n            if (mapped != result.charAt(result.length() - 1)) {\n                result.append(mapped);\n            }\n            if (result.length() == 4) {\n                break;\n            }\n        }\n\n        while (result.length() < 4) {\n            result.append('0');\n        }\n\n        return result.toString();\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final char[] chars = str.toCharArray();\n        final char[] soundex = new char[4];\n        soundex[0] = chars[0];\n\n        int count = 1;\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char soundexChar = US_ENGLISH_MAPPING[c - 'A'];\n            if (soundexChar != '0' && soundexChar != soundex[count - 1]) {\n                soundex[count++] = soundexChar;\n                if (count == 4) {\n                    break;\n                }\n            }\n        }\n\n        while (count < 4) {\n            soundex[count++] = '0';\n        }\n\n        return new String(soundex);\n    }",
      "public String soundex(String str)  {\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final char[] chars = str.toCharArray();\n        final char[] code = new char[4];\n        code[0] = chars[0];\n        int count = 1;\n\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char mapped = US_ENGLISH_MAPPING[c - 'A'];\n            if (mapped != '0') {\n                if (mapped != code[count - 1]) {\n                    code[count++] = mapped;\n                }\n            }\n        }\n        while (count < 4) {\n            code[count++] = '0';\n        }\n        return new String(code);\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final char[] chars = str.toCharArray();\n        final char[] soundex = new char[4];\n        soundex[0] = chars[0];\n\n        int count = 1;\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char mapped = US_ENGLISH_MAPPING[c - 'A'];\n            if (mapped != '0') {\n                soundex[count++] = mapped;\n                if (count == soundex.length) {\n                    break;\n                }\n            }\n        }\n\n        while (count < soundex.length) {\n            soundex[count++] = '0';\n        }\n\n        return new String(soundex);\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    // Use the same clean rules as Soundex\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    final StringBuilder result = new StringBuilder(str.length());\n    result.append(str.charAt(0));\n\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    for (int i = 1; i < len; i++) {\n        final char c = chars[i];\n        final char mapped = soundexMapping[c - 'A'];\n        if (mapped == '0') {\n            continue;\n        }\n        if (mapped != result.charAt(result.length() - 1)) {\n            result.append(mapped);\n        }\n        if (result.length() == maxLength) {\n            break;\n        }\n    }\n\n    while (result.length() < maxLength) {\n        result.append('0');\n    }\n\n    return result.toString();\n}",
      "public String soundex(String str)  {\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder code = new StringBuilder(str.length());\n        code.append(str.charAt(0));\n\n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n        for (int i = 1; i < len; i++) {\n            final char c = chars[i];\n            final char mapped = US_ENGLISH_MAPPING[c - 'A'];\n            if (mapped == '0') {\n                continue;\n            }\n            if (mapped != code.charAt(code.length() - 1)) {\n                code.append(mapped);\n            }\n            if (code.length() == 4) {\n                break;\n            }\n        }\n\n        while (code.length() < 4) {\n            code.append('0');\n        }\n        return code.toString();\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final char[] chars = str.toCharArray();\n        final char[] soundex = new char[4];\n        soundex[0] = chars[0];\n\n        int count = 1;\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char mapped = US_ENGLISH_MAPPING[c - 'A'];\n            if (mapped == '0') {\n                continue;\n            }\n            if (mapped == '#') {\n                if (count == 1) {\n                    soundex[count++] = '0';\n                }\n                continue;\n            }\n            if (mapped == soundex[0]) {\n                continue;\n            }\n            soundex[count++] = mapped;\n            if (count == 4) {\n                break;\n            }\n        }\n        while (count < 4) {\n            soundex[count++] = '0';\n        }\n        return new String(soundex);\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n\n        str = SoundexUtils.clean(str);\n\n        if (str.length() == 0) {\n            return str;\n        }\n\n        final StringBuilder result = new StringBuilder(str.length());\n        result.append(str.charAt(0));\n\n        final char[] chars = str.toCharArray();\n        final int len = chars.length;\n        for (int i = 1; i < len; i++) {\n            final char c = chars[i];\n            final int mapped = US_ENGLISH_MAPPING[c - 'A'];\n            if (mapped == 0) {\n                throw new IllegalArgumentException(\"Character \" + c + \" is not mapped\");\n            }\n            if (mapped != US_ENGLISH_MAPPING[chars[i - 1] - 'A']) {\n                result.append((char) ('0' + mapped));\n            }\n        }\n\n        while (result.length() < 4) {\n            result.append('0');\n        }\n\n        return result.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n        return str;\n    }\n\n    final char[] chars = str.toCharArray();\n    final char[] soundex = new char[4];\n    soundex[0] = chars[0];\n    int count = 1;\n\n    for (int i = 1; i < chars.length; i++) {\n        final char c = chars[i];\n        final char mapped = US_ENGLISH_MAPPING[c - 'A'];\n        if (mapped != '0') {\n            if (mapped != soundex[0]) {\n                soundex[count++] = mapped;\n                if (count == soundex.length) {\n                    break;\n                }\n            }\n        }\n    }\n\n    while (count < soundex.length) {\n        soundex[count++] = '0';\n    }\n\n    return new String(soundex);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == Integer.class) {\n            return _intType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Void.class) {\n        return _voidType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Integer.class) {\n            return _intType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Integer.class) {\n            return _integerType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Integer.class) {\n            return _intType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Void.class) {\n        return _voidType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Void.class) {\n        return _voidType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == Integer.class) {\n            return _intType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Date.class) {\n            return _dateType;\n        }\n        if (clz == Calendar.class) {\n            return _calendarType;\n        }\n        if (clz == Class.class) {\n            return _classType;\n        }\n        if (clz == Object.class) {\n            return _objectType;\n        }\n        if (clz == BigDecimal.class) {\n            return _bigDecimalType;\n        }\n        if (clz == BigInteger.class) {\n            return _bigIntegerType;\n        }\n        if (clz == UUID.class) {\n            return _uuidType;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == String.class) {\n            return _stringType;\n        }\n        if (clz == Boolean.class) {\n            return _booleanType;\n        }\n        if (clz == Integer.class) {\n            return _integerType;\n        }\n        if (clz == Long.class) {\n            return _longType;\n        }\n        if (clz == Double.class) {\n            return _doubleType;\n        }\n        if (clz == Float.class) {\n            return _floatType;\n        }\n        if (clz == Byte.class) {\n            return _byteType;\n        }\n        if (clz == Short.class) {\n            return _shortType;\n        }\n        if (clz == Character.class) {\n            return _charType;\n        }\n        if (clz == Void.class) {\n            return _voidType;\n        }\n        return null;\n    }"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n == null) \n    {\n        return null;\n    }\n    if (n.getType() == Token.NAME) \n    {\n        return new PrototypeMemberDeclaration(n.getString(), null, null);\n    }\n    if (n.getType() == Token.ASSIGN) \n    {\n        Node name = n.getFirstChild();\n        if (name.getType() == Token.NAME) \n        {\n            Node value = n.getLastChild();\n            return new PrototypeMemberDeclaration(name.getString(), null, value.getString());\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n == null) {\n        return null;\n    }\n    if (n.isName()) {\n        return new PrototypeMemberDeclaration(n.getName(), n.getType());\n    }\n    if (n.isAssign()) {\n        return extractDeclaration(n.getFirstChild());\n    }\n    if (n.isFunction()) {\n        return new PrototypeMemberDeclaration(n.getName(), n.getType(), n.getFirstChild());\n    }\n    if (n.isVar()) {\n        return new PrototypeMemberDeclaration(n.getName(), n.getType(), n.getFirstChild());\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isName()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild().getString(), n.getType());\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() == Token.NAME) \n    {\n        String name = n.getString();\n        Node next = n.getNext();\n        if (next != null && next.getType() == Token.COLON) \n        {\n            JavaType type = new JavaType(next.getFirstChild().getString());\n            return new PrototypeMemberDeclaration(name, type);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isName()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n.getNext());\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    Node parent = n.getParent();\n    if (parent.isName()) \n    {\n        return getDeclaration(parent);\n    } \n    else if (parent.isAssign()) \n    {\n        return getDeclaration(parent.getFirstChild());\n    } \n    else if (isObjectLitKey(parent)) \n    {\n        return getDeclaration(parent);\n    } \n    else if (parent.isFunction()) \n    {\n        return getDeclaration(parent);\n    } \n    else if (parent.isVar() && parent.hasOneChild()) \n    {\n        return getDeclaration(parent.getFirstChild());\n    } \n    else if ((parent.isHook() && parent.getFirstChild() != n) ||\n             parent.isOr() ||\n             parent.isAnd() ||\n             (parent.isComma() && parent.getFirstChild() != n)) \n    {\n        return extractDeclaration(parent);\n    } \n    else if (parent.isCast()) \n    {\n        return getDeclaration(parent);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    Node parent = n.getParent();\n    if (parent.isName()) \n    {\n        return getBestJSDocInfo(parent);\n    } \n    else if (parent.isAssign()) \n    {\n        return getBestJSDocInfo(parent);\n    } \n    else if (isObjectLitKey(parent)) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if (parent.isFunction()) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if (parent.isVar() && parent.hasOneChild()) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if ((parent.isHook() && parent.getFirstChild() != n) ||\n             parent.isOr() ||\n             parent.isAnd() ||\n             (parent.isComma() && parent.getFirstChild() != n)) \n    {\n        return getBestJSDocInfo(parent);\n    } \n    else if (parent.isCast()) \n    {\n        return parent.getJSDocInfo();\n    }\n    return info;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    Node parent = n.getParent();\n    if (parent.isName()) \n    {\n        return (PrototypeMemberDeclaration) parent.getJSDocInfo();\n    } \n    else if (parent.isAssign()) \n    {\n        return (PrototypeMemberDeclaration) parent.getJSDocInfo();\n    } \n    else if (isObjectLitKey(parent)) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if (parent.isFunction()) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if (parent.isVar() && parent.hasOneChild()) \n    {\n        return parent.getJSDocInfo();\n    } \n    else if ((parent.isHook() && parent.getFirstChild() != n) ||\n             parent.isOr() ||\n             parent.isAnd() ||\n             (parent.isComma() && parent.getFirstChild() != n)) \n    {\n        return extractDeclaration(parent);\n    } \n    else if (parent.isCast()) \n    {\n        return parent.getJSDocInfo();\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isName()) \n    {\n        return new PrototypeMemberDeclaration(n.getName(), n.getType());\n    } \n    else if (n.isAssign()) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.isName()) \n        {\n            return new PrototypeMemberDeclaration(lhs.getName(), n.getType());\n        }\n    } \n    else if (n.isFunction()) \n    {\n        Node name = n.getFirstChild();\n        if (name.isName()) \n        {\n            return new PrototypeMemberDeclaration(name.getName(), n.getType());\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n == null || n.getType() != Token.NAME) {\n        return null;\n    }\n    Node parent = n.getParent();\n    if (parent == null || !parent.isAssign()) {\n        return null;\n    }\n    Node grandParent = parent.getParent();\n    if (grandParent == null || !grandParent.isFunction()) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(n.getString(), parent.getType());\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws OutOfRangeException, MatrixDimensionMismatchException {\n    final int rowDim = mat.getRowDimension();\n    final int colDim = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rowDim * n, colDim * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat, i * rowDim, j * colDim);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws OutOfRangeException, MatrixDimensionMismatchException {\n    final int originalRows = mat.getRowDimension();\n    final int originalCols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(originalRows * n, originalCols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat, i * originalRows, j * originalCols);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws MatrixDimensionMismatchException {\n    int originalRowDimension = mat.getRowDimension();\n    int originalColumnDimension = mat.getColumnDimension();\n    if (n <= 0 || m <= 0) {\n        throw new MatrixDimensionMismatchException(n, m);\n    }\n    RealMatrix result = MatrixUtils.createRealMatrix(originalRowDimension * n, originalColumnDimension * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat, i * originalRowDimension, j * originalColumnDimension);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws MatrixDimensionMismatchException {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(i * rows, j * cols, mat);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws MatrixDimensionMismatchException {\n    if (n <= 0 || m <= 0) {\n        throw new IllegalArgumentException(\"n and m must be positive integers\");\n    }\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat, i * rows, j * cols);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws MatrixDimensionMismatchException {\n    if (mat.getRowDimension() != mat.getColumnDimension()) {\n        throw new MatrixDimensionMismatchException(\n                \"Replication only possible for square matrices.\");\n    }\n    final int size = mat.getRowDimension();\n    final RealMatrix result = MatrixUtils.createRealMatrix(size * n, size * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(i * size, j * size, mat);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws OutOfRangeException, MatrixDimensionMismatchException {\n    int originalRows = mat.getRowDimension();\n    int originalCols = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(originalRows * n, originalCols * m);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat, i * originalRows, j * originalCols);\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws OutOfRangeException, MatrixDimensionMismatchException {\n    int originalRows = mat.getRowDimension();\n    int originalCols = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(originalRows*n, originalCols*m);\n\n    for(int i=0; i<n; i++) {\n        for(int j=0; j<m; j++) {\n            result.setSubMatrix(mat, i*originalRows, j*originalCols);\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws MatrixDimensionMismatchException {\n    int rowDim = mat.getRowDimension();\n    int colDim = mat.getColumnDimension();\n    RealMatrix repMat = MatrixUtils.createRealMatrix(rowDim * n, colDim * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            repMat.setSubMatrix(mat, i * rowDim, j * colDim);\n        }\n    }\n    return repMat;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  throws OutOfRangeException, MatrixDimensionMismatchException {\n    int originalRowDimension = mat.getRowDimension();\n    int originalColumnDimension = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(originalRowDimension * n, originalColumnDimension * m);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat, i * originalRowDimension, j * originalColumnDimension);\n        }\n    }\n\n    return result;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long inflated = bytesRead - inf.getBytesRead();\n    if (inflated < 0) {\n        inflated = 0;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = getBytesRead();\n    if (bytesInflated > inf.getBytesRead()) {\n        bytesInflated = inf.getBytesRead();\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = bytesRead - lastRead;\n    if (bytesInflated < 0) {\n        bytesInflated += Long.MAX_VALUE;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long total = getBytesRead();\n    final long lastRead = inf.getBytesRead();\n    if (total < lastRead) {\n        // we've wrapped around\n        return total;\n    }\n    final long inflated = total - lastRead;\n    if (inflated > total) {\n        // we've wrapped around again\n        return total;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = getBytesRead();\n    long bytesConsumed = inf.getBytesConsumed();\n    if (bytesConsumed > bytesInflated) {\n        bytesConsumed = bytesInflated;\n    }\n    return bytesInflated - bytesConsumed;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = getBytesRead();\n    final long inflated = inf.getBytesRead();\n    if (inflated > bytesRead) {\n        return bytesRead;\n    }\n    if (inflated < (bytesRead - Long.MAX_VALUE)) {\n        return inflated;\n    }\n    return bytesRead - (Long.MAX_VALUE - inflated);\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = in.getBytesRead();\n    final long bytesInflated = inf.getBytesRead();\n    return bytesRead > bytesInflated ? bytesRead : bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long ret = bytesRead - lastRead;\n    if (ret < 0) {\n        ret += Long.MAX_VALUE + 1;\n    }\n    return ret;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = bytesRead;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        bytesInflated -= inf.getRemaining();\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long ret = bytesRead - lastRead;\n    if (ret < 0) {\n        ret += Long.MAX_VALUE;\n    }\n    return ret;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidPropertyName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidPropertyName(name) || isValidFunctionName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n        return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n        return isValidPropertyName(name);\n    }\n    return isValidPropertyName(name.substring(0, dot)) &&\n        isValidQualifiedName(name.substring(dot + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n      return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n      return isValidIdentifier(name);\n    }\n    return isValidIdentifier(name.substring(0, dot)) &&\n        isValidIdentifier(name.substring(dot + 1));\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n      return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n      return isValidPropertyName(name);\n    }\n    return isValidPropertyName(name.substring(0, dot)) &&\n        isValidQualifiedName(name.substring(dot + 1));\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n        return false;\n    }\n\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n        return isValidIdentifier(name);\n    }\n\n    return isValidIdentifier(name.substring(0, dot)) &&\n        isValidQualifiedName(name.substring(dot + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidPropertyName(name) && name.contains(\".\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n        return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n        return isValidPropertyName(name);\n    }\n    return isValidPropertyName(name.substring(0, dot)) && isValidQualifiedName(name.substring(dot + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n      return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n      return isValidIdentifier(name);\n    }\n    return isValidIdentifier(name.substring(0, dot)) &&\n        isValidIdentifier(name.substring(dot + 1));\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n      return false;\n    }\n    int dot = name.indexOf('.');\n    if (dot == -1) {\n      return isValidIdentifier(name);\n    }\n    return isValidIdentifier(name.substring(0, dot)) &&\n        isValidIdentifier(name.substring(dot + 1));\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double scale = 0.0;\n    double h = 0.0;\n    final int n = matrixT.length;\n\n    for (int k = il; k <= iu; k++) {\n        scale = scale + FastMath.abs(realEigenvalues[k]);\n    }\n\n    for (int k = il; k <= iu; k++) {\n        if (k != iu) {\n            double x = (FastMath.abs(realEigenvalues[k]) / scale) * (FastMath.abs(realEigenvalues[k]) / scale);\n            h = h + x;\n        }\n    }\n\n    double f = (((double) (iu - il)) * h - (realEigenvalues[iu] - realEigenvalues[il])) / scale;\n    double p = f / 2.0;\n    double q = FastMath.sqrt(FastMath.abs(p * p + f * f));\n    double r = FastMath.sqrt(FastMath.abs(p * p + q * q));\n    double shiftX = p + q;\n    double shiftY = p - q;\n    double s = FastMath.abs(realEigenvalues[iu - 1]) + FastMath.abs(f);\n    double z = realEigenvalues[iu];\n\n    for (int k = iu - 1; k >= il; k--) {\n        double x = (k == (iu - 1) ? shiftX : FastMath.abs(realEigenvalues[k])) + s;\n        double prev = realEigenvalues[k + 1];\n        realEigenvalues[k + 1] = (FastMath.abs(realEigenvalues[k + 1]) + FastMath.abs(shiftY)) / x;\n        s = s * realEigenvalues[k + 1] * 2.0;\n        shift.x = shiftX = shiftX / x;\n        shift.y = shiftY = shiftY / x;\n        if (k == (iu - 1)) {\n            break;\n        }\n        z = realEigenvalues[k + 2];\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double scale = 0.0;\n    double h = 0.0;\n    int n = matrixT.length;\n\n    for (int i = il; i < iu; i++) {\n        scale = scale + FastMath.abs(realEigenvalues[i]);\n    }\n\n    for (int i = il; i < iu; i++) {\n        if (i == il) {\n            h = scale * (FastMath.abs(realEigenvalues[i]) / scale);\n        } else {\n            h = h + FastMath.abs(realEigenvalues[i]);\n        }\n    }\n\n    double f = 0.0;\n    double g = 0.0;\n    for (int i = il; i < iu; i++) {\n        if (i != il) {\n            f = f + ((realEigenvalues[i - 1] - realEigenvalues[i]) * (realEigenvalues[i - 1] + realEigenvalues[i]));\n            g = g + e[i - 1];\n        }\n    }\n\n    h = h + f;\n    g = g / 2.0;\n    double z = FastMath.sqrt((h * h) - (f * g));\n    double p = h + z;\n    double q = h - z;\n\n    if (p >= 0.0) {\n        realEigenvalues[iu] = q;\n        h = g - f / p;\n        shift.x = p / 2.0;\n        shift.y = (q + p) / 2.0;\n        shift.z = (q - p) / 2.0;\n    } else {\n        realEigenvalues[iu] = h;\n        shift.x = (f / g) * (g + z);\n        shift.y = g;\n        shift.z = z;\n    }\n\n    // Initialize vector\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = h;\n\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    final int n = matrixT.length;\n    double scale = 0.0;\n    double h = 0.0;\n    for (int k = im; k >= il; k--) {\n        double s = 0.0;\n        for (int i = 0; i < n; i++) {\n            s += FastMath.abs(matrixT[i][k]);\n        }\n        if (s != 0.0) {\n            double t = (matrixT[k][k] / s) * s;\n            h += t * t;\n            if (k != iu) {\n                scale += FastMath.abs(matrixT[k][k + 1]);\n            }\n            for (int i = 0; i < n; i++) {\n                matrixT[i][k] /= s;\n            }\n            matrixT[k][k] += 1.0;\n        }\n    }\n    double f = (scale / h) * h;\n    h = scale * FastMath.sqrt(f);\n    shift.x = h;\n    for (int k = im - 1; k >= il; k--) {\n        shift.x = matrixT[k][k];\n        if (k != iu) {\n            if (shift.x != 0.0) {\n                double s = 0.0;\n                for (int i = 0; i < n; i++) {\n                    s += FastMath.abs(matrixT[i][k + 1]);\n                }\n                if (s != 0.0) {\n                    double t = (matrixT[k + 1][k + 1] / s) * s;\n                    h = t * t;\n                    if (k != iu - 1) {\n                        scale += FastMath.abs(matrixT[k + 2][k + 1]);\n                    }\n                    for (int i = 0; i < n; i++) {\n                        matrixT[i][k + 1] /= s;\n                    }\n                    matrixT[k + 1][k + 1] += 1.0;\n                    if (h != 0.0) {\n}\n}\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double scale = 0.0;\n    double h = 0.0;\n    final int n = matrixT.length;\n    final double eps = epsilon * epsilon;\n\n    for (int i = il; i < iu; i++) {\n        scale = scale + FastMath.abs(realEigenvalues[i]);\n    }\n    for (int i = il; i < iu; i++) {\n        if (i == (iu - 1)) {\n            // Only one eigenvalue left to process\n            hVec[0] = scale;\n            hVec[1] = matrixT[iu][iu - 1];\n            hVec[2] = 0.0;\n        } else {\n            final double x = scale + FastMath.abs(realEigenvalues[i]);\n            if (i != (iu - 1)) {\n                h = matrixT[i + 1][i];\n            }\n            if (x != 0.0) {\n                hVec[0] = h / x;\n            } else {\n                hVec[0] = 0.0;\n            }\n            hVec[1] = 1.0;\n            hVec[2] = h;\n            final double norm = FastMath.abs(hVec[0]) + FastMath.abs(hVec[2]);\n            if (norm == 0.0) {\n                continue;\n            }\n            final double scale = hVec[0] / norm;\n            hVec[0] += hVec[2] / norm;\n            hVec[2] = hVec[0] * hVec[2] - hVec[1] * hVec[1];\n            hVec[1] *= scale;\n        }\n        final double hh = FastMath.abs(hVec[0]) * FastMath.abs(hVec[0]);\n        if (hh <= eps * (FastMath.abs(realEigenvalues[im]) + FastMath.abs(realEigenvalues[iu]))) {\n            break;\n        }\n        im--;\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double scale = 0.0;\n    double h = 0.0;\n    int n = matrixT.length;\n\n    for (int k = im; k >= il; k--) {\n        double s = FastMath.abs(matrixT[k][k - 1]) +\n            FastMath.abs(matrixT[k + 1][k - 1]);\n        if (s != 0.0) {\n            double t = (matrixT[k + 1][k - 1] / s);\n            h = h + s * (1.0 + t * t);\n        }\n    }\n    double f = (matrixT[iu][iu - 1] * (1.0 + h));\n    h = h + f;\n    scale = FastMath.abs(f) + scale;\n    shift.x = scale * epsilon;\n    hVec[0] = f / h;\n    hVec[1] = 1.0;\n    hVec[2] = h;\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n\n    for (int k = iu - 1; k >= il; k--) {\n        double scale = FastMath.abs(matrixT[k][k - 1]) +\n            FastMath.abs(matrixT[k + 1][k - 1]);\n        if (scale == 0.0) {\n            hVec[0] = 0.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        } else {\n            double h = matrixT[k + 1][k - 1] / scale;\n            double s = FastMath.sign(h);\n            h = h * s;\n            double t = s / (scale + h);\n            p = p + t * matrixT[k][k - 1];\n            q = q + t * matrixT[k + 1][k - 1];\n            r = r - t * (scale * matrixT[k + 2][k - 1] + h * matrixT[k + 2][k]);\n            double z = FastMath.sqrt(p * p + q * q + r * r);\n            if (k != iu - 1) {\n                matrixT[k + 2][k - 1] = r / z;\n            }\n            p = p / z;\n            q = q / z;\n            r = r / z;\n            hVec[2] = h;\n            hVec[1] = q;\n            hVec[0] = p;\n            if (k == im) {\n                double max = FastMath.max(FastMath.max(FastMath.abs(p), FastMath.abs(h)),\n                                          FastMath.abs(matrixT[k][k] / scale));\n                shift.x = 1.0 / (max * (max + 2.0));\n            }\n        }\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double scale = 0.0;\n    double h = 0.0;\n    int n = matrixT.length;\n\n    for (int i = il; i < iu; i++) {\n        scale = scale + FastMath.abs(realEigenvalues[i]);\n    }\n\n    if (scale == 0.0) {\n        return im;\n    }\n\n    for (int i = il; i < iu; i++) {\n        h = h + FastMath.abs((realEigenvalues[i] / scale) * (realEigenvalues[i] / scale));\n    }\n\n    double f = (h - ((double) (iu - il + 1)) / 2) / ((double) (iu - il));\n    double g = FastMath.sqrt((f * f) + e[iu - 1]);\n    if (f > 0) {\n        g = -g;\n    }\n    h = f - g;\n    hVec[2] = h;\n\n    for (int i = il; i < iu; i++) {\n        hVec[i] = realEigenvalues[i];\n    }\n\n    // Next QR transformation\n    for (int j = iu - 1; j >= il; j--) {\n        double f = hVec[j];\n        double hh = h;\n        for (int i = j; i >= il; i--) {\n            double hh = hh + hVec[i] * realEigenvalues[i];\n        }\n        hVec[j] = hh;\n        if (j == im) {\n            continue;\n        }\n        f = f / hh;\n        double g = -FastMath.sqrt(scale * scale + h * h);\n        shift.x = scale * g;\n        shift.y = h + g;\n        h = g * (realEigenvalues[j] / scale);\n        scale = scale + h;\n        hVec[j] = h;\n        for (int i = j; i < iu; i++) {\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    final int n = matrixT.length;\n    double scale = 0.0;\n    double h = 0.0;\n\n    for (int k = im; k >= il; k--) {\n        double s = FastMath.abs(matrixT[k][k - 1]) + FastMath.abs(matrixT[k + 1][k - 1]);\n        if (s != 0.0) {\n            scale = scale + s;\n        }\n    }\n\n    for (int k = im; k >= il; k--) {\n        double p = matrixT[k][k - 1] / scale;\n        double q = matrixT[k + 1][k - 1] / scale;\n        double r = FastMath.hypot(p, q);\n        hVec[2] = q / (2.0 * r);\n        hVec[1] = (p + q * hVec[2]) / (2.0 * r);\n        hVec[0] = r;\n        h = hVec[0] * scale * (h + hVec[0] * hVec[1] * hVec[2]);\n        if (k == iu) {\n            shift.x = h;\n        } else {\n            shift.y = h;\n        }\n        if (k != im) {\n            double s = FastMath.abs(matrixT[k][k - 1]);\n            if (s != 0.0) {\n                h = h * s * s;\n            }\n        }\n        hVec[2] = hVec[2] * scale;\n        hVec[1] = hVec[1] * scale;\n        hVec[0] = hVec[0] * scale;\n        if (k == iu) {\n            shift.x = h;\n        } else {\n            shift.y = h;\n        }\n        if (k == im) {\n            break;\n        }\n        double x = matrixT[k + 1][k - 1];\n        double y = 0.0;\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  [/CONTEXT]",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  "
    ],
    [
      "public List<TextNode> textNodes()  {\n    final List<Node> nodes = childNodes();\n    final List<TextNode> textNodes = new ArrayList<>(nodes.size());\n    for (Node node : nodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    final List<Node> nodes = childNodes();\n    final ArrayList<TextNode> textNodes = new ArrayList<>(nodes.size());\n    for (Node node : nodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n        final List<Node> children = childNodes();\n        final List<TextNode> textNodes = new ArrayList<>(children.size());\n        for (Node child : children) {\n            if (child instanceof TextNode) {\n                textNodes.add((TextNode) child);\n            }\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    final List<Node> nodes = childNodes();\n    final List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : nodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n        List<Node> children = childNodes();\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node child : children) {\n            if (child instanceof TextNode) {\n                textNodes.add((TextNode) child);\n            }\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes()) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes()) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    long period = endMillis - startMillis;\n    return (int) period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = zeroInstance.getPeriodType().getField(chrono).getDifference(endMillis, startMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = (int) (endMillis - startMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    long period = endMillis - startMillis;\n    return (int) period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = zeroInstance.getPeriodType().getField(chrono).getDifference(endMillis, startMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = zeroInstance.getChronology().get(zeroInstance, startMillis, endMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = (int) (endMillis - startMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = (int) ((endMillis - startMillis) / zeroInstance.getMillis());\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = (int) (endMillis - startMillis);\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    long startMillis = chrono.set(start, 0L);\n    long endMillis = chrono.set(end, 0L);\n    int period = zeroInstance.getPeriodType().getDifference(endMillis, startMillis);\n    return period;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid 'index': \" + index);\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) {\n        throw new IllegalArgumentException(\"Invalid 'index': \" + index);\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid 'index': \" + index);\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getLegendCount()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInPhysicalOrder = new ArrayList<>(entries);\n    Collections.sort(entriesInPhysicalOrder, offsetComparator);\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> entriesList = new ArrayList<>(entries);\n        entriesList.sort(offsetComparator);\n        return Collections.enumeration(entriesList);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInOrder = new ArrayList<>(entries);\n    Collections.sort(entriesInOrder, offsetComparator);\n    return Collections.enumeration(entriesInOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInPhysicalOrder = new ArrayList<>(entries);\n    Collections.sort(entriesInPhysicalOrder, offsetComparator);\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesList = new ArrayList<>(entries);\n    entriesList.sort(offsetComparator);\n    return Collections.enumeration(entriesList);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> entriesList = new ArrayList<>(entries);\n        entriesList.sort(offsetComparator);\n        return Collections.enumeration(entriesList);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> entriesList = new ArrayList<>(entries);\n        entriesList.sort(offsetComparator);\n        return Collections.enumeration(entriesList);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInOrder = new ArrayList<>(entries);\n    Collections.sort(entriesInOrder, offsetComparator);\n    return Collections.enumeration(entriesInOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> entriesInOrder = new ArrayList<>(entries);\n    Collections.sort(entriesInOrder, offsetComparator);\n    return Collections.enumeration(entriesInOrder);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return wrapNode(Token.ELLIPSIS, typeNode);\n                }\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return typeNode;\n                }\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return wrapNode(Token.ELLIPSIS, typeNode);\n                }\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return typeNode;\n                }\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return wrapNode(Token.ELLIPSIS, typeNode);\n                }\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return typeNode;\n                }\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else {\n                    next();\n                }\n                return wrapNode(Token.ELLIPSIS, typeNode);\n            }\n        } else {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    } else {\n        return parseTypeExpressionAnnotation(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return new Node(Token.OPTIONAL_PARAMETER_TYPE, typeNode);\n                }\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return new Node(Token.PARAM_TYPE_EXPRESSION, typeNode);\n                }\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpressionAnnotation(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpressionAnnotation(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : getStackFrames(t)) \n    {\n        list.add(frame);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final List<String> list = new ArrayList<String>();\n        for (final String frame : getStackFrames(t)) \n        {\n            list.add(frame);\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final String stackTrace = getStackTrace(t);\n        final String[] stackFrames = getStackFrames(stackTrace);\n        return Arrays.asList(stackFrames);\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final String stackTrace = getStackTrace(t);\n        final String[] stackFrames = getStackFrames(stackTrace);\n        return Arrays.asList(stackFrames);\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final List<String> list = new ArrayList<String>();\n        for (final StackTraceElement element : t.getStackTrace()) {\n            list.add(\"\\tat \" + element);\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    for (final StackTraceElement element : t.getStackTrace()) {\n        list.add(\"\\tat \" + element);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : getStackFrames(t)) {\n        list.add(frame);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    for (final StackTraceElement trace : t.getStackTrace()) {\n        frames.add(trace.toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    for (final StackTraceElement element : t.getStackTrace()) \n    {\n        list.add(\"\\tat \" + element);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final List<String> list = new ArrayList<String>();\n        for (final String frame : getStackFrames(t)) \n        {\n            list.add(frame);\n        }\n        return list;\n    }"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    Node args = function.getNext();\n    if (isRecursiveFunction(function)) {\n        return true;\n    }\n    for (Node arg : args.children()) {\n        if (arg.isName()) {\n            String name = arg.getString();\n            if (name.equals(\"this\") || name.equals(\"super\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (fn.isName() && isRecursiveFunction(fn)) {\n      return true;\n    }\n\n    Node arg = call.getNext();\n    while (arg != null) {\n      if (arg.isName() && arg.getString().equals(\"this\")) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    Node args = function.getNext();\n    if (args == null) {\n      return false;\n    }\n    Node arg = args.getFirstChild();\n    while (arg != null) {\n      if (arg.isName() && compiler.getFunction(arg.getString()) != null) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    Node args = function.getNext();\n    if (args == null) {\n      return false;\n    }\n\n    Node arg = args.getFirstChild();\n    while (arg != null) {\n      if (arg.isVariable() || arg.isFunction()) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    Node args = function.getNext();\n    if (args == null) \n    {\n        return false;\n    }\n\n    if (isRecursiveFunction(function)) \n    {\n        return true;\n    }\n\n    Node arg = args.getFirstChild();\n    while (arg != null) \n    {\n        if (arg.isName() && !compiler.isConstant(arg)) \n        {\n            return true;\n        }\n        arg = arg.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    Node args = function.getNext();\n    if (!isRecursiveFunction(function)) \n    {\n        return false;\n    }\n    for (Node arg : args.children()) \n    {\n        if (arg.isName()) \n        {\n            Node var = IR.var(arg);\n            if (var.getParent() != null && var.getParent().isExprResult()) \n            {\n                return true;\n            }\n        }\n        else if (arg.isExprResult()) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getNext();\n    while (args != null) {\n      if (args.isExpr() || args.isName()) {\n        Node arg = args.getFirstChild();\n        if (arg.isCall() && isRecursiveFunction(arg)) {\n          return true;\n        }\n      }\n      args = args.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (fn.isName() && isRecursiveFunction(fn)) {\n      return true;\n    }\n\n    Node argList = call.getNext();\n    for (Node arg : argList.children()) \n    {\n      if (arg.isFunction()) \n      {\n        return true;\n      }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (!fn.isFunction()) {\n      return false;\n    }\n\n    Node function = compiler.getFunctionForNode(fn);\n    if (function == null) {\n      return false;\n    }\n\n    Node args = fn.getNext();\n    Node arg = args.getFirstChild();\n    while (arg != null) {\n      if (arg.isName() && arg.getString().equals(\"this\")) {\n        arg = arg.getNext();\n        continue;\n      }\n\n      if (argMayHaveSideEffects(arg)) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (!fn.isFunction()) {\n      return false;\n    }\n    Node args = fn.getNext();\n    Node arg = args.getFirstChild();\n    while (arg != null) {\n      if (arg.isName()) {\n        Node var = compiler.getVariable(arg.getString());\n        if (var != null && var.isVar() && var.isFinal()) {\n          return false;\n        }\n      }\n      arg = arg.getNext();\n    }\n    return true;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    // Your code here\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    // Code goes here\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    // your code here\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    // your code here\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true;\n                return token;\n            } else if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int remaining = index;\n        for (int i = last; i >= 0; i--) {\n            counts[i] = remaining / uniCounterOffset[i];\n            remaining -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] = remaining;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int remaining = index;\n        for (int i = last; i >= 0; i--) {\n            counts[i] = remaining / uniCounterOffset[i];\n            remaining -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] = remaining;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = (index - uniCounterOffset[i]) / uniCounterOffset[i + 1];\n        index -= counts[i] * uniCounterOffset[i + 1];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int remaining = index;\n        for (int i = last; i >= 0; i--) {\n            counts[i] = remaining / uniCounterOffset[i];\n            remaining -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] = remaining;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        counts[i] = index % size[i];\n        index = (index - counts[i]) / size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = (index - uniCounterOffset[i]) / size[i];\n        index -= counts[i] * size[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int remaining = index;\n        for (int i = last; i >= 0; i--) {\n            counts[i] = remaining / uniCounterOffset[i];\n            remaining -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] = remaining;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        for (int i = last; i >= 0; i--) {\n            counts[i] = index % size[i];\n            index = (index - counts[i]) / size[i];\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = index % size[i];\n        index = (index - counts[i]) / size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        counts[i] = index % size[i];\n        index = (index - counts[i]) / size[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n        JsonPointer p = this;\n        while (p._nextSegment != null) {\n            p = p._nextSegment;\n        }\n        return p;\n    }",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n        JsonPointer p = this;\n        while (p._nextSegment != null) {\n            p = p._nextSegment;\n        }\n        return p;\n    }",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n        JsonPointer p = this;\n        while (p._nextSegment != null) {\n            p = p._nextSegment;\n        }\n        return p;\n    }",
      "public JsonPointer last()  {\n        JsonPointer p = this;\n        while (p._nextSegment != null) {\n            p = p._nextSegment;\n        }\n        return p;\n    }",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n        JsonPointer last = this;\n        while (last._nextSegment != null) {\n            last = last._nextSegment;\n        }\n        return last;\n    }",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read;\n\n        while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n            digest.update(buffer, 0, read);\n        }\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read;\n\n        while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n            digest.update(buffer, 0, read);\n        }\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read;\n\n        while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n            digest.update(buffer, 0, read);\n        }\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read;\n\n        while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n            digest.update(buffer, 0, read);\n        }\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read;\n\n        while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n            digest.update(buffer, 0, read);\n        }\n        return digest;\n    }"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                final T clone = (T) obj.clone();\n                return clone;\n            } catch (final CloneNotSupportedException ex) {\n                // should not happen as Cloneable is implemented\n                throw new CloneFailedException(\"Cloneable implemented class is expected to implement Cloneable interface\", ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                final T clone = (T) obj.clone();\n                return clone;\n            } catch (final CloneNotSupportedException ex) {\n                // this should never happen since we know obj is cloneable\n                throw new CloneFailedException(\"Cloneable object was not cloneable\", ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Cloneable)) {\n            throw new CloneFailedException(\"The object \" + obj + \" is not cloneable.\");\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) obj.clone();\n            return result;\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"The object \" + obj + \" is not cloneable.\", ex);\n        }\n    }\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Cloneable)) {\n            throw new CloneFailedException(\"Object \" + obj + \" is not cloneable\");\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) obj.clone();\n            return clone;\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"Object \" + obj + \" could not be cloned\", ex);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                final T clone = (T) obj.clone();\n                return clone;\n            } catch (final CloneNotSupportedException ex) {\n                // should not happen as Cloneable is implemented\n                throw new CloneFailedException(\"Cloneable implemented object is not cloneable\", ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Cloneable)) {\n            throw new CloneFailedException(\"The object \" + obj + \" is not cloneable.\");\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) obj.clone();\n            return clone;\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"The object \" + obj + \" cannot be cloned.\", ex);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) obj.clone();\n            return result;\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"Clone operation failed for \" + obj, ex);\n        }\n    }",
      "public static <T> T clone(final T obj)  ",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) obj.clone();\n            return result;\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(\"Clone operation failed for object of type [\" + obj.getClass().getName() + \"]\", e);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Cloneable)) {\n            throw new CloneFailedException(\"The object \" + obj + \" is not cloneable\");\n        }\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) obj.clone();\n            return clone;\n        } catch (final CloneNotSupportedException ex) {\n            throw new CloneFailedException(\"The object \" + obj + \" cannot be cloned\", ex);\n        }\n    }\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    for (Symbol param : type.getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    for (Symbol symbol : type.getParameters()) {\n        if (symbol.getName().equals(paramName)) {\n            return symbol;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    for (Symbol symbol : type.getParameters()) {\n        if (symbol.getName().equals(paramName)) {\n            return symbol;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    for (Symbol param : type.getParameters()) \n    {\n        if (param.getName().equals(paramName)) \n        {\n            return param;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    List<Symbol> parameters = type.getParameters();\n    for (Symbol parameter : parameters) {\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    for (Symbol param : type.getParameters()) {\n        if (param.getName().equals(paramName)) {\n            return param;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    List<Symbol> parameters = type.getParameters();\n    for (Symbol parameter : parameters) {\n      if (parameter.getName().equals(paramName)) {\n        return parameter;\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    for (Symbol parameter : type.getParameters()) \n    {\n        if (parameter.getName().equals(paramName)) \n        {\n            return parameter;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    for (Symbol symbol : type.getParameters()) {\n        if (symbol.getName().equals(paramName)) {\n            return symbol;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    for (Symbol symbol : type.getParameters()) \n    {\n        if (symbol.getName().equals(paramName)) \n        {\n            return symbol;\n        }\n    }\n\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = new Array2DRowRealMatrix(n, n);\n        double[] means = new double[n];\n        for (int i = 0; i < n; i++) {\n            means[i] = StatUtils.mean(matrix.getColumn(i));\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                covarianceMatrix.setEntry(i, j, cov);\n                covarianceMatrix.setEntry(j, i, cov);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] covarianceMatrix = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                double cov = 0.0;\n                for (int k = 0; k < matrix.getRowDimension(); k++) {\n                    cov += (data[k][i] - mean(data[k])) * (data[k][j] - mean(data[k]));\n                }\n                cov /= matrix.getRowDimension() - 1;\n                covarianceMatrix[i][j] = cov;\n                covarianceMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covarianceMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] covMatrix = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double cov = 0.0;\n                for (int k = 0; k < data[0].length; k++) {\n                    cov += (data[i][k] - mean(data[i])) * (data[j][k] - mean(data[j]));\n                }\n                cov /= (data[0].length - (biasCorrected ? 1 : 0));\n                covMatrix[i][j] = cov;\n                covMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[] means = new double[p];\n        for (int j = 0; j < p; j++) {\n            means[j] = StatUtils.mean(data, 0, n, j);\n        }\n        double[][] covMatrix = new double[p][p];\n        for (int j = 0; j < p; j++) {\n            for (int k = j; k < p; k++) {\n                double cov = 0.0;\n                for (int i = 0; i < n; i++) {\n                    cov += (data[i][j] - means[j]) * (data[i][k] - means[k]);\n                }\n                cov /= (n - (biasCorrected ? 1 : 0));\n                covMatrix[j][k] = cov;\n                covMatrix[k][j] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nCols = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] covarianceMatrix = new double[nCols][nCols];\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double cov = 0.0;\n                for (int k = 0; k < n; k++) {\n                    cov += (data[k][i] - mean(data[k])) * (data[k][j] - mean(data[k]));\n                }\n                cov /= n - (biasCorrected ? 1 : 0);\n                covarianceMatrix[i][j] = cov;\n                covarianceMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covarianceMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix meanVector = new Array2DRowRealMatrix(new double[n][1]);\n        for (int i = 0; i < n; i++) {\n            meanVector.setEntry(i, 0, mean(matrix.getColumn(i)));\n        }\n        RealMatrix centeredMatrix = new Array2DRowRealMatrix(matrix.getData()).subtract(meanVector.multiply(n));\n        return centeredMatrix.transpose().multiply(centeredMatrix).scalarDivide(n);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nCols = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] covMatrix = new double[nCols][nCols];\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double cov = covariance(data[i], data[j], biasCorrected);\n                covMatrix[i][j] = cov;\n                covMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] cov = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                double sum = 0;\n                for (int k = 0; k < n; k++) {\n                    sum += (data[k][i] - mean(data[k])) * (data[k][j] - mean(data[k]));\n                }\n                cov[i][j] = sum / (n - (biasCorrected ? 1 : 0));\n                cov[j][i] = cov[i][j];\n            }\n        }\n        return new Array2DRowRealMatrix(cov, false);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nCols = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = new Array2DRowRealMatrix(nCols, nCols);\n        double[] mean = new double[nCols];\n        for (int i = 0; i < nCols; i++) {\n            mean[i] = StatUtils.mean(matrix.getColumn(i));\n        }\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                covarianceMatrix.setEntry(i, j, cov);\n                covarianceMatrix.setEntry(j, i, cov);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nCols = matrix.getColumnDimension();\n        double[][] data = matrix.getData();\n        double[][] covMatrix = new double[nCols][nCols];\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double cov = covariance(data[i], data[j], biasCorrected);\n                covMatrix[i][j] = cov;\n                covMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covMatrix);\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (ensureCache(count)) {\n                return -1;\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > 63) {\n            throw new IllegalArgumentException(\"count must be between 1 and 63\");\n        }\n        if (bitsCachedSize < count) {\n            if (bitsCachedSize < 57) {\n                if (ensureCache(count)) {\n                    return -1;\n                }\n            } else {\n                return processBitsGreater57(count);\n            }\n        }\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    while (parent != null) {\n        if (parent.isLabel() && parent.getStringValue().equals(label)) {\n            return true;\n        }\n        parent = parent.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() != Token.LABEL) {\n        return false;\n    }\n    return target.getStringValue().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() != Token.LABEL) {\n        return false;\n    }\n    return target.getStringValue().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    while (parent != null) {\n        if (parent.isLabel() && parent.getStringValue().equals(label)) {\n            return true;\n        }\n        parent = parent.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    while (parent != null) {\n        if (parent.isLabel() && parent.getStringValue().equals(label)) {\n            return true;\n        }\n        parent = parent.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getStringValue().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getStringValue().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    while (parent != null) {\n        if (parent.isLabel() && parent.getStringValue().equals(label)) {\n            return true;\n        }\n        parent = parent.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    while (parent != null) {\n        if (parent.isLabeledStatement() && parent.getLabel().equals(label)) {\n            return true;\n        }\n        parent = parent.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getStringValue().equals(label);\n    }\n    return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYZURLGenerator urlGenerator = getURLGenerator();\n    if (urlGenerator != null) {\n        return urlGenerator.generateURL(getDataset(), series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYZURLGenerator urlGenerator = getURLGenerator();\n    if (urlGenerator != null) \n    {\n        XYZDataset dataset = getDataset();\n        if (dataset != null) \n        {\n            return urlGenerator.generateURL(dataset, series, item);\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYZURLGenerator urlGenerator = getURLGenerator();\n    if (urlGenerator != null) \n    {\n        return urlGenerator.generateURL(getDataset(), series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator generator = getURLGenerator();\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n        XYDataset dataset = getDataset();\n        XYURLGenerator urlGenerator = getURLGenerator();\n        if (urlGenerator != null) {\n            return urlGenerator.generateURL(dataset, series, item);\n        }\n        return null;\n    }",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator generator = getURLGenerator();\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator urlGenerator = getURLGenerator();\n    if (urlGenerator != null) \n    {\n        return urlGenerator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator generator = getURLGenerator();\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator generator = getURLGenerator();\n    if (generator != null) {\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = getDataset();\n    XYURLGenerator urlGenerator = getURLGenerator();\n    if (urlGenerator != null) {\n        return urlGenerator.generateURL(dataset, series, item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    if (i < len) { // skip leading sign:\n        char c = str.charAt(0);\n        if (c == '+') { // for plus, actually physically remove\n            str = str.substring(1);\n            len = str.length();\n        } else if (c == '-') { // minus, just skip for checks, must retain\n            ++i;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        // if other symbols, parse as Double, coerce\n        if (c > '9' || c < '0') {\n            try {\n                return (int) parseDouble(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) { }\n    return -1;\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    if (i < len) { // skip leading sign:\n        char c = str.charAt(0);\n        if (c == '+') { // for plus, actually physically remove\n            str = str.substring(1);\n            len = str.length();\n        } else if (c == '-') { // minus, just skip for checks, must retain\n            ++i;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        // if other symbols, parse as Double, coerce\n        if (c > '9' || c < '0') {\n            try {\n                return (int) parseDouble(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) { }\n    return -1;\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    int len = str.length();\n    int start = 0;\n    boolean negative = false;\n    char c;\n\n    if (len > 1 && str.charAt(0) == '-') {\n        negative = true;\n        start = 1;\n    }\n\n    for (int i = start; i < len; i++) {\n        c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            index = index * 10 + (c - '0');\n        } else {\n            throw new NumberFormatException(\"Invalid index: \" + str);\n        }\n    }\n\n    return negative ? -index : index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int idx = 0;\n    for (int i = 0; i < len; i++) \n    {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') \n        {\n            throw new NumberFormatException(\"Invalid index: \" + str);\n        }\n        idx = idx * 10 + (c - '0');\n    }\n    return idx;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int idx = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        idx = (idx * 10) + (c - '0');\n    }\n    return idx;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    int len = str.length();\n    int i = 0;\n    while (i < len) \n    {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') \n        {\n            break;\n        }\n        index = index * 10 + (c - '0');\n        i++;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    if (i < len) { // skip leading sign:\n        char c = str.charAt(0);\n        if (c == '+') { // for plus, actually physically remove\n            str = str.substring(1);\n            len = str.length();\n        } else if (c == '-') { // minus, just skip for checks, must retain\n            ++i;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        // if other symbols, parse as Double, coerce\n        if (c > '9' || c < '0') {\n            try {\n                return (int) parseDouble(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) { }\n    return -1;\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int index = str.indexOf('[');\n    if (index < 0) {\n        return -1;\n    }\n    int end = str.indexOf(']', index + 1);\n    if (end < 0) {\n        return -1;\n    }\n    try {\n        return Integer.parseInt(str.substring(index + 1, end));\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    if (i < len) { // skip leading sign:\n        char c = str.charAt(0);\n        if (c == '+') { // for plus, actually physically remove\n            str = str.substring(1);\n            len = str.length();\n        } else if (c == '-') { // minus, just skip for checks, must retain\n            ++i;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        // if other symbols, parse as Double, coerce\n        if (c > '9' || c < '0') {\n            try {\n                return (int) parseDouble(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) { }\n    return -1;\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    if (i < len) { // skip leading sign:\n        char c = str.charAt(0);\n        if (c == '+') { // for plus, actually physically remove\n            str = str.substring(1);\n            len = str.length();\n        } else if (c == '-') { // minus, just skip for checks, must retain\n            ++i;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        // if other symbols, parse as Double, coerce\n        if (c > '9' || c < '0') {\n            try {\n                return (int) parseDouble(str);\n            } catch (NumberFormatException e) {\n                return -1;\n            }\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) { }\n    return -1;\n}\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = getElementAt(c, permutation[i]);\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = getObjectFromCollectionByIndex(c, permutation[i]);\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE, k, n);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n    }\n\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = (Object) c.toArray()[permutation[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) \n    {\n        sample[i] = toArray(c)[permutation[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE, k, n);\n    }\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n    }\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = (Object) c.toArray()[permutation[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE, k, n);\n    }\n    if (k < 1) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n    }\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (int index : permutation) \n    {\n        sample[i++] = new ArrayList<>(c).get(index);\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) \n    {\n        sample[i] = getElementAt(c, permutation[i]);\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[permutation[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = getElementAt(c, permutation[i]);\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = toArray(c)[permutation[i]];\n    }\n    return sample;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = Node.makeMethodCall(methodName, argumentNode, srcref);\n    methodCall.setType(Token.CALL);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNode = IR.name(methodName).copyInformationFrom(srcref);\n    Node callNode = IR.call(methodNode).copyInformationFrom(srcref);\n    callNode.addChildToEnd(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = IR.call(IR.name(methodName), argumentNode);\n    methodCall.setSrcRef(srcref);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = Node.makeMethodCall(methodName, argumentNode);\n    methodCall.setSrcRef(srcref);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodNode = IR.name(methodName).copyInformationFrom(srcref);\n    Node callNode = IR.call(methodNode).copyInformationFrom(srcref);\n    callNode.addChild(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = IR.call(methodName).copyInformationFrom(srcref);\n    methodCall.addChildToEnd(argumentNode);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = IR.call(IR.name(methodName), argumentNode).copyInformationFrom(srcref);\n    if (srcref != null) {\n        methodCall.setSrcRef(srcref);\n    }\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = IR.call(IR.name(methodName), argumentNode);\n    methodCall.setSrcRef(srcref);\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCallNode = IR.call(methodName).copyInformationFrom(srcref);\n    methodCallNode.addChildToEnd(argumentNode);\n    return methodCallNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCallNode = IR.call(IR.name(methodName), argumentNode)\n        .copyInformationFrom(srcref);\n    return methodCallNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  throws NullArgumentException, DimensionMismatchException {\n    // Consistency checks.\n    if (doubles == null) {\n        throw new NullArgumentException();\n    }\n\n    final int len = doubles.length;\n\n    // Associate each fitness \"doubles[i]\" with its index \"i\".\n    final List<Pair<Double, Integer>> list\n        = new ArrayList<Pair<Double, Integer>>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Create comparators for increasing order.\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  throws NullArgumentException, DimensionMismatchException {\n    // Consistency checks.\n    if (doubles == null) {\n        throw new NullArgumentException();\n    }\n\n    final int len = doubles.length;\n\n    // Associate each abscissa \"doubles[i]\" with its index \"i\".\n    final List<Pair<Double, Integer>> list\n        = new ArrayList<Pair<Double, Integer>>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Create comparators for increasing order.\n    final Comparator<Pair<Double, Integer>> comp\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final Integer[] indices = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Initialize the array of indices.\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n\n    // Sort the indices based on the values in the doubles array.\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            qtData[i][i] = 1.0;\n            for (int j = 0; j < i; ++j) \n            {\n                double sum = 0.0;\n                for (int k = 0; k < m; ++k) \n                {\n                    sum += householderVectors[k][i] * householderVectors[k][j];\n                }\n                qtData[i][j] = -2.0 * sum;\n                qtData[j][i] = qtData[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                qtData[i][j] = householderVectors[j][i];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < cachedQt.getRowDimension(); i++) \n        {\n            for (int j = 0; j < i; j++) \n            {\n                double temp = cachedQt.getEntry(i, j);\n                cachedQt.setEntry(i, j, cachedQt.getEntry(j, i));\n                cachedQt.setEntry(j, i, temp);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            qtData[i][i] = 1.0;\n            for (int j = i + 1; j < m; ++j) {\n                for (int k = 0; k < m; ++k) {\n                    qtData[j][k] += householderVectors[i][k] * householderVectors[j][i];\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            qtData[i][i] = 1.0;\n            for (int j = 0; j < i; ++j) \n            {\n                qtData[i][j] = householderVectors[j][i];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            qtData[i][i] = 1.0;\n            for (int j = i + 1; j < m; ++j) \n            {\n                for (int k = 0; k < m; ++k) \n                {\n                    qtData[j][k] += householderVectors[k][i] * householderVectors[j][i];\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            qtData[i][i] = 1.0;\n            for (int j = 0; j < i; ++j) \n            {\n                double sum = 0.0;\n                for (int k = 0; k < m; ++k) \n                {\n                    sum += householderVectors[k][i] * householderVectors[k][j];\n                }\n                qtData[i][j] = -2.0 * sum;\n                qtData[j][i] = qtData[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            qtData[i][i] = 1.0;\n            for (int j = 0; j < i; ++j) \n            {\n                double sum = 0.0;\n                for (int k = 0; k < m; ++k) \n                {\n                    sum += householderVectors[k][i] * householderVectors[k][j];\n                }\n                qtData[i][j] = -2.0 * sum;\n                qtData[j][i] = qtData[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<E>(set, transformer);\n    Iterator<E> it = set.iterator();\n    while(it.hasNext()) \n    {\n        E element = it.next();\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  [CONTEXT]\n     * Inner class iterator.\n     */",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        @SuppressWarnings(\"unchecked\") // set is type E\n        E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n        set.clear();\n        for (E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n    if (set.size() > 0) {\n        @SuppressWarnings(\"unchecked\") // set is type E\n        final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n        set.clear();\n        for (final E value : values) {\n            decorated.decorated().add(transformer.transform(value));\n        }\n    }\n    return decorated;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) {\n}\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  [CONTEXT]\n     * Inner class iterator.\n     */",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  ",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<E>(set, transformer);\n    Iterator<E> iterator = set.iterator();\n    while(iterator.hasNext()) \n    {\n        E element = iterator.next();\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) \n    {\n}\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    final Set<E> transformedSet = new HashSet<E>();\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                total = total + value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n        }\n        int offset = 0;\n        try {\n            int hoursInMinutes = hoursOffset * 60;\n            if (hoursInMinutes < 0) {\n                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n            } else {\n                minutesOffset = hoursInMinutes + minutesOffset;\n            }\n            offset = minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n        } catch (ArithmeticException ex) {\n            throw new IllegalArgumentException(\"Offset is too large\");\n        }\n        return forOffsetMillis(offset);\n    }"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do \n        {\n            if (isEmpty()) break;\n            char c = consume();\n            if (last == 0 || last != '\\\\') \n            {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c == open) \n                {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } \n        while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) \n        {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do \n        {\n            if (queue.isEmpty()) \n                break;\n            char c = queue.consume();\n            if (last == 0 || last != '\\\\') \n            {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c == open) \n                {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } \n        while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) // ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            char c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c == open) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do \n        {\n            if (queue.isEmpty()) \n                break;\n            char c = queue.consume();\n            if (last == 0 || last != '\\\\') \n            {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c == open) \n                {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } \n        while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) \n        {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }",
      "public String chompBalanced(char open, char close)  {\n        int depth = 0;\n        int start = -1;\n        int end = -1;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != '\\\\') {\n                if (c.equals('\\'') && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c.equals('\"') && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote)\n                    continue;\n\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null) {\n            throw new NullPointerException(LocalizedFormats.DATA_NOT_LOADED);\n        }\n        int n = xMatrix.getRowDimension();\n        int p = xMatrix.getColumnDimension();\n        RealMatrix xtx = xMatrix.multiply(xMatrix.transpose());\n        QRDecomposition qr = new QRDecomposition(xtx);\n        // Only the top p rows of R are used.\n        RealMatrix r = qr.getR().getSubMatrix(0, p - 1, 0, p - 1);\n        // Invert R.\n        RealMatrix rInv = r.scalarAdd(1.0).inverse();\n        // Multiply by (X^T * X)^-1.\n        return rInv.multiply(xtx.inverse());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null) {\n            throw new NullPointerException(\"Data for the model must be loaded first.\");\n        }\n        // Calculate X'X\n        final RealMatrix xTx = xMatrix.transpose().multiply(xMatrix);\n        // Perform QR decomposition\n        final QRDecomposition qr = new QRDecomposition(xTx);\n        final RealMatrix r = qr.getR();\n        // Extract top p rows of R\n        final int p = xMatrix.getColumnDimension();\n        final RealMatrix rTop = r.getSubMatrix(0, p - 1, 0, p - 1);\n        // Calculate (R'R)^-1\n        final RealMatrix invRtR = rTop.transpose().multiply(rTop).inverse();\n        return invRtR;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null) {\n            throw new NullPointerException(LocalizedFormats.DATA_NOT_LOADED);\n        }\n        final int n = xMatrix.getRowDimension();\n        final int p = xMatrix.getColumnDimension();\n        final RealMatrix xTx = xMatrix.transpose().multiply(xMatrix);\n        final QRDecomposition qr = new QRDecomposition(xTx, QRDecomposition.LQ);\n        final RealMatrix r = qr.getR();\n        final RealMatrix rInv = r.inverse();\n        final RealMatrix betaVar = rInv.multiply(xMatrix.transpose()).multiply(rInv).transpose();\n        return betaVar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null) {\n            throw new NullPointerException(\"Data for the model has not been loaded\");\n        }\n        // Calculate X'X\n        final RealMatrix xtx = xMatrix.transpose().multiply(xMatrix);\n        // Calculate R\n        final QRDecomposition qr = new QRDecomposition(xtx);\n        final RealMatrix r = qr.getR();\n        // Calculate (R'R)^-1\n        final RealMatrix invRtr = r.transpose().multiply(r).inverse();\n        return invRtr;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Check that the data has been loaded\n        if (xMatrix == null || yVector == null) {\n            throw new NullPointerException(\"Data has not been loaded\");\n        }\n\n        // Calculate the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(xMatrix);\n        // Get the upper triangular matrix R from the QR decomposition\n        RealMatrix r = qr.getR();\n        // Get the transpose of R\n        RealMatrix rT = r.transpose();\n\n        // Calculate the inverse of R\n        RealMatrix rInv = r.inverse();\n        // Calculate the inverse of (X^T * X)\n        RealMatrix xTxInv = rT.multiply(rInv).scalarMultiply(1.0 / yVector.getL2Norm());\n\n        return xTxInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null || yVector == null) {\n            throw new NullPointerException(\"Data not loaded\");\n        }\n\n        final int n = xMatrix.getRowDimension();\n        final int p = xMatrix.getColumnDimension();\n\n        // Calculate the QR decomposition of X\n        final QRDecomposition qr = new QRDecomposition(xMatrix);\n        final UpperTriangularMatrix R = qr.getR();\n\n        // Calculate the inverse of R\n        final RealMatrix Rinv = R.inverse();\n\n        // Calculate the variance-covariance matrix\n        final RealMatrix betaVariance = Rinv.multiply(Rinv.transpose()).scalarMultiply(1.0 / n);\n\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null) {\n            throw new NullPointerException(LocalizedFormats.DATA_NOT_LOADED);\n        }\n        final int n = xMatrix.getRowDimension();\n        final int p = xMatrix.getColumnDimension();\n        // Calculate X'X\n        final RealMatrix xTx = xMatrix.transpose().multiply(xMatrix);\n        // Calculate R'R\n        final QRDecomposition qr = new QRDecomposition(xTx);\n        final RealMatrix r = qr.getR();\n        final RealMatrix rt = r.transpose();\n        final RealMatrix rtr = rt.multiply(rt);\n        // Calculate (R'R)^-1\n        final DecompositionSolver solver = new QRDecomposition(rtr).getSolver();\n        final RealMatrix invRtR = solver.getInverse();\n        // Calculate (X'X)^-1\n        final RealMatrix xTxInv = xTx.getInverse();\n        // Calculate beta variance\n        final RealMatrix betaVariance = xTxInv.multiply(invRtR).scalarMultiply(n / (n - p));\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null || yVector == null) {\n            throw new NullPointerException(\"Data for the model has not been loaded.\");\n        }\n\n        final int n = xMatrix.getRowDimension();\n        final int p = xMatrix.getColumnDimension();\n\n        // Calculate X'X\n        final RealMatrix xTx = xMatrix.transpose().multiply(xMatrix);\n\n        // Perform QR decomposition of X'X\n        final QRDecomposition qr = new QRDecomposition(xTx);\n        final RealMatrix r = qr.getR();\n\n        // Extract top p rows of R\n        final RealMatrix rTop = new Array2DRowRealMatrix(r.getData(), 0, 0, p, p);\n\n        // Calculate (R'R)^-1\n        final RealMatrix rtR = rTop.transpose().multiply(rTop);\n        final SingularValueDecomposition svd = new SingularValueDecomposition(rtR);\n        final RealMatrix inverse = svd.getSolver().solve(new DiagonalMatrix(p, p));\n\n        return inverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (xMatrix == null || yVector == null) {\n            throw new NullPointerException(LocalizedFormats.DATA_NOT_LOADED);\n        }\n\n        // Calculate the QR decomposition of the design matrix\n        final QRDecomposition qr = new QRDecomposition(xMatrix, QRDecomposition.LQ);\n        final RealMatrix r = qr.getR();\n        final int p = (int) Math.min(r.getRowDimension(), r.getColumnDimension());\n\n        // Extract the top p rows of R\n        final RealMatrix rTop = new Array2DRowRealMatrix(r.getData(), 0, 0, p, r.getColumnDimension());\n\n        // Calculate (R<sup>T</sup>R)<sup>-1</sup>\n        final RealMatrix rtRInv = new LUDecomposition(rTop.transpose().multiply(rTop)).getSolver().getInverse();\n\n        return rtRInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Check if data has been loaded\n        if (xMatrix == null || yVector == null) {\n            throw new NullPointerException(\"Data has not been loaded\");\n        }\n\n        // Calculate beta\n        RealVector beta = calculateBeta();\n\n        // Calculate X'X\n        RealMatrix xTransposeX = xMatrix.transpose().multiply(xMatrix);\n\n        // Perform QR decomposition\n        QRDecomposition qr = new QRDecomposition(xTransposeX);\n        RealMatrix r = qr.getR();\n\n        // Calculate (R'R)^-1\n        RealMatrix rTransposeR = r.transpose().multiply(r);\n        DecompositionSolver solver = new LUDecomposition(rTransposeR).getSolver();\n        RealMatrix invRTR = solver.getInverse();\n\n        // Calculate beta variance\n        RealMatrix betaVariance = invRTR.multiply(beta.outerProduct(beta));\n\n        return betaVariance;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        long seconds = offset / 1000L;\n        long absSeconds = Math.abs(seconds);\n        String sign = seconds >= 0 ? \"+\" : \"-\";\n        long hours = absSeconds / 3600;\n        long minutes = (absSeconds % 3600) / 60;\n        long secondsPart = absSeconds % 60;\n        return sign + String.format(\"%02d:%02d:%02d\", hours, minutes, secondsPart);\n    }",
      "private static String printOffset(int offset)  {\n    long millis = offset;\n    long hours = TimeUnit.MILLISECONDS.toHours(millis);\n    long minutes = TimeUnit.MILLISECONDS.toMinutes(millis) - TimeUnit.HOURS.toMinutes(hours);\n    long seconds = TimeUnit.MILLISECONDS.toSeconds(millis) - TimeUnit.MINUTES.toSeconds(minutes);\n\n    StringBuilder buf = new StringBuilder(10);\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n        StringBuilder buf = new StringBuilder(15);\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        buf.append('G');\n        if (hours < 0) {\n            buf.append('M');\n            hours = -hours;\n        } else {\n            buf.append('+');\n        }\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n    long seconds = offset / 1000;\n    long minutes = seconds / 60;\n    seconds %= 60;\n    long hours = minutes / 60;\n    minutes %= 60;\n\n    return String.format(\"%s%02d:%02d:%02d\", (hours < 0 ? \"-\" : \"+\"), Math.abs(hours), Math.abs(minutes), Math.abs(seconds));\n}",
      "private static String printOffset(int offset)  {\n    long millis = offset;\n    long seconds = millis / 1000;\n    millis -= seconds * 1000;\n    long minutes = seconds / 60;\n    seconds -= minutes * 60;\n    long hours = minutes / 60;\n    minutes -= hours * 60;\n\n    StringBuilder buf = new StringBuilder(19);\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    if (seconds > 0) {\n        buf.append(':');\n        if (seconds < 10) {\n            buf.append('0');\n        }\n        buf.append(seconds);\n        if (millis > 0) {\n            buf.append('.');\n            long fraction = millis * 1000;\n            long fractionLength = Long.toString(fraction).length();\n            for (int i = fractionLength; i < 3; i++) {\n                buf.append('0');\n            }\n            buf.append(fraction);\n        }\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuilder buf = new StringBuilder(15);\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    buf.append('+');\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    }\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n        long millis = offset;\n        long seconds = millis / 1000L;\n        long minutes = seconds / 60L;\n        long hours = minutes / 60L;\n        millis -= seconds * 1000L;\n        seconds -= minutes * 60L;\n        minutes -= hours * 60L;\n        return String.format(\"GMT%s%02d:%02d:%02d\", hours < 0 ? \"-\" : \"+\", Math.abs(hours), Math.abs(minutes), Math.abs(seconds));\n    }",
      "private static String printOffset(int offset)  {\n        StringBuilder buf = new StringBuilder(15);\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        buf.append('+');\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        offset -= hours * DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n    long offsetInMinutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n    long absOffsetInMinutes = Math.abs(offsetInMinutes);\n    long hours = absOffsetInMinutes / 60;\n    long minutes = absOffsetInMinutes % 60;\n    StringBuilder buf = new StringBuilder(9);\n    buf.append((offsetInMinutes < 0 ? '-' : '+'));\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    long millis = offset;\n    long seconds = millis / 1000L;\n    long minutes = seconds / 60L;\n    long hours = minutes / 60L;\n    minutes = minutes % 60L;\n    String sign = (hours < 0L) ? \"-\" : \"+\";\n    return sign + String.format(\"%02d:%02d\", Math.abs(hours), Math.abs(minutes));\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    index = this.underlying.getRowIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key must not be null\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted\");\n    }\n\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    index = this.underlying.getRowIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted\");\n    }\n\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    index = this.underlying.getRowIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key must not be null\");\n    }\n\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted\");\n    }\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    ConcreteScope currentScope = this;\n    while (currentScope != null) {\n      for (ConcreteSlot slot : currentScope.getSlots()) {\n        if (slot.isFlowSlot()) {\n          flowSlots.put(slot.getName(), slot);\n        }\n      }\n      currentScope = currentScope.getParentScope();\n    }\n    return flowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n    ConcreteScope currentScope = this;\n    while (currentScope != null) \n    {\n        for (ConcreteSlot slot : currentScope.getSlots()) \n        {\n            allSlots.put(slot.getName(), slot);\n        }\n        currentScope = currentScope.getParentScope();\n    }\n    return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = Maps.newHashMap();\n  ConcreteScope currentScope = this;\n  while (currentScope != null) {\n    for (ConcreteSlot slot : currentScope.getSlots()) {\n      flowSlots.put(slot.getName(), slot);\n    }\n    currentScope = currentScope.getParentScope();\n  }\n  return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n  ConcreteScope currentScope = this;\n  while (currentScope != null) \n  {\n    for (ConcreteSlot slot : currentScope.getSlots()) \n    {\n      allFlowSlots.put(slot.getName(), slot);\n    }\n    currentScope = currentScope.getParentScope();\n  }\n  return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  // Your code goes here\n  for (StaticScope<JSType> scope = this; scope != null; scope = scope.getParentScope()) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.getSlots().entrySet()) {\n      allSlots.put(entry.getKey(), entry.getValue());\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = Maps.newHashMap();\n    if (parent != null) {\n      allSlots.putAll(parent.allFlowSlots());\n    }\n    allSlots.putAll(slots);\n    return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = Maps.newHashMap();\n    ConcreteScope currentScope = this;\n    while (currentScope != null) {\n      for (ConcreteSlot slot : currentScope.getSlots()) {\n        if (!slot.isTemporary() && slot.getType() != ConcreteType.NONE) {\n          flowSlots.put(slot.getName(), new SimpleSlot(slot.getName(), slot.getType(), false));\n        }\n      }\n      currentScope = currentScope.getParentScope();\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n    if (flowsFromBottom()) {\n        allFlowSlots.putAll(getFunctionScope().getSlots());\n    } else {\n        allFlowSlots.putAll(getParentScope().allFlowSlots());\n        allFlowSlots.putAll(getFunctionScope().getSlots());\n    }\n    return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n    ConcreteScope currentScope = this;\n    while (currentScope != null) \n    {\n        for (ConcreteSlot slot : currentScope.getSlots()) \n        {\n            allFlowSlots.put(slot.getName(), slot);\n        }\n        currentScope = currentScope.getParentScope();\n    }\n    return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = new HashMap<>();\n    if (parentScope != null) {\n        allFlowSlots.putAll(parentScope.allFlowSlots());\n    }\n    allFlowSlots.putAll(slots);\n    return allFlowSlots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n\n    final int nRows = columnData.length;\n    final RealMatrix matrix = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; i++) {\n        matrix.setEntry(i, 0, columnData[i]);\n    }\n    return matrix;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n\n    final int nRows = columnData.length;\n    final RealMatrix out = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        out.setEntry(i, 0, columnData[i]);\n    }\n\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix matrix = new Array2DRowRealMatrix(columnData.length, 1);\n    for (int i = 0; i < columnData.length; i++) {\n        matrix.setEntry(i, 0, columnData[i]);\n    }\n    return matrix;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n\n    final int nRows = columnData.length;\n    final RealMatrix out = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        out.setEntry(i, 0, columnData[i]);\n    }\n\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix matrix = new Array2DRowRealMatrix(columnData.length, 1);\n    for (int i = 0; i < columnData.length; i++) {\n        matrix.setEntry(i, 0, columnData[i]);\n    }\n    return matrix;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n\n    final int nRows = columnData.length;\n    final RealMatrix out = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        out.setEntry(i, 0, columnData[i]);\n    }\n\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n\n    final int nRows = columnData.length;\n    final RealMatrix out = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        out.setEntry(i, 0, columnData[i]);\n    }\n\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix matrix = new Array2DRowRealMatrix(columnData.length, 1);\n    for (int i = 0; i < columnData.length; i++) {\n        matrix.setEntry(i, 0, columnData[i]);\n    }\n    return matrix;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final int nRows = columnData.length;\n    final RealMatrix matrix = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; i++) {\n        matrix.setEntry(i, 0, columnData[i]);\n    }\n    return matrix;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final int nRows = columnData.length;\n    final RealMatrix out = new Array2DRowRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        out.setEntry(i, 0, columnData[i]);\n    }\n\n    return out;\n}"
    ],
    [
      "public static double atanh(double a)  {\n        if (a > 1 || a < -1) {\n            throw new IllegalArgumentException(\"Argument must be in the range [-1, 1]\");\n        }\n\n        if (a == 1.0) {\n            return 0.0;\n        }\n\n        if (a == -1.0) {\n            return Math.PI;\n        }\n\n        final double absAtanh;\n        if (Math.abs(a) > 0.15) {\n            absAtanh = 0.5 * Math.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (Math.abs(a) > 0.087) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        return Double.NaN;\n    }\n\n    boolean negative = false;\n    if (a < 0.0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n        if (a > 1 || a < -1) {\n            throw new IllegalArgumentException(\"Argument must be in the range [-1,1]\");\n        }\n        return 0.5 * log((1 + a) / (1 - a));\n    }",
      "public static double atanh(double a)  {\n        if (a > 1 || a < -1) {\n            throw new IllegalArgumentException(\"Argument must be in the range (-1,1)\");\n        }\n        return 0.5 * log((1 + a) / (1 - a));\n    }",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Input must be in the range (-1, 1)\");\n    }\n\n    if (a == Double.POSITIVE_INFINITY) {\n        return 0.0;\n    }\n\n    if (a == Double.NEGATIVE_INFINITY) {\n        return 0.0;\n    }\n\n    boolean negative = false;\n    if (a < 0.0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument must be in the range [-1,1]\");\n    }\n\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n\n    boolean negative = false;\n    if (a < 0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument must be in the range [-1, 1]\");\n    }\n\n    boolean negative = false;\n    if (a < 0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"Argument must be in the range [-1,1]\");\n    }\n\n    boolean negative = false;\n    if (a < 0.0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    if (a > 1 || a < -1) {\n        throw new IllegalArgumentException(\"Input must be in range [-1, 1]\");\n    }\n\n    if (a == Double.POSITIVE_INFINITY) {\n        return 0;\n    }\n\n    if (a == Double.NEGATIVE_INFINITY) {\n        return Math.PI;\n    }\n\n    if (a == 1) {\n        return 0;\n    }\n\n    if (a == -1) {\n        return Math.PI;\n    }\n\n    boolean negative = false;\n    if (a < 0) {\n        a = -a;\n        negative = true;\n    }\n\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * Math.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n        if (a > 1.0 || a < -1.0) {\n            throw new IllegalArgumentException(\"The argument must be in the range [-1, 1]\");\n        }\n        if (a == 1.0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (a == -1.0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        return 0.5 * FastMath.log((1 + a) / (1 - a));\n    }"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  ",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  "
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIy = X.transpose().multiply(OI).multiply(y);\n        RealVector beta = new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIy = X.transpose().multiply(OI).multiply(y);\n        RealVector beta = new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIy = X.transpose().multiply(OI).multiply(y);\n        RealVector beta = new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getRowVector(0);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(OI).multiply(getX());\n        RealMatrix XTOIY = XT.multiply(OI).multiply(getY());\n        RealMatrix betaMatrix = new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n        return betaMatrix.getColumnVector(0);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.get(0);\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        id = id.trim();\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n\n    List<Element> elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.get(0);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.first(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        id = id.trim();\n\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n\n    List<Element> elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.isEmpty() ? null : elements.get(0);\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.collect(new Evaluator.Id(id), this);\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        id = id.trim();\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder(pattern.length());\n        int patternIndex = 0;\n        int formatIndex = 0;\n        while (patternIndex < pattern.length()) {\n            if (pattern.charAt(patternIndex) == ',') {\n                patternIndex++;\n                if (pattern.charAt(patternIndex) == '{') {\n                    patternIndex++;\n                    while (pattern.charAt(patternIndex) != '}') {\n                        result.append(pattern.charAt(patternIndex));\n                        patternIndex++;\n                    }\n                    result.append(customPatterns.get(formatIndex));\n                    formatIndex++;\n                }\n            }\n            result.append(pattern.charAt(patternIndex));\n            patternIndex++;\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder stripCustom = new StringBuilder(pattern.length());\n    final StringBuilder stripPattern = new StringBuilder(pattern.length());\n    final char[] c = pattern.toCharArray();\n    int fmtCount = 0;\n    int customCount = 0;\n    for (int i = 0; i < c.length; i++) \n    {\n        if (c[i] == START_FE) \n        {\n            stripCustom.append(c[i]);\n            stripCustom.append(fmtCount);\n            fmtCount++;\n            while (c[i] != END_FE) \n            {\n                stripCustom.append(c[i]);\n                i++;\n            }\n            stripCustom.append(c[i]);\n            stripPattern.append(customPatterns.get(customCount));\n            customCount++;\n        } \n        else \n        {\n            stripCustom.append(c[i]);\n            stripPattern.append(c[i]);\n        }\n    }\n    return stripPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] chars = pattern.toCharArray();\n    int index = 0;\n    int customIndex = 0;\n    while (index < chars.length) \n    {\n        if (chars[index] == START_FE) \n        {\n            result.append(chars[index]);\n            index++;\n            while (index < chars.length && Character.isDigit(chars[index])) \n            {\n                result.append(chars[index]);\n                index++;\n            }\n            if (index < chars.length && chars[index] == START_FMT) \n            {\n                result.append(chars[index]);\n                index++;\n                while (index < chars.length && chars[index] != END_FE) \n                {\n                    result.append(chars[index]);\n                    index++;\n                }\n                if (index < chars.length && chars[index] == END_FE) \n                {\n                    if (customIndex < customPatterns.size()) \n                    {\n                        result.append(customPatterns.get(customIndex));\n                        customIndex++;\n                    }\n                    result.append(chars[index]);\n                    index++;\n                }\n            }\n        } \n        else \n        {\n            result.append(chars[index]);\n            index++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int index = 0;\n    int patternIndex = 0;\n    while (index < pattern.length()) \n    {\n        if (pattern.charAt(index) == ',') \n        {\n            result.append(',');\n            index++;\n            while (index < pattern.length() && Character.isDigit(pattern.charAt(index))) \n            {\n                result.append(pattern.charAt(index));\n                index++;\n            }\n            if (index < pattern.length() && pattern.charAt(index) == '}') \n            {\n                result.append('}');\n                index++;\n            }\n        } \n        else if (pattern.charAt(index) == '\\'') \n        {\n            result.append('\\'');\n            index++;\n            while (index < pattern.length() && pattern.charAt(index) != '\\'') \n            {\n                result.append(pattern.charAt(index));\n                index++;\n            }\n            if (index < pattern.length() && pattern.charAt(index) == '\\'') \n            {\n                result.append('\\'');\n                index++;\n            }\n        } \n        else \n        {\n            result.append(pattern.charAt(index));\n            index++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder sb = new StringBuilder(pattern.length());\n        final char[] chars = pattern.toCharArray();\n        int fmtCount = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == ',') {\n                i++;\n                if (chars[i] == '}') {\n                    sb.append(',').append(customPatterns.get(fmtCount));\n                    fmtCount++;\n                }\n            }\n            sb.append(chars[i]);\n        }\n        return sb.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder();\n        final char[] chars = pattern.toCharArray();\n        int customIndex = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == START_FE && i + 1 < chars.length && chars[i + 1] == START_FMT) {\n                result.append(customPatterns.get(customIndex++));\n                i += 2;\n            } else {\n                result.append(chars[i]);\n            }\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder();\n        final char[] chars = pattern.toCharArray();\n        int formatIndex = 0;\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == START_FE) {\n                result.append(chars[i]);\n                result.append(formatIndex);\n                i++;\n                while (i < chars.length && chars[i] != END_FE) {\n                    result.append(chars[i]);\n                    i++;\n                }\n                if (i < chars.length && chars[i] == END_FE) {\n                    result.append(chars[i]);\n                    if (formatIndex < customPatterns.size()) {\n                        result.append(customPatterns.get(formatIndex));\n                    }\n                    formatIndex++;\n                }\n            } else {\n                result.append(chars[i]);\n            }\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder(pattern.length());\n        int patternIndex = 0;\n        int formatIndex = 0;\n        while (patternIndex < pattern.length()) {\n            if (pattern.charAt(patternIndex) == ',') {\n                patternIndex++;\n                result.append(',');\n                result.append(customPatterns.get(formatIndex));\n                formatIndex++;\n            } else {\n                result.append(pattern.charAt(patternIndex));\n                patternIndex++;\n            }\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n        final StringBuilder formatPattern = new StringBuilder(pattern.length());\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        for (int i = 0; i < c.length; i++) {\n            switch (c[i]) {\n                case ',':\n                    if (c[i + 1] == '}') {\n                        stripCustom.append(',');\n                        stripCustom.append(customPatterns.get(fmtCount));\n                        stripCustom.append('}');\n                        fmtCount++;\n                        i++;\n                    }\n                    break;\n                default:\n                    stripCustom.append(c[i]);\n            }\n        }\n        return stripCustom.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder sb = new StringBuilder(pattern.length());\n    int lastIndex = 0;\n    for (String customPattern : customPatterns) \n    {\n        sb.append(pattern.substring(lastIndex, customPattern == null ? pattern.length() : pattern.indexOf(customPattern)));\n        if (customPattern != null) \n        {\n            sb.append(customPattern);\n        }\n        lastIndex = customPattern == null ? pattern.length() : pattern.indexOf(customPattern) + customPattern.length();\n    }\n    return sb.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if they are the same type.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if they have the same number of type arguments.\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n\n    // Check if the type arguments are equal.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n        return from == to;\n    }\n\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    // Check if the types are exactly the same\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if the type arguments are exactly the same\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    // Check if they are the same type.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if they have the same number of type arguments.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    // Check if they have the same type arguments.\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    // Check if the types are equivalent under our current mapping.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n        return from == to;\n    }\n\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are the same type\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    // check if they have the same number of type arguments\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    // check if the type arguments are equivalent\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    // Check if the raw types are equal.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if the actual type arguments are equal.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method.\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (GraphNode<N, E> graphNode : getNodes()) {\n      if (graphNode.getAnnotation() instanceof GraphColoring.Color) {\n        if (graphNode.getValue().equals(node)) {\n          superNode = graphNode.getValue();\n          break;\n        }\n      }\n    }\n    return superNode;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap[node.getColor()] == null) {\n        colorToNodeMap[node.getColor()] = node;\n    }\n    return colorToNodeMap[node.getColor()];\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Your code here\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap[node.color] == null) {\n      colorToNodeMap[node.color] = node;\n    }\n    return colorToNodeMap[node.color];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (GraphNode<N, E> graphNode : getNodes()) {\n      if (graphNode.getValue().equals(node)) {\n        superNode = graphNode.getValue();\n        break;\n      }\n    }\n    return superNode;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap[color(node)] == null) {\n      colorToNodeMap[color(node)] = node;\n    }\n    return colorToNodeMap[color(node)];\n  }",
      "public N getPartitionSuperNode(N node)  {\n    if (!colorToNodeMap.containsKey(node)) {\n        throw new IllegalArgumentException(\"Node not found in graph\");\n    }\n    N superNode = node;\n    while (colorToNodeMap.get(superNode) != superNode) {\n        superNode = colorToNodeMap.get(superNode);\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (N n : graph.getNodes()) {\n      if (graph.getNodeAnnotation(n).equals(graph.getNodeAnnotation(node))) {\n        superNode = n;\n        break;\n      }\n    }\n    return superNode;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method.\n    return null;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    final List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint1 = (Paint) entry.getValue();\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint1 = (Paint) entry.getValue();\n        Paint paint2 = (Paint) map2.get(key);\n        if (paint2 == null || !PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry pair = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) pair.getKey();\n        Paint value1 = (Paint) pair.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value2 == null || !PaintUtilities.equal(value1, value2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        throw new IllegalArgumentException(\"Null not permitted\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint1 = (Paint) entry.getValue();\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint1 = (Paint) entry.getValue();\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint1 = (Paint) entry.getValue();\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String str = expr.getString();\n    if (str.startsWith(\"goog.getMsg(\") && str.endsWith(\");\")) {\n        String messageName = str.substring(11, str.length() - 2);\n        Node message = t.getModule().getMessages().get(messageName);\n        if (message != null) {\n            parent.replaceChild(expr, message);\n            t.report(expr, REPLACED_EXPRESSION);\n            return message;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String s = expr.getString();\n    if (s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) {\n        s = s.substring(1, s.length() - 1);\n    }\n    if (s.length() <= MAX_LENGTH) {\n        Node replacement = new Node(Token.STRING, s);\n        replacement.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, replacement);\n        t.report(expr, CODE_CHANGE);\n        return replacement;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Implementation here\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String string = expr.getString();\n    String replacement = stringMap.get(string);\n    if (replacement != null) {\n        Node newNode = new Node(Token.STRING, replacement);\n        newNode.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, newNode);\n        return newNode;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String string = expr.getString();\n    if (string.startsWith(PREFIX) && string.endsWith(SUFFIX)) {\n        String shortString = string.substring(PREFIX.length(), string.length() - SUFFIX.length());\n        Node shortExpr = new Node(Token.STRING, shortString);\n        shortExpr.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, shortExpr);\n        t.report(expr, SHORT_STRING_REPLACEMENT);\n        return shortExpr;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String string = expr.getString();\n    if (string.length() > MAX_STRING_LENGTH) {\n        return expr;\n    }\n\n    // Check for existing replacement\n    Node replacement = t.getReplacement(expr);\n    if (replacement != null) {\n        return replacement;\n    }\n\n    // Check for a match in our string map\n    String replacementString = stringMap.get(string);\n    if (replacementString != null) {\n        Node newNode = new Node(Token.STRING, replacementString);\n        newNode.copyInformationFromForTree(expr);\n        t.recordReplacement(expr, newNode);\n        return newNode;\n    }\n\n    // Check for a match in our number map\n    String replacementNumber = numberMap.get(string);\n    if (replacementNumber != null) {\n        Node newNode = new Node(Token.NUMBER, replacementNumber);\n        newNode.copyInformationFromForTree(expr);\n        t.recordReplacement(expr, newNode);\n        return newNode;\n    }\n\n    // No match found\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // If the expression is a string, we can replace it with a short string\n    if (expr.isString()) {\n        String string = expr.getString();\n        if (string.length() <= MAX_SHORT_STRING_LENGTH) {\n            Node replacement = new Node(Token.SHORT_STRING, string);\n            replacement.copyInformationFromForTree(expr);\n            parent.replaceChild(expr, replacement);\n            return replacement;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String s = expr.getString();\n    if (s.length() > 2 && s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) {\n        s = s.substring(1, s.length() - 1);\n        if (s.length() > 2 && s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) {\n            s = s.substring(1, s.length() - 1);\n            if (s.length() > 2 && s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) {\n                s = s.substring(1, s.length() - 1);\n                Node replacement = new Node(Token.STRING, s);\n                replacement.copyInformationFromForTree(expr);\n                parent.replaceChild(expr, replacement);\n                return replacement;\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // ...\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String string = expr.getString();\n    if (string.length() > MAX_LENGTH) {\n        return expr;\n    }\n    String replacement = shortEncode(string);\n    if (replacement.length() >= string.length()) {\n        return expr;\n    }\n    Node newNode = new Node(Token.STRING, replacement);\n    newNode.copyInformationFromForTree(expr);\n    parent.replaceChild(expr, newNode);\n    t.report(expr, REPLACED_EXPRESSION);\n    return newNode;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  ",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[coefficients.length];\n        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[coefficients.length];\n        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n        return out;\n    }"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setDesc(info.getDescription());\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isContainerNode()) {\n        for (JsonNode child : node) {\n            if (child.isObject() && child.has(\"@desc\")) {\n                String desc = child.get(\"@desc\").asText();\n                if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                    builder.setIsHidden(true);\n                } else {\n                    builder.setDesc(desc);\n                }\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setJsDocInfo(info);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setJsDocInfo(info);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setDesc(info.getDescription());\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setJsDocInfo(info);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setJsDocInfo(info);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.hasJsDoc()) {\n        JSDocInfo info = parseJsDoc(node.getJsDoc());\n        if (info != null && info.hasDesc()) {\n            builder.setDesc(info.getDesc());\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.hasJsDoc()) {\n        JSDocInfo info = parseJsDoc(node.getJsDoc());\n        if (info != null && info.hasDesc()) {\n            builder.setDesc(info.getDesc());\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n        JSDocInfo info = parseInlineTypeDoc(comment, node);\n        if (info != null) {\n            builder.setJsDocInfo(info);\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAYS_LENGTH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumXSquared = 0;\n    double sumYSquared = 0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSquared += xArray[i] * xArray[i];\n        sumYSquared += yArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    return (n * sumXY - sumX * sumY) / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double meanXY = sumXY / n;\n\n    double numerator = meanXY - (meanX * meanY);\n\n    if (biasCorrected) {\n        return numerator * (n / (n - 1));\n    } else {\n        return numerator;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumXSquared = 0.0;\n    double sumYSquared = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSquared += xArray[i] * xArray[i];\n        sumYSquared += yArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    return ((n * sumXY) - (sumX * sumY)) / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAYS_LENGTH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    double denominator = xArray.length * sumX2 - sumX * sumX;\n    double numerator = xArray.length * sumXY - sumX * sumY;\n\n    if (biasCorrected) {\n        denominator = denominator * (xArray.length * sumY2 - sumY * sumY) - numerator * numerator;\n        numerator = numerator * (xArray.length * sumY2 - sumY * sumY) - numerator * numerator;\n    }\n\n    return numerator / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAYS_LENGTH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n    double meanXY = sumXY / xArray.length;\n\n    double numerator = meanXY - (meanX * meanY);\n    double denominator = xArray.length - (biasCorrected ? 1 : 0);\n\n    return numerator / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double deltaX = sumXY - n * meanX * meanY;\n    double deltaY = sumXY - n * meanX * meanY;\n    double cov = deltaX / (n - (biasCorrected ? 1 : 0));\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MUST_MATCH,\n                xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    double cov = (xArray.length * sumXY - sumX * sumY) / (xArray.length * sumX2 - sumX * sumX);\n\n    if (biasCorrected) {\n        cov = cov * xArray.length / (xArray.length - 1);\n    }\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumXSquared = 0;\n    double sumYSquared = 0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSquared += xArray[i] * xArray[i];\n        sumYSquared += yArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    double cov = (n * sumXY - sumX * sumY) / denominator;\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAYS_LENGTH, xArray.length, yArray.length);\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2, xArray.length);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double meanXY = sumXY / n;\n    double meanXSquare = (sumX * sumX) / (n * n);\n    double meanYSquare = (sumY * sumY) / (n * n);\n\n    if (biasCorrected) {\n        return (meanXY - meanX * meanY) / (n - 1);\n    } else {\n        return (meanXY - meanX * meanY) / n;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, 2);\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumXSquared = 0;\n    double sumYSquared = 0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSquared += xArray[i] * xArray[i];\n        sumYSquared += yArray[i] * yArray[i];\n    }\n\n    double n = xArray.length;\n    double denominator = n * (n - 1);\n\n    if (biasCorrected) {\n        denominator = n - 1;\n    }\n\n    return (sumXY - (sumX * sumY) / n) / denominator;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Trying to skip past EOF\");\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated CPIO entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated CPIO entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count((int) n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative skip length\");\n    }\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Unexpected EOF while skipping\");\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated CPIO entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative skip length\");\n    }\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Unexpected EOF\");\n        }\n        remaining -= n;\n        count((int) n);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    ensureOpen();\n    final long max = Math.min(value, Integer.MAX_VALUE);\n    long total = 0;\n\n    while (total < max) {\n        final long len = max - total;\n        final int read = IOUtils.readFully(in, buf, 0, (int) Math.min(len, buf.length));\n        if (read == -1) {\n            entryEOF = true;\n            break;\n        }\n        total += read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Trying to skip past EOF\");\n        }\n        count(n);\n        remaining -= n;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = MessageId.generateId(tcValue, \"\");\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    long fingerprint = FP.fingerprint(tcValue);\n    String fingerprintStr = Long.toHexString(fingerprint).toUpperCase();\n\n    return fingerprintStr;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    long fingerprint = FP.fingerprint(tcValue);\n    String fingerprintStr = Long.toHexString(fingerprint).toUpperCase();\n\n    // Ensure 12 characters\n    while (fingerprintStr.length() < 12) {\n        fingerprintStr = \"0\" + fingerprintStr;\n    }\n    return fingerprintStr;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length() - minDistanceFromEnd;\n        final long maxPos = archive.length() - maxDistanceFromEnd;\n        final int sigLength = sig.length;\n        byte[] buffer = new byte[sigLength];\n\n        while (pos >= maxPos) {\n            archive.seek(pos);\n            IOUtils.readFully(archive, buffer);\n            if (Arrays.equals(sig, buffer)) {\n                archive.seek(pos + sigLength);\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length();\n        final long end = pos - minDistanceFromEnd;\n        final long start = pos - maxDistanceFromEnd;\n        while (pos > start) {\n            archive.seek(pos);\n            if (archive.read() != sig[0]) {\n                pos--;\n                continue;\n            }\n            long matchPos = pos;\n            for (int i = 1; i < sig.length; i++) {\n                if (archive.read() != sig[i]) {\n                    break;\n                }\n                matchPos++;\n            }\n            if (matchPos - pos == sig.length - 1) {\n                archive.seek(matchPos);\n                return true;\n            }\n            pos--;\n        }\n        archive.seek(end);\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long fileLength = archive.length();\n        final long maxDistance = Math.min(maxDistanceFromEnd, fileLength);\n        final long minDistance = Math.max(minDistanceFromEnd, 0);\n        final long startPos = fileLength - maxDistance;\n        final long endPos = fileLength - minDistance;\n        for (long pos = startPos; pos >= endPos; pos--) {\n            archive.seek(pos);\n            if (archive.read() == sig[0]) {\n                final byte[] buffer = new byte[(int) (maxDistance - (fileLength - pos))];\n                archive.readFully(buffer, 0, buffer.length);\n                if (Arrays.equals(sig, 0, sig.length, buffer, 0, buffer.length)) {\n                    archive.seek(pos + sig.length);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length();\n        for (long i = minDistanceFromEnd; i <= maxDistanceFromEnd; i++) {\n            archive.seek(pos - i);\n            if (archive.read() != sig[0]) {\n                continue;\n            }\n            for (int j = 1; j < sig.length; j++) {\n                if (archive.read() != sig[j]) {\n                    break;\n                }\n            }\n            archive.seek(pos - i);\n            return true;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long currentPos = archive.getFilePointer();\n        final long endOfArchive = archive.length();\n        final long minDistance = Math.max(0, minDistanceFromEnd);\n        final long maxDistance = Math.min(endOfArchive, maxDistanceFromEnd);\n        if (minDistance > maxDistance) {\n            return false;\n        }\n        final long startPos = endOfArchive - maxDistance;\n        final long endPos = endOfArchive - minDistance;\n        archive.seek(startPos);\n        for (long pos = startPos; pos >= endPos; pos--) {\n            if (archive.read() != sig[0]) {\n                archive.seek(pos);\n                continue;\n            }\n            final long remainingBytes = maxDistance - (pos - endOfArchive);\n            if (remainingBytes < sig.length) {\n                archive.seek(pos);\n                continue;\n            }\n            final byte[] buffer = new byte[(int) sig.length];\n            archive.readFully(buffer);\n            if (Arrays.equals(sig, buffer)) {\n                archive.seek(pos + sig.length);\n                return true;\n            }\n            archive.seek(pos);\n        }\n        archive.seek(currentPos);\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length() - 1;\n        for (long end = pos - maxDistanceFromEnd; pos >= end; pos--) {\n            archive.seek(pos);\n            if (archive.read() != sig[0]) {\n                continue;\n            }\n            long left = pos - 1;\n            for (int i = 1; i < sig.length; i++) {\n                if (left < 0) {\n                    break;\n                }\n                archive.seek(left);\n                if (archive.read() != sig[i]) {\n                    break;\n                }\n                left--;\n            }\n            if (left < pos - minDistanceFromEnd) {\n                archive.seek(pos);\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length() - minDistanceFromEnd;\n        long end = archive.length() - maxDistanceFromEnd;\n        byte[] buffer = new byte[sig.length];\n        while (pos > end) {\n            archive.seek(pos);\n            IOUtils.readFully(archive, buffer);\n            if (Arrays.equals(sig, buffer)) {\n                archive.seek(pos + sig.length);\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long currentPosition = archive.getFilePointer();\n        final long maxSearchPosition = currentPosition - minDistanceFromEnd;\n        final long minSearchPosition = currentPosition - maxDistanceFromEnd;\n        final long signatureLength = sig.length;\n\n        archive.seek(maxSearchPosition);\n\n        for (long pos = maxSearchPosition; pos >= minSearchPosition; pos--) {\n            final byte[] buffer = new byte[(int) signatureLength];\n            IOUtils.readFully(archive, buffer, 0, (int) signatureLength);\n            if (Arrays.equals(sig, buffer)) {\n                archive.seek(pos);\n                return true;\n            }\n            archive.seek(pos - signatureLength);\n        }\n        archive.seek(currentPosition);\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.length() - minDistanceFromEnd;\n        if (pos < 0) {\n            pos = 0;\n        }\n        final long end = archive.length() - maxDistanceFromEnd;\n        while (pos > end) {\n            final long start = pos - sig.length;\n            if (start < 0) {\n                pos = 0;\n                break;\n            }\n            final byte[] buffer = new byte[(int)sig.length];\n            archive.seek(start);\n            archive.readFully(buffer);\n            if (Arrays.equals(sig, buffer)) {\n                archive.seek(pos);\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long maxSearchStart = archive.length() - minDistanceFromEnd;\n        final long maxSearchEnd = archive.length() - maxDistanceFromEnd;\n        for (long searchStart = maxSearchStart; searchStart >= maxSearchEnd; searchStart--) {\n            archive.seek(searchStart);\n            if (archive.read() == sig[0]) {\n                final byte[] buffer = new byte[(int) (sig.length - 1)];\n                IOUtils.readFully(archive, buffer, 0, buffer.length);\n                if (Arrays.equals(buffer, sig, 1, sig.length)) {\n                    archive.seek(searchStart);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, getOrientation());\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, getOrientation());\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, getOrientation());\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, getOrientation());\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, getOrientation());\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n        return _dataStream;\n    }",
      "public InputStream getDataStream()  {\n    if (_in == null) {\n        return new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd - _inputPtr);\n    } else {\n        return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n    }\n}",
      "public InputStream getDataStream()  {\n        return _in;\n    }",
      "public InputStream getDataStream()  {\n        return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n    }",
      "public InputStream getDataStream()  {\n    if (_in == null) {\n        return new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd - _inputPtr);\n    }\n    if (_inputPtr < _inputEnd) {\n        return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n    }\n    return _in;\n}",
      "public InputStream getDataStream()  {\n        return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n    }",
      "public InputStream getDataStream()  {\n        return _in;\n    }",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_context, _in, _inputBuffer, _inputPtr, _inputEnd);\n}",
      "public InputStream getDataStream()  {\n        return _dataStream;\n    }"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    result = (Comparable) this.sectionKeys.get(section);\n    if (result == null) {\n        result = new Integer(section);\n        this.sectionKeys.set(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        // this includes the case where the underlying dataset is null\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    result = this.data.getKey(section);\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < 0 || section >= getItemCount()) {\n        throw new IndexOutOfBoundsException(\"Invalid 'section': \" + section);\n    }\n    result = (Comparable) this.sectionKeys.get(section);\n    if (result == null) {\n        result = new Integer(section);\n        this.sectionKeys.set(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n\n    Comparable result = null;\n    PieSectionEntity sectionEntity = (PieSectionEntity) this.data.get(section);\n    if (sectionEntity != null) {\n        result = sectionEntity.getSectionKey();\n    }\n\n    if (result == null) {\n        result = new Integer(section);\n    }\n\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n    return (Comparable) this.sectionKeys.get(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n    return (Comparable) this.sectionKeys.get(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n\n    Comparable result = (Comparable) this.sectionKeys.get(section);\n    if (result == null) {\n        result = new Integer(section);\n        this.sectionKeys.set(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n    return (Comparable) this.sectionKeys.get(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid 'section' index: \" + section);\n    }\n\n    Comparable key = (Comparable) this.sectionKeys.get(section);\n    if (key == null) \n    {\n        key = new Integer(section);\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getItemCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n    return (Comparable) this.sectionKeys.get(section);\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n      result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n      result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peekedString = new String(buffer, pos, peekedStringLength);\n      pos += peekedStringLength;\n      peeked = PEEKED_NONE;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peekedString = new String(buffer, pos, peekedStringLength);\n      pos += peekedStringLength;\n      peeked = PEEKED_NONE;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_STRING) {\n      result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n  }"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    if (peek() == JsonToken.NUMBER) {\n      double result = peekedNumber;\n      pos = peekedNumberEndPos;\n      peeked = PEEKED_NONE;\n      return result;\n    }\n\n    String peekedString;\n    if (peek() == JsonToken.STRING) {\n      peekedString = nextString();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    try {\n      double result = Double.parseDouble(peekedString);\n      if (isFinite(result)) {\n        return result;\n      }\n      throw new NumberFormatException(\"Invalid number: \" + peekedString);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    if (peek() == JsonToken.NUMBER) {\n      double result = peekedDouble;\n      pos = peekedNumberEndPos;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    String peekedString;\n    if (peek() == JsonToken.STRING) {\n      peekedString = nextString();\n      try {\n        double result = Double.parseDouble(peekedString);\n        if (Double.isNaN(result) || Double.isInfinite(result)) {\n          throw new NumberFormatException(\"Invalid number: \" + peekedString);\n        }\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(e);\n      }\n    }\n\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }",
      "public double nextDouble() throws IOException  {\n    if (nextToken() != JsonToken.NUMBER) {\n      throw new IllegalStateException(\"Expecting a NUMBER but was \" + peek() + locationString());\n    }\n    try {\n      return Double.parseDouble(peekedString);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Failed to parse number: \" + peekedString + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    if (nextToken() != JsonToken.NUMBER) \n    {\n        throw new IllegalStateException(\"Expecting a number but was \" + peek() + locationString());\n    }\n    try \n    {\n        return Double.parseDouble(buffer, pos, length);\n    } \n    catch (NumberFormatException e) \n    {\n        throw new JsonSyntaxException(buffer, pos, length, e);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    return (double) nextNumber();\n}",
      "public double nextDouble() throws IOException  {\n    if (nextToken() != JsonToken.NUMBER) \n    {\n        throw new IllegalStateException(\"Expected a NUMBER but was \" + peek() + locationString());\n    }\n    try \n    {\n        return Double.parseDouble(peekedString);\n    } \n    catch (NumberFormatException e) \n    {\n        throw new JsonSyntaxException(e);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    String peekedString;\n    double result;\n    synchronized (this) {\n        if (peek() == JsonToken.NUMBER) {\n            peekedString = nextNumber();\n            try {\n                result = Double.parseDouble(peekedString);\n                if (!Double.isFinite(result)) {\n                    throw new NumberFormatException(\"Invalid number: \" + peekedString);\n                }\n                pathIndices[stackSize - 1]++;\n                return result;\n            } catch (NumberFormatException e) {\n                throw new JsonSyntaxException(e);\n            }\n        } else {\n            throw new IllegalStateException(\"Expected a NUMBER but was \" + peek() + locationString());\n        }\n    }\n}",
      "public double nextDouble() throws IOException  {\n    if (peek() == JsonToken.NUMBER) {\n      double result = peekedNumber;\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      return result;\n    }\n\n    String peekedString;\n    if (peek() == JsonToken.STRING) {\n      peekedString = nextString();\n    } else {\n      throw new IllegalStateException(\"Expected a NUMBER but was \" + peek() + locationString());\n    }\n\n    try {\n      double result = Double.parseDouble(peekedString);\n      if (Double.isNaN(result) || Double.isInfinite(result)) {\n        throw new NumberFormatException(\"Invalid number: \" + peekedString);\n      }\n      return result;\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    synchronized (this) {\n      if (peek() == JsonToken.NUMBER) {\n        double result = peekedDoubleValue;\n        next();\n        return result;\n      }\n      String string = nextString();\n      try {\n        return Double.parseDouble(string);\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(string, e);\n      }\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    if (nextToken() != JsonToken.NUMBER) {\n      throw new IllegalStateException(\"Expecting a NUMBER but was \" + peek() + locationString());\n    }\n    try {\n      return Double.parseDouble(peekedString);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Failed to parse number: \" + peekedString + locationString());\n    }\n  }"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        // TODO: Implement this method\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        // TODO: Implement this method\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static String repeat(final String str, final int repeat)  {\n        // TODO: Implement your code here\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // TODO: Implement this method\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // TODO: Implement this method\n}",
      "public static String repeat(final String str, final int repeat)  {\n        // TODO: Implement this method\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return \"\";\n        }\n        final int inputLength = str.length();\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        // TODO: Implement this method\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unrecognizedExtraField = new UnrecognizedExtraField();\n            unrecognizedExtraField.setHeaderId(headerId);\n            return unrecognizedExtraField;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unrecognized = new UnrecognizedExtraField();\n            unrecognized.setHeaderId(headerId);\n            return unrecognized;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            clazz = UnrecognizedExtraField.class;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unrecognized = new UnrecognizedExtraField();\n            unrecognized.setHeaderId(headerId);\n            return unrecognized;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            UnrecognizedExtraField unf = new UnrecognizedExtraField();\n            unf.setHeaderId(headerId);\n            return unf;\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }"
    ],
    [
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            if (chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            if (chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            if (chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            if (chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) \n        {\n            if (chars.contains(chrs[i])) \n            {\n                count++;\n            }\n        }\n        return count;\n    }"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    for (Iterator iterator = keys.iterator(); iterator.hasNext();) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            clone.put(key, ((Cloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            clone.put(key, ((Cloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    for (Iterator iterator = keys.iterator(); iterator.hasNext();) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            clone.put(key, ((Cloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        clone.put(key, (Marker) value.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        clone.put(key, (Marker) value.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Cloneable) {\n            value = ((Cloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryDataLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryDataData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryDataData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getCentralDirectoryData(), 0, result, start,\n                              element.getCentralDirectoryLength().getValue());\n            start += element.getCentralDirectoryLength().getValue();\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            final byte[] central = element.getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            final byte[] central = element.getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getCentralDirectoryData(), 0, result, start,\n                              element.getCentralDirectoryLength().getValue());\n            start += element.getCentralDirectoryLength().getValue();\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryDataLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryDataData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryDataData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  throws IOException {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (add(index, element)) {\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (indexOf(element) == -1) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (!contains(element)) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (indexOf(element) == -1) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (!contains(element)) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E object = i.next();\n            if (add(index, object)) {\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E object = i.next();\n            if (indexOf(object) == -1) {\n                add(index, object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E object = i.next();\n            if (indexOf(object) == -1) {\n                add(index, object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (indexOf(element) == -1) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E element = i.next();\n            if (!contains(element)) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            normalizedConstraints.add(normalize(constraint));\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) \n        {\n            normalizedConstraints.add(normalize(constraint));\n        }\n        return normalizedConstraints;\n    }"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  ",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n\n    if (bin.lowerBound > this.upperBound || bin.upperBound < this.lowerBound) {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n\n    if (bin.lowerBound > this.upperBound) \n    {\n        return false;\n    }\n    if (bin.upperBound < this.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  ",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (bin.lowerBound > this.upperBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n\n    // Bin A is to the left of Bin B\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n\n    // Bin A is to the right of Bin B\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n\n    // Bin A is fully to the left of Bin B\n    if (this.lowerBound < bin.lowerBound && this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n\n    // Bin A is fully to the right of Bin B\n    if (this.lowerBound > bin.upperBound && this.upperBound > bin.upperBound) \n    {\n        return false;\n    }\n\n    // Bin A is fully to the left of Bin B\n    if (this.lowerBound < bin.lowerBound && this.upperBound > bin.upperBound) \n    {\n        return false;\n    }\n\n    // Bin A is fully to the right of Bin B\n    if (this.lowerBound > bin.upperBound && this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n\n    // Bin A and Bin B are adjacent\n    if (this.upperBound == bin.lowerBound && this.lowerBound == bin.upperBound) \n    {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  ",
      "public boolean overlapsWith(SimpleHistogramBin bin)  ",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.lowerBound > this.upperBound) \n    {\n        return false;\n    }\n    if (bin.upperBound < this.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) \n    {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) \n        {\n            list.add(str.substring(start, i - 1));\n            start = i - 1;\n        }\n        if (type != Character.getType(str.charAt(start))) \n        {\n            if (match || (i + 1 < len && Character.getType(str.charAt(i + 1)) != type)) \n            {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = true;\n            }\n            start = i;\n        }\n        match = true;\n        i++;\n    }\n    if (match || (i + 1 < len && Character.getType(str.charAt(i + 1)) != Character.getType(str.charAt(start)))) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) \n    {\n        final char ch = str.charAt(i);\n        final int type = Character.getType(ch);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        } \n        else if (type == Character.WHITESPACE) \n        {\n            if (match) \n            {\n                lastMatch = true;\n                if (sizePlus1++ == max) \n                {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        } \n        else \n        {\n            lastMatch = false;\n            match = true;\n        }\n        i++;\n    }\n    if (match || lastMatch) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final char ch = str.charAt(i);\n        final int type = Character.getType(ch);\n        if (camelCase && type == Character.UPPERCASE_LETTER && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(start, i - 1));\n            start = i - 1;\n        }\n        if (type != Character.getType(str.charAt(start))) {\n            if (match || (i - start > 1)) {\n                list.add(str.substring(start, i));\n            }\n            start = i;\n            match = false;\n            lastMatch = true;\n        } else {\n            match = true;\n            lastMatch = false;\n        }\n        i++;\n    }\n    if (match || (i - start > 1)) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    boolean lastIsUpperCase = false;\n    while (i < len) \n    {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (type == Character.UPPERCASE_LETTER || (camelCase && lastIsUpperCase && type == Character.LOWERCASE_LETTER)) \n        {\n            if (match || camelCase) \n            {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = true;\n            }\n            start = i;\n        } \n        else \n        {\n            lastMatch = false;\n            match = (type != Character.LOWERCASE_LETTER && type != Character.UPPERCASE_LETTER && type != Character.OTHER_LETTER);\n        }\n        lastIsUpperCase = (type == Character.UPPERCASE_LETTER);\n        i++;\n    }\n    if (match || camelCase && lastMatch) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(start, i));\n            start = i;\n        } else if (type != Character.getType(str.charAt(start))) {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) \n    {\n        final char ch = str.charAt(i);\n        final int type = Character.getType(ch);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) \n        {\n            list.add(str.substring(start, i - 1));\n            start = i - 1;\n        }\n        if (type != Character.getType(str.charAt(start))) \n        {\n            if (match || Character.isWhitespace(ch)) \n            {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = true;\n            }\n            start = i;\n        } \n        else \n        {\n            lastMatch = false;\n            match = true;\n        }\n        i++;\n    }\n    if (match || Character.isWhitespace(str.charAt(start))) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            // if camelCase is true and current character is uppercase and previous character is lowercase,\n            // add the previous character to the current token\n            list.add(str.substring(start, i - 1));\n            start = i - 1;\n        } else if (type != Character.getType(str.charAt(start))) {\n            // if character type changes, add the current token to the list\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        i++;\n    }\n    if (i > start) {\n        // add the last token\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    boolean lastIsUpperCase = false;\n    while (i < len) {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (type == Character.UPPERCASE_LETTER || (camelCase && lastIsUpperCase && type == Character.LOWERCASE_LETTER)) {\n            if (match || lastMatch) {\n                list.add(str.substring(start, i));\n                match = false;\n                lastMatch = true;\n            }\n            start = i;\n        } else {\n            lastMatch = false;\n            match = true;\n        }\n        lastIsUpperCase = (type == Character.UPPERCASE_LETTER);\n        i++;\n    }\n    if (match || lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(start, i));\n            start = i;\n        } else if (type != Character.getType(str.charAt(start))) {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        i++;\n    }\n    if (i > start) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int sizePlus1 = 1;\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) \n    {\n        final char chr = str.charAt(i);\n        final int type = Character.getType(chr);\n        if (camelCase && i > 0 && type == Character.UPPERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        } \n        else if (type == Character.WHITESPACE) \n        {\n            if (match) \n            {\n                lastMatch = true;\n                if (sizePlus1++ == max) \n                {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        } \n        else \n        {\n            lastMatch = false;\n            match = true;\n        }\n        i++;\n    }\n    if (match || lastMatch) \n    {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, ISOChronology.getInstance(), iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                bucket.setZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                bucket.setZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, ISOChronology.getInstance(), iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                bucket.setZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                bucket.setZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"\").srcref(n);\n    n.swapWith(placeholder);\n    MinimizedCondition result = new MinimizedCondition(\n        new MeasuredNode(placeholder, Integer.MAX_VALUE, false),\n        new MeasuredNode(placeholder, Integer.MAX_VALUE, false));\n    result.setPlaceholder(placeholder);\n    return result;\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), \n    Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"<unoptimized>\").srcref(n);\n    n.setParent(placeholder);\n    MeasuredNode positive = new MeasuredNode(n, 0, false);\n    MeasuredNode negative = new MeasuredNode(placeholder, Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n, 0, false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT, \"\").srcref(n), \n    Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"\").srcref(n);\n    MeasuredNode positive = new MeasuredNode(placeholder, 10000, false);\n    MeasuredNode negative = new MeasuredNode(placeholder, 10000, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"\").srcref(n);\n    n.setParent(null);\n    return new MinimizedCondition(new MeasuredNode(placeholder, Integer.MAX_VALUE, false),\n        new MeasuredNode(placeholder, Integer.MAX_VALUE, false));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), 10000, false);\n    return new MinimizedCondition(pos, neg);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"\").srcref(n);\n    n.setParent(placeholder);\n    placeholder.setFirstChild(n);\n    MeasuredNode positive = new MeasuredNode(placeholder, 0, false);\n    MeasuredNode negative = new MeasuredNode(placeholder, Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, \"\").srcref(n);\n    MeasuredNode positive = new MeasuredNode(placeholder, n.length(), false);\n    MeasuredNode negative = new MeasuredNode(placeholder, Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode posTree = new MeasuredNode(n, 0, false);\n    MeasuredNode negTree = new MeasuredNode(new Node(Token.SCRIPT),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(posTree, negTree);\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for(E value : values)\n    {\n        if(value != null)\n        {\n            condensed.add(value);\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"Enum values cannot be null\");\n        }\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for(E value : values)\n    {\n        if(value != null)\n            condensed.add(value);\n        else\n            throw new IllegalArgumentException(\"Enum values cannot be null\");\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for(E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for(E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for(E value : values)\n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope instanceof LexicalScope) \n    {\n        return scope.getDepth();\n    } \n    else if (scope instanceof PropertyScope) \n    {\n        SymbolScope parent = scope.getParent();\n        int depth = 0;\n        while (parent != null && !(parent instanceof LexicalScope)) \n        {\n            depth++;\n            parent = parent.getParent();\n        }\n        if (parent instanceof LexicalScope) \n        {\n            depth += parent.getDepth();\n        }\n        return depth;\n    } \n    else // DocInfoScope\n    {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope instanceof LexicalScope) \n    {\n        return scope.getDepth();\n    } \n    else if (scope instanceof PropertyScope) \n    {\n        int depth = 0;\n        SymbolScope parent = ((PropertyScope) scope).getParent();\n        while (parent instanceof PropertyScope) \n        {\n            depth++;\n            parent = parent.getParent();\n        }\n        return depth + ((LexicalScope) parent).getDepth();\n    } \n    else \n    {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        depth++;\n        scope = scope.getParent();\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope instanceof LexicalScope) \n    {\n        return scope.getDepth();\n    } \n    else if (scope instanceof PropertyScope) \n    {\n        SymbolScope parent = scope.getParent();\n        int depth = 1;\n        while (parent != null && !(parent instanceof LexicalScope)) \n        {\n            parent = parent.getParent();\n            depth++;\n        }\n        if (parent instanceof LexicalScope) \n        {\n            return depth + parent.getDepth();\n        }\n    } \n    else if (scope instanceof DocInfoScope) \n    {\n        return 0;\n    }\n    return -1;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        depth++;\n        scope = scope.getParent();\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope instanceof LexicalScope) {\n        return scope.getDepth();\n    }\n    if (scope instanceof PropertyScope) {\n        int depth = ((PropertyScope) scope).getLexicalScopeDepth();\n        return depth + scope.getDepth();\n    }\n    if (scope instanceof DocInfoScope) {\n        return 0;\n    }\n    throw new IllegalStateException(\"Unknown scope type: \" + scope.getClass());\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        depth++;\n        scope = scope.getParent();\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexical()) \n    {\n        return scope.getDepth();\n    } \n    else if (scope.isProperty()) \n    {\n        int depth = 0;\n        SymbolScope parent = scope.getParent();\n        while (!parent.isLexical()) \n        {\n            depth++;\n            parent = parent.getParent();\n        }\n        return depth + parent.getDepth();\n    } \n    else \n    {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) \n    {\n        if (scope.getKind() == SymbolScope.Kind.LEXICAL) \n        {\n            return depth;\n        }\n        else if (scope.getKind() == SymbolScope.Kind.PROPERTY) \n        {\n            depth++;\n        }\n        scope = scope.getParent();\n    }\n    return 0;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    SymbolScope current = scope;\n    while (current != null) \n    {\n        if (current.isLexicalScope()) \n        {\n            return depth;\n        } \n        else \n        {\n            depth++;\n            current = current.getParent();\n        }\n    }\n    return depth;\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        if (constant == null) \n        {\n            throw new IllegalArgumentException(\"Values cannot contain null\");\n        }\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.noneOf(asEnum(enumClass));\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long result = 0;\n    for (E value : values) {\n        Validate.isTrue(value != null, \"Null elements not permitted in values\");\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp e = Dfp.getE();\n        Dfp ea = e.pow(a.intValue());\n        Dfp term = e.divide(factorial(1));\n        Dfp sum = ea;\n        int i = 1;\n        while (sum.abs().lessThan(a.abs())) \n        {\n            term = term.multiply(a.divide(i));\n            ea = ea.add(term);\n            sum = sum.add(term);\n            i++;\n        }\n        return ea;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp e = new Dfp(a.getField(), 2);\n        Dfp result = new Dfp(a.getField(), 1);\n        Dfp term = new Dfp(a.getField(), 1);\n        Dfp x = a;\n        int n = 1;\n\n        while (term.compareTo(Dfp.EPSILON) > 0) {\n            result = result.add(term);\n            x = x.multiply(a);\n            term = x.divide(factorial(n++));\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getESplit()[0];\n        Dfp term = a;\n\n        for (int i = 2; i < 10000; i++) \n        {\n            term = term.multiply(a);\n            result = result.add(term.divide(factorial(i)));\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int i = 1;\n\n    while (i < Dfp.MAX_ITERATIONS) \n    {\n        result = result.add(term);\n        term = term.multiply(a);\n        term = term.divide(new Dfp(a.getField(), i+1));\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getESplit()[0];\n        Dfp term = a;\n        int n = 1;\n        while (n < MAX_ITERATIONS) \n        {\n            term = term.multiply(a);\n            result = result.add(term.divide(factorial(n)));\n            n++;\n        }\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp e = Dfp.getE();\n        Dfp x = a;\n        Dfp term = e.multiply(a);\n        Dfp sum = e;\n        int n = 2;\n\n        while (term.compareTo(Dfp.getEPSILON()) > 0) \n        {\n            sum = sum.add(term);\n            term = term.multiply(a.divide(new Dfp(n++)));\n        }\n\n        return sum;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n\n    for (int i = 2; i <= MAX_ITERATIONS; i++) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(a.getField().getFactorial(i));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp e = Dfp.getE();\n    Dfp result = e.getOne();\n    Dfp term = a;\n    int i = 1;\n\n    while (term.greaterThan(Dfp.getEpsilon())) {\n        result = result.add(term);\n        term = term.multiply(a).divide(i++);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int i = 1;\n\n    while (i < DfpMath.MAX_ITERATIONS) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(DfpMath.factorial(i+1));\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp result = new Dfp(a.getField(), 1);\n        final Dfp term = new Dfp(a.getField(), 1);\n        final Dfp a2 = a.multiply(a);\n\n        for (int i = 2; i <= DfpMath.MAX_ITERATIONS; i++) \n        {\n            term = term.multiply(a2).divide(DfpMath.factorial(i));\n            result = result.add(term);\n        }\n\n        return result;\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x.getReal()) > threshold) {\n            return new FieldVector3D<>(y, -x, z);\n        } else if (FastMath.abs(y.getReal()) > threshold) {\n            return new FieldVector3D<>(-y, x, z);\n        } else {\n            return new FieldVector3D<>(-x, y, -z);\n        }\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        // We look for a vector orthogonal to the instance.\n        // We start from the instance vector and add a small random component.\n        // The random component is chosen to be in the range [-threshold, threshold].\n        // We repeat until we find a vector orthogonal to the instance.\n        FieldVector3D<T> orthogonalVector;\n        do {\n            orthogonalVector = new FieldVector3D<>(\n                x.add(T.valueOf(RandomGenerator.getRandomGenerator().nextDouble(-threshold, threshold))),\n                y.add(T.valueOf(RandomGenerator.getRandomGenerator().nextDouble(-threshold, threshold))),\n                z.add(T.valueOf(RandomGenerator.getRandomGenerator().nextDouble(-threshold, threshold)))\n            );\n        } while (orthogonalVector.dotProduct(this).abs().getReal() > threshold);\n\n        return orthogonalVector.normalize();\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        FieldVector3D<T> orthogonal;\n        do {\n            orthogonal = new FieldVector3D<T>(FastMath.random() * 2 * FastMath.PI, FastMath.random() * 2 * FastMath.PI);\n        } while (orthogonal.getNorm() < threshold);\n        return orthogonal.normalize();\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        FieldVector3D<T> orthogonalVector;\n        if (FastMath.abs(x.getReal()) > threshold) {\n            orthogonalVector = new FieldVector3D<T>(y, -x, z);\n        } else if (FastMath.abs(y.getReal()) > threshold) {\n            orthogonalVector = new FieldVector3D<T>(-y, z, x);\n        } else {\n            orthogonalVector = new FieldVector3D<T>(-z, x, y);\n        }\n        return orthogonalVector.normalize();\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        // We use the fact that if the vector is (x, y, z), one of the\n        // orthogonal vectors is (y, -x, z). This vector is a multiple\n        // of the original vector, so we scale it by a factor.\n        T x = this.y;\n        T y = this.x.negate();\n        T z = this.z;\n\n        // Normalize the new vector.\n        double norm = FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        if (norm < threshold) {\n            // This should not happen in practice.\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        return new FieldVector3D<T>(x.divide(norm), y.divide(norm), z.divide(norm));\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x.getReal()) > threshold) {\n            return new FieldVector3D<>(y, -x, z);\n        } else if (FastMath.abs(y.getReal()) > threshold) {\n            return new FieldVector3D<>(-y, x, z);\n        } else {\n            return new FieldVector3D<>(-z, y, x);\n        }\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x.getReal()) > threshold) {\n            return new FieldVector3D<>(y, -x, z);\n        } else if (FastMath.abs(y.getReal()) > threshold) {\n            return new FieldVector3D<>(-y, x, z);\n        } else {\n            return new FieldVector3D<>(-z, y, x);\n        }\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        FieldVector3D<T> orthogonal;\n        do {\n            orthogonal = new FieldVector3D<T>(FastMath.nextDouble() * 2 * FastMath.PI, FastMath.nextDouble() * 2 * FastMath.PI);\n        } while (orthogonal.getNorm() < threshold);\n        return orthogonal.normalize();\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        // Choose an arbitrary orthogonal vector\n        FieldVector3D<T> orthogonal;\n        if (FastMath.abs(x.getReal()) > threshold) {\n            orthogonal = new FieldVector3D<>(y, -x, z);\n        } else if (FastMath.abs(y.getReal()) > threshold) {\n            orthogonal = new FieldVector3D<>(-y, x, z);\n        } else {\n            orthogonal = new FieldVector3D<>(x, y, -z);\n        }\n\n        return orthogonal.normalize();\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(getX()) < threshold) {\n            return new FieldVector3D<>(getY(), -getX(), getZ());\n        } else if (FastMath.abs(getY()) < threshold) {\n            return new FieldVector3D<>(-getZ(), getX(), getY());\n        } else {\n            return new FieldVector3D<>(getZ(), getY(), -getX());\n        }\n    }"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range is not overlapped by the other range\");\n    }\n\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n\n    return new Range<>(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n    return new Range<>(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n    return between(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The other range does not overlap with this range\");\n    }\n    return new Range<>(\n        comparator.max(this.minimum, other.minimum),\n        comparator.min(this.maximum, other.maximum),\n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The other range does not overlap with this range.\");\n    }\n    return between(\n        comparator.max(this.minimum, other.minimum),\n        comparator.min(this.maximum, other.maximum),\n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n    return new Range<>(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap.\");\n    }\n    return new Range<T>(\n        comparator.max(minimum, other.minimum), \n        comparator.min(maximum, other.maximum), \n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The other range does not overlap this range.\");\n    }\n    T min = comparator.max(this.minimum, other.minimum);\n    T max = comparator.min(this.maximum, other.maximum);\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n\n    return Range.between(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The specified range does not overlap this range\");\n    }\n    T newMin = comparator.max(minimum, other.minimum);\n    T newMax = comparator.min(maximum, other.maximum);\n    return between(newMin, newMax, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGeneratorImpl(ctxt, out, JsonEncoding.UTF8);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(out, ctxt, this);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(out, ctxt);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGeneratorImpl(out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(out, ctxt);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(out, ctxt, this);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(out, ctxt);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(ctxt, out);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        return new JsonGeneratorImpl(ctxt, out);\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGeneratorImpl(ctxt, out);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    else if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    else \n    {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n      return NoResolvedType.INSTANCE;\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoType) \n    {\n        return type;\n    }\n    else if (type instanceof ResolvedRecursiveType)\n    {\n        return filterNoResolvedType(((ResolvedRecursiveType) type).getReferencedType());\n    }\n    else\n    {\n        return NO_TYPE;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoType) {\n      return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n      return NoType.INSTANCE;\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) \n    {\n        return NoType.INSTANCE;\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n        return NoType.INSTANCE;\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n        return NoType.INSTANCE;\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoType) {\n      return NoType.INSTANCE;\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n      return NoType.INSTANCE;\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n        return NoType.INSTANCE;\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING && \"function\".equals(stream.getString()));\n    next();\n    skipEOLs();\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(parseTypeParameters());\n    functionType.addChildToBack(parseThisType());\n    functionType.addChildToBack(parseParametersType());\n    functionType.addChildToBack(parseResultType(next()));\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.missing\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return null;\n    }\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n\n    next();\n\n    return wrapNode(Token.FUNCTION,\n        wrapNode(Token.TYPE_PARAMETERS, typeParams),\n        wrapNode(Token.THIS, thisType),\n        wrapNode(Token.PARAMETERS, paramsType),\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING && \"function\".equals(stream.getString()));\n    next();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    skipEOLs();\n    if (!match(JsDocToken.LT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lt\");\n    }\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams != null) {\n      functionType.addChildToBack(typeParams);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node thisType = newNode(Token.THIS);\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    thisType.addChildToBack(paramsType);\n    functionType.addChildToBack(thisType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    Node resultType = parseResultType(next());\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING);\n    Preconditions.checkArgument(\"function\".equals(stream.getString()));\n    next();\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParams = parseTypeParameters();\n    if (typeParams != null) {\n      functionType.addChildToBack(typeParams);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    Node thisType = parseTypeName();\n    if (thisType == null) {\n      return null;\n    }\n    functionType.addChildToBack(thisType);\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n    functionType.addChildToBack(paramsType);\n\n    Node resultType = parseResultType();\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.missing\");\n    }\n    next();\n    skipEOLs();\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this.missing\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.colon.missing\");\n    }\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeNameAnnotation(next());\n    if (thisType == null) {\n      return null;\n    }\n\n    Node paramsType = parseParametersType(next());\n    if (paramsType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    } else {\n      next();\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParams);\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(paramsType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING && \"function\".equals(stream.getString()));\n\n    next();\n    skipEOLs();\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return null;\n    }\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    return wrapNode(Token.FUNCTION, typeParams, thisType, paramsType, resultType);\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING);\n    Preconditions.checkArgument(\"function\".equals(stream.getString()));\n\n    token = next();\n    skipEOLs();\n\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (match(JsDocToken.LB)) {\n      functionType.addChildToBack(parseTypeParameters());\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      }\n      next();\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName();\n    if (thisType == null) {\n      return null;\n    }\n    functionType.addChildToBack(thisType);\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n    functionType.addChildToBack(paramsType);\n\n    Node resultType = parseResultType();\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING);\n    String functionToken = stream.getString();\n    if (!\"function\".equals(functionToken)) {\n      return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeParams = parseTypeParameters();\n    skipEOLs();\n    if (!match(JsDocToken.STRING)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    token = next();\n    if (!\"this\".equals(token.getValue())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node thisType = parseTypeName(token);\n    if (thisType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.missing\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName();\n    if (thisType == null) {\n      return null;\n    }\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType();\n    if (resultType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n\n    next();\n\n    return newNode(Token.FUNCTION, typeParams, thisType, paramsType, resultType);\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.STRING && \"function\".equals(stream.getString()));\n    next();\n    skipEOLs();\n\n    Node typeParams = parseTypeParameters();\n    if (typeParams == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.this\");\n    }\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.function.colon\");\n    }\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return null;\n    }\n\n    Node paramsType = parseParametersType();\n    if (paramsType == null) {\n      return null;\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParams);\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(paramsType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getMax());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregateStatistics.getN(),\n            aggregateStatistics.getSum(),\n            aggregateStatistics.getMin(),\n            aggregateStatistics.getMax(),\n            aggregateStatistics.getMean(),\n            aggregateStatistics.getVariance()\n    );\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sum2 = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        if (stat != null) \n        {\n            long nn = stat.getN();\n            if (nn > 0) \n            {\n                double summand = stat.getSum();\n                double summand2 = stat.getSum() * stat.getSum();\n                double minVal = stat.getMin();\n                double maxVal = stat.getMax();\n\n                n += nn;\n                sum += summand;\n                sum2 += summand2;\n                min = (minVal < min) ? minVal : min;\n                max = (maxVal > max) ? maxVal : max;\n            }\n        }\n    }\n\n    double mean = (n > 0) ? sum / n : Double.NaN;\n    double variance = (n > 1) ? (sum2 - n * mean * mean) / (n - 1) : Double.NaN;\n\n    return new StatisticalSummaryValues(n, sum, mean, min, max, variance);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sum2 = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        if (stat != null) \n        {\n            long nn = stat.getN();\n            if (nn > 0) \n            {\n                double sum1 = stat.getSum();\n                double sum3 = stat.getMin() * nn;\n                double sum4 = stat.getMax() * nn;\n\n                n += nn;\n                sum += sum1;\n                sum2 += stat.getVariance() * nn;\n                min = Math.min(min, sum3);\n                max = Math.max(max, sum4);\n            }\n        }\n    }\n\n    double mean = (n > 0) ? sum / n : Double.NaN;\n    double variance = (n > 1) ? (sum2 - n * mean * mean) / (n - 1) : Double.NaN;\n\n    return new StatisticalSummaryValues(n, sum, mean, variance, min, max);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) \n    {\n        aggregate.addValue(stat.getSum());\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getMin());\n    }\n\n    return new StatisticalSummaryValues(aggregate);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumSq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            sum += stat.getSum();\n            sumSq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            n += stat.getN();\n        }\n    }\n\n    double mean = n > 0 ? sum / n : Double.NaN;\n    double variance = n > 1 ? (sumSq - (sum * sum) / n) / (n - 1) : Double.NaN;\n\n    return new StatisticalSummaryValues(n, min, max, mean, variance, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumSq = 0.0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumSq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumSq / n) - (mean * mean);\n\n    return new DefaultStatisticalSummaryValues(n, min, max, mean, variance);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat.getSum());\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getMin());\n    }\n\n    return new StatisticalSummaryValues(aggregate);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumSq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumSq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = sumSq / n - mean * mean;\n\n    return new DefaultStatisticalSummaryValues(n, min, max, mean, variance, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getMax());\n    }\n\n    double sum = aggregateStatistics.getSum();\n    double min = aggregateStatistics.getMin();\n    double max = aggregateStatistics.getMax();\n    double mean = sum / statistics.size();\n    double varianceSum = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        double deviation = stat.getMean() - mean;\n        varianceSum += stat.getN() * deviation * deviation;\n    }\n\n    double variance = varianceSum / (statistics.size() - 1);\n\n    return new StatisticalSummaryValues(sum, min, max, mean, variance, statistics.size());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sum2 = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            sum += stat.getSum();\n            sum2 += stat.getSum() * stat.getSum();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            n += stat.getN();\n        }\n    }\n\n    double mean = sum / n;\n    double variance = sum2 / n - mean * mean;\n\n    return new StatisticalSummaryValues(n, min, max, mean, variance);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            result += diff * diff;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int count = dataset.getItemCount();\n    for (int i = 0; i < count; i++) \n    {\n        Number number = dataset.getValue(i);\n        if (number != null && number.doubleValue() > 0.0) \n        {\n            total += number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int count = dataset.getItemCount();\n    for (int i = 0; i < count; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number number = dataset.getValue(i);\n        if (number != null && number.doubleValue() > 0.0) \n        {\n            total += number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      char quote = p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"';\n      String result = nextQuotedValue(quote);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_SINGLE_QUOTED) {\n      String result = nextQuotedValue('\\'');\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED) {\n      String result = nextQuotedValue('\"');\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      char quote = p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"';\n      String result = nextQuotedValue(quote);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      char quote = p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"';\n      String result = nextQuotedValue(quote);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      char quote = p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"';\n      String result = nextQuotedValue(quote);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      String result = peekedString;\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      String result = nextUnquotedValue();\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      char quote = p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"';\n      String result = nextQuotedValue(quote);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    int read = currentChunk.read(b, off, len);\n    if (read == -1) {\n        currentChunk = null;\n    } else {\n        bytesRead += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining <= 0) {\n            readNextBlock();\n            if (endReached) {\n                return -1;\n            }\n        }\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    int read = currentChunk.read(b, off, len);\n    if (read >= 0) {\n        bytesRead += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    int read = currentChunk.read(b, off, len);\n    if (read == -1) {\n        currentChunk = null;\n    } else {\n        bytesRead += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n            return -1;\n        }\n        int read = IOUtils.readFully(in, b, off, Math.min(len, uncompressedBytesRemaining));\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    int read = currentChunk.read(b, off, len);\n    if (read == -1) {\n        currentChunk = null;\n    } else {\n        bytesRead += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    int read = currentChunk.read(b, off, len);\n    if (read == -1) {\n        currentChunk = null;\n    } else {\n        bytesRead += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = IOUtils.readFully(in, b, off, Math.min(uncompressedBytesRemaining, len));\n        uncompressedBytesRemaining -= read;\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        Node arg = null;\n        if (call.isCall()) {\n            arg = call.getNext();\n            for (int i = 0; i < argIndex && arg != null; i++) {\n                arg = arg.getNext();\n            }\n        } else if (call.isDot()) {\n            Node receiver = call.getNext();\n            if (receiver.isName() && receiver.getFirstChild().isName()\n                    && receiver.getFirstChild().getFirstChild().getString()\n                            .equals(\"new\")) {\n                arg = call.getNext();\n                for (int i = 0; i < argIndex && arg != null; i++) {\n                    arg = arg.getNext();\n                }\n            }\n        }\n        return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        if (call.isCall()) {\n            Node arg = call.getNext();\n            for (int i = 0; i < argIndex; i++) {\n                if (arg == null) {\n                    return null;\n                }\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (call.isDot()) {\n            Node base = call.getFirstChild();\n            Node prop = call.getLastChild();\n            if (prop.isName() && prop.getString().equals(\"call\")) {\n                Node arg = base.getNext();\n                for (int i = 0; i < argIndex; i++) {\n                    if (arg == null) {\n                        return null;\n                    }\n                    arg = arg.getNext();\n                }\n                return arg;\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getNode();\n    if (call.isCall()) {\n        Node arg = call.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    } else if (call.isDot()) {\n        Node receiver = call.getFirstChild();\n        Node property = receiver.getNext();\n        while (property != null) {\n            if (property.isName() && property.getString().equals(\"call\")) {\n                Node arg = property.getNext();\n                for (int i = 0; i < argIndex; i++) {\n                    arg = arg.getNext();\n                }\n                return arg;\n            }\n            property = property.getNext();\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node arg = site.getNode();\n        while (arg != null) {\n            if (arg.isCall() || arg.isDot()) {\n                Node argNode = arg.getFirstChild();\n                for (int i = 0; i < argIndex; i++) {\n                    argNode = argNode.getNext();\n                }\n                return argNode;\n            }\n            arg = arg.getNext();\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getNode();\n    if (call.isCall()) {\n        Node arg = call.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    } else if (call.isDot()) {\n        Node base = call.getFirstChild();\n        Node prop = base.getNext();\n        if (prop.isName() && prop.getString().equals(\"call\")) {\n            Node arg = base.getNext();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        if (call.isCall()) {\n            Node arg = call.getFirstChild();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (call.isDot()) {\n            Node receiver = call.getFirstChild();\n            Node property = receiver.getNext();\n            while (property != null) {\n                if (property.isGetProp()) {\n                    if (argIndex == 0) {\n                        return property;\n                    }\n                    argIndex--;\n                }\n                property = property.getNext();\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        if (call.isCall()) {\n            Node arg = call.getNext();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (call.isDot()) {\n            Node base = call.getFirstChild();\n            Node prop = call.getLastChild();\n            if (prop.isName() && prop.getString().equals(\"call\")) {\n                Node arg = base.getNext();\n                for (int i = 0; i < argIndex; i++) {\n                    arg = arg.getNext();\n                }\n                return arg;\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        if (call.isCall()) {\n            return call.getArgument(argIndex);\n        } else if (call.isDot()) {\n            Node base = call.getFirstChild();\n            Node property = call.getLastChild();\n            if (property.isName() && property.getString().equals(\"call\")) {\n                return base.getNext();\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getNode();\n    if (node.isCall()) {\n        Node arg = node.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    } else if (node.isDot()) {\n        Node receiver = node.getFirstChild();\n        Node property = receiver.getNext();\n        if (property.isName() && property.getString().equals(\"call\")) {\n            Node arg = receiver.getNext();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.getNode();\n        if (call.isCall()) {\n            Node arg = call.getFirstChild();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (call.isDot()) {\n            Node base = call.getLastChild();\n            Node prop = base.getNext();\n            while (prop != null && prop.isDot()) {\n                base = prop;\n                prop = base.getNext();\n            }\n            if (prop != null && prop.isName() && prop.getString().equals(\"call\")) {\n                Node arg = base.getNext();\n                for (int i = 0; i < argIndex; i++) {\n                    arg = arg.getNext();\n                }\n                return arg;\n            }\n        }\n        return null;\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        JSDocInfo info = type.getJsDoc();\n        if (info != null) {\n            JSDocTag tag = info.getTag(\"deprecated\");\n            if (tag != null) {\n                return tag.getDescription();\n            }\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasDeprecatedAnnotation()) {\n        JSDocInfo info = type.getJsDocInfo();\n        if (info != null) {\n            return info.getDeprecationDescription();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasDeprecatedAnnotation()) {\n        return type.getDeprecationAnnotation().getReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationMessage();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    Annotations annotations = type.getAnnotations();\n    if (annotations != null) {\n        for (AnnotationNode annotation : annotations.getAnnotations()) {\n            if (annotation.getShortName().equals(\"deprecated\")) {\n                return annotation.getFirstArg().getString();\n            }\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJsDocInfo();\n    if (info != null) {\n        JSDocTag tag = info.getTag(\"deprecated\");\n        if (tag != null) {\n            return tag.getDescription();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isClass()) {\n        Annotations annotations = type.getAnnotations();\n        if (annotations.has(Deprecated.class)) {\n            AnnotationNode node = (AnnotationNode) annotations.get(Deprecated.class);\n            if (node.hasElement(\"since\")) {\n                return node.getElement(\"since\").toString();\n            }\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasOwnProperty(\"deprecated\")) {\n        return type.getOwnProperty(\"deprecated\").toString();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.hasAnnotation(Deprecated.class)) {\n        AnnotationNode annotation = type.getAnnotation(Deprecated.class);\n        if (annotation.hasExpression()) {\n            return annotation.getExpression().getStringValue();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isObject()) {\n      ObjectType objectType = (ObjectType) type;\n      Annotations annotations = objectType.getAnnotations();\n      if (annotations.hasAnnotation(\"deprecated\")) {\n        AnnotationNode deprecated = annotations.getAnnotation(\"deprecated\");\n        if (deprecated.getArguments().isEmpty()) {\n          return \"\";\n        } else {\n          return deprecated.getArguments().get(0).getString();\n        }\n      }\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = sDisplayCache.get(key);\n    if (display == null) \n    {\n        display = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        sDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = cache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create a cache key\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n\n    // Check if the key is in the cache\n    String cachedValue = cache.get(key);\n    if (cachedValue != null) \n    {\n        return cachedValue;\n    }\n\n    // If not in cache, generate the value and store it in the cache\n    String newValue;\n    if (daylight) \n    {\n        newValue = tz.getDisplayName(daylight, style, locale);\n    } \n    else \n    {\n        newValue = tz.getDisplayName(daylight, style, locale);\n    }\n    cache.put(key, newValue);\n\n    return newValue;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create the cache key\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n\n    // Check if the key exists in the cache\n    String displayName = cache.get(key);\n\n    // If not, get the display name and store it in the cache\n    if (displayName == null) {\n        displayName = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        cache.put(key, displayName);\n    }\n\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create the cache key\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n\n    // Check the cache\n    String cached = cache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n\n    // Calculate the display name\n    final String display;\n    if (daylight) {\n        display = tz.getDisplayName(daylight, style, locale);\n    } else {\n        display = tz.getDisplayName(daylight, style, locale);\n    }\n\n    // Store the result in the cache\n    cache.put(key, display);\n\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Create the cache key\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n\n    // Lookup the time zone display name in the cache\n    String displayName = cache.get(key);\n\n    // If the time zone display name is not in the cache, get it and put it in the cache\n    if (displayName == null) \n    {\n        displayName = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        cache.put(key, displayName);\n    }\n\n    // Return the time zone display name\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = sTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        sTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = timeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        timeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = TIME_ZONE_CACHE.get(key);\n    if (display == null) {\n        display = daylight ? tz.getDisplayName(true, style, locale) : tz.getDisplayName(false, style, locale);\n        TIME_ZONE_CACHE.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, style, locale);\n    String display = sTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        if (daylight) {\n            display = tz.getDisplayName(daylight, style, locale);\n        } else {\n            display = tz.getDisplayName(daylight, style, locale);\n        }\n        sTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.columnKeys.indexOf(key);\n    if (result < 0 && this.defaultColumnKey.equals(key)) \n    {\n        result = 0;\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.columnKeys.indexOf(key);\n    if (result < 0 && this.defaultColumnKey.equals(key)) \n    {\n        result = 0;\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.columnKeys.indexOf(key);\n    if (result < 0 && this.defaultColumnKey.equals(key)) {\n        result = 0;\n    }\n    return result;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (forward) {\n            if (point < interval.getPreviousTime() - tolerance) {\n                return Location.OUTSIDE;\n            } else if (point > interval.getCurrentTime() + tolerance) {\n                return Location.OUTSIDE;\n            } else if (point < interval.getPreviousTime() + tolerance) {\n                return Location.INSIDE;\n            } else if (point > interval.getCurrentTime() - tolerance) {\n                return Location.INSIDE;\n            } else {\n                return Location.BOUNDARY;\n            }\n        } else {\n            if (point > interval.getPreviousTime() + tolerance) {\n                return Location.OUTSIDE;\n            } else if (point < interval.getCurrentTime() - tolerance) {\n                return Location.OUTSIDE;\n            } else if (point > interval.getPreviousTime() - tolerance) {\n                return Location.INSIDE;\n            } else if (point < interval.getCurrentTime() + tolerance) {\n                return Location.INSIDE;\n            } else {\n                return Location.BOUNDARY;\n            }\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        final int location = locatePoint(point, this);\n        if (location == -1) {\n            return Location.OUTSIDE;\n        } else if (location == 0) {\n            return (FastMath.abs(point - getPreviousTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n        } else {\n            return (FastMath.abs(point - getCurrentTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - getPreviousTime()) < tolerance) \n    {\n        return forward ? Location.INSIDE : Location.OUTSIDE;\n    }\n    if (Math.abs(point - getCurrentTime()) < tolerance) \n    {\n        return forward ? Location.OUTSIDE : Location.INSIDE;\n    }\n    return Math.abs(point - getPreviousTime()) < Math.abs(point - getCurrentTime()) ? Location.INSIDE : Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    final int location = locatePoint(point, interval);\n    if (location == -1) {\n        return Location.OUTSIDE;\n    } else if (location == 0) {\n        return (FastMath.abs(point - interval.getPreviousTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n    } else {\n        return (FastMath.abs(point - interval.getCurrentTime()) <= tolerance) ? Location.BOUNDARY : Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    final int result = locatePoint(point, interval);\n    if (result == -1) {\n        return Location.OUTSIDE;\n    } else if (result == 1) {\n        return Location.OUTSIDE;\n    } else {\n        if (FastMath.abs(point - interval.getCurrentTime()) <= tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (forward) {\n            if (point < interval.getPreviousTime() - tolerance) {\n                return Location.OUTSIDE;\n            } else if (point > interval.getCurrentTime() + tolerance) {\n                return Location.OUTSIDE;\n            } else if (point > interval.getPreviousTime() && point < interval.getCurrentTime()) {\n                return Location.INSIDE;\n            } else {\n                return Location.BOUNDARY;\n            }\n        } else {\n            if (point > interval.getPreviousTime() + tolerance) {\n                return Location.OUTSIDE;\n            } else if (point < interval.getCurrentTime() - tolerance) {\n                return Location.OUTSIDE;\n            } else if (point > interval.getPreviousTime() && point < interval.getCurrentTime()) {\n                return Location.INSIDE;\n            } else {\n                return Location.BOUNDARY;\n            }\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    final int loc = locatePoint(point, this);\n    if (loc == -1) {\n        return Location.OUTSIDE;\n    } else if (loc == 0) {\n        return (FastMath.abs(point - getPreviousTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n    } else {\n        return (FastMath.abs(point - getCurrentTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (forward) {\n        if (point < (interval.getPreviousTime() - tolerance)) {\n            return Location.OUTSIDE;\n        } else if (point > (interval.getCurrentTime() + tolerance)) {\n            return Location.OUTSIDE;\n        } else if (point > interval.getPreviousTime() && point < interval.getCurrentTime()) {\n            return Location.INSIDE;\n        } else {\n            return Location.BOUNDARY;\n        }\n    } else {\n        if (point > (interval.getPreviousTime() + tolerance)) {\n            return Location.OUTSIDE;\n        } else if (point < (interval.getCurrentTime() - tolerance)) {\n            return Location.OUTSIDE;\n        } else if (point < interval.getPreviousTime() && point > interval.getCurrentTime()) {\n            return Location.INSIDE;\n        } else {\n            return Location.BOUNDARY;\n        }\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (forward) \n    {\n        if (point < (interval.getPreviousTime() - tolerance)) \n        {\n            return Location.OUTSIDE;\n        } \n        else if (point > (interval.getCurrentTime() + tolerance)) \n        {\n            return Location.OUTSIDE;\n        } \n        else if ((point > (interval.getPreviousTime() - tolerance)) && (point < (interval.getCurrentTime() + tolerance))) \n        {\n            return Location.INSIDE;\n        }\n    } \n    else \n    {\n        if (point > (interval.getPreviousTime() + tolerance)) \n        {\n            return Location.OUTSIDE;\n        } \n        else if (point < (interval.getCurrentTime() - tolerance)) \n        {\n            return Location.OUTSIDE;\n        } \n        else if ((point < (interval.getPreviousTime() + tolerance)) && (point > (interval.getCurrentTime() - tolerance))) \n        {\n            return Location.INSIDE;\n        }\n    }\n    return Location.BOUNDARY;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    final int location = locatePoint(point, interval);\n    if (location == -1) {\n        return Location.OUTSIDE;\n    } else if (location == 0) {\n        return (FastMath.abs(point - interval.getCurrentTime()) <= tolerance) ? Location.BOUNDARY : Location.INSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n        TickUnits units = new TickUnits();\n        NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n        units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.001, numberFormat, 2));\n        units.add(new NumberTickUnit(0.01, numberFormat, 2));\n        units.add(new NumberTickUnit(0.1, numberFormat, 2));\n        units.add(new NumberTickUnit(1, numberFormat, 2));\n        units.add(new NumberTickUnit(10, numberFormat, 2));\n        units.add(new NumberTickUnit(100, numberFormat, 2));\n        units.add(new NumberTickUnit(1000, numberFormat, 2));\n        units.add(new NumberTickUnit(10000, numberFormat, 2));\n        units.add(new NumberTickUnit(100000, numberFormat, 2));\n        units.add(new NumberTickUnit(1000000, numberFormat, 2));\n        units.add(new NumberTickUnit(10000000, numberFormat, 2));\n        units.add(new NumberTickUnit(100000000, numberFormat, 2));\n        units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"0.0\");\n    DecimalFormat df2 = new DecimalFormat(\"0.00\");\n    DecimalFormat df3 = new DecimalFormat(\"0.000\");\n    DecimalFormat df4 = new DecimalFormat(\"0.0000\");\n    DecimalFormat df5 = new DecimalFormat(\"0.00000\");\n    DecimalFormat df6 = new DecimalFormat(\"0.000000\");\n    DecimalFormat df7 = new DecimalFormat(\"0.0000000\");\n    DecimalFormat df8 = new DecimalFormat(\"0.00000000\");\n    DecimalFormat df9 = new DecimalFormat(\"0.000000000\");\n    DecimalFormat df10 = new DecimalFormat(\"0.0000000000\");\n\n    // we can add the units in any order, the TickUnits collection will\n    // sort them...\n    units.add(new NumberTickUnit(0.000000001, df0, 2));\n    units.add(new NumberTickUnit(0.00000001, df0, 2));\n    units.add(new NumberTickUnit(0.0000001, df1, 2));\n    units.add(new NumberTickUnit(0.000001, df2, 2));\n    units.add(new NumberTickUnit(0.00001, df3, 2));\n    units.add(new NumberTickUnit(0.0001, df4, 2));\n    units.add(new NumberTickUnit(0.001, df5, 2));\n    units.add(new NumberTickUnit(0.01, df6, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.000000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.000001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.00001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.0001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.001, numberFormat, 2));\n    units.add(new NumberTickUnit(0.01, numberFormat, 2));\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"0.0\");\n    DecimalFormat df2 = new DecimalFormat(\"0.00\");\n    DecimalFormat df3 = new DecimalFormat(\"0.000\");\n    DecimalFormat df4 = new DecimalFormat(\"0.0000\");\n    DecimalFormat df5 = new DecimalFormat(\"0.00000\");\n    DecimalFormat df6 = new DecimalFormat(\"0.000000\");\n    DecimalFormat df7 = new DecimalFormat(\"0.0000000\");\n    DecimalFormat df8 = new DecimalFormat(\"0.00000000\");\n    DecimalFormat df9 = new DecimalFormat(\"0.000000000\");\n    DecimalFormat df10 = new DecimalFormat(\"0.0000000000\");\n\n    units.add(new NumberTickUnit(0.000000001, df0, 2));\n    units.add(new NumberTickUnit(0.00000001, df1, 2));\n    units.add(new NumberTickUnit(0.0000001, df2, 2));\n    units.add(new NumberTickUnit(0.000001, df3, 2));\n    units.add(new NumberTickUnit(0.00001, df4, 2));\n    units.add(new NumberTickUnit(0.0001, df5, 2));\n    units.add(new NumberTickUnit(0.001, df6, 2));\n    units.add(new NumberTickUnit(0.01, df7, 2));\n    units.add(new NumberTickUnit(0.1, df8, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minVal = tableau.getEntry(0, 0);\n    for (int i = 1; i < tableau.getWidth(); i++) {\n        final double val = tableau.getEntry(0, i);\n        if (val < minVal) {\n            minVal = val;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) {\n            minCoefficient = coefficient;\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double pivotVal = tableau.getEntry(0, pivotCol);\n\n    for (int i = 1; i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, pivotVal, maxUlps) < 0) {\n            pivotCol = i;\n            pivotVal = entry;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double maxCoefficient = Double.NEGATIVE_INFINITY;\n        Integer maxCol = null;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            final double coefficient = tableau.getEntry(0, i);\n            if (Precision.compareTo(coefficient, maxCoefficient, maxUlps) < 0) {\n                maxCoefficient = coefficient;\n                maxCol = i;\n            }\n        }\n        return maxCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double minCoefficient = Double.MAX_VALUE;\n        Integer pivotCol = null;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            final double coefficient = tableau.getEntry(0, i);\n            if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) {\n                minCoefficient = coefficient;\n                pivotCol = i;\n            }\n        }\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoefficient = tableau.getEntry(0, pivotCol);\n\n    for (int col = 1; col < tableau.getWidth() - 1; col++) {\n        final double coefficient = tableau.getEntry(0, col);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) {\n            minCoefficient = coefficient;\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double maxCoefficient = Double.NEGATIVE_INFINITY;\n        Integer pivotCol = null;\n        for (int col = 0; col < tableau.getWidth() - 1; col++) {\n            final double coefficient = tableau.getEntry(0, col);\n            if (Precision.compareTo(coefficient, maxCoefficient, maxUlps) < 0) {\n                maxCoefficient = coefficient;\n                pivotCol = col;\n            }\n        }\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int pivotCol = 0;\n        double minCoefficient = tableau.getEntry(0, 1);\n        for (int i = 2; i < tableau.getWidth(); i++) {\n            final double coefficient = tableau.getEntry(0, i);\n            if (coefficient < minCoefficient) {\n                minCoefficient = coefficient;\n                pivotCol = i;\n            }\n        }\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double maxCoefficient = Double.NEGATIVE_INFINITY;\n        Integer maxColumn = null;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            final double coefficient = tableau.getEntry(0, i);\n            if (Precision.compareTo(coefficient, maxCoefficient, maxUlps) < 0) {\n                maxCoefficient = coefficient;\n                maxColumn = i;\n            }\n        }\n        return maxColumn;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double maxNegativeCoefficient = Double.MIN_VALUE;\n        Integer maxNegativeCol = null;\n        for (int col = 0; col < tableau.getWidth() - 1; col++) {\n            final double coefficient = tableau.getEntry(tableau.getNumObjectiveFunctions(), col);\n            if (Precision.compareTo(coefficient, maxNegativeCoefficient, maxUlps) < 0) {\n                maxNegativeCoefficient = coefficient;\n                maxNegativeCol = col;\n            }\n        }\n        return maxNegativeCol;\n    }"
    ]
  ]
}