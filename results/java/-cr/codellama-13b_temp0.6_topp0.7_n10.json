{
  "benchmark": "javaeval-cr",
  "lastest_eval": {
    "compile@1": 0.5793969849246232,
    "pass@1": 0.27537688442211045,
    "compile@3": 0.7543132328308207,
    "pass@3": 0.38844221105527643,
    "compile@5": 0.8137313551886417,
    "pass@5": 0.43664752333094053
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         _checkNotNull(type, \"type\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"Serializer\");\n         _checkNotNull(type, \"Type\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         _checkNotNull(type, \"type\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(ser, \"serializer\");\n         _checkNotNull(type, \"type\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = (TaskSeries) this.data.get(this.getRowIndex(rowKey));\n    Task task = (Task) series.getData().get(this.getColumnIndex(columnKey));\n    return new Double(task.getPercentComplete());\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = getSeries(rowKey);\n    Task task = series.get(columnKey);\n    return task.getPercentComplete();\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = (TaskSeries) this.data.get(this.getRowIndex(rowKey));\n    Task task = (Task) series.get(this.getColumnIndex(columnKey));\n    return task.getPercentComplete();\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = getSeries(rowKey);\n    if (series != null) {\n        return series.getPercentComplete(columnKey);\n    }\n    else {\n        return null;\n    }\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = getSeries(rowKey);\n    Task task = series.get(columnKey);\n    return task.getPercentComplete();\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = (TaskSeries) this.data.get(this.getRowIndex(rowKey));\n    Task task = (Task) series.getData().get(this.getColumnIndex(columnKey));\n    return new Double(task.getPercentComplete());\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = (TaskSeries) this.data.get(this.getRowIndex(rowKey));\n    Task task = (Task) series.getData().get(this.getColumnIndex(columnKey));\n    return task.getPercentComplete();\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n        // TODO add code\n    }",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    TaskSeries series = getSeries(rowKey);\n    if (series == null) {\n        return null;\n    }\n    Task task = series.get(columnKey);\n    if (task == null) {\n        return null;\n    }\n    return task.getPercentComplete();\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        delete(index, index + len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos >= 0) {\n        deleteImpl(pos, pos + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        delete(index, index + len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos >= 0) {\n        deleteImpl(pos, pos + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos >= 0) {\n        deleteImpl(pos, pos + len, len);\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } else {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } else {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } else {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getColumnDimension();\n    final int mRow = m.getRowDimension();\n    if (n != mRow) {\n        throw new DimensionMismatchException(n, mRow);\n    }\n    final RealMatrix out = m.getSubMatrix(0, n - 1, 0, 0);\n    return out;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } \n    else \n    {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getColumnMatrix(0);\n    } else if (m.getRowDimension() == 1) {\n        return m.getRowMatrix(0);\n    } else {\n        throw new DimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } \n    else \n    {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getColumnMatrix(0);\n    } else if (m.getRowDimension() == 1) {\n        return m.getRowMatrix(0);\n    } else {\n        final int n = m.getRowDimension();\n        final RealMatrix out = m.getSubMatrix(0, n - 1, 0, n - 1);\n        for (int i = 0; i < n; i++) {\n            out.setEntry(i, i, m.getEntry(i, i));\n        }\n        return out;\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } else if (m.getRowDimension() == 1) {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    } else {\n        throw new IllegalArgumentException(\"The input matrix must be a column or row matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        return m.getColumnMatrix(0);\n    } \n    else \n    {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // Create the blocks layout\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][blockColumns];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][];\n    for (int i = 0; i < blockRows; ++i) {\n        final int startRow = i * BLOCK_SIZE;\n        final int endRow = Math.min(startRow + BLOCK_SIZE, rows);\n        final int blockHeight = endRow - startRow;\n        blocks[i] = new double[blockColumns * blockHeight];\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    // Complete this function\n    return null;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final double[][] blocks = new double[blockRows][blockColumns];\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final double[][] blocks = new double[blockRows][blockColumns];\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        // number of blocks in rows\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        // number of blocks in columns\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        // number of rows in the last block\n        final int lastBlockRows = rows - (blockRows - 1) * BLOCK_SIZE;\n        // number of columns in the last block\n        final int lastBlockColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n        // create the array\n        final double[][] blocks = new double[blockRows][];\n        for (int i = 0; i < blockRows; ++i) {\n            final int blockRowsI = (i == blockRows - 1) ? lastBlockRows : BLOCK_SIZE;\n            blocks[i] = new double[blockColumns * blockRowsI];\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][blockColumns];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][blockColumns];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][];\n    for (int i = 0; i < blockRows; ++i) {\n        blocks[i] = new double[blockColumns * BLOCK_SIZE];\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][blockColumns];\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) \n    {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        ClassUtils.validateAccess(field, null, false);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) \n    {\n        return field.get(null);\n    }\n    else \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) \n    {\n        return field.get(null);\n    }\n    else \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field %s.%s is not static\", field.getDeclaringClass().getName(), field.getName());\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) \n    {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        ClassUtils.validateAccess(field, null, false);\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (cFixedOffsetCache == null) {\n            cFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n        }\n        SoftReference<DateTimeZone> ref = cFixedOffsetCache.get(id);\n        DateTimeZone zone = (ref == null) ? null : ref.get();\n        if (zone == null) {\n            int offset = parseOffset(id);\n            zone = fixedOffsetZone(id, offset);\n            cFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(id);\n        }\n        return forID(id, null);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        id = getConvertedId(id);\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        synchronized (DateTimeZone.class) {\n            if (cFixedOffsetCache == null) {\n                cFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n            }\n            SoftReference<DateTimeZone> ref = cFixedOffsetCache.get(id);\n            DateTimeZone zone = (ref == null) ? null : ref.get();\n            if (zone == null) {\n                zone = fixedOffsetZone(id, parseOffset(id));\n                cFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n            return zone;\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        id = getConvertedId(id);\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(parseOffset(id));\n        }\n        synchronized (DateTimeZone.class) {\n            if (cAvailableIDs == null) {\n                cAvailableIDs = new HashSet<String>(getProvider().getAvailableIDs());\n            }\n        }\n        if (cAvailableIDs.contains(id)) {\n            return getProvider().getZone(id);\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        id = getConvertedId(id);\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        Provider provider = getProvider();\n        if (provider != null) \n        {\n            DateTimeZone zone = provider.getZone(id);\n            if (zone != null) \n            {\n                return zone;\n            }\n        }\n        if (cAvailableIDs != null) \n        {\n            if (cAvailableIDs.contains(id)) \n            {\n                return new DateTimeZone(id);\n            }\n        }\n        else \n        {\n            try \n            {\n                return new DateTimeZone(id);\n            }\n            catch (RuntimeException ex) \n            {\n                // ignore\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        else \n        {\n            return getProvider().getZone(id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        id = getConvertedId(id);\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        synchronized (DateTimeZone.class) {\n            DateTimeZone zone = iFixedOffsetCache.get(id);\n            if (zone == null) {\n                int offset = parseOffset(id);\n                zone = new FixedDateTimeZone(id, offset);\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n            return zone;\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        return forID0(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        id = getConvertedId(id);\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        synchronized (DateTimeZone.class) {\n            if (cAvailableIDs == null) {\n                cAvailableIDs = new HashSet<String>(Arrays.asList(getProvider().getAvailableIDs()));\n            }\n        }\n        if (cAvailableIDs.contains(id)) {\n            return getProvider().getZone(id);\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        else \n        {\n            return getProvider().getZone(id);\n        }\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    // handle sign\n    if (x == 0) {\n        return newInstance(0);\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == -1) {\n        return negate();\n    }\n\n    // handle special cases\n    if (nans != 0) {\n        return newInstance(sign, nans);\n    }\n    if (exp == 0) {\n        return newInstance(sign * x);\n    }\n    if (exp == Integer.MIN_VALUE) {\n        return newInstance(0);\n    }\n\n    // handle simple cases\n    if (x == RADIX) {\n        return newInstance(sign, nans, exp + 1);\n    }\n    if (x == -RADIX) {\n        return newInstance(-sign, nans, exp + 1);\n    }\n\n    // handle the general case\n    int[] m = new int[mant.length];\n    System.arraycopy(mant, 0, m, 0, m.length);\n    for (int i = 0; i < m.length; ++i) {\n        m[i] *= x;\n    }\n    return newInstance(sign, m, exp + 1);\n}",
      "private Dfp multiplyFast(final int x)  {\n    final int[] m = mant;\n    final int[] m2 = new int[m.length];\n    for (int i = 0; i < m.length; ++i) {\n        m2[i] = m[i] * x;\n    }\n    return new Dfp(field, m2, sign, nans);\n}",
      "private Dfp multiplyFast(final int x)  {\n    return newInstance(mantissa * x);\n}",
      "private Dfp multiplyFast(final int x)  {\n    // we want to compute\n    //    this * x\n    // without overflow.\n    // we know that\n    //    this.mant[0] * x < 2^53\n    // so we can multiply directly.\n    // we know that\n    //    this.mant[0] * x * radix < 2^54\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix < 2^55\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix < 2^56\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix * radix < 2^57\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix * radix * radix < 2^58\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix * radix * radix * radix < 2^59\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix * radix * radix * radix * radix < 2^60\n    // so we can add the result to the first mantissa element without overflow.\n    // we know that\n    //    this.mant[0] * x * radix * radix * radix * radix * radix * radix * radix * radix < 2^61\n    // so we can add the result to the first mantissa element without overflow.\n}",
      "private Dfp multiplyFast(final int x)  {\n    // we know that 0 < x < radix\n    // we know that the result will be finite\n    // we know that the result will not be zero\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n    // we know that the result will not be NaN\n    // we know that the result will not be denormalized\n    // we know that the result will not be infinite\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == radix) {\n        return shiftLeft();\n    }\n    if (x == -1) {\n        return negate();\n    }\n    if (x == -radix) {\n        return shiftRight();\n    }\n    if (x > 0) {\n        return multiply(newInstance(x));\n    }\n    return multiply(newInstance(-x)).negate();\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == radix) {\n        return this.shiftLeft();\n    }\n    if (x == -1) {\n        return this.negate();\n    }\n    if (x == -radix) {\n        return this.shiftRight();\n    }\n    return multiply(newInstance(x));\n}",
      "private Dfp multiplyFast(final int x)  {\n    return new Dfp(field, mant, sign, exp, nans, x);\n}",
      "private Dfp multiplyFast(final int x)  {\n    final int[] m = mant;\n    final int r = RADIX;\n    final int r2 = r * r;\n    final int r3 = r2 * r;\n    final int r4 = r3 * r;\n    final int r5 = r4 * r;\n    final int r6 = r5 * r;\n    final int r7 = r6 * r;\n    final int r8 = r7 * r;\n    final int r9 = r8 * r;\n    final int r10 = r9 * r;\n    final int r11 = r10 * r;\n    final int r12 = r11 * r;\n    final int r13 = r12 * r;\n    final int r14 = r13 * r;\n    final int r15 = r14 * r;\n    final int r16 = r15 * r;\n    final int r17 = r16 * r;\n    final int r18 = r17 * r;\n    final int r19 = r18 * r;\n    final int r20 = r19 * r;\n    final int r21 = r20 * r;\n    final int r22 = r21 * r;\n    final int r23 = r22 * r;\n    final int r24 = r23 * r;\n    final int r25 = r24 * r;\n    final int r26 = r25 * r;\n    final int r27 = r26 * r;\n    final int r28 = r27 * r;\n    final int r29 = r28 * r;\n    final int r30 = r29 * r;\n    final int r31 = r30 * r;\n    final int r32 = r31 * r;\n    final int r33 = r32 * r;\n    final int r34 = r33 * r;\n    final int r35 = r34 * r;\n    final int r36 = r35 * r;\n    final int r37 = r36 * r;\n}",
      "private Dfp multiplyFast(final int x)  {\n\n    if (x == 0) {\n        return newInstance(0);\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    final int[] m = mant;\n    final int[] m2 = new int[m.length];\n    int carry = 0;\n    for (int i = 0; i < m.length; ++i) {\n        final int product = m[i] * x + carry;\n        m2[i] = product & 0xffffffff;\n        carry = product >>> 32;\n    }\n\n    if (carry != 0) {\n        m2[m2.length - 1] = carry;\n    }\n\n    return newInstance(m2, sign, nans);\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> result = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = transformKey(entry.getKey());\n            final V value = transformValue(entry.getValue());\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    // TODO: Implement this function.\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the function node.\n    Node functionNode = new Node(Node.FUNCTION, exportedFunction.getFirstChild(), exportedFunction.getLastChild());\n\n    // Create the function name node.\n    Node functionNameNode = new Node(Node.STRING, exportedFunction.getFirstChild().getNext());\n\n    // Create the function body node.\n    Node functionBodyNode = new Node(Node.BLOCK, exportedFunction.getLastChild().getNext());\n\n    // Create the function parameter node.\n    Node functionParameterNode = new Node(Node.PARAM_LIST, exportedFunction.getFirstChild().getNext().getNext());\n\n    // Create the function return node.\n    Node functionReturnNode = new Node(Node.RETURN, exportedFunction.getLastChild().getNext().getNext());\n\n    // Create the function return value node.\n    Node functionReturnValueNode = new Node(Node.NUMBER, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n    Node functionReturnTypeNode = new Node(Node.STRING, exportedFunction.getLastChild().getNext().getNext().getNext());\n\n    // Create the function return type node.\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = exportedFunction.cloneNode();\n    function.removeChildren();\n    function.setType(Token.FUNCTION);\n    function.setIsSyntheticBlock(true);\n    function.setJSDocInfo(exportedFunction.getJSDocInfo());\n    function.setSourceEncodedPositionForTree(exportedFunction.getSourceEncodedPositionForTree());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    externFunction.setJSType(exportedFunction.getJSType());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node with the same name as the original\n    // function.\n    Node newFunction = new Node(Node.FUNCTION, exportedFunction.getFirstChild(), exportedFunction.getLastChild());\n    newFunction.setJSType(exportedFunction.getJSType());\n\n    // Add the parameters to the new function.\n    for (Node param : exportedFunction.getFirstChild().children()) {\n        newFunction.getFirstChild().addChildToBack(param.cloneTree());\n    }\n\n    // Add the return type to the new function.\n    if (exportedFunction.getJSType() != null) {\n        JSType returnType = exportedFunction.getJSType().getReturnType();\n        if (returnType != null) {\n            newFunction.getLastChild().addChildToFront(new Node(Node.RETURN, new Node(Node.NUMBER, returnType.toString())));\n        }\n    }\n\n    return newFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the function name\n    Node functionName = NodeUtil.getFunctionNameNode(exportedFunction);\n    Preconditions.checkNotNull(functionName);\n\n    // Create the function parameters\n    Node functionParams = NodeUtil.getFunctionParameters(exportedFunction);\n    Preconditions.checkNotNull(functionParams);\n\n    // Create the function body\n    Node functionBody = NodeUtil.getFunctionBody(exportedFunction);\n    Preconditions.checkNotNull(functionBody);\n\n    // Create the function\n    Node function = NodeUtil.newFunction(functionName, functionParams, functionBody);\n\n    // Add the function to the externs\n    NodeUtil.addChildToBack(function);\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = new Node(Node.FUNCTION, exportedFunction.getFirstChild().cloneNode(), exportedFunction.getLastChild().cloneNode());\n    externFunction.setJSType(exportedFunction.getJSType());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = new Node(exportedFunction.getType(), exportedFunction.getLineno(), exportedFunction.getCharno());\n    Node paramList = exportedFunction.getFirstChild();\n    Node returnType = paramList.getNext();\n    Node body = returnType.getNext();\n    Node newParamList = new Node(paramList.getType(), paramList.getLineno(), paramList.getCharno());\n    Node newReturnType = new Node(returnType.getType(), returnType.getLineno(), returnType.getCharno());\n    Node newBody = new Node(body.getType(), body.getLineno(), body.getCharno());\n    Node param = paramList.getFirstChild();\n    while (param != null) {\n        Node newParam = new Node(param.getType(), param.getLineno(), param.getCharno());\n        newParam.addChildToBack(param.getFirstChild());\n        newParamList.addChildToBack(newParam);\n        param = param.getNext();\n    }\n    newReturnType.addChildToBack(returnType.getFirstChild());\n    newBody.addChildToBack(body.getFirstChild());\n    externFunction.addChildToBack(newParamList);\n    externFunction.addChildToBack(newReturnType);\n    externFunction.addChildToBack(newBody);\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = exportedFunction.cloneNode();\n    function.removeChildren();\n    function.setIsFromExterns(true);\n    function.setJSType(exportedFunction.getJSType());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = exportedFunction.cloneNode();\n    function.removeChildren();\n    function.setJSType(exportedFunction.getJSType());\n    return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n\n        // compute the covariance matrix\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n\n        // compute the standard deviation\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariance = computeCovariances(params,\n                                                   covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[cov.length];\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        return computeCovariances(params, covarianceSingularityThreshold)[0];\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n\n        // compute covariance matrix\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n\n        // compute standard deviation\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        return computeCovariances(params, covarianceSingularityThreshold)[0];\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] cov = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        return computeCovariances(params, covarianceSingularityThreshold)[0];\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        return computeCovariances(params, covarianceSingularityThreshold)[0];\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n\n        double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, recursive substitution is not allowed\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, recursion not allowed\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, recursion not allowed\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been used. Cyclic substitution is not allowed.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, loop detected in property resolution.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, loop in definition not allowed\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted on this call\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, \" +\n                \"cyclic substitution detected\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, loop in definition\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted, loop in definition\");\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return getInputsWithoutProvides();\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n      return getSortedDependenciesOf(roots);\n    } else {\n      return getInputsWithoutProvides();\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return getInputsWithoutProvides();\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> result = new ArrayList<>();\n  for (INPUT root : roots) {\n    result.add(root);\n    result.addAll(getDependenciesOf(root, sorted));\n  }\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return getSortedDependenciesOf(roots);\n    } else {\n        return getInputsWithoutProvides();\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    if (sorted) {\n        result.addAll(getSortedDependenciesOf(roots));\n    } else {\n        result.addAll(inputs);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  if (sorted) {\n    return getSortedDependenciesOf(roots);\n  } else {\n    return roots;\n  }\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int index = 0, codePoint; index < strLen; index += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(index);\n        if (isDelimiter(codePoint, delimiters)) {\n            newCodePoints[outOffset++] = codePoint;\n        } else {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n    int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer[i] = ch;\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) \n    {\n        codePoint = str.codePointAt(offset);\n        if (offset == 0 || isDelimiter(codePoint, delimiters)) \n        {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } \n        else \n        {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int index = 0, codePoint; index < strLen; index += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(index);\n        if (isDelimiter(codePoint, delimiters)) {\n            newCodePoints[outOffset++] = codePoint;\n        } else if (Character.isTitleCase(codePoint)) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n    int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder buffer = new StringBuilder(strLen);\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            if (uncapitalizeNext && i > 0 && i < strLen - 1) {\n                ch = Character.toLowerCase(ch);\n            }\n            buffer.append(ch);\n            uncapitalizeNext = true;\n        } else {\n            if (uncapitalizeNext) {\n                ch = Character.toLowerCase(ch);\n            }\n            buffer.append(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0; offset < strLen;) {\n        final int codepoint = str.codePointAt(offset);\n        final int type = Character.getType(codepoint);\n        if (type == Character.UPPERCASE_LETTER) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codepoint);\n        } else if (type == Character.LOWERCASE_LETTER) {\n            newCodePoints[outOffset++] = Character.toUpperCase(codepoint);\n        } else {\n            newCodePoints[outOffset++] = codepoint;\n        }\n        offset += Character.charCount(codepoint);\n    }\n    if (outOffset == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int index = 0, codePoint = 0; index < strLen; index += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(index);\n        if (isDelimiter(codePoint, delimiters)) {\n            newCodePoints[outOffset++] = codePoint;\n        } else if (Character.isTitleCase(codePoint)) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n    int[] positions = new int[delimiters.length];\n    int len = str.length();\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                positions[count++] = i;\n            }\n            lastWasGap = false;\n        }\n    }\n    if (lastWasGap && count > 0) {\n        count--;\n    }\n    if (count == 0) {\n        return str;\n    }\n    char[] buffer = new char[len];\n    for (int i = 0; i < count; i++) {\n        int pos = positions[i];\n        buffer[pos] = Character.toLowerCase(str.charAt(pos));\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) \n    {\n        codePoint = str.codePointAt(offset);\n        boolean isDelimiter = false;\n        if (offset > 0) \n        {\n            final char ch = str.charAt(offset - 1);\n            isDelimiter = isDelimiter(ch, delimiters);\n        }\n        if (isUpperCase(codePoint) && !isDelimiter) \n        {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } \n        else \n        {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    if (outOffset != newCodePoints.length) \n    {\n        newCodePoints = Arrays.copyOf(newCodePoints, outOffset);\n    }\n    return new String(newCodePoints, 0, outOffset);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    final Dfp[] split = new Dfp[2];\n    split[0] = a.newInstance(a.getField(), a.mant[0]);\n    split[1] = a.newInstance(a.getField(), a.mant[1]);\n    return split;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[] {a.newInstance(a.mant[0] >> 1), a.newInstance(a.mant[0] & 1)};\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] split = new Dfp[2];\n    split[0] = a.newInstance(a.getField(), a.getSign(), a.getNans());\n    split[1] = a.newInstance(a.getField(), a.getSign(), a.getNans());\n    return split;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] split = new Dfp[2];\n    split[0] = a.newInstance(a.getField().getRadixDigits());\n    split[1] = a.newInstance(a.getField().getRadixDigits());\n    return split;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[] { a.newInstance(a.getField(), a.getRadixDigits() / 2, a.getField().getZero()), a.newInstance(a.getField(), a.getRadixDigits() / 2, a.getField().getZero()) };\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] split = new Dfp[2];\n    split[0] = a.field.newInstance(a.mant[0]);\n    split[1] = a.field.newInstance(a.mant[1]);\n    return split;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final Dfp[] split = new Dfp[2];\n    split[0] = a.newInstance(a.mant[0]);\n    split[1] = a.newInstance(a.mant[1]);\n    return split;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.newInstance(a.getField().getRadixDigits());\n    result[1] = a.newInstance(a.getField().getRadixDigits());\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[] {a.newInstance(a.getField(), a.getSign(), 0), a.newInstance(a.getField(), a.getSign(), 0)};\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.newInstance(a.getField().getRadixDigits() / 2);\n    result[1] = a.newInstance(a.getField().getRadixDigits() / 2);\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    // If this element has an ID, return the ID selector\n    if (hasAttr(\"id\")) {\n        return \"#\" + attr(\"id\");\n    }\n    // Otherwise, get the selector for the parent and add the element's selector to the end of it\n    else {\n        if (parent() == null) {\n            return tagName();\n        }\n        else {\n            return parent().cssSelector() + \" > \" + tagName();\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    // If this element has an ID, return the ID selector\n    if (id().length() > 0)\n        return \"#\" + id();\n\n    // Otherwise, get the parent and generate a selector based on that\n    Elements parents = parents();\n    if (parents.size() == 0)\n        return tagName();\n    else {\n        String parentSelector = parents.get(0).cssSelector();\n        return String.format(\"%s > %s:nth-child(%d)\", parentSelector, tagName(), elementSiblingIndex() + 1);\n    }\n}",
      "public String cssSelector()  {\n    String id = id();\n    if (id.length() > 0)\n        return \"#\" + id;\n    else {\n        Elements parents = parents();\n        if (parents.size() == 0)\n            return tagName;\n        else {\n            String uniqueSelector = \":nth-child(\" + elementSiblingIndex() + \")\";\n            return parents.get(0).cssSelector() + \">\" + tagName + uniqueSelector;\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) {\n        return \"#\" + id();\n    }\n    Elements parents = parents();\n    StringBuilder selector = new StringBuilder();\n    for (int i = 0; i < parents.size(); i++) {\n        Element parent = parents.get(i);\n        selector.append(parent.tagName());\n        if (!parent.id().isEmpty()) {\n            selector.append(\"#\").append(parent.id());\n        } else if (parent.siblingIndex() > 0) {\n            selector.append(\":nth-child(\").append(1 + parent.siblingIndex()).append(\")\");\n        }\n        if (i < parents.size() - 1) {\n            selector.append(\" > \");\n        }\n    }\n    if (selector.length() > 0) {\n        selector.append(\" > \");\n    }\n    selector.append(tagName());\n    if (!className().isEmpty()) {\n        selector.append(\".\").append(className().replace('.', ' '));\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    String id = id();\n    if (id.length() > 0)\n        return \"#\" + id;\n\n    Elements parents = parents();\n    if (parents.size() == 0)\n        return tagName;\n\n    Element parent = parents.get(0);\n    String combo = parent.cssSelector() + \" > \" + uniqueSelector();\n    return combo;\n}",
      "public String cssSelector()  {\n    String id = id();\n    if (id.length() > 0)\n        return \"#\" + id;\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) {\n        return \"#\" + id();\n    } else if (parent() != null) {\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    } else {\n        return uniqueSelector();\n    }\n}",
      "public String cssSelector()  {\n    // If this element has an ID, return #id\n    if (id().length() > 0)\n        return \"#\" + id();\n\n    // Otherwise, get the parent and find the index of this element in it\n    Elements parents = parents();\n    Element parent = parents.size() == 0 ? null : parents.get(0);\n    int index = parent == null ? 0 : indexInList(this, parent.children());\n\n    // Now build up the selector from the parent\n    StringBuilder selector = new StringBuilder();\n    if (parent != null)\n        selector.append(parent.cssSelector());\n\n    // If there's no parent, or we're the root node, we don't need to add a >\n    if (parent != null)\n        selector.append(\" > \");\n\n    // Add the tag name, and any classes\n    selector.append(tagName);\n    if (hasClass())\n        selector.append(\".\").append(className());\n\n    // If there's more than one element, add the :nth-child() selector\n    if (siblingIndex > 0)\n        selector.append(\":nth-child(\").append(siblingIndex + 1).append(\")\");\n\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot())  {\n        cost += 1;\n    }\n    if (n.isOp())  {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.AND:\n        case Token.OR:\n            cost = 2;\n            break;\n        case Token.HOOK:\n            cost = 3;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += 1;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n    case Token.NOT:\n        cost = 1;\n        break;\n    case Token.AND:\n    case Token.OR:\n        cost = 2;\n        break;\n    case Token.HOOK:\n        cost = 3;\n        break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.AND:\n        case Token.OR:\n            cost = 2;\n            break;\n        case Token.HOOK:\n            cost = 3;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isAnd() || n.isOr()) {\n        cost++;\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int len = size;\n    int mid = len / 2;\n    for (int i = 0, j = len - 1; i < mid; i++, j--) \n    {\n        char ch = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = ch;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char swap = buffer[left];\n        buffer[left++] = buffer[right];\n        buffer[right--] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char swap = buffer[left];\n        buffer[left++] = buffer[right];\n        buffer[right--] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size();\n    for (int i = 0, j = len - 1; j > i; i++, j--) \n    {\n        char swap = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) \n        {\n            swap(i, j);\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) \n        {\n            swap(i, j);\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size();\n    if (len <= 1) \n    {\n        return this;\n    }\n    int mid = len >> 1;\n    len--;\n    char[] chars = buffer;\n    char temp;\n    for (int i = 0, j = len; i < mid; i++, j--) \n    {\n        temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size;\n    if (len <= 1) \n    {\n        return this;\n    }\n    int mid = len >> 1;\n    char[] chars = buffer;\n    for (int i = 0, j = len - 1; i < mid; i++, j--) \n    {\n        char ch = chars[i];\n        chars[i] = chars[j];\n        chars[j] = ch;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) \n        {\n            char swap = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = swap;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) \n        {\n            swap(i, j);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n        if (offset < 0 || offset > getWholeText().length()) {\n            throw new IllegalArgumentException(\"Split offset must be not be negative and not greater than current text length\");\n        }\n\n        String head = getWholeText().substring(0, offset);\n        String tail = getWholeText().substring(offset);\n\n        TextNode tailNode = new TextNode(tail, baseUri());\n        text(head);\n        this.parentNode.addChild(tailNode);\n        return tailNode;\n    }",
      "public TextNode splitText(int offset)  {\n    // Check offset is valid\n    if (offset < 0 || offset > this.text().length()) {\n        throw new IllegalArgumentException(\"Split offset must be not be negative and not greater than current text length\");\n    }\n\n    // Split text node and sibling\n    String head = this.text().substring(0, offset);\n    String tail = this.text().substring(offset);\n    this.text(head);\n    TextNode tailNode = new TextNode(tail, this.baseUri());\n    this.parentNode().addChildAfter(tailNode, this);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    //check if offset is within the bounds of the text\n    if (offset < 0 || offset > text.length())\n        throw new IndexOutOfBoundsException(\"Split offset must be within 0 and current text length\");\n\n    //create a new text node containing the text after the offset\n    TextNode tail = new TextNode(text.substring(offset), baseUri);\n\n    //update this node to contain the text before the offset\n    text = text.substring(0, offset);\n\n    //insert the new node after this node\n    if (parent != null)\n        parent.addChildren(siblingIndex + 1, tail);\n\n    return tail;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    if (offset < 0 || offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"Split offset must be within 0 and current text length\");\n    }\n    String head = text.substring(0, offset);\n    String tail = text.substring(offset);\n    TextNode tailNode = new TextNode(tail, baseUri());\n    this.text(head);\n    this.parentNode.addChild(tailNode);\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n        if (offset < 0 || offset > this.text.length()) {\n            throw new IllegalArgumentException(\"Split offset must be not be negative and not larger than current text length\");\n        }\n        TextNode tail = new TextNode(this.text.substring(offset), this.baseUri);\n        this.text = this.text.substring(0, offset);\n        this.parentNode.addChild(this.siblingIndex + 1, tail);\n        return tail;\n    }",
      "public TextNode splitText(int offset)  {\n        if (offset < 0 || offset > this.text().length()) {\n            throw new IllegalArgumentException(\"Split offset must be > 0 and < current text length\");\n        }\n        String head = this.text().substring(0, offset);\n        String tail = this.text().substring(offset);\n        this.text(head);\n        return new TextNode(tail, this.baseUri());\n    }",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > getWholeText().length())\n        throw new IllegalArgumentException(\"Split offset must be not be negative and not greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    this.text(head);\n    TextNode tailNode = new TextNode(tail, baseUri());\n    this.parentNode.addChild(tailNode);\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String firstText = text.substring(0, offset);\n    String secondText = text.substring(offset);\n    this.text(firstText);\n    return new TextNode(secondText, this.baseUri());\n}",
      "public TextNode splitText(int offset)  {\n    //TODO: Implement this method\n    return null;\n}",
      "public TextNode splitText(int offset)  {\n    //check if the offset is valid\n    if(offset < 0 || offset > text.length())\n        throw new IllegalArgumentException(\"offset must be > 0 and < current text length\");\n    \n    //create a new text node with the remaining text\n    TextNode newTextNode = new TextNode(text.substring(offset), baseUri);\n    \n    //update this node with the original text\n    text = text.substring(0, offset);\n    \n    //return the new text node\n    return newTextNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = CollectionUtils.union(a, b);\n    final Collection<O> intersection = CollectionUtils.intersection(a, b);\n    return CollectionUtils.subtract(union, intersection);\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] valBytes = value.toByteArray();\n    int bytesLen = valBytes.length;\n    if (bytesLen > 8) \n    {\n        throw new IllegalArgumentException(\"Input too large to convert to eight bytes\");\n    }\n    int srcPos = (valBytes[0] == 0 && valBytes[1] == -1) ? 4 : 0;\n    int destPos = 8 - bytesLen;\n    System.arraycopy(valBytes, srcPos, bytes, destPos, bytesLen - srcPos);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = new byte[8];\n        byte[] biBytes = value.toByteArray();\n        int start = (biBytes.length == 8) ? 0 : 1;\n        int length = Math.min(8, biBytes.length);\n        System.arraycopy(biBytes, start, bytes, 8 - length, length);\n        return bytes;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final byte[] valBytes = value.toByteArray();\n    final int start = valBytes.length > 8 ? valBytes.length - 8 : 0;\n    final int length = Math.min(valBytes.length, 8);\n    System.arraycopy(valBytes, start, bytes, 8 - length, length);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] valueBytes = value.toByteArray();\n    int offset = valueBytes.length - 8;\n    if (offset < 0) {\n        offset = 0;\n    }\n    System.arraycopy(valueBytes, offset, bytes, 0, 8);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final byte[] valBytes = value.toByteArray();\n    final int start = valBytes.length > 8 ? valBytes.length - 8 : 0;\n    final int length = Math.min(8, valBytes.length);\n    System.arraycopy(valBytes, start, bytes, 8 - length, length);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] valBytes = value.toByteArray();\n    int bytesLen = valBytes.length;\n    if (bytesLen > 8) \n    {\n        throw new IllegalArgumentException(\"Input too large to convert to eight bytes\");\n    }\n    int srcPos = (valBytes[0] == 0 && valBytes[1] == -1) ? 4 : 0;\n    int destPos = 8 - bytesLen;\n    System.arraycopy(valBytes, srcPos, bytes, destPos, bytesLen - srcPos);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final byte[] biBytes = value.toByteArray();\n    final int start = (biBytes.length == 8) ? 0 : 1;\n    for (int i = 7; i >= start; i--) \n    {\n        bytes[i - start] = biBytes[i];\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final byte[] src = value.toByteArray();\n    int offset = src.length - bytes.length;\n    if (offset < 0) {\n        offset = 0;\n    }\n    System.arraycopy(src, offset, bytes, 0, bytes.length);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final byte[] valBytes = value.toByteArray();\n    int bytesOffset = bytes.length - valBytes.length;\n    for (int i = 0; i < valBytes.length; i++) {\n        bytes[bytesOffset++] = valBytes[i];\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int length = bytes.length;\n    if (length > 8) {\n        length = 8;\n    }\n    int srcPos = bytes.length - length;\n    int destPos = 8 - length;\n    System.arraycopy(bytes, srcPos, result, destPos, length);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    // check if matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // check if matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // compute the eigen decomposition of the matrix\n    EigenDecomposition eigen = new EigenDecomposition(this);\n\n    // compute the square-root of the eigenvalues\n    double[] sqrtEigenvalues = new double[eigen.getRealEigenvalues().length];\n    for (int i = 0; i < sqrtEigenvalues.length; ++i) {\n        sqrtEigenvalues[i] = Math.sqrt(eigen.getRealEigenvalue(i));\n    }\n\n    // compute the square-root of the eigenvectors\n    ArrayRealVector[] eigenvectors = new ArrayRealVector[eigen.getEigenvectors().length];\n    for (int i = 0; i < eigenvectors.length; ++i) {\n        eigenvectors[i] = (ArrayRealVector) eigen.getEigenvector(i).mapMultiply(1 / sqrtEigenvalues[i]);\n    }\n\n    // build the square-root matrix\n    RealMatrix sqrt = MatrixUtils.createRealMatrix(getRowDimension(), getColumnDimension());\n    for (int i = 0; i < eigenvectors.length; ++i) {\n        sqrt = sqrt.add(eigenvectors[i].outerProduct(eigenvectors[i]));\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n        // Check if matrix is symmetric\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n        }\n\n        // Check if matrix is positive definite\n        if (!isPositiveDefinite) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n\n        // Compute the eigen decomposition of the matrix\n        final EigenDecomposition eigen = new EigenDecomposition(this);\n\n        // Compute the square-root of the eigenvalues\n        final double[] sqrtEigenvalues = new double[eigen.getRealEigenvalues().length];\n        for (int i = 0; i < sqrtEigenvalues.length; ++i) {\n            sqrtEigenvalues[i] = Math.sqrt(eigen.getRealEigenvalue(i));\n        }\n\n        // Compute the square-root of the eigenvectors\n        final ArrayRealVector[] eigenvectors = new ArrayRealVector[eigen.getEigenvectors().length];\n        for (int i = 0; i < eigenvectors.length; ++i) {\n            eigenvectors[i] = (ArrayRealVector) eigen.getEigenvector(i).mapDivideToSelf(sqrtEigenvalues[i]);\n        }\n\n        // Build the square-root matrix\n        final RealMatrix sqrt = MatrixUtils.createRealMatrix(eigenvectors[0].getDimension(), eigenvectors[0].getDimension());\n        for (int i = 0; i < eigenvectors.length; ++i) {\n            sqrt.setColumnVector(i, eigenvectors[i]);\n        }\n\n        return sqrt;\n    }",
      "public RealMatrix getSquareRoot()  {\n    // compute the eigen decomposition of the matrix\n    final EigenDecomposition ed = new EigenDecomposition(this);\n    final double[] realEigenvalues = ed.getRealEigenvalues();\n    final double[] imagEigenvalues = ed.getImagEigenvalues();\n    final ArrayRealVector[] eigenvectors = ed.getEigenVectors();\n    final int n = realEigenvalues.length;\n    // check that the matrix is symmetric and positive definite\n    for (int i = 0; i < n; ++i) {\n        if (imagEigenvalues[i] != 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SPD);\n        }\n        if (realEigenvalues[i] <= 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SPD);\n        }\n    }\n    // compute the square-root of the eigenvalues\n    final double[] sqrtEigenvalues = new double[n];\n    for (int i = 0; i < n; ++i) {\n        sqrtEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n    }\n    // compute the square-root of the matrix\n    final RealMatrix sqrtMatrix =\n        MatrixUtils.createRealMatrix(n, n);\n    for (int i = 0; i < n; ++i) {\n        final ArrayRealVector sqrtEigenvector =\n            (ArrayRealVector) eigenvectors[i].mapMultiply(1 / sqrtEigenvalues[i]);\n        sqrtMatrix.setColumnVector(i, sqrtEigenvector);\n    }\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final int n = main.length;\n    final double[][] s = new double[n][n];\n    for (int i = 0; i < n; ++i) {\n        s[i][i] = FastMath.sqrt(main[i]);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            s[i][j] = secondary[i] / (s[i][i] * s[j][j]);\n            s[j][i] = s[i][j];\n        }\n    }\n    return new Array2DRowRealMatrix(s, false);\n}",
      "public RealMatrix getSquareRoot()  {\n    // check that the matrix is symmetric\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // check that the matrix is positive definite\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // compute the eigen decomposition of the matrix\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n\n    // get the eigen values and vectors\n    final double[] realEigenvalues = eigen.getRealEigenvalues();\n    final double[] imagEigenvalues = eigen.getImagEigenvalues();\n    final ArrayRealVector[] eigenvectors = eigen.getEigenVectors();\n\n    // check that all eigen values are positive\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        if (realEigenvalues[i] <= 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n    }\n\n    // compute the square-root of the eigen values\n    final double[] sqrtRealEigenvalues = new double[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        sqrtRealEigenvalues[i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // compute the square-root of the matrix\n    final RealMatrix sqrt = new Array2DRowRealMatrix(realEigenvalues.length, realEigenvalues.length);\n    for (int i = 0; i < realEigenvalues.length; ++i) {\n        final ArrayRealVector sqrtEigenvector =\n            (ArrayRealVector) eigenvectors[i].mapMultiply(1.0 / sqrtRealEigenvalues[i]);\n        sqrt.setColumnVector(i, sqrtEigenvector);\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    // check if matrix is symmetric\n    for (int i = 0; i < main.length; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (main[i][j] != main[j][i]) {\n                throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n            }\n        }\n    }\n\n    // check if matrix is positive definite\n    for (int i = 0; i < main.length; ++i) {\n        if (main[i][i] <= 0) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n    }\n\n    // compute square-root\n    RealMatrix sqrt = new Array2DRowRealMatrix(main.length, main.length);\n    for (int i = 0; i < main.length; ++i) {\n        sqrt.setEntry(i, i, Math.sqrt(main[i][i]));\n        for (int j = 0; j < i; ++j) {\n            sqrt.setEntry(i, j, main[i][j] / (2 * sqrt.getEntry(i, i) * sqrt.getEntry(j, j)));\n        }\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    // check if matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // check if matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // compute square-root\n    final RealMatrix sqrt = new Array2DRowRealMatrix(size, size);\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j <= i; j++) {\n            sqrt.setEntry(i, j, FastMath.sqrt(getEntry(i, j)));\n        }\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n        }\n        if (!isPositiveDefinite) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n        // transform matrix to tridiagonal form\n        transformToTridiagonal(getV());\n        // transform tridiagonal matrix to diagonal form\n        final double[] d = transformToDiagonal(getMainDiagonal(), getSecondaryDiagonal());\n        // compute square root of diagonal elements\n        final double[] dSqrt = new double[d.length];\n        for (int i = 0; i < d.length; ++i) {\n            dSqrt[i] = JdkMath.sqrt(d[i]);\n        }\n        // build diagonal matrix from diagonal elements\n        final RealMatrix dMatrix = MatrixUtils.createRealDiagonalMatrix(dSqrt);\n        // compute square root of matrix\n        return dMatrix.multiply(getV());\n    }",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n        }\n        final double[][] squareRoot = new double[main.length][main.length];\n        for (int i = 0; i < main.length; i++) {\n            for (int j = 0; j < main.length; j++) {\n                squareRoot[i][j] = FastMath.sqrt(main[i][j]);\n            }\n        }\n        return new Array2DRowRealMatrix(squareRoot, false);\n    }",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n        }\n        if (!isPositiveDefinite) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n        }\n\n        final int n = main.length;\n        final double[][] V = new double[n][n];\n        final double[][] U = new double[n][n];\n        final double[][] R = new double[n][n];\n        final double[][] S = new double[n][n];\n        final double[][] T = new double[n][n];\n        final double[][] Z = new double[n][n];\n        final double[][] W = new double[n][n];\n        final double[][] Vt = new double[n][n];\n        final double[][] UT = new double[n][n];\n        final double[][] RT = new double[n][n];\n        final double[][] ST = new double[n][n];\n        final double[][] TT = new double[n][n];\n        final double[][] ZT = new double[n][n];\n        final double[][] WT = new double[n][n];\n\n        // Compute the eigenvectors and eigenvalues of the matrix.\n        final EigenDecomposition ed = new EigenDecomposition(this);\n        final double[] d = ed.getRealEigenvalues();\n        final ArrayRealVector[] v = ed.getEigenVectors();\n\n        // Compute the square-root of the eigenvalues.\n        for (int i = 0; i < n; ++i) {\n            d[i] = Math.sqrt(d[i]);\n        }\n\n        // Compute the square-root of the eigenvectors.\n        for (int i = 0; i < n; ++i) {\n}\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        final BeanPropertyMap props = _beanProperties;\n        final int propCount = props.size();\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        PropertyValueBuffer buffer = new PropertyValueBuffer(propCount);\n\n        for (int i = 0; i < propCount; ++i) {\n            SettableBeanProperty prop = props.get(i);\n            // 06-Nov-2015, tatu: [databind#120] Coercion/conversion?\n            Object value = prop.deserialize(p, ctxt);\n            buffer.assignParameter(prop, value);\n        }\n        buffer.writeParameters(bean);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        final PropertyValueBuffer buffer = new PropertyValueBuffer(ctxt.getConfig());\n        final boolean hasViews = ctxt.isEnabled(DeserializationFeature.VIEW_INCLUSION);\n        final Class<?> activeView = hasViews ? ctxt.getActiveView() : null;\n        final boolean hasBuffered = deserializeWithoutProperty(p, ctxt, bean, buffer, activeView);\n        if (hasBuffered) {\n            buffer.write(bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        final SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        final int len = props.length;\n        PropertyValueBuffer buffer = ctxt.leasePropertyValueBuffer();\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = props[i];\n            if (buffer.assignParameter(prop, prop.deserialize(p, ctxt))) {\n                continue;\n            }\n            return _deserializeOther(p, ctxt, t);\n        }\n        _valueInstantiator.createUsingDefault(ctxt);\n        _beanProperties.set(bean, buffer);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t// Ok: we have the first token, and we know it's value; so let's just proceed\n    \t// as if it were the only token.\n    \tif (t == JsonToken.VALUE_STRING) {\n    \t\treturn deserializeFromString(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\treturn deserializeFromNumber(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\treturn deserializeFromDouble(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_TRUE) {\n    \t\treturn deserializeFromBoolean(p, ctxt, true);\n    \t}\n    \tif (t == JsonToken.VALUE_FALSE) {\n    \t\treturn deserializeFromBoolean(p, ctxt, false);\n    \t}\n    \tif (t == JsonToken.VALUE_NULL) {\n    \t\treturn deserializeFromNull(p, ctxt);\n    \t}\n    \tif (t == JsonToken.START_ARRAY) {\n    \t\treturn deserializeFromArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.START_OBJECT) {\n    \t\treturn deserializeFromObject(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_ARRAY) {\n    \t\treturn deserializeFromEndOfArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_OBJECT) {\n    \t\treturn deserializeFromEndOfObject(p, ctxt);\n    \t}\n    \tif (t == JsonToken.FIELD_NAME) {\n    \t\treturn deserializeFromFieldName(p, ctxt);\n    \t}\n    \tif (t == JsonToken.NOT_AVAILABLE) {\n    \t\treturn deserializeFromAny(p, ctxt);\n    \t}\n    \t// should never get here\n    \tthrow new IllegalStateException(\"Don't know how to deserialize JsonToken of type \"+t);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t// 15-Apr-2017, tatu: As per [databind#1551], need to handle nulls\n    \t//    more carefully\n    \tif (t == JsonToken.VALUE_NULL) {\n    \t\treturn _deserializeFromEmpty(p, ctxt);\n    \t}\n    \tif (_nonStandardCreation) {\n    \t\treturn deserializeFromNonStandard(p, ctxt, t);\n    \t}\n    \tif (_standardStringKey) {\n    \t\treturn deserializeFromString(p, ctxt);\n    \t}\n    \tif (_standardStringDeserializer != null) {\n    \t\treturn _standardStringDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardStringKeyDeserializer != null) {\n    \t\treturn _standardStringKeyDeserializer.deserializeKey(p, ctxt);\n    \t}\n    \tif (_standardNumberDeserializer != null) {\n    \t\treturn _standardNumberDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardBooleanDeserializer != null) {\n    \t\treturn _standardBooleanDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardEnumDeserializer != null) {\n    \t\treturn _standardEnumDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardNodeDeserializer != null) {\n    \t\treturn _standardNodeDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardAnyDeserializer != null) {\n    \t\treturn _standardAnyDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardMapDeserializer != null) {\n    \t\treturn _standardMapDeserializer.deserialize(p, ctxt);\n    \t}\n    \tif (_standardCollectionDeserializer != null) {\n    \t\treturn _standardCollectionDeserializer.deserialize(p, ctxt);\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t// Ok: we have following, which we need to split up in more generic way\n    \tif (t == JsonToken.VALUE_STRING) {\n    \t\tif (_hasTextualNull(p)) {\n    \t\t\treturn _deserializeNullForDefault(ctxt);\n    \t\t}\n    \t}\n    \t// And then other cases...\n    \treturn _deserializeOther(p, ctxt, t);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        final SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();\n        final int len = props.length;\n        PropertyValueBuffer buffer = ctxt.startPropertyValueBuffering();\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = props[i];\n            if (buffer.assignParameter(prop, _deserializeWithErrorWrapping(p, ctxt, prop))) {\n                continue;\n            }\n            if (p.hasToken(prop.getMember().getToken())) {\n                p.nextToken();\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            if (buffer.readIdProperty(prop.getMember().getFullName())) {\n                continue;\n            }\n            // value not found:\n            if (prop.isRequired()) {\n                throw ctxt.instantiationException(bean.getClass(),\n                        String.format(\"Missing property '%s' for type %s\",\n                                prop.getName(), bean.getClass().getName()));\n            }\n            // otherwise, value is null which is fine\n        }\n        buffer.writeParametersToBean(bean);\n        return bean;\n    }\n\n    /*\n    /**********************************************************\n    /* Deserialization with Object Id handling\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.START_OBJECT) {\n    \t\treturn vanillaDeserialize(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_STRING) {\n    \t\treturn _deserializeFromString(p, ctxt);\n    \t}\n    \tif (t == JsonToken.START_ARRAY) {\n    \t\treturn _deserializeFromArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\treturn _deserializeFromNumber(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\treturn _deserializeFromDouble(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_TRUE) {\n    \t\treturn _deserializeFromBoolean(p, ctxt, true);\n    \t}\n    \tif (t == JsonToken.VALUE_FALSE) {\n    \t\treturn _deserializeFromBoolean(p, ctxt, false);\n    \t}\n    \tif (t == JsonToken.VALUE_NULL) {\n    \t\treturn _deserializeFromNull(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_ARRAY) {\n    \t\treturn _deserializeFromEndOfArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_OBJECT) {\n    \t\treturn _deserializeFromEndOfObject(p, ctxt);\n    \t}\n    \tif (t == JsonToken.FIELD_NAME) {\n    \t\treturn _deserializeFromFieldName(p, ctxt);\n    \t}\n    \tif (t == JsonToken.NOT_AVAILABLE) {\n    \t\treturn _deserializeFromNotAvailable(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\treturn _deserializeFromEmbedded(p, ctxt);\n    \t}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 23-Mar-2017, tatu: As per [databind#1558], need to be able to\n        //     handle nulls from \"unwrapped\" values (ones that are\n        //     not within JSON Object)\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        if (_nonStandardCreation) {\n            return vanillaNonStdCreate(p, ctxt, t);\n        }\n        final SettableBeanProperty[] props = _properties;\n        int propsCount = props.length;\n        final Object[] values = new Object[propsCount];\n        for (int i = 0; i < propsCount; ++i) {\n            SettableBeanProperty prop = props[i];\n            // 06-Mar-2017, tatu: Related to [databind#1510], need to\n            //     check for \"ignorable\"\n            if (prop == null) {\n                continue;\n            }\n            // And then the usual property case\n            if (prop.visibleInView(ctxt.getActiveView())) {\n                JsonToken t0 = p.currentToken();\n                if (t0 == JsonToken.VALUE_NULL && prop.isRequired()) {\n                    return _deserializeFromEmpty(p, ctxt);\n                }\n                values[i] = prop.deserialize(p, ctxt);\n            }\n        }\n        try {\n            return _valueInstantiator.createFromObjectWith(ctxt, values);\n        } catch (Exception e) {\n            wrapAndThrow((IOException) null, e, ctxt);\n            return null;\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 23-Jun-2016, tatu: As per [databind#1313], need to be able to deal with nulls\n        //   here; and since we can't call \"nextToken()\" (since it may fail) need to\n        //   be able to do some lookahead.\n        //   So, the approach here is to use \"getCurrentToken\" (which should NOT\n        //   throw an exception for nulls), and if it indicates we have a null\n        //   token, handle appropriately.\n        //   As per [databind#155], need to also allow \"expected\" nulls, which\n        //   are ones that are marked as ignored.\n        JsonToken t0 = p.getCurrentToken();\n        if (t0 == JsonToken.VALUE_NULL) {\n            if (_skipNullValues) {\n                return deserialize(p, ctxt);\n            }\n            if (_hasDefaultCreator) {\n                return _valueInstantiator.createUsingDefault(ctxt);\n            }\n            if (_nullProvider != null) {\n                return _nullProvider.getNullValue(ctxt);\n            }\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        if (t0 == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t0 == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        // 11-May-2017, tatu: As per [databind#1995], need to handle edge case\n        //   of \"empty\" String as null as well\n        if (t0 == JsonToken.VALUE_STRING && p.getText().length() == 0) {\n            if (_skipNullValues) {\n                return deserialize(p, ctxt);\n            }\n            if (_hasDefaultCreator) {\n                return _valueInstantiator.createUsingDefault(ctxt);\n            }\n            if (_nullProvider != null) {\n                return _nullProvider.getNullValue(ctxt);\n            }\n}\n}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    return sum(difference(sample1, sample2));\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    checkSampleData(sample1, sample2);\n    double sumDiff = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sumDiff += sample1[i] - sample2[i];\n    }\n    return sumDiff;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sumDiff = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sumDiff += sample1[i] - sample2[i];\n    }\n    return sumDiff;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        double sumDiff = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sumDiff += sample1[i] - sample2[i];\n        }\n\n        return sumDiff;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // TODO: implement\n         return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = node;\n         } else {\n             _tail.setNext(node);\n         }\n         _tail = node;\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = _tail = node;\n         } else {\n             _tail.next = node;\n             _tail = node;\n         }\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // ///////////////////////////////////////////////////////////////////////\n         // TODO: Add code to append the full chunk to this buffer, and to\n         // return a new chunk buffer for caller to fill.\n         // ///////////////////////////////////////////////////////////////////////\n         return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n     // Add the completed chunk to the end of the linked list\n     if (_tail == null) {\n         _head = _tail = new LinkedNode<>(fullChunk);\n     } else {\n         _tail.next = new LinkedNode<>(fullChunk);\n         _tail = _tail.next;\n     }\n     _size += fullChunk.length;\n     // And return a new array for caller to fill\n     return resetAndStart();\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.type) \n    {\n        case JsDocToken.STAR:\n            return newNode(Token.STAR);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case JsDocToken.IDENTIFIER:\n            return parseTypeName(token);\n        case JsDocToken.FUNCTION:\n            return parseFunctionType(token);\n        case JsDocToken.LBRACK:\n            return parseArrayType(token);\n        case JsDocToken.LC:\n            return parseRecordType(token);\n        case JsDocToken.UNION:\n            return parseUnionType(token);\n        default:\n            return reportTypeSyntaxWarning(\"Expected type expression\");\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case STAR:\n            return parseTypeName(next());\n        case NULL:\n        case UNDEFINED:\n            return newNode(token.ordinal());\n        case FUNCTION:\n            return parseFunctionType(next());\n        case OPEN_BRACE:\n            return parseRecordType(next());\n        case OPEN_BRACKET:\n            return parseArrayType(next());\n        default:\n            return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case MULTIPLY:\n            return newNode(Token.MUL);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.VOID);\n        case IDENTIFIER:\n            return parseTypeName(token);\n        case LBRACE:\n            return parseRecordType(token);\n        case LPAREN:\n            return parseFunctionType(token);\n        case LBRACK:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  Node typeNode;\n  switch (token) {\n    case MULT:\n      typeNode = newNode(Token.MUL);\n      break;\n    case NULL:\n      typeNode = newNode(Token.NULL);\n      break;\n    case VOID:\n      typeNode = newNode(Token.VOID);\n      break;\n    case UNDEFINED:\n      typeNode = newNode(Token.UNDEFINED);\n      break;\n    case IDENTIFIER:\n      typeNode = parseTypeName(token);\n      break;\n    case LBRACE:\n      typeNode = parseRecordType(token);\n      break;\n    case LSQUARE:\n      typeNode = parseArrayType(token);\n      break;\n    case FUNCTION:\n      typeNode = parseFunctionType(token);\n      break;\n    case LPAREN:\n      typeNode = parseUnionType(token);\n      break;\n    default:\n      reportTypeSyntaxWarning(\"Invalid type expression\");\n      typeNode = newNode(Token.EMPTY);\n      break;\n  }\n  return typeNode;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node node = null;\n    switch (token) \n    {\n        case STAR:\n            node = newNode(Token.MUL);\n            break;\n        case NULL:\n            node = newNode(Token.NULL);\n            break;\n        case UNDEFINED:\n            node = newNode(Token.UNDEFINED);\n            break;\n        case IDENTIFIER:\n            node = parseTypeName(token);\n            break;\n        case FUNCTION:\n            node = parseFunctionType(token);\n            break;\n        case LBRACK:\n            node = parseArrayType(token);\n            break;\n        case LBRACE:\n            node = parseRecordType(token);\n            break;\n        case LPAREN:\n            node = parseUnionType(token);\n            break;\n        default:\n            throw reportTypeSyntaxWarning(\"Unexpected token in BasicTypeExpression: \" + token);\n    }\n    return node;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case MULT:\n      return parseTypeName(next());\n    case NULL:\n      return parseTypeName(next());\n    case UNDEFINED:\n      return parseTypeName(next());\n    case LBRACE:\n      return parseRecordType(token);\n    case LBRACK:\n      return parseArrayType(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case UNION:\n      return parseUnionType(token);\n    default:\n      return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.type) {\n      case JsDocToken.STAR:\n        return newNode(Token.STAR);\n      case JsDocToken.NULL:\n        return newNode(Token.NULL);\n      case JsDocToken.UNDEFINED:\n        return newNode(Token.VOID);\n      case JsDocToken.IDENTIFIER:\n        return parseTypeName(token);\n      case JsDocToken.FUNCTION:\n        return parseFunctionType(token);\n      case JsDocToken.LBRACK:\n        return parseArrayType(token);\n      case JsDocToken.LC:\n        return parseRecordType(token);\n      case JsDocToken.UNION:\n        return parseUnionType(token);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    Node n;\n    switch (token.type) {\n        case JsDocToken.STAR:\n            n = newNode(Token.STAR);\n            break;\n        case JsDocToken.NULL:\n            n = newNode(Token.NULL);\n            break;\n        case JsDocToken.UNDEFINED:\n            n = newNode(Token.UNDEFINED);\n            break;\n        case JsDocToken.IDENTIFIER:\n            n = parseTypeName(token);\n            break;\n        case JsDocToken.FUNCTION:\n            n = parseFunctionType(token);\n            break;\n        case JsDocToken.UNION:\n            n = parseUnionType(token);\n            break;\n        case JsDocToken.RECORD:\n            n = parseRecordType(token);\n            break;\n        case JsDocToken.ARRAY:\n            n = parseArrayType(token);\n            break;\n        default:\n            reportTypeSyntaxWarning(\"unexpected.token\");\n            n = null;\n    }\n    return n;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  Node typeAst = null;\n  int lineno = token.lineno;\n  int startCharno = token.charno;\n  switch (token.type) {\n    case JsDocToken.STAR:\n      typeAst = newNode(Token.STAR);\n      break;\n    case JsDocToken.NULL:\n      typeAst = newNode(Token.NULL);\n      break;\n    case JsDocToken.UNDEFINED:\n      typeAst = newNode(Token.UNDEFINED);\n      break;\n    case JsDocToken.IDENTIFIER:\n      typeAst = parseTypeName(token);\n      break;\n    case JsDocToken.FUNCTION:\n      typeAst = parseFunctionType(token);\n      break;\n    case JsDocToken.LBRACK:\n      typeAst = parseUnionType(token);\n      break;\n    case JsDocToken.LC:\n      typeAst = parseRecordType(token);\n      break;\n    case JsDocToken.ARRAY:\n      typeAst = parseArrayType(token);\n      break;\n    default:\n      parser.addTypeWarning(\"JSDoc syntax error\", token.lineno, token.charno);\n      break;\n  }\n  if (typeAst != null) {\n    typeAst.setSourceEncodedPositionForTree(lineno, startCharno);\n  }\n  return typeAst;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case ASTERISK:\n      return newNode(Token.MUL);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case LBRACE:\n      return parseRecordType(token);\n    case LBRACK:\n      return parseArrayType(token);\n    case LPAREN:\n      return parseFunctionType(token);\n    case IDENTIFIER:\n      return parseTypeName(token);\n    case BAR:\n      return parseUnionType(token);\n    default:\n      throw reportTypeSyntaxWarning(\"Invalid type expression\");\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  beforeName();\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    beforeName();\n    deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    double min = Double.POSITIVE_INFINITY;\n    int columnCount = dataset.getColumnCount();\n    for (int item = 0; item < columnCount; item++) \n    {\n        double total = 0.0;\n        for (int category = 0; category < dataset.getRowCount(); category++) \n        {\n            Number value = dataset.getValue(category, item);\n            if (value != null) \n            {\n                total += value.doubleValue();\n            }\n        }\n        if (total < min) \n        {\n            min = total;\n        }\n    }\n    return new Double(min);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item);\n            if (value < result) \n            {\n                result = value;\n            }\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // delegate to the overloaded method\n    return findMinimumStackedRangeValue(dataset, 0.0);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    double result = Double.POSITIVE_INFINITY;\n    int columnCount = dataset.getColumnCount();\n    for (int item = 0; item < columnCount; item++) \n    {\n        double total = 0.0;\n        for (int i = 0; i < item; i++) \n        {\n            total += dataset.getValue(item, i);\n        }\n        double value = dataset.getValue(item, item);\n        if (value < 0.0) \n        {\n            total += value;\n        }\n        if (total < result) \n        {\n            result = total;\n        }\n    }\n    return new Double(result);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) \n    {\n        Comparable seriesKey = dataset.getRowKey(i);\n        int itemCount = dataset.getColumnCount();\n        for (int j = 0; j < itemCount; j++) \n        {\n            Comparable itemKey = dataset.getColumnKey(j);\n            Number value = dataset.getValue(seriesKey, itemKey);\n            if (value != null) \n            {\n                double v = value.doubleValue();\n                if (v < result) \n                {\n                    result = v;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range range = findStackedRangeBounds(dataset);\n    return range.getLowerBound();\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    double min = Double.POSITIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    int columnCount = dataset.getColumnCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        for (int c = 0; c < columnCount; c++) \n        {\n            Number value = dataset.getValue(r, c);\n            if (value != null) \n            {\n                double v = value.doubleValue();\n                if (v < min) \n                {\n                    min = v;\n                }\n            }\n        }\n    }\n    return new Double(min);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    double min = Double.MAX_VALUE;\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) {\n            double v = dataset.getValue(i, j).doubleValue();\n            total += v;\n            if (total < min) {\n                min = total;\n            }\n        }\n    }\n    return new Double(min);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // if the dataset is empty, return 0.0\n    if (DatasetUtilities.isEmptyOrNull(dataset)) {\n        return 0.0;\n    }\n\n    // find the minimum value in the dataset\n    double minimum = Double.POSITIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    int columnCount = dataset.getColumnCount();\n    for (int r = 0; r < rowCount; r++) {\n        for (int c = 0; c < columnCount; c++) {\n            double value = dataset.getValue(r, c).doubleValue();\n            if (value < minimum) {\n                minimum = value;\n            }\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = Double.POSITIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    int columnCount = dataset.getColumnCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        for (int c = 0; c < columnCount; c++) \n        {\n            Number value = dataset.getValue(r, c);\n            if (value != null) \n            {\n                double v = value.doubleValue();\n                if (v < result) \n                {\n                    result = v;\n                }\n            }\n        }\n    }\n    return new Double(result);\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"The Array must not be empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"The Array must not contain any null object\");\n    }\n    for (final Boolean bool : array) {\n        if (bool) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"The Array must not be empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"The array must not contain any nulls\");\n        }\n    }\n    return Arrays.stream(array).reduce(Boolean::logicalOr).get();\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"The Array must not be empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"The array must not contain any nulls\");\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    for (final Boolean bool : array) {\n        if (bool == null) {\n            throw new IllegalArgumentException(\"Array contains null\");\n        }\n    }\n    return Arrays.stream(array).reduce((a, b) -> a || b).orElse(false);\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty or null\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array cannot contain null\");\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty or null\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array cannot contain null\");\n    }\n    return Arrays.stream(array).reduce(Boolean::logicalOr).get();\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"Array cannot contain null\");\n        }\n    }\n    return Boolean.valueOf(Arrays.stream(array).anyMatch(Boolean::booleanValue));\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be null or empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"Array contains null value\");\n        }\n        if (b) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"The Array must not be empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"The array must not contain any nulls\");\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"The Array must not be empty\");\n    }\n    for (final Boolean b : array) {\n        if (b == null) {\n            throw new IllegalArgumentException(\"The array must not contain any nulls\");\n        }\n    }\n    for (final Boolean b : array) {\n        if (b) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0, 1);\n    }\n    final int strLen = str.length();\n    final StringBuilder sb = new StringBuilder(strLen / 5);\n    int start = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char c = str.charAt(i);\n        boolean isDelimiter = false;\n        for (int j = 0; j < delimLen; j++) {\n            if (c == delimiters[j]) {\n                isDelimiter = true;\n                break;\n            }\n        }\n        if (!isDelimiter && lastWasGap) {\n            sb.append(Character.toTitleCase(c));\n            lastWasGap = false;\n        } else if (isDelimiter) {\n            lastWasGap = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int[] delLen = new int[delimiters.length];\n    for (int i = 0; i < delimiters.length; i++) \n    {\n        delLen[i] = delimiters[i];\n    }\n    final StringBuilder[] buf = new StringBuilder[delimiters.length + 1];\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = new StringBuilder(strLen / 5); // Guess a bit bigger\n    }\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            if (!lastWasGap) \n            {\n                buf[buf.length - 1].append(ch);\n            }\n            lastWasGap = true;\n        } \n        else \n        {\n            for (int j = 0; j < buf.length - 1; j++) \n            {\n                if (ch == delimiters[j]) \n                {\n                    buf[j].append(ch);\n                }\n            }\n            lastWasGap = false;\n        }\n    }\n    // Convert all buffers to String\n    final StringBuilder result = new StringBuilder();\n    for (final StringBuilder builder : buf) \n    {\n        result.append(builder);\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    final int strLen = str.length();\n    final int delLen = delimiters.length;\n    if (delLen == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(strLen / 5);\n    char[] chs = new char[1];\n    int count = 0;\n    for (int i = 0; i < strLen; i++) {\n        chs[0] = str.charAt(i);\n        if (isDelimiter(chs[0], delimiters)) {\n            count++;\n        }\n        if (count == 0) {\n            sb.append(Character.toTitleCase(chs[0]));\n        } else if (count == 1) {\n            sb.append(Character.toLowerCase(chs[0]));\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = (delimiters == null ? -1 : delimiters.length);\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buffer[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    int len = delimiters.length;\n    if (len == 0) {\n        return str.substring(0, 1);\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final int delimLen = (delimiters == null ? -1 : delimiters.length);\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buffer[count++] = ch;\n            }\n\n            lastWasGap = false;\n        }\n    }\n\n    return new String(buffer, 0, count);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        Number value = data.getValue(row, column);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        total += data.getValue(row, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        total += data.getValue(row, column).doubleValue();\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column).doubleValue();\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // defer to the plot\n    return this.plot.translateScreenToJava2D(screenPoint);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Rectangle2D area = getScreenDataArea();\n    double x = screenPoint.getX();\n    double y = screenPoint.getY();\n    double xx = x - area.getX();\n    double yy = y - area.getY();\n    double scaleX = getScaleX();\n    double scaleY = getScaleY();\n    double xx2 = xx / scaleX;\n    double yy2 = yy / scaleY;\n    Point2D result = new Point2D.Double(xx2, yy2);\n    return result;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // get the chart's current width and height\n    int chartWidth = getWidth();\n    int chartHeight = getHeight();\n\n    // get the chart's current drawing area\n    Rectangle2D drawArea = getScreenDataArea();\n\n    // calculate the scale factors\n    double scaleX = chartWidth / drawArea.getWidth();\n    double scaleY = chartHeight / drawArea.getHeight();\n\n    // calculate the translation factors\n    double translateX = drawArea.getX();\n    double translateY = drawArea.getY();\n\n    // calculate the Java2D coordinates\n    double java2DX = (screenPoint.getX() - translateX) * scaleX;\n    double java2DY = (screenPoint.getY() - translateY) * scaleY;\n\n    // return the Java2D coordinates\n    return new Point2D.Double(java2DX, java2DY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Insets insets = getInsets();\n        Rectangle2D drawArea = getScreenDataArea();\n        double x = drawArea.getX();\n        double y = drawArea.getY();\n        double w = drawArea.getWidth();\n        double h = drawArea.getHeight();\n        double xx = screenPoint.getX() - x - insets.left;\n        double yy = screenPoint.getY() - y - insets.top;\n        double ww = w - insets.left - insets.right;\n        double hh = h - insets.top - insets.bottom;\n        double xx2 = xx / ww;\n        double yy2 = yy / hh;\n        double xxx = xx2 * this.chartBufferWidth;\n        double yyy = yy2 * this.chartBufferHeight;\n        return new Point2D.Double(xxx, yyy);\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // TODO: implement this method\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // defer to the plot...\n    return this.plot.translateScreenToJava2D(screenPoint);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Rectangle2D screenDataArea = getScreenDataArea();\n    double x = screenPoint.getX();\n    double y = screenPoint.getY();\n    double xx = screenDataArea.getX();\n    double yy = screenDataArea.getY();\n    double ww = screenDataArea.getWidth();\n    double hh = screenDataArea.getHeight();\n    double xxx = this.getX();\n    double yyy = this.getY();\n    double w = this.getWidth();\n    double h = this.getHeight();\n    double xScale = ww / w;\n    double yScale = hh / h;\n    double xx1 = (x - xx) * xScale;\n    double yy1 = (y - yy) * yScale;\n    return new Point2D.Double(xx1 + xxx, yy1 + yyy);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Rectangle2D dataArea = getScreenDataArea();\n        double x = dataArea.getX() + (screenPoint.getX() / this.scaleX);\n        double y = dataArea.getY() + (screenPoint.getY() / this.scaleY);\n        return new Point2D.Double(x, y);\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n        Insets insets = getInsets();\n        Rectangle2D dataArea = getScreenDataArea();\n        double x = (screenPoint.getX() - insets.left - dataArea.getX())\n                / dataArea.getWidth() * getWidth();\n        double y = (screenPoint.getY() - insets.top - dataArea.getY())\n                / dataArea.getHeight() * getHeight();\n        return new Point2D.Double(x, y);\n    }",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Rectangle2D dataArea = getScreenDataArea();\n    double x = dataArea.getX() + (screenPoint.getX() - dataArea.getX())\n        / getScaleX();\n    double y = dataArea.getY() + (screenPoint.getY() - dataArea.getY())\n        / getScaleY();\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        return parse(source, new ParsePosition(0));\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        return parse(source, new ParsePosition(0));\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        return parse(source, new ParsePosition(0));\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // Parse the fraction as a BigDecimal\n        BigDecimal decimal = new BigDecimal(source);\n\n        // Convert the BigDecimal to a BigFraction\n        return new BigFraction(decimal.unscaledValue(), decimal.scale());\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: implement this method\n        return null;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        return parse(source, new ParsePosition(0));\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    final Set<E> set = new HashSet<E>(list);\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot subplot = (CategoryPlot) iterator.next();\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null)  {\n            if (result == null)  {\n                result = subplotRange;\n            }\n            else  {\n                result = result.add(subplotRange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        return null;\n    }\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r != null) {\n            if (result == null) {\n                result = r;\n            }\n            else {\n                result = Range.combine(result, r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (this.subplots == null || this.subplots.size() == 0) {\n        return null;\n    }\n    Range range = null;\n    for (int i = 0; i < this.subplots.size(); i++) {\n        CategoryPlot subplot = (CategoryPlot) this.subplots.get(i);\n        if (subplot != null) {\n            Range subrange = subplot.getDataRange(axis);\n            if (subrange != null) {\n                if (range == null) {\n                    range = subrange;\n                }\n                else {\n                    range = range.combine(subrange);\n                }\n            }\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (range != null)  {\n            if (result == null)  {\n                result = range;\n            }\n            else  {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        if (plot.getRangeAxis() == axis)  {\n            Range r = plot.getDataRange(axis);\n            if (result == null)  {\n                result = r;\n            }\n            else  {\n                result = Range.combine(result, r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range r = plot.getDataRange(axis);\n        if (r == null)  {\n            continue;\n        }\n        if (result == null)  {\n            result = r;\n        }\n        else  {\n            result = result.add(r);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++)  {\n        CategoryPlot subplot = (CategoryPlot) this.subplots.get(i);\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null)  {\n            if (result == null)  {\n                result = subplotRange;\n            }\n            else  {\n                result = Range.combine(result, subplotRange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot subplot = (CategoryPlot) iterator.next();\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null)  {\n            if (result == null)  {\n                result = subplotRange;\n            }\n            else  {\n                result = Range.combine(result, subplotRange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++)  {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r != null)  {\n            if (result == null)  {\n                result = r;\n            }\n            else  {\n                result = result.combine(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < subplots.size(); i++)  {\n        CategoryPlot subplot = (CategoryPlot) subplots.get(i);\n        if (subplot.getRangeAxis() == axis)  {\n            Range subplotRange = subplot.getDataRange(axis);\n            if (subplotRange != null)  {\n                if (result == null)  {\n                    result = subplotRange;\n                }\n                else  {\n                    result = result.combine(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    double adjusted = val;\n    if (val < 0) {\n        adjusted = -val;\n    }\n    if (val < 10) {\n        adjusted = Math.log10(adjusted) + (10 - val);\n    }\n    else {\n        adjusted = Math.log10(adjusted);\n    }\n    if (val < 0) {\n        adjusted = -adjusted;\n    }\n    return adjusted;\n}",
      "public double adjustedLog10(double val)  {\n    double logVal = Math.log10(Math.abs(val));\n    if (val < 1) {\n        double scale = Math.abs(val - 1);\n        logVal -= scale;\n    }\n    if (val < 0) {\n        logVal = -logVal;\n    }\n    return logVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val <= 0.0)  {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (val < 1.0)  {\n        val = val / (1.0 - val);\n    }\n    if (val > 1.0)  {\n        val = Math.log10(val);\n    }\n    else  {\n        val = 0.0;\n    }\n    return val;\n}",
      "public double adjustedLog10(double val)  {\n    if (val <= 0.0) \n    {\n        return -1000.0;\n    }\n    else \n    {\n        double adjustedVal = val;\n        if (val < 1.0) \n        {\n            adjustedVal = 1.0 + Math.log(val) / Math.log(10.0);\n        }\n        else \n        {\n            adjustedVal = Math.log(val) / Math.log(10.0);\n        }\n        return adjustedVal;\n    }\n}",
      "public double adjustedLog10(double val)  {\n    double result = 0.0;\n    if (val < 0.0) {\n        result = -val;\n    }\n    else {\n        result = val;\n    }\n    if (result < 1.0) {\n        result = Math.log10(result) + Math.log10(SMALL_LOG_VALUE);\n    }\n    else {\n        result = Math.log10(result);\n    }\n    if (val < 0.0) {\n        result = -result;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double result = 0;\n    if (val < 0) {\n        result = -val;\n    }\n    else {\n        result = val;\n    }\n\n    if (result < 10) {\n        result = result + (10 - result);\n    }\n\n    if (val < 0) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 1) {\n        val = val / (1 - val);\n    }\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    double result = 0;\n    if (val < 0) {\n        result = -1 * Math.log10(-val);\n    }\n    else {\n        result = Math.log10(val);\n    }\n    if (result < 10) {\n        result += Math.log10(10);\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double log10Val = 0;\n    if (val > 0)\n    {\n        log10Val = Math.log10(val);\n    }\n    else if (val < 0)\n    {\n        log10Val = Math.log10(-val);\n        log10Val = -log10Val;\n    }\n    if (val < 1)\n    {\n        log10Val = log10Val + Math.log10(val);\n    }\n    return log10Val;\n}",
      "public double adjustedLog10(double val)  {\n    double result;\n    if (val < 0.0) {\n        result = -Math.log10(-val);\n    } else {\n        result = Math.log10(val);\n    }\n    if (result < SMALL_LOG_VALUE) {\n        result = Math.log10(val / SMALL_LOG_VALUE) + 1.0;\n    }\n    return result;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) {\n      if (node == cfg.getImplicitReturn()) {\n        continue;\n      }\n      if (!node.getAnnotation().isReturn()) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() != null) {\n    return true;\n  }\n\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> seen = new HashSet<>();\n  Queue<DiGraphNode<Node, ControlFlowGraph.Branch>> queue = new ArrayDeque<>();\n  queue.add(cfg.getEntry());\n\n  while (!queue.isEmpty()) {\n    DiGraphNode<Node, ControlFlowGraph.Branch> node = queue.poll();\n    if (seen.contains(node)) {\n      continue;\n    }\n    seen.add(node);\n\n    if (node.getValue() != null && NodeUtil.isReturnStatement(node.getValue())) {\n      return true;\n    }\n\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getOutEdges(node)) {\n      queue.add(edge.getDestination());\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getImplicitReturn() != null) {\n      return true;\n    }\n    // Find the entry and exit nodes\n    DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n    DiGraphNode<Node, ControlFlowGraph.Branch> exit = cfg.getImplicitReturn();\n    if (entry == null || exit == null) {\n      return false;\n    }\n    // Check that all paths from the entry node to the exit node go through\n    // the exit node.\n    Set<DiGraphNode<Node, ControlFlowGraph.Branch>> visited = new HashSet<>();\n    Deque<DiGraphNode<Node, ControlFlowGraph.Branch>> worklist = new ArrayDeque<>();\n    worklist.add(entry);\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, ControlFlowGraph.Branch> n = worklist.removeFirst();\n      if (n == exit) {\n        continue;\n      }\n      if (visited.contains(n)) {\n        continue;\n      }\n      visited.add(n);\n      for (DiGraphEdge<Node, ControlFlowGraph.Branch> e : cfg.getOutEdges(n)) {\n        worklist.add(e.getDestination());\n      }\n    }\n    return visited.contains(exit);\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> n : cfg.getDirectedGraphNodes()) {\n    if (cfg.getImplicitReturn().equals(n)) {\n      continue;\n    }\n    if (!cfg.isImplicitReturn(n)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the function is empty, it returns by default.\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // If the function has no returns, it doesn't return.\n  if (cfg.getImplicitReturn().getOutEdges().isEmpty()) {\n    return false;\n  }\n\n  // If the function has a single return, it returns.\n  if (cfg.getImplicitReturn().getOutEdges().size() == 1) {\n    return true;\n  }\n\n  // If the function has multiple returns, we need to check if all\n  // paths lead to a return.\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> visited = new HashSet<>();\n  Queue<DiGraphNode<Node, ControlFlowGraph.Branch>> queue = new ArrayDeque<>();\n  queue.add(cfg.getEntry());\n  while (!queue.isEmpty()) {\n    DiGraphNode<Node, ControlFlowGraph.Branch> node = queue.remove();\n    if (!visited.add(node)) {\n      continue;\n    }\n\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) {\n      if (edge.getValue() == ControlFlowGraph.Branch.ON_TRUE ||\n          edge.getValue() == ControlFlowGraph.Branch.ON_FALSE) {\n        queue.add(edge.getDestination());\n      }\n    }\n\n    if (node == cfg.getImplicitReturn()) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO(johnlenz): Consider caching the result of this computation.\n    // TODO(johnlenz): Consider computing this for all functions.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract and are not\n    //                 extern.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract and are not\n    //                 extern and are not implemented.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract and are not\n    //                 extern and are not implemented and are not\n    //                 declared in an extern block.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract and are not\n    //                 extern and are not implemented and are not\n    //                 declared in an extern block and are not\n    //                 declared in a typedef.\n    // TODO(johnlenz): Consider computing this for all functions in a\n    //                 compilation unit that have a return statement and\n    //                 are not native and are not abstract and are not\n    //                 extern and are not implemented and are not\n    //                 declared in an extern block and are not\n    //                 declared in a typedef and are not\n    //                 declared in a goog.scope.\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // We want to find a path from the entry node to the implicit return node.\n  // If we find one, then all paths return.  If we find no path, then not all\n  // paths return.  If we find a path that does not go through the implicit\n  // return node, then we conservatively assume that not all paths return.\n  //\n  // This algorithm is based on the idea of finding a path from the entry node\n  // to the implicit return node.  We do this by iteratively expanding the\n  // set of nodes that are reachable from the entry node.  We maintain a set\n  // of nodes that are currently reachable, and a set of nodes that are\n  // reachable but have not yet been visited.  We repeatedly take a node from\n  // the set of nodes that are currently reachable, and add it to the set of\n  // nodes that are reachable but have not yet been visited.  We then add all\n  // the successors of the node to the set of currently reachable nodes.\n  //\n  // We continue this process until the set of reachable nodes contains the\n  // implicit return node.  If at any point the set of nodes that are reachable\n  // but have not yet been visited is empty, then we know that there is no path\n  // to the implicit return node, and therefore not all paths return.\n  //\n  // The algorithm is O(n) in the number of nodes, where n is the number of\n  // nodes in the graph.\n\n  // The set of nodes that are currently reachable.\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> reachable = new HashSet<>();\n\n  // The set of nodes that are reachable but have not yet been visited.\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> unvisited = new HashSet<>();\n\n  // The set of nodes that are known to be in the entry block.\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> entryNodes = cfg.getEntry().getChildren();\n\n  // Add all the nodes in the entry block to the set of reachable nodes.\n  reachable.addAll(entryNodes);\n\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getImplicitReturn() != null) {\n      return true;\n    }\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) {\n      if (node.getValue() != null && !NodeUtil.isControlStructure(node.getValue())) {\n        continue;\n      }\n      if (node.getOutEdges().isEmpty()) {\n        return false;\n      }\n      boolean foundReturn = false;\n      for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) {\n        if (edge.getValue() == ControlFlowGraph.Branch.ON_TRUE) {\n          foundReturn = true;\n          break;\n        }\n      }\n      if (!foundReturn) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): Implement this method.\n  return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] result = new Dfp[a.length];\n    final Dfp[] one = new Dfp[a.length];\n    final Dfp[] two = new Dfp[a.length];\n    final Dfp[] three = new Dfp[a.length];\n    final Dfp[] five = new Dfp[a.length];\n    final Dfp[] seven = new Dfp[a.length];\n    final Dfp[] nine = new Dfp[a.length];\n    final Dfp[] eleven = new Dfp[a.length];\n    final Dfp[] thirteen = new Dfp[a.length];\n    final Dfp[] fifteen = new Dfp[a.length];\n    final Dfp[] seventeen = new Dfp[a.length];\n    final Dfp[] nineteen = new Dfp[a.length];\n    final Dfp[] twentyone = new Dfp[a.length];\n    final Dfp[] twentythree = new Dfp[a.length];\n    final Dfp[] twentynine = new Dfp[a.length];\n    final Dfp[] thirtyone = new Dfp[a.length];\n    final Dfp[] thirtythree = new Dfp[a.length];\n    final Dfp[] thirtyfive = new Dfp[a.length];\n    final Dfp[] thirtyseven = new Dfp[a.length];\n    final Dfp[] thirtynine = new Dfp[a.length];\n    final Dfp[] fortyone = new Dfp[a.length];\n    final Dfp[] fortythree = new Dfp[a.length];\n    final Dfp[] fortyfive = new Dfp[a.length];\n    final Dfp[] fortyseven = new Dfp[a.length];\n    final Dfp[] fortynine = new Dfp[a.length];\n    final Dfp[] fiftyone = new Dfp[a.length];\n    final Dfp[] fiftythree = new Dfp[a.length];\n    final Dfp[] fiftyfive = new Dfp[a.length];\n    final Dfp[] fiftysix = new Dfp[a.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = new Dfp(a[i].getField(), (a[i].getReal() - 1.0) / (a[i].getReal() + 1.0));\n    }\n    return splitPow(x, 2);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = new Dfp(a[i].getField(), a[i].getField().newInstance(a[i].getField().getRadixDigits()));\n        x[i].mant[0] = (a[i].mant[0] - 1) / (a[i].mant[0] + 1);\n        x[i].exp = 0;\n        x[i].nans = 0;\n    }\n    return DfpMath.splitMult(x, DfpMath.splitPow(x, 2));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] result = new Dfp[a.length];\n    final Dfp[] x = new Dfp[a.length];\n    final Dfp[] y = new Dfp[a.length];\n    final Dfp[] z = new Dfp[a.length];\n    final Dfp[] w = new Dfp[a.length];\n    final Dfp[] u = new Dfp[a.length];\n    final Dfp[] v = new Dfp[a.length];\n    final Dfp[] t = new Dfp[a.length];\n    final Dfp[] t2 = new Dfp[a.length];\n    final Dfp[] t3 = new Dfp[a.length];\n    final Dfp[] t4 = new Dfp[a.length];\n    final Dfp[] t5 = new Dfp[a.length];\n    final Dfp[] t6 = new Dfp[a.length];\n    final Dfp[] t7 = new Dfp[a.length];\n    final Dfp[] t8 = new Dfp[a.length];\n    final Dfp[] t9 = new Dfp[a.length];\n    final Dfp[] t10 = new Dfp[a.length];\n    final Dfp[] t11 = new Dfp[a.length];\n    final Dfp[] t12 = new Dfp[a.length];\n    final Dfp[] t13 = new Dfp[a.length];\n    final Dfp[] t14 = new Dfp[a.length];\n    final Dfp[] t15 = new Dfp[a.length];\n    final Dfp[] t16 = new Dfp[a.length];\n    final Dfp[] t17 = new Dfp[a.length];\n    final Dfp[] t18 = new Dfp[a.length];\n    final Dfp[] t19 = new Dfp[a.length];\n    final Dfp[] t20 = new Dfp[a.length];\n    final Dfp[] t21 = new Dfp[a.length];\n    final Dfp[] t22 = new Dfp[a.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].newInstance();\n    }\n    x[0].subtract(1.0);\n    x[0].divide(a[0]);\n    x[0].subtract(1.0);\n    x[0].divide(a[0]);\n    for (int i = 1; i < a.length; i++) {\n        x[i].subtract(1.0);\n        x[i].divide(a[i]);\n        x[i].subtract(1.0);\n        x[i].divide(a[i]);\n    }\n    Dfp[] result = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        result[i] = a[i].newInstance();\n    }\n    result[0].subtract(1.0);\n    result[0].divide(x[0]);\n    for (int i = 1; i < a.length; i++) {\n        result[i].subtract(1.0);\n        result[i].divide(x[i]);\n    }\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].newInstance((a[i].getReal() - 1) / (a[i].getReal() + 1));\n    }\n    Dfp[] x2 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x2[i] = x[i].newInstance(x[i].getReal() * x[i].getReal());\n    }\n    Dfp[] x3 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x3[i] = x[i].newInstance(x[i].getReal() * x2[i].getReal());\n    }\n    Dfp[] x5 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x5[i] = x[i].newInstance(x2[i].getReal() * x3[i].getReal());\n    }\n    Dfp[] x7 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x7[i] = x[i].newInstance(x3[i].getReal() * x4[i].getReal());\n    }\n    Dfp[] x9 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x9[i] = x[i].newInstance(x5[i].getReal() * x4[i].getReal());\n    }\n    Dfp[] x11 = new Dfp[x.length];\n    for (int i = 0; i < x.length; i++) {\n        x11[i] = x[i].newInstance(x7[i].getReal() * x4[i].getReal());\n    }\n    Dfp[] x13 = new Dfp[x.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] log = new Dfp[a.length];\n    final Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].reciprocal();\n    }\n    for (int i = 0; i < a.length; i++) {\n        log[i] = DfpMath.splitPow(x, 3);\n        log[i] = log[i].add(DfpMath.splitPow(x, 5));\n        log[i] = log[i].add(DfpMath.splitPow(x, 7));\n        log[i] = log[i].add(DfpMath.splitPow(x, 9));\n        log[i] = log[i].add(DfpMath.splitPow(x, 11));\n        log[i] = log[i].add(DfpMath.splitPow(x, 13));\n        log[i] = log[i].add(DfpMath.splitPow(x, 15));\n        log[i] = log[i].add(DfpMath.splitPow(x, 17));\n        log[i] = log[i].add(DfpMath.splitPow(x, 19));\n        log[i] = log[i].add(DfpMath.splitPow(x, 21));\n        log[i] = log[i].add(DfpMath.splitPow(x, 23));\n        log[i] = log[i].add(DfpMath.splitPow(x, 25));\n        log[i] = log[i].add(DfpMath.splitPow(x, 27));\n        log[i] = log[i].add(DfpMath.splitPow(x, 29));\n        log[i] = log[i].add(DfpMath.splitPow(x, 31));\n        log[i] = log[i].add(DfpMath.splitPow(x, 33));\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] log = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        log[i] = new Dfp(a[i].getField());\n    }\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = new Dfp(a[i].getField());\n    }\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].subtract(1).divide(a[i].add(1));\n    }\n    for (int i = 0; i < a.length; i++) {\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        result[i] = a[i].newInstance();\n    }\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] result = new Dfp[a.length];\n    final Dfp[] x = new Dfp[a.length];\n    final Dfp[] xp1 = new Dfp[a.length];\n    final Dfp[] xm1 = new Dfp[a.length];\n    final Dfp[] x2 = new Dfp[a.length];\n    final Dfp[] x3 = new Dfp[a.length];\n    final Dfp[] x4 = new Dfp[a.length];\n    final Dfp[] x5 = new Dfp[a.length];\n    final Dfp[] x6 = new Dfp[a.length];\n    final Dfp[] x7 = new Dfp[a.length];\n    final Dfp[] x8 = new Dfp[a.length];\n    final Dfp[] x9 = new Dfp[a.length];\n    final Dfp[] x10 = new Dfp[a.length];\n    final Dfp[] x11 = new Dfp[a.length];\n    final Dfp[] x12 = new Dfp[a.length];\n    final Dfp[] x13 = new Dfp[a.length];\n    final Dfp[] x14 = new Dfp[a.length];\n    final Dfp[] x15 = new Dfp[a.length];\n    final Dfp[] x16 = new Dfp[a.length];\n    final Dfp[] x17 = new Dfp[a.length];\n    final Dfp[] x18 = new Dfp[a.length];\n    final Dfp[] x19 = new Dfp[a.length];\n    final Dfp[] x20 = new Dfp[a.length];\n    final Dfp[] x21 = new Dfp[a.length];\n    final Dfp[] x22 = new Dfp[a.length];\n    final Dfp[] x23 = new Dfp[a.length];\n    final Dfp[] x24 = new Dfp[a.length];\n    final Dfp[] x25 = new Dfp[a.length];\n    final Dfp[] x26 = new Dfp[a.length];\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean removed = coll.remove(value);\n        if (coll.isEmpty()) {\n            map.remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            if (coll.remove(value)) {\n                if (coll.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            if (coll.remove(value)) {\n                if (coll.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            if (coll.remove(value)) {\n                if (coll.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node result = processGeneric(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = processGeneric(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = processGeneric(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = processGeneric(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = process(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = processGeneric(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = processGeneric(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = process(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = process(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = processGeneric(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.putBooleanProp(Node.QUOTED_PROP, true);\n    }\n    return result;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                total = total + v;\n            }\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                double p = v / total;\n                if (asPercentages) {\n                    p = p * 100.0;\n                }\n                result.add(new Double(base + p));\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // if the dataset is null, return an empty list\n    if (dataset == null) {\n        return new ArrayList();\n    }\n\n    // if the category is null, return an empty list\n    if (category == null) {\n        return new ArrayList();\n    }\n\n    // if the included rows are null, return an empty list\n    if (includedRows == null) {\n        return new ArrayList();\n    }\n\n    // create an empty list to store the stacked values\n    List result = new ArrayList();\n\n    // loop through the rows in the dataset\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n\n        // get the current row key\n        Comparable rowKey = dataset.getRowKey(r);\n\n        // check if the row is included in the list\n        if (Arrays.binarySearch(includedRows, r) >= 0) {\n\n            // get the value for the current row and column\n            Number value = dataset.getValue(r, category);\n\n            // check if the value is not null\n            if (value != null) {\n\n                // add the value to the list\n                result.add(value);\n            }\n        }\n    }\n\n    // return the list\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // TODO: implement this method\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    // create the list of values...\n    List result = new ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double value = dataset.getValue(row, category);\n        if (value >= 0.0) {\n            result.add(new Double(value + base));\n        }\n        else {\n            result.add(new Double(value));\n        }\n    }\n    // convert to percentages if required...\n    if (asPercentages) {\n        double total = 0.0;\n        for (int i = 0; i < result.size(); i++) {\n            Double d = (Double) result.get(i);\n            total += d.doubleValue();\n        }\n        for (int i = 0; i < result.size(); i++) {\n            Double d = (Double) result.get(i);\n            double percentage = d.doubleValue() / total;\n            result.set(i, new Double(percentage));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the value list...\n    List values = new ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        double v = dataset.getValue(category, includedRows[i]);\n        if (v >= 0.0) {\n            values.add(new Double(v));\n        }\n        else {\n            values.add(new Double(0.0));\n        }\n    }\n\n    // add the base value...\n    values.add(new Double(base));\n\n    // convert to percentages, if required...\n    if (asPercentages) {\n        double total = 0.0;\n        for (int i = 0; i < values.size(); i++) {\n            total = total + ((Double) values.get(i)).doubleValue();\n        }\n        for (int i = 0; i < values.size(); i++) {\n            double v = ((Double) values.get(i)).doubleValue();\n            values.set(i, new Double(v / total));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v >= 0.0) {\n            total += v;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v >= 0.0) {\n            double p = v / total;\n            if (asPercentages) {\n                p = p * 100.0;\n            }\n            result.add(new Double(base + p));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // this method is copied from StackedBarRenderer3D\n    // and modified to accept the includedRows parameter\n    // to support the \"ignore zero values\" feature\n    // (see bug report 1730137)\n    List result = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v > 0.0) {\n            total += v;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v > 0.0) {\n            double p = v / total;\n            if (asPercentages) {\n                p = p * 100.0;\n            }\n            result.add(new Double(base + p));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (this.renderAsPercentages) {\n                v = v / base * 100.0;\n            }\n            result.add(new Double(v));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            double v = value.doubleValue();\n            result.add(new Double(v));\n            total += v;\n        }\n        else {\n            result.add(null);\n        }\n    }\n    if (asPercentages) {\n        for (int i = 0; i < result.size(); i++) {\n            Double d = (Double) result.get(i);\n            if (d != null) {\n                double v = d.doubleValue();\n                result.set(i, new Double(v / total));\n            }\n        }\n    }\n    result.add(new Double(base));\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null) {\n        // shadow list is empty, or was invalidated\n        shadowChildren = new ArrayList<>(childNodes.size());\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                shadowChildren.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> children = ensureChildNodes();\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        List<Element> shadowChildren = shadowChildrenRef.get();\n        if (shadowChildren == null) {\n            shadowChildren = new ArrayList<>();\n            for (Node child: ensureChildNodes()) {\n                if (child instanceof Element)\n                    shadowChildren.add((Element) child);\n            }\n            shadowChildrenRef = new WeakReference<>(shadowChildren);\n        }\n        return shadowChildren;\n    }",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = shadowChildrenRef.get();\n    if (childElements == null) {\n        synchronized (this) {\n            childElements = shadowChildrenRef.get();\n            if (childElements == null) {\n                childElements = new ArrayList<>(childNodes.size());\n                for (Node childNode : childNodes) {\n                    if (childNode instanceof Element)\n                        childElements.add((Element) childNode);\n                }\n                shadowChildrenRef = new WeakReference<>(childElements);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null) \n    {\n        shadowChildren = new ArrayList<>(childNodes.size());\n        for (Node child: childNodes) \n        {\n            if (child instanceof Element) \n            {\n                shadowChildren.add((Element) child);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new WeakReference<>(ensureChildNodes());\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                elements.add((Element) child);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        List<Element> shadowChildren = shadowChildrenRef.get();\n        if (shadowChildren == null) {\n            shadowChildren = new ArrayList<>();\n            for (int i = 0; i < childNodes.size(); i++) {\n                Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    shadowChildren.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(shadowChildren);\n        }\n        return shadowChildren;\n    }",
      "private List<Element> childElementsList()  {\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null) \n    {\n        shadowChildren = new ArrayList<Element>();\n        for (Node child : ensureChildNodes()) \n        {\n            if (child instanceof Element) \n            {\n                shadowChildren.add((Element) child);\n            }\n        }\n        shadowChildrenRef = new WeakReference<List<Element>>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = shadowChildrenRef.get();\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return Math.abs(hash);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    //-----------------------------------------------------------------------\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    // This is the hashCode of the key.\n    int h = key.hashCode();\n    // This is the number of buckets.\n    int n = buckets.length;\n    // This is the exact hash entry.\n    return Math.abs(h % n);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int n = m.getRowDimension();\n    int m_k = m.getColumnDimension();\n    if (k < 0) {\n        k = 0;\n    }\n    if (k > m_k) {\n        k = m_k;\n    }\n    RealMatrix out = m.getSubMatrix(0, n - 1, 0, k - 1);\n    for (int i = 0; i < n; i++) {\n        for (int j = k; j < m_k; j++) {\n            out.setEntry(i, j, 0);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix out = m.getSubMatrix(0, rows - 1, 0, cols - 1);\n    for (int i = 0; i < rows; i++) \n    {\n        for (int j = i + k; j < cols; j++) \n        {\n            out.setEntry(i, j, 0);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix res = m.getSubMatrix(0, rows - 1, 0, cols - 1);\n    for (int i = 0; i < rows; i++) {\n        for (int j = i + k + 1; j < cols; j++) {\n            res.setEntry(i, j, 0);\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    return m.getSubMatrix(k, m.getRowDimension() - 1, k, m.getColumnDimension() - 1);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix result = m.getSubMatrix(0, rows - 1, 0, cols - 1);\n    for (int i = 0; i < rows; i++) \n    {\n        for (int j = i + 1; j < cols; j++) \n        {\n            result.setEntry(i, j, 0);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int n = m.getRowDimension();\n    final int[] rows = new int[n];\n    final int[] cols = new int[n];\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i < j + k) {\n                rows[count] = i;\n                cols[count] = j;\n                count++;\n            }\n        }\n    }\n    return m.getSubMatrix(rows, cols);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int n = m.getRowDimension();\n    final int p = m.getColumnDimension();\n    final RealMatrix result = m.getSubMatrix(0, n - 1, 0, p - 1);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < p; j++) {\n            if (i + k < j) {\n                result.setEntry(i, j, 0);\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    // TODO: Implement\n    return null;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix result = m.getSubMatrix(0, rows - 1, 0, cols - 1);\n    for (int i = 0; i < rows; i++) {\n        for (int j = i + k; j < cols; j++) {\n            result.setEntry(i, j, 0);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix res = m.getSubMatrix(0, rows - 1, 0, cols - 1);\n    for (int i = 0; i < rows; i++) {\n        for (int j = i + k; j < cols; j++) {\n            res.setEntry(i, j, 0);\n        }\n    }\n    return res;\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    if (this.skew == Skew.RIGHT_HEAVY) {\n        this.skew = Skew.BALANCED;\n        return false;\n    }\n    if (this.skew == Skew.BALANCED) {\n        this.skew = Skew.LEFT_HEAVY;\n        return true;\n    }\n    if (this.skew == Skew.LEFT_HEAVY) {\n        this.skew = Skew.BALANCED;\n        return false;\n    }\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (this.skew == Skew.RIGHT_HEAVY) \n    {\n        if (this.right.skew == Skew.RIGHT_HEAVY) \n        {\n            this.rotateCW();\n            return false;\n        } \n        else \n        {\n            this.skew = Skew.BALANCED;\n            return true;\n        }\n    } \n    else \n    {\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    Node parent = this.parent;\n    if (parent == null) {\n        return false;\n    }\n    if (parent.skew == Skew.LEFT_HEAVY) {\n        parent.skew = Skew.BALANCED;\n        return true;\n    }\n    if (parent.skew == Skew.BALANCED) {\n        parent.skew = Skew.RIGHT_HEAVY;\n        return false;\n    }\n    if (parent.skew == Skew.RIGHT_HEAVY) {\n        parent.skew = Skew.BALANCED;\n        return parent.rebalanceRightShrunk();\n    }\n    throw new IllegalStateException();\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (skew == Skew.BALANCED) {\n        skew = Skew.RIGHT_SKEW;\n        return false;\n    } else if (skew == Skew.LEFT_SKEW) {\n        skew = Skew.BALANCED;\n        return true;\n    } else {\n        skew = Skew.RIGHT_SKEW;\n        return rebalanceRightShrunk();\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n        if (skew == Skew.RIGHT_HEAVY) {\n                skew = Skew.BALANCED;\n                return false;\n        } else if (skew == Skew.RIGHT_HEAVY_RIGHT_HEAVY) {\n                skew = Skew.LEFT_HEAVY;\n                return true;\n        } else {\n                throw new IllegalStateException(\"skew=\" + skew);\n        }\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (skew == Skew.RIGHT_HEAVY) \n    {\n        skew = Skew.BALANCED;\n        return false;\n    }\n    else if (skew == Skew.LEFT_HEAVY) \n    {\n        skew = Skew.BALANCED;\n        return true;\n    }\n    else \n    {\n        throw new RuntimeException(\"skew should be RIGHT_HEAVY or LEFT_HEAVY\");\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    // If the left sub-tree is Skew.UNBALANCED, we need to rotate the right sub-tree\n    // to the left, and then rotate the whole tree to the right.\n    if (left.skew == Skew.UNBALANCED) {\n        left.rotateCCW();\n        rotateCW();\n    }\n    // If the left sub-tree is Skew.BALANCED, we need to rotate the whole tree to the right.\n    else {\n        rotateCW();\n    }\n    return true;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (skew == Skew.BALANCED) {\n        skew = Skew.RIGHT_SKEW;\n        return true;\n    }\n    if (skew == Skew.LEFT_SKEW) {\n        skew = Skew.BALANCED;\n        return false;\n    }\n    // skew == RIGHT_SKEW\n    Node left = getLeft();\n    if (left.skew == Skew.BALANCED) {\n        rotateCW();\n        skew = Skew.BALANCED;\n        return false;\n    }\n    // left.skew == RIGHT_SKEW\n    left.rotateCCW();\n    rotateCW();\n    skew = Skew.BALANCED;\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (skew == Skew.BALANCED) {\n        skew = Skew.RIGHT_SKEW;\n        return false;\n    }\n    else if (skew == Skew.LEFT_SKEW) {\n        skew = Skew.BALANCED;\n        return true;\n    }\n    else {\n        skew = Skew.RIGHT_SKEW;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    // 1. Get the right sub-tree\n    Node right = this.right;\n\n    // 2. Check if the right sub-tree is skewed\n    if (right.skew == Skew.BALANCED) {\n        // 3. The right sub-tree is skewed, so rotate to the left\n        this.rotateCCW();\n        return true;\n    }\n    else {\n        // 4. The right sub-tree is not skewed, so rotate to the left\n        this.rotateCW();\n        return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.getRowDimension() - 1) \n    {\n        if (Math.abs(matrixT.getEntry(idx + 1, idx)) <= epsilon * norm) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.getRowDimension(); i++) {\n        if (Math.abs(matrixT.getEntry(i, i - 1)) < epsilon * norm) {\n            return i;\n        }\n    }\n    return matrixT.getRowDimension() - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // TODO: Implement this method\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.getColumnDimension() - 1; i++) {\n        final double value = Math.abs(matrixT.getEntry(i, i + 1));\n        if (value <= epsilon * norm) {\n            return i;\n        }\n    }\n    return matrixT.getColumnDimension() - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.getRowDimension(); i++) {\n        if (Math.abs(matrixT.getEntry(i, i)) < epsilon * norm) {\n            return i;\n        }\n    }\n    return matrixT.getRowDimension();\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // TODO: implement this method\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.getColumnDimension() - 1 &&\n            Math.abs(matrixT.getEntry(idx, idx + 1)) < epsilon * norm) {\n        ++idx;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.getRowDimension() - 1 && Math.abs(matrixT.getEntry(idx, idx + 1)) < epsilon * norm) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.getColumnDimension(); i++) {\n        if (Math.abs(matrixT.getEntry(i, i - 1)) < epsilon * norm) {\n            return i;\n        }\n    }\n    return matrixT.getColumnDimension() - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.getColumnDimension() - 1; i++) {\n        if (Math.abs(matrixT.getEntry(i, i + 1)) <= epsilon * norm) {\n            return i;\n        }\n    }\n    return matrixT.getColumnDimension() - 1;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    if (node == null) {\n        return null;\n    }\n    while (node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n        if (node == null) {\n            return null;\n        }\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    while (current != null) {\n        int cmp = current.getElement().compareTo(reference);\n        if (cmp >= 0) {\n            return current;\n        }\n        current = current.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty())\n        return null;\n    Node current = top;\n    while (current != null)\n    {\n        int comparison = current.getElement().compareTo(reference);\n        if (comparison == 0)\n            return current;\n        if (comparison > 0)\n            current = current.getPrevious();\n        else\n            current = current.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    while (current != null && current.element.compareTo(reference) < 0) {\n        current = current.right;\n    }\n    return current;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty()) return null;\n    Node node = getSmallest();\n    while (node != null && node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty()) return null;\n    Node node = top;\n    while (node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n        if (node == null) return null;\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty()) return null;\n    Node node = top;\n    while (node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n        if (node == null) return null;\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    if (node == null)\n        return null;\n    while (node.getElement().compareTo(reference) < 0)\n        node = node.getNext();\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    if (current == null) return null;\n    while (current.getElement().compareTo(reference) < 0) {\n        current = current.getNext();\n        if (current == null) return null;\n    }\n    return current;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty()) {\n        return null;\n    }\n    Node node = getSmallest();\n    while (node != null && node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || isEmpty() || str.isEmpty()) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos < 0) {\n        return this;\n    }\n    int deleteLen = str.length();\n    int start = pos;\n    while (pos >= 0) {\n        deleteImpl(start, start + deleteLen, deleteLen);\n        pos = indexOf(str, start);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || isEmpty()) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos < 0) {\n        return this;\n    }\n    int deleteLen = str.length();\n    int endIndex = pos + deleteLen;\n    int startIndex = pos;\n    while (true) {\n        replaceImpl(startIndex, endIndex, deleteLen, null, 0);\n        pos = indexOf(str, startIndex);\n        if (pos < 0) {\n            break;\n        }\n        endIndex = pos + deleteLen;\n        startIndex = pos;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || isEmpty()) {\n        return this;\n    }\n    int sz = str.length();\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + sz);\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos < 0) {\n        return this;\n    }\n    int deleteLen = str.length();\n    int sz = size();\n    while (pos >= 0) {\n        deleteImpl(pos, pos + deleteLen, deleteLen);\n        sz = sz - deleteLen;\n        pos = indexOf(str, pos);\n    }\n    size(sz);\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || isEmpty()) {\n        return this;\n    }\n    int pos = indexOf(str);\n    if (pos >= 0) {\n        delete(pos, pos + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int pos = indexOf(str, 0);\n    if (pos < 0) {\n        return this;\n    }\n    int deleteLen = str.length();\n    int start = pos;\n    while (pos >= 0) {\n        deleteImpl(start, pos + deleteLen, deleteLen);\n        start = start + deleteLen;\n        pos = indexOf(str, start);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || isEmpty()) {\n        return this;\n    }\n    int sz = str.length();\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + sz);\n        index = indexOf(str, index);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node instanceof Name) {\n    // TODO(johnlenz): handle the case where the NAME is not a child of a\n    // VAR or PARAM_LIST node.\n    Node parent = irNode.getParent();\n    if (parent.isVar() || parent.isParamList()) {\n      JSDocInfo info = parseInlineTypeDoc(node, irNode);\n      if (info != null) {\n        irNode.setJSDocInfo(info);\n      }\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = handleJsDoc(node, null);\n  if (info != null) {\n    if (info.isExternsFunction()) {\n      errorReporter.error(\n          \"externs function definitions should not have inline JSDoc\",\n          node.getSourcePosition());\n    }\n    Node irNode = transform(node);\n    if (irNode != null) {\n      irNode.setJSDocInfo(info);\n    }\n    return irNode;\n  } else {\n    return transform(node);\n  }\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo info = handleJsDoc(node, irNode);\n  if (info != null) {\n    irNode.setJSDocInfo(info);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node instanceof Name) {\n    Node irNode = transform(node);\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n    return irNode;\n  } else {\n    return transform(node);\n  }\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = handleJsDoc(node, null);\n  if (info != null) {\n    Node irNode = transform(node);\n    irNode.setJSDocInfo(info);\n    return irNode;\n  } else {\n    return transform(node);\n  }\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = handleJsDoc(node, null);\n  if (info != null) {\n    Node irNode = transform(node);\n    irNode.setJSDocInfo(info);\n    return irNode;\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.isName()) {\n    JSDocInfo info = getJsDocInfo(node);\n    if (info != null) {\n      validateTypeAnnotations(info, node);\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.isName()) {\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = handleJsDoc(node, null);\n  Node irNode = transform(node);\n  if (info != null) {\n    irNode.setJSDocInfo(info);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.isName()) {\n    JSDocInfo info = parseInlineTypeDoc(node, irNode);\n    if (info != null) {\n      validateTypeAnnotations(info, node);\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null.\");\n    }\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    // Check if the array type is a single-element array type.\n    if (match(JsDocToken.ELLIPSIS)) {\n        // Parse the type expression.\n        Node typeAst = parseTypeExpression(next());\n        // Create the array type node.\n        return newNode(Token.ARRAYLIT, typeAst);\n    }\n\n    // Parse the element type list.\n    Node typeAst = parseTypeExpressionList(token);\n\n    // Check if the array type is a multi-element array type.\n    if (match(JsDocToken.ELLIPSIS)) {\n        // Parse the type expression.\n        Node typeAst2 = parseTypeExpression(next());\n        // Create the array type node.\n        return newNode(Token.ARRAYLIT, typeAst, typeAst2);\n    }\n\n    // Create the array type node.\n    return newNode(Token.ARRAYLIT, typeAst);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    // Consume '['\n    token = next();\n    Preconditions.checkState(token.type == JsDocToken.BEGIN_ARRAY);\n\n    // Parse ElementTypeList\n    Node elementTypeList = parseElementTypeList(token);\n\n    // Consume ']'\n    token = next();\n    Preconditions.checkState(token.type == JsDocToken.END_ARRAY);\n\n    return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    int lineno = token.lineno;\n    int startCharno = token.charno;\n    Node node = parseAndRecordTypeNode(next(), lineno, startCharno, false, false);\n    if (match(JsDocToken.ELLIPSIS)) {\n        node = newNode(Token.ELLIPSIS, node);\n        node.setSourceEncodedPositionForTree(mergeLineCharNo(lineno, startCharno));\n        node = parseAndRecordTypeNode(next(), lineno, startCharno, false, false);\n    }\n    return newNode(Token.ARRAYLIT, node);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY_TYPE);\n    arrayType.addChildToBack(parseTypeExpression(next()));\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayTypeNode = newNode(Token.ARRAY_TYPE);\n    Node elementTypeListNode = newNode(Token.ELEMENT_TYPE_LIST);\n    arrayTypeNode.addChildToBack(elementTypeListNode);\n\n    // Parse '['\n    token = next();\n    if (!match(JsDocToken.LBRACKET)) {\n        throw new JsDocParseException(\"Expected '['\");\n    }\n\n    // Parse ElementTypeList\n    token = parseElementTypeList(token, elementTypeListNode);\n\n    // Parse ']'\n    token = next();\n    if (!match(JsDocToken.RBRACKET)) {\n        throw new JsDocParseException(\"Expected ']'\");\n    }\n\n    return arrayTypeNode;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAY_TYPE);\n    arrayType.addChildToBack(parseTypeExpression(next()));\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    int lineno = token.lineno;\n    int startCharno = token.charno;\n    token = next();\n    if (token.type != JsDocToken.TYPE_ELLIPSIS) {\n        Node elementType = parseTypeExpression(token);\n        token = next();\n        if (token.type == JsDocToken.TYPE_COMMA) {\n            // TODO: support multiple element types\n            errorReporter.report(token.lineno, token.charno,\n                    \"Multiple element types not supported\");\n        }\n        return newNode(Node.ARRAY_TYPE, elementType);\n    }\n    token = next();\n    Node elementType = parseTypeExpression(token);\n    return newNode(Node.ARRAY_TYPE, elementType);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    int lineno = token.lineno;\n    int startCharno = token.charno;\n    Node typeAst = null;\n    boolean matchingLC = false;\n    if (match(JsDocToken.LBRACKET)) {\n        typeAst = parseTypeExpression(next());\n        if (match(JsDocToken.ELLIPSIS)) {\n            typeAst = newNode(Node.ELLIPSIS, typeAst);\n            typeAst.setLineno(lineno);\n            typeAst.setCharno(startCharno);\n            typeAst.setSourceEncodedPositionForTree(token.sourcePosition);\n            typeAst = parseAndRecordTypeNode(next(), lineno, startCharno, matchingLC, true);\n        }\n        if (!match(JsDocToken.RBRACKET)) {\n            reportTypeSyntaxWarning(\"missing-rbracket-in-array-type\");\n        }\n    }\n    return typeAst;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    // [\n    if (!match(JsDocToken.LBRACKET)) \n    {\n        return null;\n    }\n    // TypeExpression\n    Node elementType = parseTypeExpression(next());\n    // ',' ElementTypeList\n    if (match(JsDocToken.COMMA)) \n    {\n        // TODO: support multiple element types\n        errorReporter.reportError(sourceFile, getLineno(), getCharno(),\n            \"Arrays with multiple element types are not supported\");\n        return null;\n    }\n    // '...' TypeExpression\n    if (match(JsDocToken.ELLIPSIS)) \n    {\n        // TODO: support array of unknown size\n        errorReporter.reportError(sourceFile, getLineno(), getCharno(),\n            \"Arrays of unknown size are not supported\");\n        return null;\n    }\n    // ]\n    if (!match(JsDocToken.RBRACKET)) \n    {\n        return null;\n    }\n    return elementType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node node = newNode(Token.ARRAYLIT);\n    int lineno = token.lineno;\n    int charno = token.charno;\n    token = next();\n    if (token.type == Token.ELLIPSIS) {\n        node.addChildToBack(parseTypeExpression(token));\n        token = next();\n    } else {\n        while (token.type != Token.RBRACKET) {\n            if (token.type == Token.ELLIPSIS) {\n                token = next();\n                node.addChildToBack(parseTypeExpression(token));\n                break;\n            }\n            node.addChildToBack(parseTypeExpression(token));\n            token = next();\n            if (token.type == Token.COMMA) {\n                token = next();\n            }\n        }\n    }\n    return node;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double[][] m = getMatrix();\n    return new Vector3D(m[0][0], m[1][0], m[2][0]);\n}",
      "public Vector3D getAxis()  {\n    // Get the axis of the rotation\n    Vector3D axis = new Vector3D(q0, q1, q2);\n\n    // Normalize the axis\n    axis = axis.normalize();\n\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    // get the axis of the rotation\n    double[][] m = getMatrix();\n    Vector3D axis = new Vector3D(m[0][0], m[1][0], m[2][0]);\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    double n = Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q0 / n, q1 / n, q2 / n);\n}",
      "public Vector3D getAxis()  {\n  // Return the normalized axis of the rotation\n  return new Vector3D(q0, q1, q2);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q0 / norm, q1 / norm, q2 / norm);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q0, q1, q2);\n}",
      "public Vector3D getAxis()  {\n    double n = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (n == 0) {\n        return new Vector3D(q0, q1, q2, q3);\n    } else {\n        return new Vector3D(q0 / n, q1 / n, q2 / n, q3 / n);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q0 / norm, q1 / norm, q2 / norm);\n}",
      "public Vector3D getAxis()  {\n  return new Vector3D(q0, q1, q2);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        throw new IllegalArgumentException(\"bytes cannot be null\");\n    }\n    return decodeUrl(bytes, 0, bytes.length);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte[] decodedBytes = decodeHex(bytes, i + 1, 2);\n                buffer.write(decodedBytes[0]);\n                i += 2;\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final BitSet safechars = WWW_FORM_URL_SAFE;\n    final BitSet safechars2 = WWW_FORM_URL;\n    final byte[] buffer = new byte[bytes.length];\n    int pos = 0;\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b2 = bytes[++i];\n                final byte b3 = bytes[++i];\n                buffer[pos++] = (byte) (((b2 - 48) * 10) + (b3 - 48));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (safechars.get(b) || safechars2.get(b)) {\n            buffer[pos++] = b;\n        } else {\n            throw new DecoderException(\"Invalid URL character: \" + b);\n        }\n    }\n    final byte[] out = new byte[pos];\n    System.arraycopy(buffer, 0, out, 0, pos);\n    return out;\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final BitSet urlsafe = WWW_FORM_URL_SAFE;\n    final byte[] buffer = new byte[bytes.length];\n    int pos = 0;\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Incomplete trailing escape (%) pattern\");\n            }\n            final byte b1 = bytes[++i];\n            final byte b2 = bytes[++i];\n            if (!urlsafe.get(b1) || !urlsafe.get(b2)) {\n                throw new DecoderException(\"Invalid URL escape '%\" + b1 + b2 + \"'\");\n            }\n            buffer[pos++] = (byte) ((b1 - '0') * 10 + (b2 - '0'));\n        } else {\n            buffer[pos++] = b;\n        }\n    }\n    return Arrays.copyOf(buffer, pos);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte[] decodedBytes = decodeHex(bytes, i + 1, 2);\n                buffer.write(decodedBytes[0]);\n                i += 2;\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final BitSet safechars = WWW_FORM_URL_SAFE;\n    final byte[] buffer = new byte[bytes.length];\n    int pos = 0;\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Incomplete trailing escape (%) pattern\");\n            }\n            final byte b1 = bytes[++i];\n            final byte b2 = bytes[++i];\n            final byte b3 = (byte) ((b1 - 48) * 10 + (b2 - 48));\n            if (b3 < 0 || b3 >= 128 || !safechars.get(b3)) {\n                throw new DecoderException(\"Invalid URL escape '%\" + String.valueOf((char) b1) + String.valueOf((char) b2) + \"'\");\n            }\n            buffer[pos++] = b3;\n        } else if (safechars.get(b)) {\n            buffer[pos++] = b;\n        } else {\n            throw new DecoderException(\"Invalid URL character 0x\" + Integer.toHexString(b & 0xff));\n        }\n    }\n    final byte[] out = new byte[pos];\n    System.arraycopy(buffer, 0, out, 0, pos);\n    return out;\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Utils.digit16(bytes[++i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    int length = bytes.length;\n    if (length == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream(length);\n    for (int i = 0; i < length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                int u = Utils.digit16(bytes[++i]);\n                int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null || bytes.length == 0) {\n        return null;\n    }\n    final BitSet safechars = WWW_FORM_URL_SAFE;\n    final BitSet safechars_ext = WWW_FORM_URL;\n    final byte[] buffer = new byte[bytes.length];\n    int pos = 0;\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Integer.parseInt(String.valueOf((char) bytes[i + 1]) + String.valueOf((char) bytes[i + 2]), RADIX);\n                buffer[pos++] = (byte) u;\n                i += 2;\n            } catch (final NumberFormatException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else if (safechars.get(b) || safechars_ext.get(b)) {\n            buffer[pos++] = b;\n        } else {\n            throw new DecoderException(\"Invalid URL encoding: \" + String.valueOf((char) b));\n        }\n    }\n    final byte[] out = new byte[pos];\n    System.arraycopy(buffer, 0, out, 0, pos);\n    return out;\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPeriodConverters;\n    if (set == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    set = set.remove(converter, removed);\n    if (set == null) {\n        return null;\n    }\n    iPeriodConverters = set;\n    return (PeriodConverter) removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        PeriodConverter[] converters = iPeriodConverters.getConverters();\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                PeriodConverter[] newConverters = new PeriodConverter[converters.length - 1];\n                System.arraycopy(converters, 0, newConverters, 0, i);\n                System.arraycopy(converters, i + 1, newConverters, i,\n                        converters.length - i - 1);\n                iPeriodConverters = new ConverterSet(newConverters);\n                return converter;\n            }\n        }\n        return null;\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        Converter[] removed = new Converter[1];\n        ConverterSet set = iPeriodConverters;\n        set = set.remove(converter, removed);\n        if (set == iPeriodConverters) {\n            return null;\n        }\n        iPeriodConverters = set;\n        return (PeriodConverter) removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        PeriodConverter removed = null;\n        if (iPeriodConverters != null) {\n            removed = iPeriodConverters.remove(converter, null);\n            if (iPeriodConverters.size() == 0) {\n                iPeriodConverters = null;\n            }\n        }\n        return removed;\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPeriodConverters;\n    if (set != null) {\n        Converter[] removed = new Converter[1];\n        set = set.remove(converter, removed);\n        if (set != iPeriodConverters) {\n            iPeriodConverters = set;\n            return (PeriodConverter) removed[0];\n        }\n    }\n    return null;\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.remove(converter, null);\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.remove(converter, null);\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    return iPeriodConverters.remove(converter, null);\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.remove(converter, new Converter[0]);\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.remove(converter, new PeriodConverter[0]);\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    int size = types.length;\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = types[size - 1];\n    DateTimeField lastField = partial.getField(size - 1);\n    for (int i = size - 2; i >= 0; i--) {\n        DateTimeFieldType type = types[i];\n        DateTimeField field = partial.getField(i);\n        if (field.getRangeDurationField().getType() != lastType) {\n            return false;\n        }\n        lastType = type;\n        lastField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType type = partial.getFieldType(0);\n    DateTimeFieldType nextType = partial.getFieldType(1);\n    if (type.getRangeDurationField().equals(nextType.getDurationField()) == false) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        type = nextType;\n        nextType = partial.getFieldType(i + 1);\n        if (type.getRangeDurationField().equals(nextType.getDurationField()) == false) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(0);\n    DateTimeFieldType thisType = partial.getFieldType(1);\n    if (lastType.getRangeDurationField() != null &&\n            lastType.getRangeDurationField().equals(thisType)) {\n        return isContiguous(partial.subtract(1));\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType type = partial.getFieldType(0);\n    DateTimeField field = partial.getField(0);\n    int value = partial.getValue(0);\n    for (int i = 1; i < size; i++) {\n        DateTimeFieldType nextType = partial.getFieldType(i);\n        DateTimeField nextField = partial.getField(i);\n        int nextValue = partial.getValue(i);\n        if (nextField.getRangeDurationField().getUnitMillis() != field.getRangeDurationField().getUnitMillis()) {\n            return false;\n        }\n        field = nextField;\n        type = nextType;\n        value = nextValue;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType lastFieldType = partial.getFieldType(size - 1);\n    DateTimeFieldType thisFieldType = partial.getFieldType(size - 2);\n    if (lastFieldType.getRangeDurationField().equals(thisFieldType.getDurationField()) == false) {\n        return false;\n    }\n    return isContiguous(partial.subtract(1));\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    if (types.length < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = types[0];\n    DateTimeField lastField = partial.getField(0);\n    for (int i = 1; i < types.length; i++) {\n        DateTimeFieldType type = types[i];\n        DateTimeField field = partial.getField(i);\n        if (field.getRangeDurationField() != lastField.getDurationField()) {\n            return false;\n        }\n        lastType = type;\n        lastField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType lastType = null;\n    for (int i = 0; i < partial.size(); i++) {\n        DateTimeFieldType type = partial.getFieldType(i);\n        if (lastType != null) {\n            if (type.getRangeDurationField() != lastType) {\n                return false;\n            }\n        }\n        lastType = type;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType type = partial.getFieldType(0);\n    DateTimeFieldType nextType = partial.getFieldType(1);\n    if (type.getRangeDurationField() != nextType.getDurationField()) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        type = nextType;\n        nextType = partial.getFieldType(i + 1);\n        if (type.getRangeDurationField() != nextType.getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    DateTimeField lastField = partial.getField(size - 1);\n    DateTimeFieldType nextType = null;\n    DateTimeField nextField = null;\n    for (int i = size - 2; i >= 0; i--) {\n        nextType = partial.getFieldType(i);\n        nextField = partial.getField(i);\n        if (nextField.getRangeDurationField() != lastField.getDurationField()) {\n            return false;\n        }\n        if (nextType.getRangeDurationField() != lastType.getRangeDurationField()) {\n            return false;\n        }\n        lastType = nextType;\n        lastField = nextField;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType type = partial.getFieldType(0);\n    DateTimeFieldType nextType = partial.getFieldType(1);\n    if (type.getRangeDurationField().equals(nextType.getDurationField()) == false) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        nextType = partial.getFieldType(i);\n        if (type.getRangeDurationField().equals(nextType.getDurationField()) == false) {\n            return false;\n        }\n        type = nextType;\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    //TODO: Implement this method\n    return null;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return new SetOperationCardinalityHelper<O>(a, b).list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<>();\n    set.addAll(a);\n    set.addAll(b);\n    return set;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n    final Set<O> set = new HashSet<>(helper.list());\n    for (final O obj : helper.elements) {\n        set.add(obj);\n    }\n    return set;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b, false);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    // TODO: Implement this method\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    //TODO: implement this method\n    return null;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return new SetOperationCardinalityHelper<O>(a, b) \n    {\n}\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n        strings.add(new StringNode(Node.STRING, param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n  {\n    if (child.getType() == Token.EMPTY) \n    {\n      continue;\n    }\n    strings.add(new StringNode(Token.STRING, child.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n    {\n        if (child.getType() == Token.NAME) \n        {\n            strings.add(Node.newString(child.getString()));\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n        strings.add(Node.newString(param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) \n  {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n    strings.add(Node.newString(child.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        strings.add(new StringNode(Token.STRING, param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.getType() == Token.NAME) {\n            strings.add(new StringNode(Token.STRING, child.getString()));\n        }\n    }\n    return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            this.append(str);\n            this.appendPadding(width - len, padChar);\n        } \n        else \n        {\n            this.append(str.substring(0, width));\n        }\n    } \n    else \n    {\n        this.append(obj);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            int pad = width - len;\n            for (int i = 0; i < pad; i++) \n            {\n                append(padChar);\n            }\n        }\n        append(str);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            append(str);\n            append(repeat(padChar, width - len));\n        } \n        else \n        {\n            append(str.substring(0, width));\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) {\n            append(str);\n            appendPadding(width - len, padChar);\n        } else {\n            append(str.substring(len - width));\n        }\n    } else {\n        append(obj);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            this.append(str);\n            this.append(padChar, width - len);\n        } \n        else \n        {\n            this.append(str.substring(len - width));\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        if (obj == null) {\n            return appendFixedWidthPadRight(nullText, width, padChar);\n        } else {\n            return appendFixedWidthPadRight(obj.toString(), width, padChar);\n        }\n    } else {\n        return this;\n    }\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0)  {\n        if (obj != null)  {\n            String str = obj.toString();\n            if (str.length() > width)  {\n                str = str.substring(0, width);\n            }\n            return append(str, padChar);\n        }\n        else  {\n            return append(nullText, width, padChar);\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            int pad = width - len;\n            for (int i = 0; i < pad; i++) \n            {\n                append(padChar);\n            }\n        }\n        append(str);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            append(str);\n            append(padChar, width - len);\n        } \n        else \n        {\n            append(str.substring(0, width));\n        }\n    } \n    else \n    {\n        append(obj);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        int len = str.length();\n        if (len < width) \n        {\n            append(str);\n            append(padChar, width - len);\n        } \n        else \n        {\n            append(str.substring(len - width));\n        }\n    } \n    else \n    {\n        append(obj);\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (delimLen == 0) {\n        return capitalize(str);\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        return capitalize(str, delimiters[0]);\n    }\n    int[] positions = new int[delimLen];\n    int len = str.length();\n    int count = 0;\n    boolean contains = false;\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                contains = true;\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n\n    if (!contains) {\n        return capitalize(str);\n    }\n    if (count == 0) {\n        return str;\n    }\n    StringBuilder builder = new StringBuilder(str);\n    int prev = 0;\n    for (int i = 0; i < count; i++) {\n        int start = positions[i];\n        if (start - prev > 1) {\n            builder.replace(prev + 1, start + 1,\n                    str.substring(prev + 1, start + 1).toUpperCase());\n        }\n        prev = start;\n    }\n    return builder.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        return capitalize(str, delimiters[0]);\n    }\n    final int strLen = str.length();\n    final int[] positions = new int[strLen];\n    int count = 0;\n    boolean containsDelimiter = false;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                containsDelimiter = true;\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n    if (!containsDelimiter) {\n        return capitalize(str);\n    }\n    final char[] out = new char[strLen];\n    for (int i = 0, j = 0; i < count; ) {\n        out[positions[i++]] = Character.toTitleCase(str.charAt(j++));\n    }\n    for (int i = positions[count - 1] + 1; i < strLen; i++) {\n        out[i] = str.charAt(i);\n    }\n    return new String(out);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (delimLen == 0) {\n        return capitalize(str);\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null)  {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"BST\", \"BST\");\n        cZoneIdConversion.put(\"IST\", \"IST\");\n        cZoneIdConversion.put(\"WAT\", \"WAT\");\n        cZoneIdConversion.put(\"CET\", \"CET\");\n        cZoneIdConversion.put(\"MET\", \"CET\");\n        cZoneIdConversion.put(\"ECT\", \"CET\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"MIT\", \"MIT\");\n        cZoneIdConversion.put(\"HST\", \"HST\");\n        cZoneIdConversion.put(\"SST\", \"SST\");\n        cZoneIdConversion.put(\"AST\", \"AST\");\n        cZoneIdConversion.put(\"PST\", \"PST\");\n        cZoneIdConversion.put(\"PNT\", \"PNT\");\n        cZoneIdConversion.put(\"MST\", \"MST\");\n        cZoneIdConversion.put(\"CST\", \"CST\");\n        cZoneIdConversion.put(\"ICT\", \"ICT\");\n        cZoneIdConversion.put(\"PRT\", \"PRT\");\n        cZoneIdConversion.put(\"CNT\", \"CNT\");\n        cZoneIdConversion.put(\"AGT\", \"AGT\");\n        cZoneIdConversion.put(\"BET\", \"BET\");\n        cZoneIdConversion.put(\"CAT\", \"CAT\");\n        cZoneIdConversion.put(\"ECT\", \"ECT\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"ART\", \"ART\");\n        cZoneIdConversion.put(\"EAT\", \"EAT\");\n        cZoneIdConversion.put(\"MET\", \"MET\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"AET\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cZoneIdConversion.put(\"ART\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n        cZoneIdConversion.put(\"BET\", \"America/Sao_Paulo\");\n        cZoneIdConversion.put(\"BST\", \"Asia/Dhaka\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"CNT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CTT\", \"Asia/Shanghai\");\n        cZoneIdConversion.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"ECT\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"JST\", \"Asia/Tokyo\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"NET\", \"Asia/Yerevan\");\n        cZoneIdConversion.put(\"NST\", \"Pacific/Auckland\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"BST\", \"BST\");\n        cZoneIdConversion.put(\"ART\", \"Africa/Tunis\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Helsinki\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Guadalcanal\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PNT\", \"America/Phoenix\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cZoneIdConversion.put(\"PRT\", \"America/Puerto_Rico\");\n        cZoneIdConversion.put(\"CNT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cZoneIdConversion.put(\"BET\", \"America/Sao_Paulo\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"ECT\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"EST5EDT\", \"America/New_York\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"WET\", \"UTC\");\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"ECT\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Bucharest\");\n        cZoneIdConversion.put(\"ART\", \"America/Buenos_Aires\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"AET\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Guadalcanal\");\n        cZoneIdConversion.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PNT\", \"America/Phoenix\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MET\", \"Europe/Paris\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"BST\", \"BST\");\n        cZoneIdConversion.put(\"IST\", \"IST\");\n        cZoneIdConversion.put(\"WAT\", \"WAT\");\n        cZoneIdConversion.put(\"CET\", \"CET\");\n        cZoneIdConversion.put(\"MET\", \"CET\");\n        cZoneIdConversion.put(\"ECT\", \"CET\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"MIT\", \"MIT\");\n        cZoneIdConversion.put(\"HST\", \"HST\");\n        cZoneIdConversion.put(\"SST\", \"SST\");\n        cZoneIdConversion.put(\"AST\", \"AST\");\n        cZoneIdConversion.put(\"PST\", \"PST\");\n        cZoneIdConversion.put(\"PNT\", \"PNT\");\n        cZoneIdConversion.put(\"MST\", \"MST\");\n        cZoneIdConversion.put(\"CST\", \"CST\");\n        cZoneIdConversion.put(\"ICT\", \"ICT\");\n        cZoneIdConversion.put(\"ACT\", \"ACT\");\n        cZoneIdConversion.put(\"ECT\", \"ECT\");\n        cZoneIdConversion.put(\"SLT\", \"SLT\");\n        cZoneIdConversion.put(\"ART\", \"ART\");\n        cZoneIdConversion.put(\"CAT\", \"CAT\");\n        cZoneIdConversion.put(\"EAT\", \"EAT\");\n        cZoneIdConversion.put(\"NET\", \"NET\");\n        cZoneIdConversion.put(\"PLT\", \"PLT\");\n        cZoneIdConversion.put(\"TFT\", \"TFT\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String newId = null;\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        for (String oldId : DateTimeZone.getAvailableIDs()) \n        {\n            DateTimeZone zone = DateTimeZone.forID(oldId);\n            String newId = zone.getID();\n            cZoneIdConversion.put(oldId, newId);\n        }\n    }\n    newId = cZoneIdConversion.get(id);\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEWT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WAT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WAST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSK\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSD\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n        cZoneIdConversion.put(\"ADT\", \"America/Halifax\");\n        cZoneIdConversion.put(\"NST\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"NDT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"MET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Jerusalem\");\n        cZoneIdConversion.put(\"WAT\", \"Africa/Lagos\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Istanbul\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Midway\");\n        cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"PNT\", \"America/Phoenix\");\n        cZoneIdConversion.put(\"YST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"AKST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"GALT\", \"Pacific/Galapagos\");\n        cZoneIdConversion.put(\"GAMT\", \"Pacific/Gambier\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UTC\", \"Etc/UTC\");\n        cZoneIdConversion.put(\"UCT\", \"Etc/UCT\");\n        cZoneIdConversion.put(\"UP1\", \"Etc/GMT-1\");\n        cZoneIdConversion.put(\"UP2\", \"Etc/GMT-2\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        for (String oldId : DateTimeZone.getAvailableIDs()) \n        {\n            DateTimeZone zone = DateTimeZone.forID(oldId);\n            String newId = zone.getID();\n            cZoneIdConversion.put(oldId, newId);\n        }\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"BST\", \"BST\");\n        cZoneIdConversion.put(\"IST\", \"IST\");\n        cZoneIdConversion.put(\"WAT\", \"WAT\");\n        cZoneIdConversion.put(\"CET\", \"CET\");\n        cZoneIdConversion.put(\"MET\", \"CET\");\n        cZoneIdConversion.put(\"MEWT\", \"MET\");\n        cZoneIdConversion.put(\"MEST\", \"MES\");\n        cZoneIdConversion.put(\"CEST\", \"MES\");\n        cZoneIdConversion.put(\"MESZ\", \"MES\");\n        cZoneIdConversion.put(\"MEZ\", \"MEZ\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"EEST\", \"EEST\");\n        cZoneIdConversion.put(\"EEST\", \"EEST\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"WAST\", \"WAST\");\n        cZoneIdConversion.put(\"WADT\", \"WADT\");\n        cZoneIdConversion.put(\"CCT\", \"CCT\");\n        cZoneIdConversion.put(\"JST\", \"JST\");\n        cZoneIdConversion.put(\"GST\", \"GST\");\n        cZoneIdConversion.put(\"NZST\", \"NZST\");\n        cZoneIdConversion.put(\"NZDT\", \"NZDT\");\n        cZoneIdConversion.put(\"IDLE\", \"IDLE\");\n        cZoneIdConversion.put(\"IDLW\", \"IDLW\");\n        cZoneIdConversion.put(\"CHAST\", \"CHAST\");\n        cZoneIdConversion.put(\"CHADT\", \"CHADT\");\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Compute the Jacobian\n        final RealMatrix jacobian = jF.computeJacobian(params);\n\n        // Compute the weighted Jacobian\n        final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(jacobian);\n\n        // Increment the number of Jacobian evaluations\n        jacobianEvaluations++;\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // compute Jacobian\n    final double[][] jacobian = jF.value(params);\n\n    // compute W^1/2\n    final RealMatrix weightSqrt = getWeightSquareRoot();\n\n    // return W^1/2 J\n    return weightSqrt.multiply(new BlockRealMatrix(jacobian));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // compute Jacobian\n        RealMatrix jacobian = jF.computeJacobian(params);\n        // compute weighted Jacobian\n        return weightMatrixSqrt.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.value(params);\n    if (weightMatrixSqrt == null) {\n        return jacobian;\n    }\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // compute Jacobian\n    final double[][] jacobian = jF.value(params);\n    // compute weighted Jacobian\n    return weightMatrixSqrt.multiply(new BlockRealMatrix(jacobian));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Compute the Jacobian matrix\n        final RealMatrix jacobian = jF.jacobian();\n        // Compute the weighted Jacobian\n        return weightMatrixSqrt.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian\n    final RealMatrix jacobian = jF.value(params);\n\n    // Compute the weighted Jacobian\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final int n = weightedResidualJacobian.length;\n        final int m = weightedResidualJacobian[0].length;\n        final RealMatrix jacobian = new Array2DRowRealMatrix(n, m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                jacobian.setEntry(i, j, weightedResidualJacobian[i][j]);\n            }\n        }\n        return jacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Get the Jacobian\n    RealMatrix jacobian = jF.jacobian();\n\n    // Compute W<sup>1/2</sup> J\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian\n    final double[][] jacobian = jF.value(params);\n    // Compute the weighted Jacobian\n    final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(new BlockRealMatrix(jacobian));\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                return -1;\n            }\n        }\n        if (least == -1 || comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be non-null\");\n    }\n    if (values == null) {\n        start();\n    }\n    int least = -1;\n    for (int i = values.size() - 1; i >= 0; i--) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                E v1 = values.get(least);\n                E v2 = values.get(i);\n                if (comparator.compare(v1, v2) > 0) {\n                    least = i;\n                }\n            }\n        } else {\n            if (!set(i)) {\n                return -1;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"comparator\");\n    }\n    int least = -1;\n    for (int i = values.size(); --i >= 0;) {\n        if (valueSet.get(i)) {\n            if (least < 0) {\n                least = i;\n            } else {\n                int c = comparator.compare(values.get(least), values.get(i));\n                if (c > 0) {\n                    least = i;\n                }\n            }\n        } else if (set(i)) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    if (values.isEmpty()) {\n        return -1;\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            set(i);\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(least), values.get(i)) > 0) {\n                    least = i;\n                }\n            }\n        } else {\n            if (set(i)) {\n                if (least == -1) {\n                    least = i;\n                } else {\n                    if (comparator.compare(values.get(least), values.get(i)) > 0) {\n                        least = i;\n                    }\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = values.size() - 1; i >= 0; i--) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        } else {\n            if (set(i)) {\n                if (least == -1) {\n                    least = i;\n                } else {\n                    if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                        least = i;\n                    }\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            continue;\n        }\n        if (!set(i)) {\n            continue;\n        }\n        if (least == -1 || comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = values.size(); i-- > 0;) {\n        if (!valueSet.get(i)) {\n            set(i);\n        }\n        if (least == -1 || comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be non-null\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                continue;\n            }\n        }\n        if (least == -1) {\n            least = i;\n        } else {\n            if (comparator.compare(values.get(least), values.get(i)) > 0) {\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No more elements\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    if (values == null) {\n        values = new ArrayList<E>();\n    }\n    if (valueSet == null) {\n        valueSet = new BitSet(iterators.size());\n    }\n    for (int i = valueSet.nextClearBit(0); i < iterators.size(); i = valueSet.nextClearBit(i + 1)) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    throw new NoSuchElementException();\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        if (step.getNodeTest() instanceof NodeNameTest) {\n            NodeNameTest nameTest = (NodeNameTest) step.getNodeTest();\n            childPointer = parentPointer.createChildNodePointer(\n                    nameTest.getNodeName(), null);\n        } else if (step.getNodeTest() instanceof NodeTypeTest) {\n            NodeTypeTest typeTest = (NodeTypeTest) step.getNodeTest();\n            if (typeTest.getNodeType() == NodeTypeTest.NODE) {\n                childPointer = parentPointer.createChildNodePointer(\n                        null, null);\n            } else if (typeTest.getNodeType() == NodeTypeTest.TEXT) {\n                childPointer = parentPointer.createChildNodePointer(\n                        null, null);\n            } else if (typeTest.getNodeType() == NodeTypeTest.COMMENT) {\n                childPointer = parentPointer.createChildNodePointer(\n                        null, null);\n            } else if (typeTest.getNodeType() == NodeTypeTest.PROCESSING_INSTRUCTION) {\n                childPointer = parentPointer.createChildNodePointer(\n                        null, null);\n            }\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.getNodeTest().isNodeType(NodeTest.NODE)) {\n            return new NodePointer(parentPointer);\n        }\n        else {\n            return new PropertyPointer(parentPointer, step.getNodeTest());\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // Get the node test\n        NodeTest nodeTest = step.getNodeTest();\n        // Get the name\n        QName name = nodeTest.getNameTest();\n        // Create the child pointer\n        NodePointer childPointer = null;\n        if (name != null) {\n            // Create the child pointer\n            childPointer = newNodePointer(name, null, parentPointer.getLocale());\n            // Set the parent\n            childPointer.setParent(parentPointer);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  ",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Step.ATTRIBUTE) {\n        childPointer = parentPointer.attributePointer(step.getNodeTest().getName());\n    } else {\n        childPointer = parentPointer.childPointer(step.getNodeTest().getName());\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return newChildNodePointer(parentPointer, step.getName(), null);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        if (step.getAxis() == Step.ATTRIBUTE) {\n            return parentPointer.attributePointer(step.getName());\n        }\n        return parentPointer.childPointer(step.getName());\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the name of the step\n    QName name = step.getNodeTest().getNodeName();\n    // Create the child pointer\n    NodePointer childPointer = parentPointer.createChildNodePointer(\n                name, null, null);\n    // Set the index of the child pointer\n    childPointer.setIndex(step.getIndex());\n    // Return the child pointer\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        if (step.getAxis() == Step.ATTRIBUTE) {\n            childPointer = parentPointer.attributePointer(step.getName());\n        } else if (step.getAxis() == Step.CHILD) {\n            childPointer = parentPointer.childPointer(step.getName());\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        return parentPointer.createChildNodePointer(step.getName(), null);\n    }"
    ],
    [
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (getTree(true).getCut().getPlus().getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return getTree(true).getCut().getPlus().getCut().getLocation().getX();\n}",
      "public double getInf()  {\n        if (isEmpty()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (getTree(true).getCut().getLocation().getX() == Double.NEGATIVE_INFINITY) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        return getTree(true).getCut().getLocation().getX();\n    }",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n        return Double.NEGATIVE_INFINITY;\n    }",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (getTree(true).getCut().getCut().getLocation() == Double.NEGATIVE_INFINITY) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return getTree(true).getCut().getCut().getLocation();\n}",
      "public double getInf()  {\n    return Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n        return Double.NEGATIVE_INFINITY;\n    }",
      "public double getInf()  {\n        return Double.NEGATIVE_INFINITY;\n    }",
      "public double getInf()  {\n        return Double.NEGATIVE_INFINITY;\n    }"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        switch (field) {\n            case Calendar.ERA:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected String getFieldValue(int value) {\n                        return definingCalendar.getDisplayName(field, Calendar.LONG, locale);\n                    }\n                };\n            case Calendar.MONTH:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected String getFieldValue(int value) {\n                        return definingCalendar.getDisplayName(field, Calendar.SHORT, locale);\n                    }\n                };\n            case Calendar.DAY_OF_WEEK:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected String getFieldValue(int value) {\n                        return definingCalendar.getDisplayName(field, Calendar.SHORT, locale);\n                    }\n                };\n            default:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected String getFieldValue(int value) {\n                        return String.valueOf(value);\n                    }\n                };\n        }\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        switch (field) {\n            case Calendar.ERA:\n                return new TextStrategy(field, definingCalendar, locale);\n            case Calendar.ZONE_OFFSET:\n            case Calendar.DST_OFFSET:\n                return new TimeZoneStrategy(locale);\n            default:\n                return new CopyQuotedStrategy(getFormatField(field));\n        }\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        switch (field) {\n            case Calendar.AM_PM:\n                return new TextStrategy(field, definingCalendar, locale) {\n}\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    switch (field) {\n        case Calendar.ERA:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected String getFieldValue(final Calendar cal) {\n                    return getEra(cal.get(field));\n                }\n            };\n        case Calendar.ZONE_OFFSET:\n        case Calendar.DST_OFFSET:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected String getFieldValue(final Calendar cal) {\n                    return getOffset(cal.get(field));\n                }\n            };\n        default:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected String getFieldValue(final Calendar cal) {\n                    return getText(cal.get(field), field);\n                }\n            };\n    }\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    switch (field) {\n        case Calendar.AM_PM:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected String getText(final Calendar cal) {\n                    return cal.get(Calendar.AM_PM) == Calendar.AM ? getAmPmStrings()[0] : getAmPmStrings()[1];\n                }\n            };\n        case Calendar.ERA:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected String getText(final Calendar cal) {\n                    return cal.get(Calendar.ERA) == GregorianCalendar.BC ? getEras()[0] : getEras()[1];\n                }\n            };\n        default:\n            return new TextStrategy(field, definingCalendar, locale);\n    }\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    Map<String, Integer> textValues = getDisplayNames(field, definingCalendar, locale);\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    switch (field) {\n        case Calendar.AM_PM:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n                    int hour = cal.get(Calendar.HOUR_OF_DAY);\n                    cal.set(Calendar.HOUR_OF_DAY, hour % 12 + (value.equalsIgnoreCase(amPmStrings[Calendar.AM]) ? 0 : 12));\n                }\n            };\n        case Calendar.ERA:\n            return new TextStrategy(field, definingCalendar, locale) {\n                @Override\n                protected void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n                    cal.set(Calendar.ERA, value.equalsIgnoreCase(eraStrings[Calendar.BC]) ? Calendar.BC : Calendar.AD);\n                }\n            };\n        default:\n            return new TextStrategy(field, definingCalendar, locale);\n    }\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        switch (field) {\n            case Calendar.AM_PM:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected void addRegex(FastDateParser parser, StringBuilder regex) {\n                        // NOTE: The following regex is different from the one in\n                        //       SimpleDateFormat. It allows to parse single\n                        //       character AM and PM.\n                        regex.append(\"([apAP][mM])\");\n                    }\n\n                    @Override\n                    protected void setCalendar(FastDateParser parser, Calendar cal, String value) {\n                        int hour = cal.get(Calendar.HOUR_OF_DAY);\n                        cal.set(Calendar.HOUR_OF_DAY, (hour % 12) + (value.equalsIgnoreCase(\"am\") ? 0 : 12));\n                    }\n                };\n            case Calendar.ERA:\n                return new TextStrategy(field, definingCalendar, locale) {\n                    @Override\n                    protected void addRegex(FastDateParser parser, StringBuilder regex) {\n                        // NOTE: The following regex is different from the one in\n                        //       SimpleDateFormat. It allows to parse single\n                        //       character AD and BC.\n                        regex.append(\"([aAdD][cC][.]?|[bB][cC][eE]?)\");\n                    }\n\n                    @Override\n                    protected void setCalendar(FastDateParser parser, Calendar cal, String value) {\n                        if (value.equalsIgnoreCase(\"bc\")) {\n                            cal.set(Calendar.ERA, GregorianCalendar.BC);\n                        }\n                    }\n                };\n            default:\n                return new TextStrategy(field, definingCalendar, locale);\n        }\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        switch (field) {\n            case Calendar.ERA:\n                return new TextStrategy(field, definingCalendar, locale);\n            case Calendar.MONTH:\n                return new TextStrategy(field, definingCalendar, locale);\n            case Calendar.DAY_OF_WEEK:\n                return new TextStrategy(field, definingCalendar, locale);\n            case Calendar.AM_PM:\n                return new TextStrategy(field, definingCalendar, locale);\n            default:\n                throw new IllegalArgumentException(\"Invalid field \" + field);\n        }\n    }"
    ],
    [
      "private boolean setNextObject()  {\n    if (iterator == null) {\n        return false;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (iterator == null) {\n        throw new IllegalStateException(\"Iterator must be set before invoking next()\");\n    }\n    if (predicate == null) {\n        throw new IllegalStateException(\"Predicate must be set before invoking next()\");\n    }\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (iterator == null) {\n        throw new IllegalStateException(\"Iterator has not been set\");\n    }\n    if (predicate == null) {\n        throw new IllegalStateException(\"Predicate has not been set\");\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (iterator == null) {\n        throw new IllegalStateException(\"Iterator has not been set\");\n    }\n    if (predicate == null) {\n        throw new IllegalStateException(\"Predicate has not been set\");\n    }\n    nextObjectSet = false;\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < 0.0) \n        {\n            repaired[i] = 0.0;\n        } \n        else if (x[i] > 1.0) \n        {\n            repaired[i] = 1.0;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(0.0, Math.min(1.0, x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(Math.min(x[i], 1.0), 0.0);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < 0) \n        {\n            repaired[i] = 0;\n        } \n        else if (x[i] > 1) \n        {\n            repaired[i] = 1;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(0, Math.min(1, x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < 0.0) {\n            repaired[i] = 0.0;\n        } else if (x[i] > 1.0) {\n            repaired[i] = 1.0;\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(0, Math.min(1, x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.min(Math.max(x[i], 0), 1);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < 0) \n        {\n            repaired[i] = 0;\n        } \n        else if (x[i] > 1) \n        {\n            repaired[i] = 1;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    // TODO: Implement this method.\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        schur.transform();\n        return schur;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        return new SchurTransformer(matrix);\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        return new SchurTransformer(matrix);\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        schur.transform();\n        return schur;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    schur.transform();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        schur.transform();\n        return schur;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n        final SchurTransformer schur = new SchurTransformer(matrix);\n        schur.transform();\n        return schur;\n    }"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final Class<E> cls = checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(cls);\n    for (int i = 0; i < values.length; i++) {\n        final long bitVector = values[i];\n        for (int bitPos = 0; bitPos < Long.SIZE; bitPos++) {\n            if (bitVector == 0) {\n                break;\n            }\n            final long mask = 1L << bitPos;\n            if ((bitVector & mask) != 0) {\n                final E constant = E.valueOf(cls, Integer.toString(bitPos));\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    return processBitVectors(enumClass, Arrays.asList(values));\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    return processBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        final int bitVectorSize = Long.SIZE - Long.numberOfLeadingZeros(value);\n        final int enumSize = enumClass.getEnumConstants().length;\n        if (bitVectorSize > enumSize) {\n            throw new IllegalArgumentException(String.format(\n                    \"The bit vector [%d] is too long to represent the enum [%s]\",\n                    value, enumClass.getSimpleName()));\n        }\n        for (int i = 0; i < enumSize; i++) {\n            final long mask = 1L << i;\n            if ((value & mask) != 0) {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        final Class<E> enumClass = checkBitVectorable(enumClass);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (long v : values) {\n            int i = 0;\n            for (E e : enumClass.getEnumConstants()) {\n                if ((v & (1L << i)) != 0) {\n                    result.add(e);\n                }\n                i++;\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (final E e : EnumSet.allOf(enumClass)) {\n            if (((1L << e.ordinal()) & value) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        final Class<E> cls = checkBitVectorable(enumClass);\n        final EnumSet<E> result = EnumSet.noneOf(cls);\n        for (final long element : values) {\n            for (final E e : cls.getEnumConstants()) {\n                if (((element >> e.ordinal()) & 1) == 1) {\n                    result.add(e);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long v : values) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((v & (1L << e.ordinal())) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E e : enumClass.getEnumConstants()) {\n        final long bitVector = generateBitVector(enumClass, e);\n        for (final long value : values) {\n            if (bitVector == value) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    return processBitVectors(enumClass, Arrays.asList(values));\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null)  {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newLocalMillis = newZone.convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(newLocalMillis, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    if (newZone == this) {\n        return oldInstant;\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == this) {\n        return oldInstant;\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis, false, oldInstant);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // get the calendar field for the tick unit\n    int field = unit.getCalendarField();\n\n    // get the current date\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    // add the tick unit to the current date\n    calendar.add(field, unit.getMultiple());\n\n    // return the next \"standard\" date\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int count = unit.getMultiple();\n    calendar.add(field, count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // get the calendar field for the unit\n    int field = unit.getCalendarField();\n    // get the current value of the field\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int current = calendar.get(field);\n    // get the next value of the field\n    int next = current + unit.getMultiple();\n    // set the new value of the field\n    calendar.set(field, next);\n    // return the new date\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int count = unit.getMultiple();\n    calendar.add(field, count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.getTimeZone());\n    calendar.setTime(date);\n    calendar.add(unit.getCalendarField(), unit.getMultiple());\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // get the calendar field\n    int field = unit.getCalendarField();\n    // get the current value\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int current = calendar.get(field);\n    // get the next value\n    int next = current + unit.getMultiple();\n    // set the new value\n    calendar.set(field, next);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    //TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    //TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int amount = unit.getMultiple();\n    calendar.add(field, amount);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int count = unit.getMultiple();\n    calendar.add(field, count);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() != null) {\n        return getVariableResolver().lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() == null) {\n        return null;\n    }\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() != null) {\n        return getVariableResolver().lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() == null) {\n        return null;\n    }\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() != null) {\n        return getVariableResolver().lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value != null) {\n        if (isEnableSubstitutionInVariables()) {\n            final StrBuilder bufValue = new StrBuilder(value);\n            substitute(bufValue, 0, bufValue.length());\n            return bufValue.toString();\n        }\n        return value;\n    }\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] in = str.toCharArray();\n    final char[] out = new char[maxLength];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < in.length && length < maxLength; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            if (c != out[length - 1]) {\n                out[length] = c;\n                length++;\n            }\n        }\n    }\n    while (length < maxLength) {\n        out[length] = '0';\n        length++;\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final int len = str.length();\n    final char[] out = new char[maxLength];\n    final char[] in = str.toCharArray();\n    out[0] = in[0];\n    int count = 1;\n    char last = '*';\n    for (int i = 1; i < len && count < maxLength; i++) {\n        final char c = map(in[i]);\n        if (c != '0' && c != last) {\n            out[count++] = c;\n            last = c;\n        }\n    }\n    return new String(out, 0, count);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] s = new char[str.length()];\n    final char[] mapping = getSoundexMapping();\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = map(str.charAt(i));\n        if (i == 0) {\n            s[i] = ch;\n        } else if (ch != 0) {\n            s[i] = ch;\n        } else {\n            s[i] = s[i - 1];\n        }\n    }\n    final StringBuilder buf = new StringBuilder();\n    buf.append(s[0]);\n    for (int i = 1; i < s.length; i++) {\n        if (s[i] != s[i - 1]) {\n            buf.append(s[i]);\n        }\n    }\n    return buf.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final int len = str.length();\n    if (len == 0) {\n        return str;\n    }\n    final char[] in = str.toCharArray();\n    final char[] out = new char[maxLength];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < len && length < maxLength; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            if (c != out[length - 1]) {\n                out[length] = c;\n                length++;\n            }\n        }\n    }\n    while (length < maxLength) {\n        out[length] = '0';\n        length++;\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] s = new char[str.length()];\n    final char[] in = str.toCharArray();\n    for (int i = 0; i < in.length; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            s[i] = c;\n        }\n    }\n    final StringBuilder buffer = new StringBuilder();\n    buffer.append(s[0]);\n    for (int i = 1; i < s.length; i++) {\n        if (s[i] != s[i - 1]) {\n            buffer.append(s[i]);\n        }\n    }\n    return buffer.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final int len = str.length();\n        final char[] in = new char[len];\n        str.getChars(0, len, in, 0);\n        final char[] out = new char[maxLength];\n        out[0] = in[0];\n        int length = 1;\n        for (int i = 1; i < len; i++) {\n            final char c = map(in[i]);\n            if (c != 0) {\n                if (c != out[length - 1]) {\n                    out[length++] = c;\n                }\n                if (length >= maxLength) {\n                    break;\n                }\n            }\n        }\n        while (length < out.length) {\n            out[length++] = '0';\n        }\n        return new String(out);\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] in = str.toCharArray();\n    final char[] out = new char[maxLength];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < in.length && length < maxLength; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            if (c != out[length - 1]) {\n                out[length] = c;\n                length++;\n            }\n        }\n    }\n    while (length < maxLength) {\n        out[length] = '0';\n        length++;\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] s = new char[str.length()];\n        for (int i = 0; i < s.length; i++) {\n            s[i] = map(str.charAt(i));\n        }\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(s[0]);\n        for (int i = 1; i < s.length; i++) {\n            if (s[i] != 0) {\n                buffer.append(s[i]);\n            }\n        }\n        while (buffer.length() < maxLength) {\n            buffer.append('0');\n        }\n        return buffer.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] in = str.toCharArray();\n    final char[] out = new char[maxLength];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < in.length; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            if (c != out[length - 1]) {\n                out[length] = c;\n                length++;\n            }\n        }\n    }\n    while (length < out.length) {\n        out[length++] = '0';\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final int len = str.length();\n    if (len == 0) {\n        return str;\n    }\n    final char[] in = str.toCharArray();\n    final char[] out = new char[maxLength];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < len && length < maxLength; i++) {\n        final char c = map(in[i]);\n        if (c != 0) {\n            if (c != out[length - 1]) {\n                out[length] = c;\n                length++;\n            }\n        }\n    }\n    return new String(out, 0, length);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First: well-known core types\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // first, check out of core types\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First, simple types:\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n        if (n.getType() != Token.FUNCTION) {\n            return null;\n        }\n        String qualifiedClassName = null;\n        Node lhs = null;\n        Node node = n;\n        if (n.getChildCount() == 3) {\n            lhs = n.getFirstChild();\n            node = n.getLastChild();\n            if (lhs.getType() == Token.GETPROP) {\n                qualifiedClassName = lhs.getQualifiedName();\n            }\n        }\n        String memberName = node.getQualifiedName();\n        return new PrototypeMemberDeclaration(lhs, node, qualifiedClassName, memberName);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    // Check if the node is a function declaration\n    if (n.getType() == Token.FUNCTION) \n    {\n        // Get the function name\n        String functionName = n.getFirstChild().getString();\n        // Get the function node\n        Node functionNode = n.getFirstChild().getNext();\n        // Get the qualified class name\n        String qualifiedClassName = n.getQualifiedName();\n        // Get the left hand side node\n        Node lhs = n.getFirstChild();\n        // Create a new prototype member declaration\n        PrototypeMemberDeclaration prototypeMemberDeclaration = new PrototypeMemberDeclaration(lhs, functionNode);\n        // Set the member name\n        prototypeMemberDeclaration.memberName = functionName;\n        // Set the qualified class name\n        prototypeMemberDeclaration.qualifiedClassName = qualifiedClassName;\n        // Return the prototype member declaration\n        return prototypeMemberDeclaration;\n    }\n    // Return null if there is no prototype member declaration\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() != Token.VAR) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (lhs.getType() != Token.NAME) {\n        return null;\n    }\n    Node rhs = lhs.getNext();\n    if (rhs == null) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(lhs, rhs);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() == Token.VAR) {\n        Node lhs = n.getFirstChild();\n        if (lhs.getType() == Token.NAME) {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() == Token.FUNCTION) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.getType() == Token.NAME) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() == Token.FUNCTION) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    } else if (n.getType() == Token.STRING) {\n        return new PrototypeMemberDeclaration(n, n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() != Token.NAME) {\n        return null;\n    }\n\n    // Check if the name is a prototype member declaration.\n    Node lhs = n.getFirstChild();\n    if (lhs == null || lhs.getType() != Token.GETPROP) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function declaration.\n    Node rhs = lhs.getNext();\n    if (rhs == null || rhs.getType() != Token.FUNCTION) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a constructor.\n    Node nameNode = lhs.getFirstChild();\n    if (nameNode == null || nameNode.getType() != Token.NAME) {\n        return null;\n    }\n    String name = nameNode.getString();\n    if (!name.equals(\"constructor\")) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function expression.\n    Node parent = n.getParent();\n    if (parent == null || parent.getType() != Token.EXPR_RESULT) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function expression.\n    Node grandParent = parent.getParent();\n    if (grandParent == null || grandParent.getType() != Token.BLOCK) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function expression.\n    Node greatGrandParent = grandParent.getParent();\n    if (greatGrandParent == null || greatGrandParent.getType() != Token.SCRIPT) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function expression.\n    Node greatGreatGrandParent = greatGrandParent.getParent();\n    if (greatGreatGrandParent == null || greatGreatGrandParent.getType() != Token.ROOT) {\n        return null;\n    }\n\n    // Check if the prototype member declaration is a function expression.\n    Node greatGreatGreatGrandParent = greatGreatGrandParent.getParent();\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    // If the node is not a member function definition, return null.\n    if (n.getType() != Token.FUNCTION) {\n        return null;\n    }\n\n    // If the node is not a prototype member function, return null.\n    if (n.getParent().getType() != Token.GETPROP || n.getParent().getFirstChild().getType() != Token.GETPROP) {\n        return null;\n    }\n\n    // If the node is not a prototype member function, return null.\n    if (!n.getParent().getFirstChild().getString().equals(\"prototype\")) {\n        return null;\n    }\n\n    // If the node is not a member function definition, return null.\n    if (n.getFirstChild().getType() != Token.NAME) {\n        return null;\n    }\n\n    // If the node is not a member function definition, return null.\n    if (!n.getFirstChild().getString().equals(\"constructor\")) {\n        return null;\n    }\n\n    // Return the prototype member declaration.\n    return new PrototypeMemberDeclaration(n.getParent().getFirstChild(), n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() == Token.FUNCTION) {\n        Node lhs = n.getFirstChild();\n        if (lhs.getType() == Token.NAME) {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n        if (n.getType() != Token.EXPR_RESULT) {\n            return null;\n        }\n        Node expr = n.getFirstChild();\n        if (expr.getType() != Token.ASSIGN) {\n            return null;\n        }\n        Node lhs = expr.getFirstChild();\n        Node rhs = expr.getLastChild();\n        if (rhs.getType() != Token.FUNCTION) {\n            return null;\n        }\n        return new PrototypeMemberDeclaration(lhs, rhs);\n    }"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int nrows = mat.getRowDimension();\n    int ncols = mat.getColumnDimension();\n    RealMatrix result = mat.createMatrix(nrows * n, ncols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat.getData(), i * nrows, (i + 1) * nrows - 1, j * ncols, (j + 1) * ncols - 1);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int row = mat.getRowDimension();\n    final int col = mat.getColumnDimension();\n    final RealMatrix res = mat.createMatrix(row * n, col * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            res.setSubMatrix(mat.getData(), i * row, (i + 1) * row - 1, j * col, (j + 1) * col - 1);\n        }\n    }\n    return res;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int nRows = mat.getRowDimension();\n    int nCols = mat.getColumnDimension();\n    RealMatrix result = mat.createMatrix(nRows * n, nCols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat.getData(), i * nRows, (i + 1) * nRows - 1, j * nCols, (j + 1) * nCols - 1);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final double[][] data = new double[nRows * n][nCols * m];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            final double value = mat.getEntry(i, j);\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = value;\n                }\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(data);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int nRows = mat.getRowDimension();\n    final int nCols = mat.getColumnDimension();\n    final RealMatrix out = mat.createMatrix(nRows * n, nCols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat.getData(), i * nRows, (i + 1) * nRows - 1, j * nCols, (j + 1) * nCols - 1);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix with the desired size\n    RealMatrix newMat = mat.createMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n\n    // Fill the matrix with the input matrix\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            newMat.setSubMatrix(mat.getData(), i * mat.getRowDimension(), (i + 1) * mat.getRowDimension() - 1, j * mat.getColumnDimension(), (j + 1) * mat.getColumnDimension() - 1);\n        }\n    }\n\n    return newMat;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int row = mat.getRowDimension();\n    int col = mat.getColumnDimension();\n    RealMatrix res = mat.createMatrix(row * n, col * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            res.setSubMatrix(mat.getData(), i * row, (i + 1) * row - 1, j * col, (j + 1) * col - 1);\n        }\n    }\n    return res;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDim = mat.getRowDimension();\n    final int colDim = mat.getColumnDimension();\n    final RealMatrix out = mat.createMatrix(rowDim * n, colDim * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            out.setSubMatrix(mat.getData(), i * rowDim, (i + 1) * rowDim - 1, j * colDim, (j + 1) * colDim - 1);\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // TODO: Implement this method\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty()) {\n        return null;\n    }\n    Node current = top;\n    while (current != null) {\n        int cmp = reference.compareTo(current.element);\n        if (cmp == 0) {\n            return current;\n        }\n        if (cmp < 0) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = top;\n    if (current == null) {\n        return null;\n    }\n    while (current.element.compareTo(reference) < 0) {\n        current = current.right;\n        if (current == null) {\n            return null;\n        }\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty())\n        return null;\n    Node current = top;\n    while (current != null)\n    {\n        final int comparison = current.getElement().compareTo(reference);\n        if (comparison < 0)\n            current = current.getNext();\n        else if (comparison > 0)\n            current = current.getPrevious();\n        else\n            return current;\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = top;\n    if (current == null) {\n        return null;\n    }\n    while (current.getElement().compareTo(reference) < 0) {\n        current = current.getNext();\n        if (current == null) {\n            return null;\n        }\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = top;\n    while (current != null) {\n        int comparison = reference.compareTo(current.element);\n        if (comparison == 0) {\n            return current;\n        } else if (comparison < 0) {\n            current = current.left;\n        } else {\n            Node next = current.right;\n            if (next == null) {\n                return current;\n            } else {\n                current = next;\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = top;\n    while (current != null) {\n        int comparison = reference.compareTo(current.getElement());\n        if (comparison == 0) {\n            return current;\n        } else if (comparison < 0) {\n            current = current.getPrevious();\n        } else {\n            current = current.getNext();\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty()) {\n        return null;\n    }\n    Node node = top;\n    while (node.getElement().compareTo(reference) < 0) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node node = getLargest();\n    if (node == null)\n        return null;\n    if (node.getElement().compareTo(reference) <= 0)\n        return node;\n    while (node.getPrevious() != null) {\n        node = node.getPrevious();\n        if (node.getElement().compareTo(reference) <= 0)\n            return node;\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty()) \n    {\n        return null;\n    }\n    Node current = top;\n    while (current != null) \n    {\n        int comparison = reference.compareTo(current.element);\n        if (comparison == 0) \n        {\n            return current;\n        }\n        else if (comparison < 0) \n        {\n            current = current.left;\n        }\n        else \n        {\n            if (current.right == null) \n            {\n                return current;\n            }\n            current = current.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = top;\n    while (current != null) {\n        final int comparison = current.getElement().compareTo(reference);\n        if (comparison == 0) {\n            return current;\n        } else if (comparison < 0) {\n            current = current.getNext();\n        } else {\n            current = current.getPrevious();\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated < bytesRead) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < current.bytesRead) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesRead();\n    long read = current.bytesReadFromStream;\n    if (read > 0 && result > read) {\n        result = read;\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = inf.getBytesRead();\n    long bytesReadFromStream = inf.getBytesWritten();\n    if (bytesReadFromStream - bytesRead > TWO_EXP_32) {\n        bytesRead = bytesReadFromStream - TWO_EXP_32;\n    }\n    return bytesRead;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < current.bytesReadFromStream) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long totalBytesRead = getBytesRead();\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = inf.getBytesRead();\n    if (bytesInflated > totalBytesRead) {\n        bytesInflated = totalBytesRead;\n    }\n    if (bytesRead > totalBytesRead) {\n        bytesRead = totalBytesRead;\n    }\n    if (bytesInflated < bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    } else if (bytesInflated < TWO_EXP_32 - bytesRead) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesRead();\n    long read = current.bytesReadFromStream;\n    if (result > read) {\n        result = read;\n    }\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated < bytesRead) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = inf.getBytesRead();\n    long bytesReadFromStream = inf.getBytesWritten();\n    if (bytesReadFromStream - bytesRead < 0) {\n        bytesRead = bytesReadFromStream;\n    }\n    return bytesRead;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported, please provide an implementation for the sizeOf(Object) method\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported, please provide an Iterable, Iterator, Enumeration or Array\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    } \n    else if (object instanceof Iterator) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"The object is not a collection, map, array, iterator or enumeration\");\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object is not a Collection, Map, Array, Iterator or Enumeration\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported, please provide an iterator or an array\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported, please provide an isEmpty() method\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object is not a collection, map, array, iterator or enumeration.\");\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty())  {\n    return false;\n  }\n\n  int len = name.length();\n  if (name.charAt(0) == '.')  {\n    return false;\n  }\n\n  for (int i = 0; i < len; i++)  {\n    char c = name.charAt(i);\n    if (c == '.')  {\n      if (i == len - 1)  {\n        return false;\n      }\n    } else if (!isValidNameChar(c))  {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return name.indexOf('.') != -1;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidPropertyName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty())  {\n    return false;\n  }\n  for (int i = 0; i < name.length(); i++)  {\n    char c = name.charAt(i);\n    if (i == 0)  {\n      if (!isValidSimpleName(c))  {\n        return false;\n      }\n    } else {\n      if (!isValidPropertyName(c))  {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n\n  // Qualified names are broken into two cases:\n  // 1. Names that start with a valid identifier.\n  // 2. Names that start with a number.\n  //\n  // The first case is easy to deal with. The second case is a little\n  // trickier. It's valid for a qualified name to start with a number,\n  // but it's not valid for an unqualified name to start with a number.\n  //\n  // We're going to cheat a little bit here. We're going to say that\n  // a qualified name can start with a number, but an unqualified name\n  // can't. This means that we'll have to check the qualified name\n  // case specially.\n  int index = name.indexOf('.');\n  if (index == -1) {\n    return isValidSimpleName(name);\n  } else {\n    return isValidQualifiedNameParts(name, index);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidPropertyName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n  int index = name.indexOf('.');\n  if (index == -1) {\n    return isValidSimpleName(name);\n  } else {\n    return isValidSimpleName(name.substring(0, index))\n        && isValidQualifiedName(name.substring(index + 1));\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n  String[] parts = name.split(\"\\\\.\");\n  for (String part : parts) {\n    if (!isValidSimpleName(part)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty())  {\n        return false;\n    }\n    for (String part : name.split(\"\\\\.\"))  {\n        if (!isValidSimpleName(part))  {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"[a-zA-Z_$][a-zA-Z_$0-9]*\");\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int start = il;\n    int end = iu;\n    double[][] matrix = matrixT.getData();\n    double[][] pMatrix = matrixP.getData();\n    double[][] pTMatrix = matrixP.getData();\n    double[][] pTMatrixP = matrixP.getData();\n    double[][] pMatrixP = matrixP.getData();\n    double[][] pMatrixPt = matrixP.getData();\n    double[][] pTMatrixPt = matrixP.getData();\n    double[][] pTMatrixPtP = matrixP.getData();\n    double[][] pTMatrixPtPt = matrixP.getData();\n    double[][] pMatrixPtPt = matrixP.getData();\n    double[][] pMatrixPtPtP = matrixP.getData();\n    double[][] pTMatrixPtPtP = matrixP.getData();\n    double[][] pMatrixPtPtPt = matrixP.getData();\n    double[][] pTMatrixPtPtPt = matrixP.getData();\n    double[][] pMatrixPtPtPtP = matrixP.getData();\n    double[][] pTMatrixPtPtPtP = matrixP.getData();\n    double[][] pMatrixPtPtPtPt = matrixP.getData();\n    double[][] pTMatrixPtPtPtPt = matrixP.getData();\n    double[][] pMatrixPtPtPtPtP = matrixP.getData();\n    double[][] pTMatrixPtPtPtPtP = matrixP.getData();\n    double[][] pMatrixPtPtPtPtPt = matrixP.getData();\n    double[][] pTMatrixPtPtPtPtPt = matrixP.getData();\n    double[][] pMatrixPtPtPtPtPtP = matrixP.getData();\n    double[][] pTMatrixPtPtPtPtPtP = matrixP.getData();\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    int start = il;\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT.getEntry(i, i) - shift.exShift;\n    }\n    return start;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int start = iu;\n    int end = il;\n    if (il == iu) {\n        hVec[il] = matrixT.getEntry(il, il);\n        return start;\n    }\n    if (matrixT.getEntry(il, il) == 0) {\n        hVec[il] = 0;\n        for (int i = il + 1; i <= iu; i++) {\n            hVec[i] = matrixT.getEntry(i, i);\n        }\n        return start;\n    }\n    int m = il + 1;\n    int k = il + 1;\n    double scale = 0;\n    double h = 0;\n    for (int i = m; i <= iu; i++) {\n        scale += Math.abs(matrixT.getEntry(i, i));\n    }\n    if (scale == 0) {\n        hVec[il] = matrixT.getEntry(il, il);\n        for (int i = il + 1; i <= iu; i++) {\n            hVec[i] = matrixT.getEntry(i, i);\n        }\n        return start;\n    }\n    for (int i = m; i <= iu; i++) {\n        hVec[i] = matrixT.getEntry(i, i) / scale;\n        h += hVec[i] * hVec[i];\n    }\n    double f = hVec[m] + Math.sqrt(h);\n    hVec[il] = f <= 0 ? matrixT.getEntry(il, il) * (scale / hVec[m]) : scale * Math.sqrt(h / (hVec[m] + f));\n    for (int i = m + 1; i <= iu; i++) {\n        hVec[i] = -hVec[i];\n    }\n    return start;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = findSmallSubDiagonalElement(il, getNorm());\n    double norm = getNorm();\n    double exShift = shift.exShift;\n    double sigma = 0;\n    if (startIdx > il) {\n        hVec[startIdx - 1] = matrixT.getEntry(startIdx - 1, startIdx - 1) - exShift;\n        for (int i = startIdx; i < iu; i++) {\n            hVec[i] = matrixT.getEntry(i, i);\n            sigma += hVec[i] * hVec[i];\n        }\n        final double f = hVec[startIdx - 1];\n        final double g = f > 0 ? -Math.sqrt(sigma) : Math.sqrt(sigma);\n        if (f > 0) {\n            hVec[startIdx - 1] = f - g;\n        } else {\n            hVec[startIdx - 1] = f + g;\n        }\n        for (int j = startIdx; j < iu; j++) {\n            double t = 0;\n            for (int k = startIdx; k <= j; k++) {\n                t += hVec[k] * matrixT.getEntry(k, j);\n            }\n            double tau = t / hVec[j];\n            for (int k = startIdx; k <= j; k++) {\n                matrixT.addToEntry(k, j, -tau * hVec[k]);\n            }\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = findSmallSubDiagonalElement(il, getNorm());\n    double norm = getNorm();\n    double s = 0;\n    for (int i = startIdx; i <= iu; i++) \n    {\n        s += Math.pow(matrixT.getEntry(i, i), 2);\n    }\n    double f = matrixT.getEntry(startIdx, startIdx) - shift.exShift;\n    double g = matrixT.getEntry(startIdx + 1, startIdx + 1) - shift.exShift;\n    double h = matrixT.getEntry(startIdx + 2, startIdx + 2) - shift.exShift;\n    double t = (f * g - s) / 2.0;\n    double exShift = shift.exShift;\n    double p = (t * t) / (h * norm);\n    double j = 0;\n    for (int i = startIdx + 2; i <= iu; i++) \n    {\n        j += Math.pow(matrixT.getEntry(i, i), 2);\n    }\n    double q = j / norm;\n    double z = Math.sqrt(p * p + q * q);\n    double r = Math.sqrt((p + z) * (p + z) + q * q);\n    double x = p / r;\n    double y = q / r;\n    double d = x * h + y * (t + norm);\n    double exShiftNew = shift.exShift;\n    if (d < 0) \n    {\n        z = p / (r - z);\n        x = x - z;\n        y = y - z;\n        double d1 = x * h + y * (t + norm);\n        if (d1 > 0) \n        {\n            z = p / (r * (r - z));\n            x = x - z;\n            y = y - z;\n        }\n    }\n    shift.x = x;\n    shift.y = y;\n    shift.w = r;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vector\n    final int startIdx = findSmallSubDiagonalElement(il, shift.exShift);\n    final int endIdx = iu - 1;\n    final int length = endIdx - startIdx + 1;\n    final double[] subDiagonal = new double[length];\n    final double[] superDiagonal = new double[length];\n    final double[][] matrix = matrixT.getData();\n    for (int i = 0; i < length; i++) {\n        subDiagonal[i] = matrix[startIdx + i][startIdx + i];\n        superDiagonal[i] = matrix[startIdx + i][startIdx + i + 1];\n    }\n    final double norm = getNorm(subDiagonal, superDiagonal);\n    final double shiftedNorm = norm - shift.exShift;\n    final double scale = 1.0 / shiftedNorm;\n    final double[] scaledSubDiagonal = new double[length];\n    final double[] scaledSuperDiagonal = new double[length];\n    for (int i = 0; i < length; i++) {\n        scaledSubDiagonal[i] = subDiagonal[i] * scale;\n        scaledSuperDiagonal[i] = superDiagonal[i] * scale;\n    }\n    final double[][] houseHolder = new double[length][length];\n    for (int i = 0; i < length; i++) {\n        houseHolder[i][i] = 1.0;\n    }\n    for (int i = 0; i < length; i++) {\n        houseHolder[i][i] -= scaledSubDiagonal[i] * scaledSubDiagonal[i] + scaledSuperDiagonal[i] * scaledSuperDiagonal[i];\n    }\n    for (int i = 0; i < length; i++) {\n        for (int j = i + 1; j < length; j++) {\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Find the start index for the QR step\n    int startIdx = findSmallSubDiagonalElement(il, shift.getExShift());\n    // Initialize the householder vector\n    hVec[startIdx] = 1.0;\n    for (int i = startIdx + 1; i < iu; i++) {\n        hVec[i] = 0.0;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // TODO: implement\n    return 0;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    int endIdx = iu;\n    double[] hVecRef = hVec;\n    while (startIdx < endIdx) {\n        if (Math.abs(matrixT.getEntry(startIdx, startIdx)) <= shift.exShift) {\n            hVecRef[startIdx] = matrixT.getEntry(startIdx, startIdx + 1);\n            hVecRef[startIdx + 1] = matrixT.getEntry(startIdx + 1, startIdx + 1);\n            startIdx++;\n        } else {\n            hVecRef[startIdx] = matrixT.getEntry(startIdx, startIdx);\n            hVecRef[startIdx + 1] = matrixT.getEntry(startIdx + 1, startIdx);\n            startIdx += 2;\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT.getEntry(i, i) - shift.exShift;\n    }\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    return ensureChildNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList());\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    return childNodes.stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList());\n}",
      "public List<TextNode> textNodes()  {\n    return ensureChildNodes().stream()\n            .filter(Node::isTextNode)\n            .map(TextNode.class::cast)\n            .collect(Collectors.toList());\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.inIncludeSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.inIncludeSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.inIncludeSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n        boolean inIncludeSegments = true;\n        for (Segment segment : segments) {\n                if (!segment.inIncludeSegments()) {\n                        inIncludeSegments = false;\n                        break;\n                }\n        }\n        return inIncludeSegments;\n}",
      "public boolean inIncludeSegments()  {\n        // TODO: Implement this method\n        return false;\n    }",
      "public boolean inIncludeSegments()  {\n        return false;\n}",
      "public boolean inIncludeSegments()  {\n        return true;\n}",
      "public boolean inIncludeSegments()  {\n    if (segmentNumber == 0) {\n        return false;\n    }\n    for (Segment segment : segments) {\n        if (!segment.inIncludeSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n        // TODO: Implement this method\n        return false;\n    }",
      "public boolean inIncludeSegments()  {\n    return false;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial and ReadablePeriod objects must have the same set of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    return calculatePeriod(startValues, endValues, zeroValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    return standardPeriodIn(zeroInstance, standardPeriodIn(zeroInstance, startValues, endValues) - standardPeriodIn(zeroInstance, startValues, zeroValues));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be both LocalDate objects\");\n    }\n    LocalDate startDate = (LocalDate) start;\n    LocalDate endDate = (LocalDate) end;\n    return Period.between(startDate, endDate).getDays();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false || zeroInstance instanceof LocalDate == false) {\n        throw new IllegalArgumentException(\"ReadablePartial classes must be consistent\");\n    }\n    LocalDate startDate = (LocalDate) start;\n    LocalDate endDate = (LocalDate) end;\n    LocalDate zeroDate = (LocalDate) zeroInstance;\n    int startValue = startDate.getYear() * 10000 + startDate.getMonthOfYear() * 100 + startDate.getDayOfMonth();\n    int endValue = endDate.getYear() * 10000 + endDate.getMonthOfYear() * 100 + endDate.getDayOfMonth();\n    int zeroValue = zeroDate.getYear() * 10000 + zeroDate.getMonthOfYear() * 100 + zeroDate.getDayOfMonth();\n    return (endValue - startValue) / zeroValue;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false || zeroInstance instanceof LocalDate == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be of the same type\");\n    }\n    LocalDate startDate = (LocalDate) start;\n    LocalDate endDate = (LocalDate) end;\n    LocalDate zeroDate = (LocalDate) zeroInstance;\n    int years = endDate.getYear() - startDate.getYear();\n    int months = endDate.getMonthOfYear() - startDate.getMonthOfYear();\n    int days = endDate.getDayOfMonth() - startDate.getDayOfMonth();\n    if (years != 0) {\n        int startDOW = startDate.getDayOfWeek();\n        int endDOW = endDate.getDayOfWeek();\n        int curStart = startDate.getDayOfMonth();\n        int curEnd = endDate.getDayOfMonth();\n        while (curEnd < curStart) {\n            curEnd += zeroDate.getDaysInMonthMax();\n        }\n        while (curStart > curEnd) {\n            curStart -= zeroDate.getDaysInMonthMax();\n        }\n        if (startDOW <= endDOW) {\n            days += (curEnd - curStart);\n        } else {\n            days -= (curEnd - curStart);\n        }\n    }\n    return years * 12 + months + days / 7;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    int[] minValues = new int[start.size()];\n    int[] maxValues = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        if (startValues[i] < endValues[i]) {\n            minValues[i] = startValues[i];\n            maxValues[i] = endValues[i];\n        } else {\n            minValues[i] = endValues[i];\n            maxValues[i] = startValues[i];\n        }\n    }\n    int[] minZeroValues = new int[start.size()];\n    int[] maxZeroValues = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        if (minValues[i] < zeroValues[i]) {\n            minZeroValues[i] = minValues[i];\n            maxZeroValues[i] = zeroValues[i];\n        } else {\n            minZeroValues[i] = zeroValues[i];\n            maxZeroValues[i] = minValues[i];\n}\n}\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size() || start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    return between(startValues, endValues, zeroValues);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false || zeroInstance instanceof LocalDate == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be same type\");\n    }\n    return ((LocalDate) start).daysUntil((LocalDate) end);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int size = start.size();\n    int[] starts = new int[size];\n    int[] ends = new int[size];\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType fieldType = start.getFieldType(i);\n        if (end.getFieldType(i) != fieldType) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        starts[i] = start.getValue(i);\n        ends[i] = end.getValue(i);\n    }\n    return between(starts, ends, zeroInstance);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start.size() != zeroInstance.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial and ReadablePeriod objects must have the same set of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    int[] zeroValues = new int[zeroInstance.size()];\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeFieldType startField = start.getFieldType(i);\n        DateTimeFieldType endField = end.getFieldType(i);\n        if (startField != endField) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    int[] durations = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        if (startValues[i] != endValues[i]) {\n            if (startValues[i] < endValues[i]) {\n                durations[i] = endValues[i] - startValues[i];\n            } else {\n                durations[i] = endValues[i] + zeroValues[i] - startValues[i];\n            }\n        }\n    }\n    return standardPeriodIn(new ArrayBasedPeriod(durations, start.getChronology()), 1);\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null && this.subtitles.size() > index) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            return (LegendTitle) obj;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n        if (this.subtitles == null) {\n            return null;\n        }\n        int count = 0;\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) {\n                if (count == index) {\n                    return (LegendTitle) title;\n                }\n                count++;\n            }\n        }\n        return null;\n    }",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null && this.subtitles.size() > index) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            return (LegendTitle) obj;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) \n    {\n        return null;\n    }\n    else \n    {\n        int count = 0;\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) \n        {\n            Title title = (Title) iterator.next();\n            if (title instanceof LegendTitle) \n            {\n                if (count == index) \n                {\n                    return (LegendTitle) title;\n                }\n                count++;\n            }\n        }\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n        if (this.subtitles == null) {\n            return null;\n        }\n        else if (index < this.subtitles.size()) {\n            return (LegendTitle) this.subtitles.get(index);\n        }\n        else {\n            return null;\n        }\n    }",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null && index >= 0 && index < this.subtitles.size()) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            return (LegendTitle) obj;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) \n    {\n        return null;\n    }\n    else \n    {\n        int count = 0;\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) \n        {\n            Title title = (Title) iterator.next();\n            if (title instanceof LegendTitle) \n            {\n                if (count == index) \n                {\n                    return (LegendTitle) title;\n                }\n                else \n                {\n                    count++;\n                }\n            }\n        }\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) this.subtitles.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Enumeration<ZipArchiveEntry> allEntries = getEntries();\n    final List<ZipArchiveEntry> entries = new ArrayList<>();\n    while (allEntries.hasMoreElements()) {\n        entries.add(allEntries.nextElement());\n    }\n    Collections.sort(entries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Iterator<ZipArchiveEntry> it = entries.iterator();\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Enumeration<ZipArchiveEntry> e = entries.elements();\n    final List<ZipArchiveEntry> ordered = new ArrayList<ZipArchiveEntry>();\n    while (e.hasMoreElements()) {\n        final ZipArchiveEntry ze = e.nextElement();\n        if (ze.getMethod() == ZipArchiveEntry.STORED) {\n            ordered.add(ze);\n        }\n    }\n    Collections.sort(ordered, offsetComparator);\n    ordered.addAll(entries);\n    return Collections.enumeration(ordered);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Iterator<ZipArchiveEntry> it = entries.iterator();\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Iterator<ZipArchiveEntry> iter = entries.iterator();\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node typeNode = parseAndRecordTypeNode(token, 0, 0, false, true);\n  if (typeNode == null) {\n    return null;\n  }\n  if (match(JsDocToken.ELLIPSIS)) {\n    return newNode(Token.ELLIPSIS, typeNode);\n  } else {\n    return typeNode;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node node = null;\n    if (match(token, JsDocToken.LBRACE)) {\n        token = next();\n        if (match(token, JsDocToken.ELLIPSIS)) {\n            token = next();\n            node = parseAndRecordTypeNode(token, getLineno(), getCharno(), true);\n        } else {\n            node = parseAndRecordTypeNode(token, getLineno(), getCharno(), true, true);\n        }\n        if (match(token, JsDocToken.RBRACE)) {\n            token = next();\n        } else {\n            reportTypeSyntaxWarning(\"Missing closing brace for parameter type expression annotation\");\n        }\n    }\n    return node;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    // Check for the start of a type expression.\n    if (token.type != JsDocToken.LBRACE) {\n        return null;\n    }\n\n    // Consume the opening brace.\n    token = next();\n\n    // Check for the start of an optional parameter type.\n    if (token.type == JsDocToken.IDENTIFIER && token.string.equals(\"...\")) {\n        // Consume the optional parameter type.\n        token = next();\n\n        // Parse the type expression.\n        Node typeNode = parseAndRecordTypeNode(token, -1, -1, false);\n\n        // Check for the end of the type expression.\n        if (token.type != JsDocToken.RBRACE) {\n            return null;\n        }\n\n        // Consume the closing brace.\n        token = next();\n\n        // Return the optional parameter type.\n        return typeNode;\n    }\n\n    // Check for the start of a type expression.\n    if (token.type != JsDocToken.IDENTIFIER) {\n        return null;\n    }\n\n    // Parse the type expression.\n    Node typeNode = parseAndRecordTypeNode(token, -1, -1, false);\n\n    // Check for the end of the type expression.\n    if (token.type != JsDocToken.RBRACE) {\n        return null;\n    }\n\n    // Consume the closing brace.\n    token = next();\n\n    // Return the type expression.\n    return typeNode;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    // TODO(johnlenz): support for '...'\n    // TODO(johnlenz): support for '='\n    return parseTypeExpression(token);\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node typeAst = null;\n    boolean isVarArgs = false;\n    int lineno = getLineno();\n    int startCharno = getCharno();\n    int endCharno = getCharno();\n\n    // Check for the opening brace.\n    if (!match(JsDocToken.LBRACE)) {\n      return null;\n    }\n\n    // Check for the optional parameter type.\n    if (lookAheadForType()) {\n      typeAst = parseAndRecordTypeNode(next(), lineno, startCharno, true, true);\n      if (match(JsDocToken.EQUALS)) {\n        // Consume the equals token.\n        next();\n      } else {\n        reportTypeSyntaxWarning(\"missing-equals-in-optional-parameter-type\");\n      }\n    } else if (match(JsDocToken.ELLIPSIS)) {\n      // Consume the ellipsis token.\n      next();\n      isVarArgs = true;\n    }\n\n    // Check for the closing brace.\n    if (!match(JsDocToken.RBRACE)) {\n      reportTypeSyntaxWarning(\"missing-rbrace-in-parameter-type\");\n    }\n\n    // Return the type node.\n    return newNode(\n        Node.PARAM_TYPE_EXPRESSION_ANNOTATION,\n        typeAst,\n        lineno,\n        startCharno,\n        endCharno,\n        isVarArgs);\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node typeNode = parseAndRecordTypeNode(token, 0, 0, false);\n  if (typeNode == null) {\n    return null;\n  }\n\n  if (match(JsDocToken.ELLIPSIS)) {\n    // Parse a rest parameter.\n    typeNode = newNode(Token.REST, typeNode);\n    token = next();\n  }\n\n  if (match(JsDocToken.EQUALS)) {\n    // Parse an optional parameter.\n    Node defaultValue = parseAndRecordTypeNode(token, 0, 0, false);\n    if (defaultValue == null) {\n      return null;\n    }\n    typeNode = newNode(Token.ASSIGN, typeNode, defaultValue);\n    token = next();\n  }\n\n  if (!match(JsDocToken.RBRACE)) {\n    return null;\n  }\n\n  return typeNode;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node typeNode = parseAndRecordTypeNode(token);\n  if (typeNode == null) {\n    return null;\n  }\n  return typeNode;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node typeAst = null;\n    boolean isVarArgs = false;\n    int lineno = token.lineno;\n    int startCharno = token.charno;\n    JsDocToken nextToken = next();\n    if (match(nextToken, JsDocToken.ELLIPSIS)) {\n        isVarArgs = true;\n        nextToken = next();\n    }\n    if (match(nextToken, JsDocToken.LC)) {\n        typeAst = parseAndRecordTypeNode(nextToken, lineno, startCharno, true);\n        nextToken = next();\n        if (!match(nextToken, JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"missing-r-brace\");\n        }\n    } else {\n        reportTypeSyntaxWarning(\"missing-l-brace\");\n    }\n    if (isVarArgs) {\n        typeAst = newNode(Token.ELLIPSIS, typeAst);\n    }\n    return typeAst;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node node = newNode(Token.PARAM_TYPE_EXPRESSION_ANNOTATION);\n    node.putBooleanProp(Node.IS_PARAMETER_TYPE, true);\n    node.putBooleanProp(Node.IS_VAR_ARGS, false);\n    node.putBooleanProp(Node.IS_OPTIONAL, false);\n\n    // Consume '{'\n    token = next();\n    if (!match(token, JsDocToken.LBRACE)) {\n        reportError(token, \"Expected '{'\");\n        return null;\n    }\n\n    // Parse OptionalParameterType\n    if (lookAheadFor(JsDocToken.EQUAL)) {\n        // Consume '='\n        token = next();\n\n        // Parse TopLevelTypeExpression\n        Node typeAst = parseAndRecordTypeNode(token, -1, -1, false, false);\n        if (typeAst == null) {\n            reportError(token, \"Expected TopLevelTypeExpression\");\n            return null;\n        }\n\n        node.addChildToBack(typeAst);\n        node.putBooleanProp(Node.IS_OPTIONAL, true);\n    } else if (lookAheadFor(JsDocToken.ELLIPSIS)) {\n        // Consume '...'\n        token = next();\n\n        // Parse TopLevelTypeExpression\n        Node typeAst = parseAndRecordTypeNode(token, -1, -1, false, false);\n        if (typeAst == null) {\n            reportError(token, \"Expected TopLevelTypeExpression\");\n            return null;\n        }\n\n        node.addChildToBack(typeAst);\n        node.putBooleanProp(Node.IS_VAR_ARGS, true);\n    } else {\n        // Parse TopLevelTypeExpression\n        Node typeAst = parseAndRecordTypeNode(token, -1, -1, false, false);\n        if (typeAst == null) {\n            reportError(token, \"Expected TopLevelTypeExpression\");\n            return null;\n        }\n\n        node.addChildToBack(typeAst);\n    }\n\n    // Consume '}'\n}\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node typeAst = null;\n    boolean isVarArgs = false;\n    boolean matchingLC = false;\n\n    // Consume the '{' token.\n    token = next();\n\n    if (match(token, JsDocToken.ELLIPSIS)) {\n        isVarArgs = true;\n        token = next();\n    }\n\n    if (match(token, JsDocToken.RBRACE)) {\n        // Empty parameter type expression.\n        return null;\n    }\n\n    if (match(token, JsDocToken.ASSIGN)) {\n        // Optional parameter type expression.\n        typeAst = parseAndRecordTypeNode(next(), -1, -1, matchingLC, false);\n        if (typeAst == null) {\n            // No type expression.\n            return null;\n        }\n    } else {\n        // Top-level parameter type expression.\n        typeAst = parseAndRecordTypeNode(token, -1, -1, matchingLC, false);\n        if (typeAst == null) {\n            // No type expression.\n            return null;\n        }\n    }\n\n    // Consume the '}' token.\n    token = next();\n\n    if (!match(token, JsDocToken.RBRACE)) {\n        // Unexpected token.\n        return null;\n    }\n\n    return newNode(Node.PARAM_TYPE_EXPRESSION_ANNOTATION, typeAst);\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = stackTrace.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>(lines.length);\n    for (final String line : lines) \n    {\n        if (line.startsWith(\"&nbsp;&nbsp;&nbsp;at\")) \n        {\n            list.add(line);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> list = new ArrayList<String>();\n    String stackTrace = getStackTrace(t);\n    String[] lines = stackTrace.split(System.getProperty(\"line.separator\"));\n    for (String line : lines) \n    {\n        if (line.startsWith(\"&nbsp;&nbsp;&nbsp;&nbsp;at\")) \n        {\n            list.add(line);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final List<String> list = new ArrayList<String>();\n    final String[] frames = getStackFrames(stackTrace);\n    for (final String frame : frames) {\n        if (frame.startsWith(\"&nbsp;&nbsp;&nbsp;at\")) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = stackTrace.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>(lines.length);\n    for (final String line : lines) \n    {\n        if (line.startsWith(\"&nbsp;&nbsp;&nbsp;&nbsp;at\")) \n        {\n            list.add(line);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    return getStackFrameList(stackTrace);\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(result);\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_TRUE) {\n        result = \"true\";\n        peeked = PEEKED_NONE;\n    } else if (p == PEEKED_FALSE) {\n        result = \"false\";\n        peeked = PEEKED_NONE;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    return Boolean.parseBoolean(result);\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child : call.getChildren()) {\n      if (child.hasSideEffects()) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check the arguments of the call.\n    for (Node arg : call.getChildren()) {\n        if (arg.mayHaveSideEffects()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // If the call is a method invocation, check the arguments.\n  if (call.getType() == Token.CALL) \n  {\n    // Iterate over the arguments.\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n    {\n      // If the argument has side effects, return true.\n      if (NodeUtil.mayHaveSideEffects(arg)) \n      {\n        return true;\n      }\n    }\n  }\n  \n  // If the call is a property access, check the property.\n  else if (call.getType() == Token.GETPROP) \n  {\n    // If the property has side effects, return true.\n    if (NodeUtil.mayHaveSideEffects(call.getLastChild())) \n    {\n      return true;\n    }\n  }\n  \n  // If the call is a variable reference, check the variable.\n  else if (call.getType() == Token.NAME) \n  {\n    // If the variable has side effects, return true.\n    if (NodeUtil.mayHaveSideEffects(call)) \n    {\n      return true;\n    }\n  }\n  \n  // If the call is a string literal, return false.\n  else if (call.getType() == Token.STRING) \n  {\n    return false;\n  }\n  \n  // If the call is a number literal, return false.\n  else if (call.getType() == Token.NUMBER) \n  {\n    return false;\n  }\n  \n  // If the call is a boolean literal, return false.\n  else if (call.getType() == Token.TRUE || call.getType() == Token.FALSE) \n  {\n    return false;\n  }\n  \n  // If the call is a null literal, return false.\n  else if (call.getType() == Token.NULL) \n  {\n    return false;\n  }\n  \n  // If the call is a regex literal, return false.\n  else if (call.getType() == Token.REGEXP) \n  {\n    return false;\n}\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node child = call.getFirstChild().getNext();\n    while (child != null) {\n        if (child.hasSideEffects()) {\n            return true;\n        }\n        child = child.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getFirstChild().getNext();\n  while (arg != null) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n    if (arg.mayHaveSideEffects()) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Check if the arguments have side effects.\n  for (Node child : call.getChildren()) \n  {\n    if (child.hasSideEffects()) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n        if (arg.mayHaveSideEffects()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node child = call.getFirstChild().getNext();\n    while (child != null) {\n        if (child.hasSideEffects()) {\n            return true;\n        }\n        child = child.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null) {\n        cachedP = createP();\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if (pivot == null) {\n        return null;\n    }\n    final int n = pivot.length;\n    final FieldMatrix<T> p = field.getField().getOne().getField().getMatrix(n, n);\n    for (int i = 0; i < n; ++i) {\n        p.setEntry(pivot[i], i, field.getField().getOne());\n    }\n    return p;\n}",
      "public FieldMatrix<T> getP()  {\n        if (pivot == null) {\n            return null;\n        }\n        final int n = pivot.length;\n        final FieldMatrix<T> p = field.getField().getOne().getField().getMatrixFactory().createFieldMatrix(n, n);\n        for (int i = 0; i < n; ++i) {\n            p.setEntry(i, pivot[i], field.getField().getOne());\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n        if (pivot == null) {\n            return null;\n        }\n        int n = pivot.length;\n        T[][] pData = new T[n][n];\n        for (int i = 0; i < n; ++i) {\n            pData[i][pivot[i]] = field.getOne();\n        }\n        return new Array2DRowFieldMatrix<T>(field, pData, false);\n    }",
      "public FieldMatrix<T> getP()  {\n    if (pivot == null) {\n        return null;\n    }\n    int n = pivot.length;\n    T[][] pData = MathArrays.buildArray(field, n, n);\n    for (int i = 0; i < n; ++i) {\n        pData[i][pivot[i]] = field.getOne();\n    }\n    return new Array2DRowFieldMatrix<T>(pData, false);\n}",
      "public FieldMatrix<T> getP()  {\n        if (pivot == null) {\n            return null;\n        }\n        int n = pivot.length;\n        Field<T> field = field;\n        T[][] pData = new T[n][n];\n        for (int i = 0; i < n; ++i) {\n            pData[i][pivot[i]] = field.getOne();\n        }\n        return new Array2DRowFieldMatrix<T>(field, pData, false);\n    }",
      "public FieldMatrix<T> getP()  {\n    if (singular) {\n        return null;\n    }\n    if (cachedP == null) {\n        cachedP = MatrixUtils.createFieldIdentityMatrix(field).getSubMatrix(pivot, pivot);\n    }\n    return cachedP.copy();\n}",
      "public FieldMatrix<T> getP()  {\n        if (cachedP == null) {\n            if (pivot == null) {\n                throw new IllegalStateException(\"decomposition not computed yet\");\n            }\n            cachedP = createFieldMatrix(field, lu.length, lu.length);\n            for (int i = 0; i < lu.length; ++i) {\n                cachedP.setEntry(pivot[i], i, field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n    if (singular) {\n        return null;\n    }\n    if (cachedP == null) {\n        cachedP = createP();\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null) {\n        if (pivot == null) {\n            return null;\n        }\n        cachedP = createMatrix(field.getZero(), lu.length, lu[0].length);\n        for (int i = 0; i < pivot.length; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP.copy();\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = null;\n    if (data != null) {\n        int size = 0;\n        for (ZipExtraField element : data) {\n            size += element.getLocalFileDataLength().getValue();\n        }\n        result = new byte[size];\n        int offset = 0;\n        for (ZipExtraField element : data) {\n            System.arraycopy(element.getLocalFileDataData(), 0, result, offset, element.getLocalFileDataLength().getValue());\n            offset += element.getLocalFileDataLength().getValue();\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField zipExtraField : data) {\n        byte[] bytes = zipExtraField.getLocalFileDataData();\n        result = Arrays.copyOf(result, result.length + bytes.length);\n        System.arraycopy(bytes, 0, result, result.length - bytes.length, bytes.length);\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        // TODO: Implement this method\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        byte[] result = null;\n        int size = 0;\n        for (ZipExtraField element : data) {\n            size += element.getLocalFileDataLength().getValue();\n        }\n        if (size > 0) {\n            result = new byte[size];\n            int offset = 0;\n            for (ZipExtraField element : data) {\n                System.arraycopy(element.getLocalFileDataData(), 0, result, offset, element.getLocalFileDataLength().getValue());\n                offset += element.getLocalFileDataLength().getValue();\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    int size = 0;\n    for (ZipExtraField e : data) {\n        size += e.getLocalFileDataLength().getValue();\n    }\n    byte[] result = new byte[size];\n    int offset = 0;\n    for (ZipExtraField e : data) {\n        System.arraycopy(e.getLocalFileDataData(), 0, result, offset, e.getLocalFileDataLength().getValue());\n        offset += e.getLocalFileDataLength().getValue();\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = null;\n    for (int i = 0; i < data.length; i++) {\n        byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            if (result == null) {\n                result = local;\n            } else {\n                byte[] tmp = new byte[result.length + local.length];\n                System.arraycopy(result, 0, tmp, 0, result.length);\n                System.arraycopy(local, 0, tmp, result.length, local.length);\n                result = tmp;\n            }\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        byte[] result = new byte[0];\n        for (ZipExtraField field : data) {\n            byte[] fieldData = field.getLocalFileDataData();\n            if (fieldData != null) {\n                result = Arrays.copyOf(result, result.length + fieldData.length);\n                System.arraycopy(fieldData, 0, result, result.length - fieldData.length, fieldData.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<byte[]> dataList = new ArrayList<>();\n    for (final ZipExtraField e : data) {\n        dataList.add(e.getLocalFileDataData());\n    }\n    return merge(dataList);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        byte[] result = null;\n        if (data != null) {\n            int size = 0;\n            for (ZipExtraField element : data) {\n                size += element.getLocalFileDataLength().getValue();\n            }\n            result = new byte[size];\n            int offset = 0;\n            for (ZipExtraField element : data) {\n                byte[] data = element.getLocalFileDataData();\n                System.arraycopy(data, 0, result, offset, data.length);\n                offset += data.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        // TODO: implement\n    }"
    ],
    [
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return getSize() == 0 ? Double.POSITIVE_INFINITY : getBoundary().get(0).getSize();\n    }\n}",
      "public double getSup()  {\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n        return getInf();\n    }",
      "public double getSup()  {\n        if (isEmpty()) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (getTree(true).getCut().getPlus().getCut() == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return getTree(true).getCut().getPlus().getCut().getLocation().getX();\n    }",
      "public double getSup()  {\n    return getSize() == 0 ? Double.NEGATIVE_INFINITY : getBarycenter().getX();\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (getTree(true).getCut().getPlus().getAttribute() == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return getTree(true).getCut().getPlus().getAttribute();\n}",
      "public double getSup()  {\n        if (isEmpty()) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (getTree(true).getCut().getCut().getSize() == 0) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return getTree(true).getCut().getCut().getHigh();\n    }",
      "public double getSup()  {\n    return getSize() == 0 ? Double.NEGATIVE_INFINITY : getTree(true).getAttribute().getInf();\n}",
      "public double getSup()  {\n        return getSize() == 0 ? Double.NEGATIVE_INFINITY :\n            getSize() == 1 ? getBoundary().get(0).getInf() :\n            getBoundary().get(getSize() - 1).getInf();\n    }",
      "public double getSup()  {\n        if (getSize() == 0) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.reset();\n    boolean isEscaped = false;\n    while (ch != Lexer.DISABLED) {\n        if (isEscaped) {\n            token.content.append(delimiter);\n            isEscaped = false;\n        } else if (isEscape(ch)) {\n            isEscaped = true;\n        } else if (isDelimiter(ch)) {\n            token.type = Token.Type.TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = Token.Type.EOF;\n            return token;\n        } else if (isEndOfLine(ch)) {\n            token.type = Token.Type.EORECORD;\n            return token;\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // read until the end of the line\n    while (ch != -1 && ch != delimiter && ch != '\\r' && ch != '\\n') {\n        if (ch == escape) {\n            ch = readEscape();\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n\n    // check for end of line\n    if (ch == '\\r' || ch == '\\n') {\n        token.type = Token.Type.EORECORD;\n    } else if (ch == -1) {\n        token.type = Token.Type.EOF;\n    } else {\n        token.type = Token.Type.TOKEN;\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // first character is delimiter, so token is empty\n    if (isDelimiter(ch)) \n    {\n        token.type = Token.Type.TOKEN;\n        token.isReady = true;\n        return token;\n    }\n\n    // first character is comment start, so token is empty\n    if (isCommentStart(ch)) \n    {\n        token.type = Token.Type.TOKEN;\n        token.isReady = true;\n        return token;\n    }\n\n    // first character is quote, so token is quoted\n    if (isQuoteChar(ch)) \n    {\n        token.type = Token.Type.QUOTED;\n        return parseEncapsulatedToken(token);\n    }\n\n    // first character is whitespace, so token is empty\n    if (isWhitespace(ch)) \n    {\n        token.type = Token.Type.TOKEN;\n        token.isReady = true;\n        return token;\n    }\n\n    // first character is not a delimiter, comment start, quote or whitespace\n    token.type = Token.Type.TOKEN;\n    token.content.append((char) ch);\n\n    // read until end of line, end of stream or unescaped delimiter\n    while ((ch = read()) != -1) \n    {\n        // end of line\n        if (isEndOfLine(ch)) \n        {\n            token.type = Token.Type.EORECORD;\n            token.isReady = true;\n            return token;\n        }\n\n        // end of stream\n        if (isEndOfFile(ch)) \n        {\n            token.type = Token.Type.EOF;\n            token.isReady = true;\n            return token;\n        }\n\n        // unescaped delimiter\n        if (isDelimiter(ch)) \n        {\n            token.type = Token.Type.TOKEN;\n            token.isReady = true;\n            return token;\n        }\n\n        // escaped delimiter\n        if (isEscape(ch)) \n        {\n            ch = readEscape();\n}\n}\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // first character of the token\n    token.reset();\n    token.type = Token.Type.TOKEN;\n    token.content.append((char) ch);\n\n    // token is finished when one of the following conditions become true:\n    // end of line has been reached (EORECORD)\n    // end of stream has been reached (EOF)\n    // an unescaped delimiter has been reached (TOKEN)\n    while (true) {\n        ch = reader.read();\n        if (ch == -1) {\n            token.type = Token.Type.EOF;\n            break;\n        } else if (isEndOfFile(ch)) {\n            token.type = Token.Type.EOF;\n            break;\n        } else if (isDelimiter(ch)) {\n            token.type = Token.Type.TOKEN;\n            break;\n        } else if (isEscape(ch)) {\n            ch = readEscape();\n            token.content.append((char) ch);\n        } else {\n            token.content.append((char) ch);\n        }\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder buffer = token.content;\n    boolean eol = false;\n    boolean eof = false;\n    boolean isEscape = false;\n    boolean isDelimiter = false;\n    boolean isCommentStart = false;\n    boolean isMetaChar = false;\n    boolean isQuoteChar = false;\n    boolean isEndOfFile = false;\n    boolean isStartOfLine = false;\n    boolean isWhitespace = false;\n    boolean isClosed = false;\n    while (!eol && !eof && !isEscape && !isDelimiter && !isCommentStart && !isMetaChar && !isQuoteChar && !isEndOfFile && !isStartOfLine && !isWhitespace && !isClosed) \n    {\n        if (isEndOfFile(ch)) \n        {\n            eof = true;\n        } \n        else if (isEscape(ch)) \n        {\n            isEscape = true;\n        } \n        else if (isDelimiter(ch)) \n        {\n            isDelimiter = true;\n        } \n        else if (isCommentStart(ch)) \n        {\n            isCommentStart = true;\n        } \n        else if (isMetaChar(ch)) \n        {\n            isMetaChar = true;\n        } \n        else if (isQuoteChar(ch)) \n        {\n            isQuoteChar = true;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            isEndOfFile = true;\n        } \n        else if (isStartOfLine(ch)) \n        {\n            isStartOfLine = true;\n        } \n        else if (isWhitespace(ch)) \n        {\n            isWhitespace = true;\n        } \n        else if (isClosed()) \n        {\n            isClosed = true;\n        } \n        else \n        {\n            buffer.append((char) ch);\n        }\n        if (!isEscape && !isClosed) \n        {\n            ch = read();\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.reset();\n    boolean isEscaped = false;\n    boolean isQuoted = false;\n    boolean isEscapedQuote = false;\n    boolean isEscapedDelimiter = false;\n    boolean isEscapedCommentStart = false;\n    boolean isEscapedCommentEnd = false;\n    boolean isEscapedMetaChar = false;\n    boolean isEscapedEscaped = false;\n    boolean isEscapedDisabled = false;\n    boolean isEscapedEol = false;\n    boolean isEscapedEof = false;\n    boolean isEscapedEscapedEol = false;\n    boolean isEscapedEscapedEof = false;\n    boolean isEscapedEscapedMetaChar = false;\n    boolean isEscapedEscapedDisabled = false;\n    boolean isEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n    boolean isEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscapedEscaped = false;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.reset();\n    token.type = Token.Type.TOKEN;\n    boolean escaped = false;\n    while (ch != -1) {\n        if (isDelimiter(ch)) {\n            if (!escaped) {\n                break;\n            }\n            escaped = false;\n        } else if (isEscape(ch)) {\n            escaped = !escaped;\n        } else if (isQuoteChar(ch)) {\n            throw new IOException(\"Unexpected quote char '\" + ch + \"'\");\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.reset();\n    token.type = Token.Type.TOKEN;\n    boolean escaped = false;\n    while (ch != -1) {\n        if (ch == this.delimiter && !escaped) {\n            token.type = Token.Type.TOKEN;\n            return token;\n        }\n        if (ch == this.escape) {\n            escaped = !escaped;\n        } else {\n            escaped = false;\n        }\n        token.content.append((char) ch);\n        ch = this.reader.read();\n    }\n    token.type = Token.Type.EOF;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.reset();\n    token.type = Token.Type.TOKEN;\n    boolean isEscaped = false;\n    while (ch != -1 && !isEndOfFile(ch)) {\n        if (isDelimiter(ch) && !isEscaped) {\n            token.isReady = true;\n            return token;\n        }\n        if (isEscape(ch) && !isEscaped) {\n            isEscaped = true;\n        } else {\n            isEscaped = false;\n            token.content.append((char) ch);\n        }\n        ch = read();\n    }\n    token.isReady = true;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder buffer = token.content;\n    boolean isEscaped = false;\n    boolean isEol = false;\n    while (!isEol && !isEndOfFile(ch)) {\n        if (!isEscaped && isDelimiter(ch)) {\n            // We are at the end of the token\n            token.type = Token.Type.TOKEN;\n            return token;\n        }\n        if (!isEscaped && isEscape(ch)) {\n            // The next character is escaped\n            isEscaped = true;\n        } else {\n            if (!isEscaped && isEndOfLine(ch)) {\n                // We are at the end of the line\n                token.type = Token.Type.EORECORD;\n                isEol = true;\n            } else {\n                buffer.append((char) ch);\n            }\n            isEscaped = false;\n        }\n        ch = reader.read();\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                      index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = dimension - 1;\n    while (i >= 0) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n        i--;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(LocalizedFormats.INDEX_OUT_OF_RANGE_SIMPLE,\n                                      index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = (index / uniCounterOffset[i]) % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, index, 0, getSize() - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        c[i] = index / uniCounterOffset[i];\n        index -= c[i] * uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.INDEX_OUT_OF_RANGE_SIMPLE, index, 0, getSize() - 1);\n    }\n\n    int[] counts = new int[dimension];\n    int currentIndex = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = currentIndex / uniCounterOffset[i];\n        currentIndex = currentIndex % uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(LocalizedFormats.INDEX_NOT_IN_RANGE_SIMPLE, index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = (index / uniCounterOffset[i]) % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                      index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int index2 = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index2 / uniCounterOffset[i];\n        index2 -= counts[i] * uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, index, 0, getSize() - 1);\n    }\n    int[] c = new int[dimension];\n    int m = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        c[i] = m / uniCounterOffset[i];\n        m = m % uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                      index, 0, getSize() - 1);\n    }\n\n    int[] counts = new int[getDimension()];\n    int m = 1;\n    for (int i = getDimension() - 1; i >= 0; i--) {\n        counts[i] = index / m;\n        index = index % m;\n        m *= size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n                                      index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = (index / uniCounterOffset[i]) % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(LocalizedFormats.INDEX_NOT_IN_RANGE_SIMPLE,\n                                      index, 0, getSize() - 1);\n    }\n    int[] counts = new int[getDimension()];\n    for (int i = 0; i < getDimension(); i++) {\n        counts[i] = (index / uniCounterOffset[i]) % size[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer head = this;\n    while (head._nextSegment != null) \n    {\n        head = head._nextSegment;\n    }\n    return head;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) \n    {\n        return this;\n    } \n    else \n    {\n        return _nextSegment.last();\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer head = _head;\n    return (head == null) ? this : head.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer head = this;\n    while (head._nextSegment != null) \n    {\n        head = head._nextSegment;\n    }\n    return head;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) \n    {\n        return this;\n    } \n    else \n    {\n        return _nextSegment.last();\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) \n    {\n        current = current._nextSegment;\n    }\n    return current;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n        while (read > -1) {\n            digest.update(buffer, 0, read);\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n        }\n\n        return digest;\n    }",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // clone() is covariant\n            T clone = (T) cls.getDeclaredMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // clone() is not generic\n            T result = (T) cls.getMethod(\"clone\").invoke(obj);\n            return result;\n        } catch (NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + cls.getName() +\n                    \" has no clone() method\", ex);\n        } catch (IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cannot clone Cloneable type \" +\n                    cls.getName(), ex);\n        } catch (java.lang.reflect.InvocationTargetException ex) {\n            throw new CloneFailedException(\"Exception cloning Cloneable type \" +\n                    cls.getName(), ex.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return cls.cast(clone.invoke(obj));\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"clone method not found\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"clone method not accessible\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"clone method invocation failed\", ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            return (T) cls.getMethod(\"clone\").invoke(obj);\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return cls.cast(clone.invoke(obj));\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + cls.getName() + \" has no clone() method\");\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cannot clone Cloneable type \" + cls.getName(), ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Exception cloning Cloneable type \" + cls.getName(), ex.getCause());\n        }\n    }\n    throw new CloneFailedException(\"The object is not Cloneable\");\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return cls.cast(clone.invoke(obj));\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"clone method not found: \" + cls, ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"clone method was found but could not be invoked: \" + cls, ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"clone method was found but could not be invoked: \" + cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T clone = (T) cls.newInstance();\n            return clone;\n        } catch (InstantiationException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + cls.getName() + \" has no nullary constructor\");\n        } catch (IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cloneable type \" + cls.getName() + \" does not permit nullary constructor\");\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getType() != SymbolType.FUNCTION) {\n    return null;\n  }\n  FunctionType functionType = sym.getFunctionType();\n  for (Symbol parameter : functionType.getParameters()) {\n    if (parameter.getName().equals(paramName)) {\n      return parameter;\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n  FunctionType fnType = sym.getFunctionType();\n  for (String param : fnType.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return sym.getScope().getQualifiedSlot(param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() != null) {\n    for (Symbol param : sym.getFunctionType().getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  Preconditions.checkArgument(sym.isFunction());\n  Preconditions.checkNotNull(paramName);\n  if (sym.getFunctionType().getParameters().isEmpty()) {\n    return null;\n  }\n  FunctionType fn = sym.getFunctionType();\n  for (int i = 0; i < fn.getParameters().size(); i++) {\n    if (fn.getParameters().get(i).getName().equals(paramName)) {\n      return fn.getParameters().get(i);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getType() != SymbolType.FUNCTION) {\n    return null;\n  }\n\n  FunctionType fn = sym.getFunctionType();\n  if (fn == null) {\n    return null;\n  }\n\n  for (Symbol param : fn.getParameters()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  // Find the function definition node.\n  Node defNode = sym.getDeclaration().getNode();\n  if (defNode == null) {\n    return null;\n  }\n\n  // Find the parameter node.\n  Node paramNode = null;\n  for (Node child = defNode.getFirstChild().getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    if (child.getType() == Token.NAME &&\n        child.getString().equals(paramName)) {\n      paramNode = child;\n      break;\n    }\n  }\n\n  if (paramNode == null) {\n    return null;\n  }\n\n  // Find the Symbol for the parameter.\n  Symbol paramSym = getSymbolDeclaredBy(paramNode);\n  if (paramSym == null) {\n    return null;\n  }\n\n  return paramSym;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() != null) {\n    for (Symbol param : sym.getFunctionType().getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  Preconditions.checkNotNull(sym);\n  Preconditions.checkNotNull(paramName);\n\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n\n  for (Symbol param : sym.getFunctionType().getParameters()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() != null) {\n    for (Symbol param : sym.getFunctionType().getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getType() != SymbolType.FUNCTION) {\n    return null;\n  }\n\n  FunctionType functionType = sym.getFunctionType();\n  if (functionType == null) {\n    return null;\n  }\n\n  for (String param : functionType.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return sym.getScope().getQualifiedSlot(param);\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix covariance = matrix.subtract(matrix.getRowVector(0));\n        covariance = covariance.scalarMultiply(1 / (n - 1));\n        covariance = covariance.multiply(covariance.transpose());\n        if (biasCorrected) {\n            covariance = covariance.scalarMultiply((n - 1) / n);\n        }\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getColumnDimension();\n    RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnVector(0).scalarMultiply(1.0 / n)).transpose()\n            .multiply(matrix.subtract(matrix.getColumnVector(0).scalarMultiply(1.0 / n)));\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarMultiply((n - 1) / n);\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = matrix.copy();\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double covariance = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    RealMatrix m = matrix.subtract(matrix.getColumnVector(0).scalarMultiply(1 / matrix.getColumnDimension()));\n    return m.multiply(m.transpose()).scalarMultiply(1 / (m.getColumnDimension() - (biasCorrected ? 1 : 0)));\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getColumnDimension();\n    RealMatrix covariance = matrix.subtract(matrix.getRowVector(0).outerProduct(matrix.getColumnVector(0)));\n    if (biasCorrected) {\n        covariance = covariance.scalarMultiply(n/(n-1.0));\n    }\n    return covariance;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        final int nCols = matrix.getColumnDimension();\n        final RealMatrix cov = matrix.getSubMatrix(0, matrix.getRowDimension() - 1, 0, nCols - 1);\n        final double factor = biasCorrected ? (nCols - 1) / (nCols) : 1;\n        return cov.scalarMultiply(factor);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if sufficient data is available\n    checkSufficientData(matrix);\n\n    // Compute covariance matrix\n    RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnVector(0).scalarMultiply(1 / matrix.getColumnDimension()));\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1 / (matrix.getRowDimension() - 1));\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1 / matrix.getRowDimension());\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int nCols = matrix.getColumnDimension();\n    final RealMatrix cov = matrix.subtract(matrix.getRowVector(0).outerProduct(matrix.getColumnVector(0)));\n    return cov.scalarMultiply(1.0 / (nCols - (biasCorrected ? 1.0 : 0.0)));\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int n = matrix.getColumnDimension();\n    final RealMatrix m = matrix.subtract(matrix.getColumnVector(0).scalarMultiply(1.0 / n));\n    final RealMatrix covariance = m.transpose().multiply(m);\n    if (biasCorrected) {\n        covariance.scalarMultiply(1.0 / (n - 1));\n    } else {\n        covariance.scalarMultiply(1.0 / n);\n    }\n    return covariance;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int n = matrix.getColumnDimension();\n    final RealMatrix m = matrix.subtract(matrix.getColumnMeans());\n    final RealMatrix cov = m.transpose().multiply(m);\n    if (biasCorrected) {\n        cov.scalarMultiply(1.0 / (n - 1));\n    } else {\n        cov.scalarMultiply(1.0 / n);\n    }\n    return cov;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n    if (count > bitsCachedSize) {\n        if (!ensureCache(count)) {\n            return -1;\n        }\n    }\n    final long mask = MASKS[count];\n    final long bits = bitsCached & mask;\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (count > 32) {\n        return processBitsGreater57(count);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    final long mask = MASKS[count - 1];\n    final long result = bitsCached & mask;\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n    if (count == 63) {\n        return processBitsGreater57(count);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be a positive number not bigger than 63\");\n    }\n    if (count > bitsAvailable()) {\n        return -1;\n    }\n    long bits = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) {\n        if (bitsCachedSize < count - bitsRead) {\n            bits |= (bitsCached & MASKS[bitsCachedSize]) << bitsRead;\n            bitsCachedSize = 0;\n            bitsCached = 0;\n            bitsRead += bitsCachedSize;\n        } else {\n            bits |= (bitsCached & MASKS[count - bitsRead]) << bitsRead;\n            bitsCachedSize -= count - bitsRead;\n            bitsCached = bitsCached >> (count - bitsRead);\n            bitsRead = count;\n        }\n    }\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n    if (count == 63) {\n        return processBitsGreater57(count);\n    }\n    if (ensureCache(count)) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Invalid number of bits to read: \" + count);\n    }\n    if (count > 32) {\n        return processBitsGreater57(count);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    final long mask = MASKS[count - 1];\n    final long result = bitsCached & mask;\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    if (ensureCache(count)) {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return -1;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        if (v == null) {\n            throw new NullArgumentException();\n        }\n        if (v.getDimension() != this.getDimension()) {\n            throw new DimensionMismatchException(v.getDimension(), this.getDimension());\n        }\n        final T[][] data = new T[this.getDimension()][v.getDimension()];\n        for (int i = 0; i < this.getDimension(); i++) {\n            final T[] dataI = data[i];\n            final T[] vData = v.getDataRef();\n            for (int j = 0; j < v.getDimension(); j++) {\n                dataI[j] = this.getEntry(i).multiply(vData[j]);\n            }\n        }\n        return new Array2DRowFieldMatrix<T>(data, false);\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int nRows = this.getDimension();\n    final int nCols = v.getDimension();\n    final T[][] data = MathArrays.buildArray(field, nRows, nCols);\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = this.getEntry(i).multiply(v.getEntry(j));\n        }\n    }\n    return new Array2DRowFieldMatrix<T>(data, false);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int nRows = this.getDimension();\n    final int nCols = v.getDimension();\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    T[][] data = new T[this.getDimension()][v.getDimension()];\n    for (int i = 0; i < this.getDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            data[i][j] = this.getEntry(i).multiply(v.getEntry(j));\n        }\n    }\n    return new Array2DRowFieldMatrix<T>(data, false);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    if (v.getDimension() != this.getDimension()) {\n        throw new DimensionMismatchException(v.getDimension(), this.getDimension());\n    }\n    final T[][] data = MathArrays.buildArray(field, v.getDimension(), this.getDimension());\n    for (int i = 0; i < v.getDimension(); ++i) {\n        for (int j = 0; j < this.getDimension(); ++j) {\n            data[i][j] = field.multiply(v.getEntry(i), this.getEntry(j));\n        }\n    }\n    return new Array2DRowFieldMatrix<T>(field, data, false);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int nRows = this.getDimension();\n    int nCols = v.getDimension();\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        int nRows = v.getDimension();\n        int nCols = this.getDimension();\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int nRows = data.length;\n    int nCols = v.data.length;\n    T[][] d = MathArrays.buildArray(field, nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            d[i][j] = data[i].multiply(v.data[j]);\n        }\n    }\n    return new Array2DRowFieldMatrix<T>(field, d, false);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int nRows = data.length;\n    int nCols = v.getDimension();\n    FieldMatrix<T> m = createMatrix(nRows, nCols);\n    for (int i = 0; i < nRows; ++i) {\n        for (int j = 0; j < nCols; ++j) {\n            m.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return m;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    if (v == null) {\n        throw new NullArgumentException();\n    }\n    if (v.getDimension() != this.getDimension()) {\n        throw new DimensionMismatchException(v.getDimension(), this.getDimension());\n    }\n    final int nRows = this.getDimension();\n    final int nCols = v.getDimension();\n    final T[][] data = MathArrays.buildArray(field, nRows, nCols);\n    for (int i = 0; i < nRows; i++) {\n        final T[] dataI = data[i];\n        final T[] vData = v.getDataRef();\n        for (int j = 0; j < nCols; j++) {\n            dataI[j] = field.multiply(this.getEntry(i), vData[j]);\n        }\n    }\n    return new Array2DRowFieldMatrix<T>(data, false);\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (target.getType() == Token.LABEL) {\n      if (label == null) {\n        return true;\n      }\n      return label.equals(target.getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  return labelNode != null && labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = target.getFirstChild();\n    return labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (target.isLabel())  {\n    return target.getString().equals(label);\n  }\n  return true;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.getType() == Token.LABEL) {\n    return target.getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = target.getFirstChild();\n    if (labelNode.getType() == Token.LABEL_NAME) {\n        return labelNode.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = target.getFirstChild();\n    if (labelNode == null || labelNode.getType() != Token.LABEL) {\n        return false;\n    }\n    String labelName = labelNode.getString();\n    return labelName.equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (target == null)  {\n    return true;\n  }\n\n  if (target.getType() == Token.LABEL)  {\n    return label == null || label.equals(target.getString());\n  }\n\n  return matchLabel(target.getParent(), label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return matchLabel(target, label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (target == null || label == null) {\n      return true;\n    }\n    return target.getFirstChild().getString().equals(label);\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    return (String) this.urlSeries.get(series).get(item);\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries == null) {\n        return null;\n    }\n    if (series < 0 || series >= this.urlSeries.size()) {\n        return null;\n    }\n    List urls = (List) this.urlSeries.get(series);\n    if (item < 0 || item >= urls.size()) {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries != null && series < this.urlSeries.size()) {\n        List urls = (List) this.urlSeries.get(series);\n        if (item < urls.size()) {\n            return (String) urls.get(item);\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries == null) \n    {\n        return null;\n    }\n    else if (this.urlSeries.size() > series) \n    {\n        List seriesList = (List) this.urlSeries.get(series);\n        if (seriesList.size() > item) \n        {\n            return (String) seriesList.get(item);\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries != null) {\n        if (series < this.urlSeries.size()) {\n            List urls = (List) this.urlSeries.get(series);\n            if (item < urls.size()) {\n                return (String) urls.get(item);\n            }\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries == null) \n    {\n        return null;\n    }\n    else \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls == null) \n        {\n            return null;\n        }\n        else \n        {\n            return (String) urls.get(item);\n        }\n    }\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries == null) \n    {\n        return null;\n    }\n    else \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls == null) \n        {\n            return null;\n        }\n        else \n        {\n            return (String) urls.get(item);\n        }\n    }\n}",
      "public String getURL(int series, int item)  {\n    if (this.urlSeries == null) {\n        return null;\n    }\n    List<String> urls = this.urlSeries.get(series);\n    if (urls == null) {\n        return null;\n    }\n    return urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    return this.urlSeries.get(series).get(item);\n}",
      "public String getURL(int series, int item)  {\n    return (String) this.urlSeries.get(series).get(item);\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty String\");\n    }\n    if (str.charAt(0) != '[' || str.charAt(len - 1) != ']') {\n        throw new IllegalArgumentException(\"Expected array index\");\n    }\n    int expLen = len - 2;\n    if (expLen == 0) {\n        return 0;\n    }\n    int index = 0;\n    for (int i = 0; i < expLen; i++) {\n        char ch = str.charAt(i + 1);\n        if (ch < '0' || ch > '9') {\n            throw new IllegalArgumentException(\"Expected array index\");\n        }\n        index = index * 10 + (ch - '0');\n    }\n    return index;\n}\n\nprotected final static JsonPointer _parseTail(String input) \n{\n    int i = 0;\n    int len = input.length();\n    StringBuilder sb = new StringBuilder(len);\n    while (i < len) {\n        char ch = input.charAt(i);\n        if (ch == '~') {\n            if (i + 1 == len) {\n                throw new IllegalArgumentException(\"Unexpected end of input\");\n            }\n            char ch2 = input.charAt(i + 1);\n            if (ch2 == '/' || ch2 == '~') {\n                sb.append(ch2);\n                i += 2;\n                continue;\n            }\n            if (ch2 == '0') {\n                if (i + 2 < len && input.charAt(i + 2) == '0') {\n                    sb.append(ch2);\n                    i += 3;\n                    continue;\n                }\n            }\n            throw new IllegalArgumentException(\"Unexpected character\");\n        }\n        if (ch == '/') {\n            return _parseQuotedTail(input, i + 1);\n        }\n        sb.append(ch);\n        i++;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int value = c - '0';\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        value = value * 10 + (c - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int i = input.indexOf(SEPARATOR);\n    if (i < 0) {\n        return _parseQuotedTail(input, 0);\n    }\n    int matchIndex = _parseIndex(input.substring(0, i));\n    if (matchIndex >= 0) {\n        return _parseQuotedTail(input.substring(i+1), matchIndex);\n    }\n    return _parseQuotedTail(input.substring(i+1), 0);\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int matchIndex) \n{\n    if (input.length() == 0) {\n        return new JsonPointer(input, null, matchIndex, null);\n    }\n    int i = input.indexOf(SEPARATOR);\n    if (i < 0) {\n        return new JsonPointer(input, input, matchIndex, null);\n    }\n    return new JsonPointer(input, input.substring(0, i), matchIndex, _parseQuotedTail(input.substring(i+1), 0));\n}\n\nprotected JsonPointer _constructHead() \n{\n    return _constructHead(0, null);\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    if (suffixLength == 0) {\n        return this;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf(']');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Invalid array index value: \" + str);\n    }\n    String numStr = str.substring(0, ix);\n    int index = Integer.parseInt(numStr);\n    return index;\n}\n\nprotected JsonPointer _parseTail(String input)\n{\n    int ix = input.indexOf('/');\n    if (ix < 0) {\n        return null;\n    }\n    String segment = input.substring(0, ix);\n    String remaining = input.substring(ix+1);\n    JsonPointer next = _parseTail(remaining);\n    return new JsonPointer(input, segment, next);\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i)\n{\n    int ix = input.indexOf('\"', i);\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Unterminated quoted value\");\n    }\n    String segment = input.substring(i, ix);\n    String remaining = input.substring(ix+1);\n    JsonPointer next = _parseTail(remaining);\n    return new JsonPointer(input, segment, next);\n}\n\nprotected JsonPointer _constructHead()\n{\n    JsonPointer head = _head;\n    if (head == null) {\n        head = _head = new JsonPointer(null, null, null);\n    }\n    return head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last)\n{\n    JsonPointer head = _head;\n    if (head == null) {\n        head = _head = new JsonPointer(null, null, last);\n    } else {\n        head = _head = new JsonPointer(null, null, suffixLength, last);\n    }\n    return head;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty String\");\n    }\n    int ch = str.charAt(0);\n    if (ch < INT_0 || ch > INT_9) {\n        throw new IllegalArgumentException(\"Expected digit, got \" + ch);\n    }\n    int value = ch - INT_0;\n    for (int i = 1; i < len; ++i) {\n        ch = str.charAt(i);\n        if (ch < INT_0 || ch > INT_9) {\n            throw new IllegalArgumentException(\"Expected digit, got \" + ch);\n        }\n        value = value * 10 + (ch - INT_0);\n    }\n    return value;\n}\n\nprotected final JsonPointer _constructHead()\n{\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment._constructHead();\n}\n\nprotected final JsonPointer _constructHead(int suffixLength, JsonPointer last)\n{\n    if (_nextSegment == null) {\n        return last;\n    }\n    return _nextSegment._constructHead(suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf('[');\n    if (ix < 0) {\n        return -1;\n    }\n    return Integer.parseInt(str.substring(ix+1, str.length()-1));\n}\n\nprotected final JsonPointer _constructHead() \n{\n    if (_head == null) {\n        _head = _constructHead(0, this);\n    }\n    return _head;\n}\n\nprotected final JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    if (suffixLength == 0) {\n        return last;\n    }\n    JsonPointer prev = _nextSegment;\n    if (prev == null) {\n        return last;\n    }\n    return prev._constructHead(suffixLength-1, last);\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    if (input.startsWith(\"/\")) {\n        return _parseQuotedTail(input, 1);\n    }\n    return _parseQuotedTail(input, 0);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) \n{\n    int len = input.length();\n    StringBuilder sb = new StringBuilder(len);\n    int ix = i;\n    while (ix < len) {\n        char c = input.charAt(ix++);\n        if (c == '~') {\n            if (ix >= len) {\n                throw new IllegalArgumentException(\"Unexpected end-of-string in pointer expression\");\n            }\n            c = input.charAt(ix++);\n            if (c == '0') {\n                sb.append('/');\n            } else if (c == '1') {\n                sb.append('~');\n            } else {\n                throw new IllegalArgumentException(\"Unexpected escape sequence in pointer expression\");\n            }\n        } else {\n            sb.append(c);\n        }\n    }\n    return JsonPointer.valueOf(sb.toString());\n}\n\n/*\n/**********************************************************\n/* Public API, accessors\n/**********************************************************",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Expected array index\");\n    }\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        throw new IllegalArgumentException(\"Expected array index\");\n    }\n    int value = ch - '0';\n    for (int i = 1; i < len; ++i) {\n        ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            throw new IllegalArgumentException(\"Expected array index\");\n        }\n        value = value * 10 + (ch - '0');\n    }\n    return value;\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    int len = input.length();\n    if (len == 0) {\n        return EMPTY;\n    }\n    int i = 0;\n    char ch = input.charAt(i);\n    if (ch == SEPARATOR) {\n        i++;\n        if (i == len) {\n            throw new IllegalArgumentException(\"Unexpected end-of-string\");\n        }\n        ch = input.charAt(i);\n    }\n    if (ch == '~') {\n        i++;\n        if (i == len) {\n            throw new IllegalArgumentException(\"Unexpected end-of-string\");\n        }\n        ch = input.charAt(i);\n        if (ch == '0') {\n            return _parseTail(input.substring(i + 1));\n        }\n        if (ch == '1') {\n            return _parseQuotedTail(input.substring(i + 1), 1);\n        }\n        throw new IllegalArgumentException(\"Unexpected tilde escape\");\n    }\n    int end = i;\n    while (i < len) {\n        ch = input.charAt(i);\n        if (ch == SEPARATOR) {\n            break;\n        }\n        if (ch == '~') {\n            i++;\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int value = c - '0';\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        value = value * 10 + (c - '0');\n    }\n    return value;\n}\n\nprotected final JsonPointer _constructHead()\n{\n    JsonPointer head = _head;\n    if (head == null) {\n        head = _head = _constructHead(0, this);\n    }\n    return head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last)\n{\n    String str = _asString;\n    int len = str.length();\n    if (len == 0) {\n        return last;\n    }\n    int end = len - suffixLength;\n    if (end < 0) {\n        return last;\n    }\n    int i = end - 1;\n    for (; i >= 0; --i) {\n        char c = str.charAt(i);\n        if (c == '/') {\n            break;\n        }\n    }\n    if (i < 0) {\n        return last;\n    }\n    return new JsonPointer(str.substring(0, i), str.substring(i + 1), suffixLength, last);\n}\n\nprotected static JsonPointer _parseTail(String input)\n{\n    int i = input.indexOf('/');\n    if (i < 0) {\n        return _parseQuotedTail(input, 0);\n    }\n    return new JsonPointer(input, input.substring(i + 1), _parseTail(input.substring(i + 1)));\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i)\n{\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int result = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        if (result >= Integer.MAX_VALUE / 10) {\n            return -1;\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int result = 0;\n    for (int i = 0; i < len; ++i) {\n        char ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            return -1;\n        }\n        result = (result * 10) + (ch - '0');\n    }\n    return result;\n}\n\nprotected final JsonPointer _constructHead()\n{\n    JsonPointer head = _head;\n    if (head == null) {\n        head = _head = _constructHead(0, this);\n    }\n    return head;\n}\n\nprotected final JsonPointer _constructHead(int suffixLength, JsonPointer last)\n{\n    if (suffixLength == 0) {\n        return last;\n    }\n    if (suffixLength == 1) {\n        return this;\n    }\n    JsonPointer[] segments = new JsonPointer[suffixLength];\n    for (int i = 0; i < suffixLength; ++i) {\n        segments[i] = this;\n    }\n    return new JsonPointer(segments);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int ix = 0;\n    char c = str.charAt(0);\n    if (c == '0') {\n        return -1;\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int value = c - '0';\n    for (ix = 1; ix < len; ++ix) {\n        c = str.charAt(ix);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        value = value * 10 + (c - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int ix = 0;\n    int end = input.length();\n    int sepCount = 0;\n    while (ix < end) {\n        char c = input.charAt(ix);\n        if (c == SEPARATOR) {\n            ++sepCount;\n            if (sepCount == 2) {\n                break;\n            }\n        }\n        ++ix;\n    }\n    if (sepCount == 0) {\n        return _parseQuotedTail(input, ix);\n    }\n    String str = input.substring(0, ix);\n    String segment = str.substring(1);\n    int matchIndex = _parseIndex(segment);\n    if (matchIndex >= 0) {\n        return new JsonPointer(str, segment, matchIndex, _parseTail(input.substring(ix + 1)));\n    }\n    return new JsonPointer(str, segment, _parseTail(input.substring(ix + 1)));\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int ix) \n{\n    int end = input.length();\n    StringBuilder sb = new StringBuilder(end);\n    while (ix < end) {\n        char c = input.charAt(ix);\n        if (c == SEPARATOR) {\n            break;\n        }\n}\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    int[] perm = nextPermutation(c.size(), k);\n    Object[] res = new Object[k];\n    int i = 0;\n    for (Object o : c) {\n        if (i == k) {\n            break;\n        }\n        res[perm[i]] = o;\n        i++;\n    }\n    return res;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int[] perm = nextPermutation(c.size(), k);\n    Object[] res = new Object[k];\n    int i = 0;\n    for (Iterator<?> it = c.iterator(); it.hasNext(); i++) {\n        res[i] = it.next();\n    }\n    return res;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (c == null) {\n        throw new NullArgumentException();\n    }\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    int[] perm = nextPermutation(c.size(), k);\n    Object[] result = new Object[k];\n    int index = 0;\n    for (int i = 0; i < perm.length; i++) {\n        if (index < k) {\n            result[index] = c.toArray()[perm[i]];\n            index++;\n        }\n    }\n    return result;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (c == null) {\n        throw new NullArgumentException();\n    }\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    int[] indices = nextPermutation(c.size(), k);\n    Object[] out = new Object[k];\n    int i = 0;\n    for (int index : indices) {\n        out[i++] = c.toArray()[index];\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (n < k) {\n        throw new NumberIsTooLargeException(LocalizedFormats.COLLECTION_TOO_SMALL, n, k, true);\n    }\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_TOO_SMALL, k, 0);\n    }\n    Object[] sample = new Object[k];\n    int[] index = nextPermutation(n, k);\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (j < k) {\n            sample[j] = c.toArray()[i];\n            j++;\n        }\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_TOO_SMALL, k, 0);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (c == null) {\n        throw new NullArgumentException();\n    }\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_TOO_SMALL, k, 0);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Node.CALL,\n                                 new Node(Node.NAME, methodName),\n                                 argumentNode);\n        callNode.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Node.CALL,\n                                       new Node(Node.NAME, methodName),\n                                       argumentNode);\n        callNode.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = new Node(Node.CALL, new Node(Node.NAME, methodName),\n                                     argumentNode);\n    methodCall.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n    return methodCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Node.CALL,\n                                       new Node(Node.NAME, methodName),\n                                       argumentNode);\n        callNode.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, argumentNode, srcref);\n    callNode.putProp(Node.FUNCTION_PROP, new Node(Node.NAME, methodName, srcref));\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, srcref);\n    methodNode.setString(methodName);\n    callNode.addChildToBack(methodNode);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Token.CALL, argumentNode, srcref);\n    Node methodNode = new Node(Token.GETPROP,\n                                   new Node(Token.NAME, methodName),\n                                   srcref);\n    callNode.addChildToBack(methodNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Token.CALL, srcref);\n        Node methodNode = new Node(Token.GETPROP, srcref);\n        methodNode.addChildToBack(new Node(Token.THIS, srcref));\n        methodNode.addChildToBack(new Node(Token.STRING, methodName, srcref));\n        callNode.addChildToBack(methodNode);\n        callNode.addChildToBack(argumentNode);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, argumentNode);\n    callNode.setSourcePositionForNode(srcref);\n    callNode.putProp(Node.FUNCTION_PROP, new Node(Node.NAME, methodName));\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Node.CALL, argumentNode);\n        callNode.putProp(Node.ORIGINALNAME_PROP, methodName);\n        callNode.setSourceInfoForNode(srcref);\n        return callNode;\n    }"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] result = new int[indices.length];\n    for (int i = 0; i < result.length; i++) \n    {\n        result[i] = indices[i].index;\n    }\n    return result;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] ret = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) {\n        ret[i] = indices[i].index;\n    }\n    return ret;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // TODO: Implement this method\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = cachedQ.transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n        if (cachedQt == null) {\n            cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        }\n        return cachedQt;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors.length, householderVectors.length);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            for (int j = 0; j < householderVectors.length; j++) \n            {\n                cachedQt.setEntry(i, j, householderVectors[i][j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        cachedQT = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQT;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n        Comparable result = (Comparable) this.keyToGroupMap.get(key);\n        if (result == null) {\n            result = this.defaultGroup;\n        }\n        return result;\n    }",
      "public Comparable getGroup(Comparable key)  {\n        if (this.keyToGroupMap.containsKey(key)) {\n            return (Comparable) this.keyToGroupMap.get(key);\n        }\n        else {\n            return this.defaultGroup;\n        }\n    }",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable result = (Comparable) this.keyToGroupMap.get(key);\n        if (result == null) {\n            result = this.defaultGroup;\n        }\n        return result;\n    }",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Comparable result = (Comparable) this.keyToGroupMap.get(key);\n        if (result == null) {\n            result = this.defaultGroup;\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        int newCapacity = buffer.length * 2;\n        if (newCapacity < 0) \n        {\n            newCapacity = Integer.MAX_VALUE;\n        }\n        else if (newCapacity < capacity) \n        {\n            newCapacity = capacity;\n        }\n        expandCapacity(newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) {\n            double value = dataset.getValue(i, j);\n            total += value;\n            if (total < min) {\n                min = total;\n            }\n            if (total > max) {\n                max = total;\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) {\n            double value = dataset.getValue(i, j);\n            total += value;\n            if (result == null) {\n                result = new Range(total, total);\n            }\n            else {\n                result = Range.expandToInclude(result, total);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // calculate the cumulative totals\n    double[][] data = new double[dataset.getRowCount()][dataset.getColumnCount()];\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n        for (int c = 0; c < dataset.getColumnCount(); c++) {\n            data[r][c] = dataset.getValue(r, c);\n            for (int i = 0; i < c; i++) {\n                data[r][c] += data[r][i];\n            }\n        }\n    }\n\n    // find the range of the cumulative totals\n    return findRangeBounds(data);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    for (int i = 0; i < dataset.getRowCount(); i++) \n    {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) \n        {\n            Number value = dataset.getValue(i, j);\n            if (value != null) \n            {\n                total += value.doubleValue();\n            }\n        }\n        if (result == null) \n        {\n            result = new Range(total, total);\n        }\n        else \n        {\n            result = Range.expandToInclude(result, total);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    for (int i = 0; i < dataset.getRowCount(); i++) \n    {\n        double runningTotal = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) \n        {\n            double value = dataset.getValue(i, j);\n            runningTotal += value;\n            double value2 = runningTotal;\n            if (result == null) \n            {\n                result = new Range(value2, value2);\n            } \n            else \n            {\n                result = Range.expandToInclude(result, value2);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getColumnCount(); j++) {\n            double value = dataset.getValue(i, j);\n            total += value;\n            if (result == null) {\n                result = new Range(total, total);\n            }\n            else {\n                result = Range.expandToInclude(result, total);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    int seriesCount = dataset.getColumnCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getRowCount();\n        for (int item = 0; item < itemCount; item++) \n        {\n            Comparable key = dataset.getColumnKey(series);\n            Number value = dataset.getValue(item, series);\n            if (value != null) \n            {\n                total += value.doubleValue();\n            }\n            Comparable rowKey = dataset.getRowKey(item);\n            dataset.addValue(total, rowKey, key);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: implement this method\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // delegate to the overloaded method\n    return findCumulativeRangeBounds(dataset, 0.0);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item);\n            runningTotal += value;\n            double currentValue = runningTotal;\n            if (result == null) {\n                result = new Range(currentValue, currentValue);\n            }\n            else {\n                result = Range.expandToInclude(result, currentValue);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to 23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to 59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(\"OffsetHoursMinutes\", offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23 inclusive\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59 inclusive\");\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset <= 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return new FixedDateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n    return new FixedDateTimeZone(\"OffsetHoursMinutes\", hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(null, offset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23 inclusive: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59 inclusive: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset <= 0 && minutesOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    if (offset >= 0 && offset < 24 * 60 * 60 * 1000) \n    {\n        return FixedDateTimeZone.forOffset(offset);\n    }\n    throw new IllegalArgumentException(\"Offset must be between -23:59:59.000 and +23:59:59.000 inclusive: \" + hoursOffset + \":\" + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to 23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to 59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes offset must be positive when hours offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    if (offset >= 0 && offset < MAX_MILLIS) {\n        return new FixedDateTimeZone(\"\", offset);\n    }\n    throw new IllegalArgumentException(\"The resulting DateTimeZone would be too large\");\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 1439 || totalMinutes < -1439) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(String.valueOf(hoursOffset) + \":\" + String.valueOf(minutesOffset), totalMinutes * 60000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return forOffsetHoursMinutesMillis(hoursOffset, minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return new FixedDateTimeZone(\"\", hoursOffset * 60 + minutesOffset, hoursOffset * 60 + minutesOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    int start = pos;\n    int depth = 0;\n    String queue = this.queue;\n    int i = pos;\n    while (i < queue.length()) {\n        char c = queue.charAt(i);\n        if (c == close && depth-- == 0) {\n            pos = i + 1;\n            return queue.substring(start, i + 1);\n        }\n        if (c == open) depth++;\n        i++;\n    }\n    return \"\";\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    char start = consume();\n    if (start != open && start != close) return \"\";\n    int balance = 1;\n    StringBuilder builder = new StringBuilder();\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == close) {\n            balance--;\n            if (balance == 0) break;\n        } else if (c == open) {\n            balance++;\n        }\n        builder.append(c);\n    }\n    return builder.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int end = start;\n    int depth = 0;\n    boolean inQuote = false;\n    char last = 0;\n    while (remainingLength() > 0) {\n        char c = queue.charAt(pos);\n        if (c == '\\\\') {\n            pos++;\n            if (pos == queue.length()) break;\n            c = queue.charAt(pos);\n        } else if (c == inQuote) {\n            inQuote = false;\n        } else if (c == '\\'' || c == '\"') {\n            inQuote = c;\n        } else if (c == close) {\n            depth--;\n            if (depth < 0) {\n                end = pos;\n                break;\n            }\n        } else if (c == open) {\n            depth++;\n        }\n        pos++;\n        last = c;\n    }\n    return queue.substring(start, end);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    if (this.isEmpty()) return \"\";\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    char quote = 0;\n    String queue = this.queue;\n    int i = this.pos;\n    while (i < queue.length()) {\n        char c = queue.charAt(i);\n        if (c == close && !inQuote) {\n            if (depth == 0) {\n                this.pos = i + 1;\n                return queue.substring(start, i + 1);\n            }\n            depth--;\n        } else if (c == open && !inQuote) {\n            depth++;\n        } else if (c == '\\\\' && (i + 1 < queue.length())) {\n            i++;\n            continue;\n        } else if (c == '\\'' || c == '\"') {\n            if (last != '\\\\' && !inQuote) {\n                inQuote = true;\n                quote = c;\n            } else if (last == '\\\\' && inQuote && quote == c) {\n                inQuote = false;\n            }\n        }\n        last = c;\n        i++;\n    }\n    return queue.substring(start, i);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    int start = pos;\n    int depth = 0;\n    String queue = this.queue;\n    int i = pos;\n    char c;\n    char last = 0;\n    boolean inQuote = false;\n    while (i < queue.length()) {\n        c = queue.charAt(i);\n        if (c == close && !inQuote) {\n            if (--depth == 0) {\n                pos = i+1;\n                return queue.substring(start, i+1);\n            }\n        } else if (c == open && !inQuote) {\n            depth++;\n        } else if (c == '\"' || c == '\\'') {\n            if (last != '\\\\' || last == 0) {\n                inQuote = !inQuote;\n            }\n        }\n        last = c;\n        i++;\n    }\n    return \"\";\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int end = this.pos;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    char c;\n\n    while (this.remainingLength() > 0) {\n        c = this.consume();\n        if (inEscape) {\n            inEscape = false;\n        } else if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth <= 0) {\n                break;\n            }\n        } else if (c == inQuote) {\n            inQuote = false;\n        } else if (c == '\\\\') {\n            inEscape = true;\n        } else if (c == '\\'' || c == '\"') {\n            inQuote = c;\n        }\n    }\n\n    return this.queue.substring(start, end);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    char start = consume();\n    if (start != open && start != close) return \"\";\n    StringBuilder accum = new StringBuilder();\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == close) depth--;\n        if (depth == 0) break;\n        if (c == open) depth++;\n        accum.append(c);\n    }\n    return accum.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int end = this.pos;\n    int depth = 0;\n    while (this.remainingLength() > 0) {\n        char c = this.consume();\n        switch (c) {\n            case '\\\\':\n                this.consume();\n                break;\n            case '\\'':\n                while (this.remainingLength() > 0 && this.peek() != '\\'')\n                    this.consume();\n                if (this.remainingLength() > 0)\n                    this.consume();\n                break;\n            case '\"':\n                while (this.remainingLength() > 0 && this.peek() != '\"')\n                    this.consume();\n                if (this.remainingLength() > 0)\n                    this.consume();\n                break;\n            case close:\n                depth--;\n                break;\n            case open:\n                depth++;\n                break;\n        }\n        if (depth == 0)\n            break;\n        end++;\n    }\n    return this.queue.substring(start, end);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        switch (c) {\n            case '\\\\':\n                consume();\n                break;\n            case '\\'':\n                while (!isEmpty() && peek() != '\\'') consume();\n                break;\n            case '\"':\n                while (!isEmpty() && peek() != '\"') consume();\n                break;\n            case open:\n                depth++;\n                break;\n            case close:\n                depth--;\n                break;\n        }\n        if (depth <= 0) break;\n    }\n    return queue.substring(start, pos - 1);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    int start = pos;\n    int end = start;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    char c;\n    while (!isEmpty()) {\n        c = consume();\n        if (inEscape) {\n            inEscape = false;\n        } else if (c == close && !inQuote) {\n            depth--;\n            if (depth < 0) {\n                end = pos;\n                break;\n            }\n        } else if (c == open && !inQuote) {\n            depth++;\n        } else if (c == '\\'' || c == '\"') {\n            inQuote = !inQuote;\n        } else if (c == '\\\\') {\n            inEscape = true;\n        }\n        last = c;\n    }\n    return queue.substring(start, end);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = calculateXtX();\n        QRDecomposition qr = new QRDecomposition(XtX);\n        RealMatrix R = qr.getR();\n        RealMatrix RtR = R.transpose().multiply(R);\n        RealMatrix RtR_1 = new LUDecomposition(RtR).getSolver().getInverse();\n        return RtR_1;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTransposeX = calculateXTransposeX();\n        QRDecomposition qr = new QRDecomposition(xTransposeX);\n        RealMatrix r = qr.getR();\n        int p = r.getColumnDimension();\n        RealMatrix rTransposeR = r.getSubMatrix(0, p - 1, 0, p - 1);\n        RealMatrix rTransposeRInverse = new LUDecomposition(rTransposeR).getSolver().getInverse();\n        return rTransposeRInverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix betaVariance = null;\n        RealMatrix xTranspose = new Array2DRowRealMatrix(x.length, x[0].length);\n        for (int i = 0; i < x.length; i++) {\n            xTranspose.setRow(i, x[i]);\n        }\n        QRDecomposition qr = new QRDecomposition(xTranspose);\n        RealMatrix r = qr.getR();\n        RealMatrix rInverse = r.transpose().multiply(r);\n        rInverse = rInverse.inverse();\n        betaVariance = rInverse;\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // TODO: Implement this method\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // TODO: implement this method\n        return null;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // QR decomposition of X^T X\n        QRDecomposition qr = new QRDecomposition(new Array2DRowRealMatrix(getXTranspose().getData()));\n        RealMatrix r = qr.getR();\n        RealMatrix rt = qr.getR().transpose();\n        RealMatrix rInv = r.multiply(rt);\n        // QR decomposition of (X^T X)^-1\n        qr = new QRDecomposition(rInv);\n        r = qr.getR();\n        rt = qr.getR().transpose();\n        rInv = r.multiply(rt);\n        // top p rows of R^-1\n        int p = getBeta().getDimension();\n        double[][] rInvData = rInv.getData();\n        double[][] rInvTopP = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            System.arraycopy(rInvData[i], 0, rInvTopP[i], 0, p);\n        }\n        return new Array2DRowRealMatrix(rInvTopP);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate the variance-covariance matrix of the regression parameters\n        // (X^T X)^-1\n        // Use QR decomposition to reduce (X^T X)^-1 to (R^T R)^-1, with only the\n        // top p rows of R included, where p = the length of the beta vector\n        RealMatrix xTx = x.transpose().multiply(x);\n        QRDecomposition qr = new QRDecomposition(xTx);\n        RealMatrix r = qr.getR();\n        RealMatrix rT = r.transpose();\n        RealMatrix rTR = rT.multiply(r);\n        RealMatrix rTRi = new LUDecomposition(rTR).getSolver().getInverse();\n        return rTRi;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix X = getX();\n        int n = X.getRowDimension();\n        int p = getBeta().getDimension();\n        RealMatrix R = X.getSubMatrix(0, n - 1, 0, p - 1);\n        QRDecomposition qr = new QRDecomposition(R);\n        RealMatrix Rinv = qr.getSolver().getInverse();\n        return Rinv.transpose().multiply(Rinv);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // TODO: Implement this method\n        return null;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTx = this.getX().transpose().multiply(this.getX());\n        QRDecomposition qr = new QRDecomposition(xTx);\n        RealMatrix rTxTx = qr.getR().transpose().multiply(xTx);\n        RealMatrix rTxTxInv = rTxTx.inverse();\n        return rTxTxInv;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    return \"GMT\" + (offset >= 0 ? \"+\" : \"\") +\n        (offset / (60 * 1000) * 100 + (offset % (60 * 1000) + 500) / 1000);\n}",
      "private static String printOffset(int offset)  {\n    return DateTimeZone.offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String printOffset(int offset)  {\n    return DateTimeZone.offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return String.format(\"%+03d:%02d\", offset / 3600000, (offset / 60000) % 60);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0)  {\n        return \"Z\";\n    }\n    String sign = offset > 0 ? \"+\" : \"-\";\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    // convert to hours and minutes\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    return (offset >= 0 ? \"+\" : \"-\") + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    return DateTimeZone.offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return String.format(\"%+03d:%02d\", Math.abs(offset / 3600000), Math.abs((offset / 60000) % 60));\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    int seconds = (absOffset - (hours * DateTimeConstants.MILLIS_PER_HOUR) - (minutes * DateTimeConstants.MILLIS_PER_MINUTE)) / DateTimeConstants.MILLIS_PER_SECOND;\n    StringBuffer buf = new StringBuffer(6);\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    if (seconds != 0) {\n        buf.append(':');\n        if (seconds < 10) {\n            buf.append('0');\n        }\n        buf.append(seconds);\n    }\n    return buf.toString();\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Integer result = (Integer) this.indexMap.get(key);\n    if (result != null) {\n        return result.intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n        // TODO add your code here\n        return -1;\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        Integer result = (Integer) this.indexMap.get(key);\n        if (result != null) {\n            return result.intValue();\n        }\n        else {\n            return -1;\n        }\n    }"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  LinkedFlowScope scope = this;\n  while (scope != null) {\n    for (StaticSlot<JSType> slot : scope.slots.values()) {\n      if (slot.getType() != null) {\n        slots.put(slot.getName(), slot);\n      }\n    }\n    scope = scope.parent;\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (LinkedFlowScope scope = this; scope != null; scope = scope.parent) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.flattened.symbols.entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (allSlots.containsKey(name) && diffSlots(slot, allSlots.get(name))) {\n        allSlots.put(name, slot);\n      }\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (LinkedFlowScope scope = this;\n      scope != null;\n      scope = scope.parent) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.cache.symbols.entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (allSlots.containsKey(name)) {\n        StaticSlot<JSType> existingSlot = allSlots.get(name);\n        if (diffSlots(existingSlot, slot)) {\n          allSlots.put(name, slot);\n        }\n      } else {\n        allSlots.put(name, slot);\n      }\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  LinkedFlowScope currentScope = this;\n  while (currentScope != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : currentScope.cache.symbols.entrySet()) {\n      if (entry.getValue().getType().isNoResolvedType()) {\n        continue;\n      }\n      if (!currentScope.frozen) {\n        slots.put(entry.getKey(), entry.getValue());\n      } else {\n        StaticSlot<JSType> slot = slots.get(entry.getKey());\n        if (slot == null) {\n          slots.put(entry.getKey(), entry.getValue());\n        } else if (diffSlots(slot, entry.getValue())) {\n          slots.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    currentScope = currentScope.parent;\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (LinkedFlowScope current = this;\n       current != null;\n       current = current.parent) {\n    for (LinkedFlowSlot slot : current.slots) {\n      if (slot.type != null) {\n        allSlots.put(slot.name, slot);\n      }\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (LinkedFlowScope scope = this; scope != null; scope = scope.parent) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.flattened.symbols.entrySet()) {\n      if (allSlots.containsKey(entry.getKey())) {\n        StaticSlot<JSType> slot = allSlots.get(entry.getKey());\n        if (diffSlots(slot, entry.getValue())) {\n          allSlots.put(entry.getKey(), entry.getValue());\n        }\n      } else {\n        allSlots.put(entry.getKey(), entry.getValue());\n      }\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  LinkedFlowScope currentScope = this;\n  while (currentScope != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : currentScope.cache.symbols.entrySet()) {\n      if (allSlots.containsKey(entry.getKey())) {\n        continue;\n      }\n      allSlots.put(entry.getKey(), entry.getValue());\n    }\n    currentScope = currentScope.parent;\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (LinkedFlowScope scope = this; scope != null; scope = scope.parent) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.flattened.symbols.entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (scope.diffSlots(slot, allSlots.get(name))) {\n        allSlots.put(name, slot);\n      }\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  LinkedFlowScope current = this;\n  while (current != null) {\n    for (StaticSlot<JSType> slot : current.flattened.symbols.values()) {\n      if (slot.getName().equals(\"this\")) {\n        continue;\n      }\n      if (allSlots.containsKey(slot.getName())) {\n        StaticSlot<JSType> oldSlot = allSlots.get(slot.getName());\n        if (oldSlot.getType().isNoType() && !slot.getType().isNoType()) {\n          allSlots.put(slot.getName(), slot);\n        }\n      } else {\n        allSlots.put(slot.getName(), slot);\n      }\n    }\n    current = current.parent;\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  LinkedFlowScope scope = this;\n  while (scope != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.cache.symbols.entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (!allSlots.containsKey(name) || diffSlots(slot, allSlots.get(name))) {\n        allSlots.put(name, slot);\n      }\n    }\n    scope = scope.parent;\n  }\n  return allSlots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n\n    int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n\n    double[][] data = new double[nRows][1];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n\n    return new Array2DRowRealMatrix(data, false);\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a == 0) {\n        return 0;\n    }\n    double x = a;\n    double y = 1 - x;\n    if (Math.abs(x) > 0.5) {\n        y = 1 + x;\n        x = y / (1 - x);\n    } else {\n        y = y / (1 + x);\n    }\n    return y * Math.log(x + Math.sqrt(x * x + 1)) / 2;\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"abs(a) should be less than 1.0\");\n    }\n    return 0.5 * log(1.0 + a, 1.0 - a);\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    if (a < -1 || a > 1) {\n        throw new IllegalArgumentException(\"abs(a) should be less than 1\");\n    }\n    if (a == 0) {\n        return 0;\n    }\n    if (a == 1 || a == -1) {\n        return Double.POSITIVE_INFINITY * a;\n    }\n    double y = Math.log((1 + a) / (1 - a)) / 2;\n    return y;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n      if (Double.isInfinite(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_TARGET_SUM_INFINITE);\n      }\n      if (Double.isNaN(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_TARGET_SUM_NAN);\n      }\n\n      double sum = 0;\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            sum += values[i];\n         }\n      }\n\n      if (sum == 0) {\n         throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_SUM_ZERO);\n      }\n\n      double[] out = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * normalizedSum / sum;\n         }\n      }\n\n      return out;\n   }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_NORMALIZATION);\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_SUM);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_NORMALIZATION);\n    }\n\n    double factor = normalizedSum / sum;\n    double[] out = new double[length];\n    for (int i = 0; i < length; i++) {\n        if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * factor;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n     if (Double.isInfinite(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_NOT_ALLOWED,\n                                                normalizedSum);\n     }\n\n     double sum = 0;\n     for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n             sum += values[i];\n         }\n     }\n\n     if (Double.isInfinite(sum)) {\n         throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n     }\n\n     if (sum == 0) {\n         throw new MathArithmeticException(LocalizedFormats.SUM_TO_ZERO);\n     }\n\n     double[] out = new double[values.length];\n     for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n             out[i] = values[i] * normalizedSum / sum;\n         }\n     }\n\n     return out;\n }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM, normalizedSum);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_TO_ZERO);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n     if (Double.isInfinite(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM, normalizedSum);\n     }\n\n     double sum = 0;\n     for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n             sum += values[i];\n         }\n     }\n\n     if (Double.isInfinite(sum)) {\n         throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n     }\n\n     if (sum == 0) {\n         throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n     }\n\n     double[] out = new double[values.length];\n     for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n             out[i] = values[i] * normalizedSum / sum;\n         }\n     }\n\n     return out;\n }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_OR_ZERO, sum);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n      double sum = 0;\n      for (double value : values) {\n         if (!Double.isNaN(value)) {\n            sum += value;\n         }\n      }\n      if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n               normalizedSum);\n      }\n      if (Double.isInfinite(sum) || sum == 0) {\n         throw new MathArithmeticException(LocalizedFormats.NORMALIZED_SUM_ZERO_OR_INFINITE);\n      }\n      double[] out = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * normalizedSum / sum;\n         }\n      }\n      return out;\n   }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_FOR_SUM,\n                                               normalizedSum);\n    }\n\n    double sum = 0;\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n        final double v = values[i];\n        if (Double.isInfinite(v)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_VALUE_IN_ARRAY,\n                                              v);\n        }\n        sum += v;\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_CONTAINS_ZERO_ELEMENTS);\n    }\n\n    double[] out = new double[length];\n    for (int i = 0; i < length; i++) {\n        out[i] = values[i] * normalizedSum / sum;\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM,\n                                               normalizedSum);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM, sum);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM, sum);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n        double v = values[i];\n        if (!Double.isNaN(v)) {\n            sum += v;\n        }\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM,\n                                               normalizedSum);\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM_NORMALIZATION);\n    }\n\n    double[] out = new double[length];\n    for (int i = 0; i < length; i++) {\n        double v = values[i];\n        if (Double.isNaN(v)) {\n            out[i] = v;\n        } else {\n            out[i] = v * normalizedSum / sum;\n        }\n    }\n\n    return out;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n        int delimLen = delimiters == null ? -1 : delimiters.length;\n        if (str == null || str.length() == 0 || delimLen == 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int count = 0;\n        boolean capitalizeNext = true;\n        for (int cp : str.codePoints().toArray()) {\n            if (isDelimiter(cp, delimiters)) {\n                capitalizeNext = true;\n            } else if (capitalizeNext) {\n                cp = Character.toTitleCase(cp);\n                capitalizeNext = false;\n            }\n            newCodePoints[count++] = cp;\n        }\n        return new String(newCodePoints, 0, count);\n    }",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        return capitalize(str, delimiters[0]);\n    }\n    int[] positions = new int[delimLen];\n    int len = str.length();\n    int count = 0;\n    boolean contains = false;\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                contains = true;\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n    if (!contains) {\n        return capitalize(str);\n    }\n    if (count == 0) {\n        return str;\n    }\n    StringBuilder builder = new StringBuilder(str.length());\n    builder.append(Character.toTitleCase(str.charAt(0)));\n    for (int i = 1; i < len; i++) {\n        if (i == positions[0]) {\n            for (int j = 1; j < count; j++) {\n                builder.append(Character.toTitleCase(str.charAt(i + j)));\n            }\n            i += count;\n            count = 0;\n            builder.append(str.substring(i));\n            return builder.toString();\n        } else {\n            builder.append(str.charAt(i));\n        }\n    }\n    return builder.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer[i] = ch;\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int cp : str.codePoints().toArray()) {\n        if (isDelimiter(cp, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            newCodePoints[count++] = Character.toTitleCase(cp);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[count++] = cp;\n        }\n    }\n    return new String(newCodePoints, 0, count);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        // indexing just once\n        return capitalize(str, delimiters[0]);\n    }\n    // indexed mapping\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n        int delimLen = (delimiters == null ? -1 : delimiters.length);\n        if (str == null || str.length() == 0 || delimLen == 0) {\n            return str;\n        }\n        final int strLen = str.length();\n        final int[] newCodePoints = new int[strLen];\n        int count = 0;\n        boolean capitalizeNext = true;\n\n        for (int cp : str.codePoints().toArray()) {\n            if (isDelimiter(cp, delimiters)) {\n                capitalizeNext = true;\n            } else if (capitalizeNext) {\n                cp = Character.toTitleCase(cp);\n                capitalizeNext = false;\n            }\n            newCodePoints[count++] = cp;\n        }\n        return new String(newCodePoints, 0, count);\n    }",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int count = 0;\n    boolean capitalizeNext = true;\n    for (int cp : str.codePoints().toArray()) {\n        if (isDelimiter(cp, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            cp = Character.toTitleCase(cp);\n            capitalizeNext = false;\n        }\n        newCodePoints[count++] = cp;\n    }\n    return new String(newCodePoints, 0, count);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        final boolean isDelimiter = isDelimiter(codePoint, delimiters);\n        newCodePoints[outOffset++] = isDelimiter ? Character.toTitleCase(codePoint) : Character.toLowerCase(codePoint);\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int count = 0;\n    boolean capitalizeNext = true;\n    int cp = 0;\n    for (int i = 0; i < strLen; i += Character.charCount(cp)) {\n        cp = str.codePointAt(i);\n        if (isDelimiter(cp, delimiters)) {\n            count++;\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            newCodePoints[count++] = Character.toTitleCase(cp);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[count++] = cp;\n        }\n    }\n    if (count == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, count);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        return capitalize(str, delimiters[0]);\n    }\n    int[] positions = new int[delimLen];\n    int len = str.length();\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n    if (count == 0) {\n        return capitalize(str);\n    }\n    StringBuilder builder = new StringBuilder(len);\n    builder.append(str.subSequence(0, positions[0]));\n    builder.append(Character.toTitleCase(str.charAt(positions[0])));\n    for (int i = 1; i < count; i++) {\n        builder.append(str.subSequence(positions[i - 1] + 1, positions[i]));\n        builder.append(Character.toTitleCase(str.charAt(positions[i])));\n    }\n    builder.append(str.substring(positions[count - 1] + 1));\n    return builder.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    if (text == null) {\n        throw new IllegalArgumentException(\"The text to parse must not be null\");\n    }\n    if (iParser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    MutableDateTime dateTime = new MutableDateTime(0L, getChronology());\n    int newPos = iParser.parseInto(dateTime, text, 0);\n    if (newPos == 0) {\n        throw new IllegalArgumentException(\"The text to parse is not well formed\");\n    }\n    if (iOffsetParsed) {\n        dateTime.setZoneRetainFields(DateTimeZone.forOffsetMillis(dateTime.getZone().getOffset(dateTime.getMillis())));\n    }\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    return parseMutableDateTime(text, null);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    if (iParser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    MutableDateTime dateTime = new MutableDateTime();\n    int position = iParser.parseInto(dateTime, text, 0);\n    if (position < text.length()) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    if (iOffsetParsed) {\n        dateTime.setZoneRetainFields(getZone());\n    }\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    requireParser();\n    MutableDateTime dateTime = new MutableDateTime(0L, getChronology());\n    int newPos = getParser().parseInto(dateTime, text, 0);\n    if (newPos != text.length()) {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n    if (isOffsetParsed()) {\n        dateTime.setZoneRetainFields(getZone());\n    }\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    if (iParser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    int[] values = new int[iParser.estimateParsedLength()];\n    int pos = iParser.parseInto(new DateTimeParserBucket(0, 0, 0, values, null), text, 0);\n    if (pos < text.length()) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    Chronology chrono = getChronology();\n    if (iOffsetParsed) {\n        chrono = chrono.withZone(DateTimeZone.forOffsetMillis(values[DateTimeFieldType.MILLIS_OF_DAY.getIndex()]));\n    }\n    return new MutableDateTime(chrono.set(values, null), chrono);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    return parseMutableDateTime(text, null);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime dateTime = new MutableDateTime();\n    parseInto(dateTime, text, 0);\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    if (text == null) {\n        throw new IllegalArgumentException(\"Text must not be null\");\n    }\n    MutableDateTime dateTime = new MutableDateTime(0L, getChronology());\n    int position = 0;\n    if (isPrinter()) {\n        position = getPrinter().parseInto(dateTime, text, position);\n    }\n    if (position < text.length()) {\n        if (isParser()) {\n            position = getParser().parseInto(dateTime, text, position);\n        }\n        if (position < text.length()) {\n            throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n        }\n    }\n    if (isOffsetParsed()) {\n        int offset = parseOffset(text);\n        dateTime.setZoneRetainFields(DateTimeZone.forOffsetMillis(offset));\n    }\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime dateTime = new MutableDateTime();\n    int position = 0;\n    if (iParser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    position = iParser.parseInto(dateTime, text, position);\n    if (position < text.length()) {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    requireParser();\n    MutableDateTime dateTime = new MutableDateTime();\n    int position = 0;\n    position = iParser.parseInto(dateTime, text, position);\n    if (position < text.length()) {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n    return dateTime;\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix Xt = X.transpose();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XtOmegaInverseX = Xt.multiply(OmegaInverse).multiply(X);\n        RealMatrix XtOmegaInverseY = Xt.multiply(OmegaInverse).operate(y);\n        return new QRDecomposition(XtOmegaInverseX).getSolver().solve(XtOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XT = X.transpose();\n        RealMatrix XTOmegaInverse = XT.multiply(OmegaInverse);\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.multiply(X);\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.inverse();\n        RealMatrix XTOmegaInverseXInverseXT = XTOmegaInverseXInverse.multiply(XT);\n        RealVector beta = XTOmegaInverseXInverseXT.operate(y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XtOmegaInverseX = getXtOmegaInverseX();\n        RealMatrix XtOmegaInverseY = getXtOmegaInverseY();\n        RealVector beta = XtOmegaInverseX.solve(XtOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealVector y = getY();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealMatrix XTransposeOmegaInverseX = XTransposeOmegaInverse.multiply(X);\n        RealMatrix XTransposeOmegaInverseXInverse = XTransposeOmegaInverseX.inverse();\n        RealMatrix XTransposeOmegaInverseXInverseXTranspose = XTransposeOmegaInverseXInverse.multiply(XTranspose);\n        RealVector b = XTransposeOmegaInverseXInverseXTranspose.operate(y);\n        return b;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverseX = XTranspose.multiply(OmegaInverse).multiply(X);\n        RealMatrix XTransposeOmegaInverseY = XTranspose.multiply(OmegaInverse).operate(y);\n        RealVector beta = XTransposeOmegaInverseX.solve(XTransposeOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverseX = XTranspose.multiply(OmegaInverse).multiply(X);\n        RealMatrix XTransposeOmegaInverseY = XTranspose.multiply(OmegaInverse).operate(y);\n        return XTransposeOmegaInverseX.solve(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix Xt = getX().transpose();\n        RealMatrix XtOmegaInverseX = Xt.multiply(OmegaInverse).multiply(getX());\n        RealMatrix XtOmegaInverseY = Xt.multiply(OmegaInverse).multiply(getY());\n        RealVector beta = XtOmegaInverseX.solve(XtOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XtOmegaInverseX = getXtOmegaInverseX();\n        RealMatrix XtOmegaInverse = getXtOmegaInverse();\n        RealVector y = getY();\n        RealVector beta = XtOmegaInverseX.solve(XtOmegaInverse.operate(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealMatrix XTransposeOmegaInverseX = XTransposeOmegaInverse.multiply(X);\n        RealMatrix XTransposeOmegaInverseXInverse = new LUDecomposition(XTransposeOmegaInverseX).getSolver().getInverse();\n        RealMatrix XTransposeOmegaInverseY = XTranspose.multiply(OmegaInverse).operate(y);\n        return XTransposeOmegaInverseXInverse.operate(XTransposeOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = new Array2DRowRealMatrix(x, false);\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XTransposeOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealMatrix XTransposeOmegaInverseX = XTransposeOmegaInverse.multiply(X);\n        RealMatrix XTransposeOmegaInverseXInverse = new LUDecomposition(XTransposeOmegaInverseX).getSolver().getInverse();\n        RealMatrix XTransposeOmegaInverseY = XTranspose.multiply(OmegaInverse).operate(new ArrayRealVector(y, false));\n        return XTransposeOmegaInverseXInverse.operate(XTransposeOmegaInverseY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    // if this element has the ID, return it\n    if (id.equals(attributes().get(\"id\")))\n        return this;\n\n    // otherwise, search for a child element with the ID\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null)\n            return found;\n    }\n\n    // nothing found\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n    else if (id.equals(attributes().get(\"id\")))\n        return this;\n    else {\n        for (Element child : children()) {\n            Element found = child.getElementById(id);\n            if (found != null)\n                return found;\n        }\n        return null;\n    }\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    // could implement with array, but this is more readable\n    Queue<Element> queue = new LinkedList<>();\n    queue.add(this);\n\n    while (!queue.isEmpty()) {\n        Element next = queue.poll();\n        if (id.equals(next.id())) {\n            return next;\n        }\n\n        for (Element child : next.children()) {\n            queue.add(child);\n        }\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n    Elements els = this.getElementsByAttributeValue(\"id\", id);\n    if (els.size() > 0) {\n        return els.get(0);\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    if (elements.size() > 0) {\n        return elements.get(0);\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    // Check if this element has the ID\n    if (id != null && id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n\n    // Check children\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n\n    // None found\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) {\n        return null;\n    }\n\n    // look in our own ID set\n    if (attributes != null && attributes.hasKey(id)) {\n        return this;\n    }\n\n    // look in children\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(attributes().get(\"id\"))) {\n        return this;\n    }\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    result.append(pattern);\n    for (final String customPattern : customPatterns) {\n        result.append(START_FE).append(customPattern).append(END_FE);\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    // Check if there are any custom patterns to re-insert\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n\n    // Create a StringBuilder to store the final pattern\n    StringBuilder finalPattern = new StringBuilder(pattern);\n\n    // Iterate over the custom patterns and re-insert them\n    for (String customPattern : customPatterns) {\n        finalPattern.insert(finalPattern.indexOf(DUMMY_PATTERN), customPattern);\n    }\n\n    // Return the final pattern\n    return finalPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    int currentArg = 0;\n    while (pos.getIndex() < pattern.length()) {\n        seekNonWs(pattern, pos);\n        final int start = pos.getIndex();\n        final int end = pattern.indexOf(START_FE, start);\n        if (end == -1) {\n            result.append(pattern.substring(start));\n            break;\n        }\n        result.append(pattern.substring(start, end));\n        pos.setIndex(end + 1);\n        final int arg = readArgumentIndex(pattern, pos);\n        if (arg == -1) {\n            // Invalid arg specification, ignore\n            continue;\n        }\n        if (arg != currentArg) {\n            // We have skipped some arguments, output the custom pattern\n            result.append(customPatterns.get(arg - currentArg - 1));\n            currentArg = arg;\n        }\n        final String desc = parseFormatDescription(pattern, pos);\n        if (desc != null) {\n            result.append(desc);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    // TODO: Implement this method\n    return pattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder(pattern);\n    int lastOffset = 0;\n    for (final String customPattern : customPatterns) {\n        final int offset = pattern.indexOf(customPattern, lastOffset);\n        if (offset < 0) {\n            continue;\n        }\n        result.insert(offset, \"{\" + customPattern + \"}\");\n        lastOffset = offset + customPattern.length() + 2;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    StringBuilder result = new StringBuilder(pattern);\n    int start = 0;\n    for (String customPattern : customPatterns) {\n        int index = result.indexOf(customPattern, start);\n        if (index < 0) {\n            break;\n        }\n        result.replace(index, index + customPattern.length(), customPattern);\n        start = index + customPattern.length();\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder(pattern);\n    for (int i = customPatterns.size() - 1; i >= 0; i--) {\n        result.insert(0, customPatterns.get(i));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < customPatterns.size(); i++) {\n        String customPattern = customPatterns.get(i);\n        int index = pattern.indexOf(customPattern, start);\n        if (index == -1) {\n            continue;\n        }\n        result.append(pattern.substring(start, index));\n        result.append(customPattern);\n        start = index + customPattern.length();\n    }\n    result.append(pattern.substring(start));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder result = new StringBuilder();\n    final String[] patterns = pattern.split(START_FE);\n    for (int i = 0; i < patterns.length; i++) {\n        final String[] subPatterns = patterns[i].split(END_FE);\n        if (subPatterns.length == 1) {\n            result.append(subPatterns[0]);\n            continue;\n        }\n        for (int j = 0; j < subPatterns.length; j++) {\n            if (j > 0) {\n                result.append(START_FE);\n            }\n            if (subPatterns[j].length() == 0) {\n                continue;\n            }\n            final int index = subPatterns[j].indexOf(QUOTE);\n            if (index == 0) {\n                result.append(subPatterns[j]);\n                continue;\n            }\n            final String formatDesc = subPatterns[j].substring(0, index);\n            final String formatPattern = subPatterns[j].substring(index + 1);\n            final int formatIndex = Integer.parseInt(formatDesc);\n            final String customPattern = customPatterns.get(formatIndex);\n            result.append(formatDesc).append(customPattern).append(formatPattern);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern);\n    if (containsElements(customPatterns)) \n    {\n        for (int i = customPatterns.size() - 1; i >= 0; i--) \n        {\n            result.insert(0, \"{\" + customPatterns.get(i) + \"}\");\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    return (InstantConverter) iInstantConverters.remove(converter, null);\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        ConverterSet set = iInstantConverters;\n        if (set == null) {\n            return null;\n        }\n        Converter[] converters = set.iConverters;\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                Converter[] removed = new Converter[converters.length - 1];\n                System.arraycopy(converters, 0, removed, 0, i);\n                System.arraycopy(converters, i + 1, removed, i, converters.length - i - 1);\n                iInstantConverters = set.remove(i, removed);\n                return (InstantConverter) converters[i];\n            }\n        }\n        return null;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        return iInstantConverters.remove(converter, null);\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        return iInstantConverters.remove(converter, null);\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterInstantConverters();\n        InstantConverter[] converters = getInstantConverters();\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                InstantConverter[] newConverters = new InstantConverter[converters.length - 1];\n                System.arraycopy(converters, 0, newConverters, 0, i);\n                System.arraycopy(converters, i + 1, newConverters, i,\n                        converters.length - i - 1);\n                iInstantConverters = new ConverterSet(newConverters);\n                return converter;\n            }\n        }\n        return null;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    InstantConverter[] converters = iInstantConverters.getConverters();\n    for (int i = 0; i < converters.length; i++) {\n        if (converter.equals(converters[i])) {\n            InstantConverter[] newConverters = new InstantConverter[converters.length - 1];\n            System.arraycopy(converters, 0, newConverters, 0, i);\n            System.arraycopy(converters, i + 1, newConverters, i,\n                    converters.length - i - 1);\n            iInstantConverters = new ConverterSet(newConverters);\n            return converter;\n        }\n    }\n    return null;\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterInstantConverters();\n    return (InstantConverter) iInstantConverters.remove(converter, null);\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterInstantConverters();\n    InstantConverter[] converters = getInstantConverters();\n    InstantConverter[] newConverters = new InstantConverter[converters.length - 1];\n    int j = 0;\n    for (int i = 0; i < converters.length; i++) {\n        if (converters[i] != converter) {\n            newConverters[j++] = converters[i];\n        }\n    }\n    iInstantConverters = new ConverterSet(newConverters);\n    return converter;\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] converters = getInstantConverters();\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                InstantConverter[] newArray = new InstantConverter[converters.length - 1];\n                System.arraycopy(converters, 0, newArray, 0, i);\n                System.arraycopy(converters, i + 1, newArray, i, newArray.length - i);\n                iInstantConverters = new ConverterSet(newArray);\n                return converter;\n            }\n        }\n        return null;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    InstantConverter[] converters = getInstantConverters();\n    InstantConverter[] removed = new InstantConverter[converters.length - 1];\n    InstantConverter[] newConverters = new InstantConverter[converters.length - 1];\n    int index = 0;\n    for (InstantConverter c : converters) {\n        if (c.equals(converter)) {\n            removed[index] = c;\n            index++;\n        } else {\n            newConverters[index] = c;\n            index++;\n        }\n    }\n    iInstantConverters = new ConverterSet(newConverters);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType().equals(to.getRawType())) {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable) {\n        String varName = ((TypeVariable<?>) fromArg).getName();\n        Type replacementType = typeVarMap.get(varName);\n        if (replacementType == null) {\n          return false;\n        }\n        if (!replacementType.equals(toArg)) {\n          return false;\n        }\n      } else if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) \n    {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) \n      {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) \n        {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to))\n    return true;\n  if (!from.getRawType().equals(to.getRawType()))\n    return false;\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    if (fromArg instanceof TypeVariable) {\n      String varName = ((TypeVariable) fromArg).getName();\n      Type replacementType = typeVarMap.get(varName);\n      if (replacementType == null)\n        return false;\n      if (!replacementType.equals(toArg))\n        return false;\n    } else if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n        if (fromArg instanceof TypeVariable) {\n          Type replacementType = typeVarMap.get(fromArg.toString());\n          if (replacementType == null) {\n            return false;\n          }\n          if (!replacementType.equals(toArg)) {\n            return false;\n          }\n        } else if (!fromArg.equals(toArg)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  return from.getRawType().equals(to.getRawType())\n      && matches(from.getOwnerType(), to.getOwnerType(), typeVarMap)\n      && Arrays.equals(from.getActualTypeArguments(), to.getActualTypeArguments());\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    return from.equals(to);\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to))\n    return true;\n  if (from.getRawType().equals(to.getRawType()))\n  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++)\n    {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable)\n      {\n        String varName = ((TypeVariable) fromArg).getName();\n        Type replacementType = typeVarMap.get(varName);\n        if (replacementType == null)\n          return false;\n        toArg = replacementType;\n      }\n      if (!matches(fromArg, toArg, typeVarMap))\n        return false;\n    }\n    return true;\n  }\n  return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to))\n    return true;\n  if (!from.getRawType().equals(to.getRawType()))\n    return false;\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    if (fromArg.equals(toArg))\n      continue;\n    if (fromArg instanceof TypeVariable) {\n      TypeVariable<?> fromVar = (TypeVariable<?>) fromArg;\n      if (fromVar.getName().equals(toArg.toString()))\n        continue;\n      if (typeVarMap.containsKey(fromVar.getName())) {\n        fromArg = typeVarMap.get(fromVar.getName());\n        if (fromArg.equals(toArg))\n          continue;\n      }\n    }\n    if (toArg instanceof TypeVariable) {\n      TypeVariable<?> toVar = (TypeVariable<?>) toArg;\n      if (toVar.getName().equals(fromArg.toString()))\n        continue;\n      if (typeVarMap.containsKey(toVar.getName())) {\n        toArg = typeVarMap.get(toVar.getName());\n        if (fromArg.equals(toArg))\n          continue;\n      }\n    }\n    return false;\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n        if (fromArg instanceof TypeVariable) {\n          String varName = ((TypeVariable<?>) fromArg).getName();\n          if (typeVarMap.containsKey(varName)) {\n            fromArg = typeVarMap.get(varName);\n          }\n        }\n        if (!fromArg.equals(toArg)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) \n    {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) \n      {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n        if (fromArg.equals(toArg)) \n        {\n          continue;\n        }\n        if (fromArg instanceof TypeVariable) \n        {\n          Type toArg2 = typeVarMap.get(fromArg.toString());\n          if (toArg2 == null) \n          {\n            return false;\n          }\n          if (!toArg2.equals(toArg)) \n          {\n            return false;\n          }\n        } \n        else if (fromArg instanceof ParameterizedType) \n        {\n          if (!typeEquals((ParameterizedType) fromArg, (ParameterizedType) toArg, typeVarMap)) \n          {\n            return false;\n          }\n        } \n        else if (fromArg instanceof GenericArrayType) \n        {\n          if (!typeEquals((GenericArrayType) fromArg, (GenericArrayType) toArg, typeVarMap)) \n          {\n            return false;\n          }\n        } \n        else \n        {\n          return false;\n        }\n      }\n      return true;\n    } \n    else \n    {\n      return false;\n    }\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        ConverterSet set = iPeriodConverters;\n        if (set == null) {\n            set = new ConverterSet(new Converter[] {converter});\n            iPeriodConverters = set;\n            return null;\n        }\n        return set.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        ConverterSet set = iPeriodConverters;\n        if (set == null) {\n            set = new ConverterSet(new Converter[] {converter});\n            iPeriodConverters = set;\n            return null;\n        }\n        return set.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPeriodConverters();\n        ConverterSet set = iPeriodConverters;\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        if (set != iPeriodConverters) {\n            iPeriodConverters = set;\n            return (PeriodConverter) removed[0];\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = new ConverterSet(new Converter[] { converter });\n    set = iPeriodConverters.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    if (set == null) {\n        set = new ConverterSet(new Converter[] {converter});\n        iPeriodConverters = set;\n        return null;\n    }\n    return set.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (set != iPeriodConverters) {\n        iPeriodConverters = set;\n        return (PeriodConverter) removed[0];\n    }\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = new ConverterSet(new Converter[] { converter });\n    set = iPeriodConverters.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    }\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPeriodConverters;\n    Converter[] converters = set.iConverters;\n    int size = set.size();\n    for (int i = 0; i < size; i++) {\n        Converter conv = converters[i];\n        if (conv.equals(converter)) {\n            return null;\n        }\n    }\n    Converter[] removed = new Converter[size];\n    set = set.add(converter, removed);\n    iPeriodConverters = set;\n    return (PeriodConverter) removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (set != iPeriodConverters) {\n        iPeriodConverters = set;\n        return (PeriodConverter) removed[0];\n    }\n    return null;\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) \n    {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    if (superNode == null) {\n        superNode = node;\n        for (N n : graph.getNodes()) {\n            if (getPartitionSuperNode(n) == superNode) {\n                superNode = n;\n                break;\n            }\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  GraphNode<N, E> graphNode = graph.getNode(node);\n  Annotation color = graphNode.getAnnotation(Color.class);\n  if (color == null) {\n    // If the node doesn't have a color, it is the super node\n    return node;\n  }\n  int colorValue = ((Color) color).value;\n  N superNode = colorToNodeMap[colorValue];\n  if (superNode == null) {\n    // If the super node hasn't been set, set it\n    colorToNodeMap[colorValue] = node;\n    return node;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  GraphNode<N, E> graphNode = graph.getNode(node);\n  Collection<Annotation> annotations = graphNode.getAnnotations();\n  for (Annotation annotation : annotations) {\n    if (annotation instanceof Color) {\n      Color color = (Color) annotation;\n      return colorToNodeMap[color.value];\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  GraphNode<N, E> graphNode = graph.getNode(node);\n  Color color = graphNode.getAnnotation(Color.class);\n  if (color == null) {\n    throw new IllegalStateException(\"No color annotation found for node \" + node);\n  }\n  N partitionSuperNode = colorToNodeMap[color.value];\n  if (partitionSuperNode == null) {\n    partitionSuperNode = node;\n    colorToNodeMap[color.value] = node;\n  }\n  return partitionSuperNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  N superNode = null;\n  int color = getColor(node);\n  for (N n : graph.getNodes()) {\n    if (getColor(n) == color) {\n      if (superNode == null) {\n        superNode = n;\n      } else {\n        if (tieBreaker.compare(n, superNode) < 0) {\n          superNode = n;\n        }\n      }\n    }\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  N superNode = null;\n  for (N nodeInPartition : getNodesInPartition(node)) {\n    if (superNode == null) {\n      superNode = nodeInPartition;\n    } else {\n      superNode = getPartitionSuperNode(superNode);\n    }\n  }\n  return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++)  {\n        if (Double.isNaN(ranks[i].getValue()))  {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++)  {\n            if (Double.isNaN(ranks[i].getValue()))  {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++)  {\n        if (Double.isNaN(ranks[i].getValue()))  {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<>();\n        for (int i = 0; i < ranks.length; i++)  {\n            if (Double.isNaN(ranks[i].getValue()))  {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++)  {\n        if (Double.isNaN(ranks[i].getValue()))  {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (!value1.equals(value2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint p1 = (Paint) entry.getValue();\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint p1 = (Paint) entry.getValue();\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint p1 = (Paint) entry.getValue();\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint p1 = (Paint) entry.getValue();\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Only consider string literals\n    if (!expr.isString()) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n    // to be evaluated at runtime\n    if (NodeUtil.mayHaveSideEffects(expr, t.getCompiler())) \n    {\n        return expr;\n    }\n\n    // Only consider strings that are not used in a way that requires them\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Check if the expression is a string literal\n  if (expr.isString()) \n  {\n    // Check if the string is short enough to be encoded\n    if (expr.getString().length() <= MAX_STRING_LENGTH) \n    {\n      // Get the replacement string\n      String replacement = getReplacement(expr.getString());\n      // Check if a replacement was found\n      if (replacement != null) \n      {\n        // Replace the expression with the encoded string\n        Node replacementNode = NodeUtil.newString(replacement);\n        replacementNode.useSourceInfoFrom(expr);\n        return replacementNode;\n      }\n    }\n  }\n  // No replacement was made\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Get the string expression\n    String str = expr.getFirstChild().getString();\n    // Get the encoded string expression\n    String replacement = getReplacement(str);\n    // If the encoded string expression is not null\n    if (replacement != null)\n    {\n        // Create a new expression node\n        Node newExpr = Node.newString(replacement);\n        // Set the new expression node's type to the original expression node's type\n        newExpr.setType(expr.getType());\n        // Replace the original expression node with the new expression node\n        parent.replaceChild(expr, newExpr);\n        // Return the new expression node\n        return newExpr;\n    }\n    // Return the original expression node\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // If the expression is not a string literal, return the original expression\n  if (expr.getType() != Token.STRING) {\n    return expr;\n  }\n\n  // Get the string value of the expression\n  String value = expr.getString();\n\n  // If the string is too long, return the original expression\n  if (value.length() > MAX_STRING_LENGTH) {\n    return expr;\n  }\n\n  // Get the configuration for the current function\n  Config config = findMatching(t.getScope().getReadableName());\n\n  // If there is no configuration, return the original expression\n  if (config == null) {\n    return expr;\n  }\n\n  // Get the replacement string\n  String replacement = getReplacement(value);\n\n  // If there is no replacement, return the original expression\n  if (replacement == null) {\n    return expr;\n  }\n\n  // Create the replacement node\n  Node replacementNode = NodeUtil.newString(replacement);\n\n  // Add the replacement to the list of replacements\n  recordReplacement(expr, value);\n\n  // Return the replacement node\n  return replacementNode;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Check if the expression is a string literal\n  if (!expr.isString()) {\n    return expr;\n  }\n\n  // Check if the string literal is too long\n  if (expr.getString().length() > 10) {\n    return expr;\n  }\n\n  // Check if the string literal is a placeholder\n  if (expr.getString().equals(placeholderToken)) {\n    return expr;\n  }\n\n  // Check if the string literal is already replaced\n  if (results.containsKey(expr.getString())) {\n    return expr;\n  }\n\n  // Get the replacement string\n  String replacement = getReplacement(expr.getString());\n\n  // Check if the replacement string is already used\n  if (results.containsKey(replacement)) {\n    return expr;\n  }\n\n  // Create the replacement node\n  Node replacementNode = NodeUtil.newString(replacement);\n\n  // Replace the expression with the replacement node\n  parent.replaceChild(expr, replacementNode);\n\n  // Record the replacement\n  recordReplacement(replacementNode, expr.getString());\n\n  // Return the replacement node\n  return replacementNode;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Check if the expression is a string literal\n    if (!expr.isString()) {\n        return expr;\n    }\n\n    // Check if the expression is a valid replacement\n    String replacement = getReplacement(expr.getString());\n    if (replacement == null) {\n        return expr;\n    }\n\n    // Replace the expression with the encoded string\n    Node replacementNode = NodeUtil.newString(replacement);\n    replacementNode.useSourceInfoIfMissingFromForTree(expr);\n    parent.replaceChild(expr, replacementNode);\n    recordReplacement(expr, replacement);\n    return replacementNode;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // If the expression is not a string literal, do nothing.\n    if (!expr.isString()) {\n        return expr;\n    }\n\n    // If the expression is a string literal, replace it with a short encoded\n    // string literal.\n    String original = expr.getString();\n    String replacement = getReplacement(original);\n    if (replacement == null) {\n        return expr;\n    }\n\n    // Replace the expression with the short encoded string literal.\n    Node replacementNode = Node.newString(replacement);\n    replacementNode.copyInformationFrom(expr);\n    parent.replaceChild(expr, replacementNode);\n    recordReplacement(expr, original);\n    return replacementNode;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): Implement this method.\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String replacement = getReplacement(expr.getString());\n        if (replacement != null) \n        {\n            Node replacementNode = Node.newString(replacement);\n            replacementNode.copyInformationFrom(expr);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Only replace strings that are not part of a larger expression\n  if (expr.getParent() != parent) {\n    return expr;\n  }\n\n  // Only replace strings that are not empty\n  if (expr.getString().isEmpty()) {\n    return expr;\n  }\n\n  // Only replace strings that are not too long\n  if (expr.getString().length() > MAX_STRING_LENGTH) {\n    return expr;\n  }\n\n  // Replace the string with a short encoded string\n  String replacement = getReplacement(expr.getString());\n  if (replacement == null) {\n    return expr;\n  }\n\n  Node replacementNode = NodeUtil.newString(replacement);\n  replacementNode.copyInformationFrom(expr);\n  return replacementNode;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n        return coefficients.clone();\n    }",
      "public double[] getCoefficients()  {\n    double[] copy = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, copy, 0, coefficients.length);\n    return copy;\n}",
      "public double[] getCoefficients()  {\n    double[] coefficientsCopy = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, coefficientsCopy, 0, coefficients.length);\n    return coefficientsCopy;\n}",
      "public double[] getCoefficients()  {\n        double[] coefficients = new double[this.coefficients.length];\n        System.arraycopy(this.coefficients, 0, coefficients, 0, this.coefficients.length);\n        return coefficients;\n    }",
      "public double[] getCoefficients()  {\n    double[] result = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, result, 0, coefficients.length);\n    return result;\n}",
      "public double[] getCoefficients()  {\n    if (!coefficientsComputed) {\n        computeCoefficients();\n    }\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n        return coefficients.clone();\n    }",
      "public double[] getCoefficients()  {\n        double[] result = new double[a.length];\n        System.arraycopy(a, 0, result, 0, a.length);\n        return result;\n    }"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  builder.setMeaning(info.getDescription());\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsdoc = node.getJSDocInfo();\n  if (jsdoc == null) {\n    return false;\n  }\n\n  String desc = jsdoc.getDescription();\n  if (desc == null) {\n    return false;\n  }\n\n  builder.setDesc(desc);\n  builder.setMeaning(jsdoc.getMeaning());\n  builder.setHidden(jsdoc.isHidden());\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  String desc = info.getDescription();\n  if (desc == null) {\n    return false;\n  }\n\n  builder.setDesc(desc);\n  builder.setMeaning(info.getMeaning());\n  builder.setHidden(info.isHidden());\n\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.isExport()) {\n      builder.setIsHidden(true);\n    }\n    String desc = info.getDescription();\n    if (desc != null) {\n      builder.setDesc(desc);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  builder.setMeaning(info.getDescription());\n  builder.setDesc(info.getBlockDescription());\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsdoc = node.getJSDocInfo();\n  if (jsdoc != null) {\n    builder.setDesc(jsdoc.getBlockDescription());\n    builder.setMeaning(jsdoc.getBlockMeaning());\n    builder.setHidden(jsdoc.isHidden());\n    return builder.hasDesc();\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.isExport()) {\n      builder.setIsHidden(true);\n    }\n    if (info.getDescription() != null) {\n      builder.setDesc(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  String desc = info.getDescription();\n  if (desc == null) {\n    return false;\n  }\n\n  builder.setDesc(desc);\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  String desc = info.getDescription();\n  if (desc == null) {\n    return false;\n  }\n\n  builder.setDesc(desc);\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsdoc = node.getJSDocInfo();\n  if (jsdoc != null) {\n    String desc = jsdoc.getDescription();\n    if (desc != null) {\n      builder.setDesc(desc);\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int previousAssignments = 0;\n        for (final T point : points) {\n            final int nearestCluster = getNearestCluster(clusters, point);\n            final CentroidCluster<T> nearestClusterObj = clusters.get(nearestCluster);\n            assignments[nearestCluster]++;\n            nearestClusterObj.addPoint(point);\n        }\n        return previousAssignments;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (final T point : points) {\n            final int clusterIndex = getNearestCluster(clusters, point);\n            assignments[numAssigned] = clusterIndex;\n            clusters.get(clusterIndex).addPoint(point);\n            numAssigned++;\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (int i = 0; i < assignments.length; i++) {\n            if (assignments[i] == -1) {\n                // Find the closest cluster\n                int closestCluster = 0;\n                double minDistance = Double.POSITIVE_INFINITY;\n                for (int j = 0; j < clusters.size(); j++) {\n                    final double distance = distanceMeasure.getDistance(clusters.get(j).getCenter(), points.iterator().next());\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        closestCluster = j;\n                    }\n                }\n                assignments[i] = closestCluster;\n                clusters.get(closestCluster).addPoint(points.iterator().next());\n                numAssigned++;\n            }\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int previousAssignments = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int clusterIndex = getNearestCluster(clusters, point);\n            final CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(point);\n            assignments[i] = clusterIndex;\n            previousAssignments++;\n        }\n        return previousAssignments;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int nbPoints = 0;\n        for (int i = 0; i < clusters.size(); i++) {\n            final CentroidCluster<T> cluster = clusters.get(i);\n            cluster.clear();\n        }\n        for (final T point : points) {\n            final int clusterIndex = getNearestCluster(clusters, point);\n            assignments[nbPoints] = clusterIndex;\n            clusters.get(clusterIndex).addPoint(point);\n            nbPoints++;\n        }\n        return nbPoints;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (final T point : points) {\n            final int clusterIndex = getNearestCluster(clusters, point);\n            assignments[numAssigned++] = clusterIndex;\n            clusters.get(clusterIndex).addPoint(point);\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int previousAssignments = 0;\n        for (int i = 0; i < assignments.length; i++) {\n            final int clusterIndex = assignments[i];\n            final CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(points.iterator().next());\n            previousAssignments++;\n        }\n        return previousAssignments;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numChanged = 0;\n        for (final T point : points) {\n            final int oldAssignment = assignments[point.getKey()];\n            final int newAssignment = getNearestCluster(clusters, point);\n            if (oldAssignment != newAssignment) {\n                numChanged++;\n            }\n            assignments[point.getKey()] = newAssignment;\n        }\n        return numChanged;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (int i = 0; i < assignments.length; i++) {\n            final T point = points.iterator().next();\n            final int clusterIndex = assignments[i];\n            final CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(point);\n            numAssigned++;\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int previousAssignmentCount = 0;\n        for (final T point : points) {\n            final int clusterIndex = getNearestCluster(clusters, point);\n            final CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(point);\n            assignments[clusterIndex]++;\n        }\n        return previousAssignmentCount;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    final double meanX = mean(xArray);\n    final double meanY = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS_IN_COVARIANCE,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_ENOUGH_DATA_FOR_COVARIANCE,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    }\n    return sum / xArray.length;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS_SIMPLE,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_SIMPLE,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    }\n    return sum / xArray.length;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n\n    double sumOfProducts = 0;\n    double sumOfX = 0;\n    double sumOfY = 0;\n    double sumOfXSquared = 0;\n    double sumOfYSquared = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumOfProducts += xArray[i] * yArray[i];\n        sumOfX += xArray[i];\n        sumOfY += yArray[i];\n        sumOfXSquared += xArray[i] * xArray[i];\n        sumOfYSquared += yArray[i] * yArray[i];\n    }\n\n    double covariance = (sumOfProducts - sumOfX * sumOfY / xArray.length) / (xArray.length - (biasCorrected ? 1 : 0));\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        sum /= xArray.length - 1;\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(xArray, yArray);\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        covariance *= (1 / (xArray.length - 1));\n    } else {\n        covariance *= (1 / xArray.length);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(xArray, yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                                               xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                                               xArray.length, 2);\n    }\n    final double meanX = new Mean().evaluate(xArray);\n    final double meanY = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        sum /= xArray.length - 1;\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    checkSufficientData(xArray, yArray);\n\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n\n    if (biasCorrected) {\n        sum /= (xArray.length - 1);\n    } else {\n        sum /= xArray.length;\n    }\n\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(xArray, yArray);\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    sum = sumXY - sumX * sumY / xArray.length;\n    if (biasCorrected) {\n        sum = sum * (xArray.length - 1) / xArray.length;\n    }\n    return sum;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    if (value == 0) {\n        return;\n    }\n    final long max = value;\n    while (value > 0) {\n        final int read = in.read(skipBuf, 0, (int) Math.min(value, skipBuf.length));\n        if (read == -1) {\n            throw new EOFException(\"Premature EOF: expected \" + max\n                                   + \" bytes but got \" + (max - value)\n                                   + \" bytes\");\n        }\n        value -= read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length: \" + value);\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final int toSkip = (int) Math.min(SKIP_BUF_SIZE, value - skipped);\n        final int ret = in.read(skipBuf, 0, toSkip);\n        if (ret < 0) {\n            throw new EOFException(\"Premature EOF: \" + this);\n        }\n        skipped += ret;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int toRead = (int) Math.min(remaining, buf.capacity());\n        final int read = in.read(buf.array(), 0, toRead);\n        if (read == -1) {\n            throw new IOException(\"Premature EOF\");\n        }\n        remaining -= read;\n        bytesRead += read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    final long skipped = IOUtils.skip(in, value);\n    if (skipped != value) {\n        throw new IOException(\"Failed to skip \" + value + \" bytes, \"\n                              + \"possibly end of stream reached\");\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    long skipped = 0;\n    while (remaining > 0) {\n        int n = in.read(skipBuf, 0, (int) Math.min(remaining, skipBuf.length));\n        if (n < 0) {\n            break;\n        }\n        skipped += n;\n        remaining -= n;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long skipped = in.skip(value);\n    if (skipped == 0) {\n        throw new EOFException(\"Unable to skip \" + value + \" bytes\");\n    }\n    current.bytesReadFromStream += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"value (\" + value + \") must be non-negative\");\n    }\n    if (value == 0) {\n        return;\n    }\n    if (value > Integer.MAX_VALUE) {\n        throw new IllegalArgumentException(\"value (\" + value + \") is too large\");\n    }\n    if (value > (in.available() + 1)) {\n        throw new IOException(\"Unable to skip \" + value + \" bytes\");\n    }\n    final byte[] skipBuf = new byte[(int) value];\n    final int bytesSkipped = in.read(skipBuf);\n    if (bytesSkipped != value) {\n        throw new IOException(\"Unable to skip \" + value + \" bytes\");\n    }\n    current.bytesReadFromStream += bytesSkipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long read = in.read(skipBuf, 0, (int) Math.min(value - skipped, skipBuf.length));\n        if (read == -1) {\n            break;\n        }\n        skipped += read;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final int toSkip = (int) Math.min(value - skipped, skipBuf.length);\n        final int n = in.read(skipBuf, 0, toSkip);\n        if (n == -1) {\n            throw new EOFException(\"Premature EOF: expected \" + value + \" bytes but received \" + skipped);\n        }\n        skipped += n;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final int read = in.read(skipBuf, 0, (int) Math.min(value - skipped, skipBuf.length));\n        if (read < 0) {\n            throw new IOException(\"unexpected end of stream\");\n        }\n        skipped += read;\n    }\n    bytesRead += skipped;\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"fieldName must not be null\");\n    final Class<?> cls = target.getClass();\n    return readDeclaredField(cls, fieldName, target, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"fieldName must not be null\");\n    final Class<?> cls = target.getClass();\n    return readDeclaredField(cls, fieldName, forceAccess);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"fieldName must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"fieldName must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) {\n        field.setAccessible(true);\n    }\n    try {\n        return field.get(target);\n    } catch (final IllegalAccessException ex) {\n        throw new IllegalAccessException(\"Unable to access field: \" + field.toString());\n    } finally {\n        if (!accessible) {\n            field.setAccessible(false);\n        }\n    }\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long hash = 0;\n    for (CharSequence part : messageParts) {\n        hash = 31 * hash + part.hashCode();\n    }\n    return Long.toString(hash, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method.\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Compute the fingerprint of the message content.\n    String fingerprint = null;\n    try {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        for (CharSequence part : messageParts) {\n            digest.update(part.toString().getBytes(StandardCharsets.UTF_8));\n        }\n        byte[] digestBytes = digest.digest();\n        fingerprint = Base64.getUrlEncoder().withoutPadding().encodeToString(digestBytes);\n    } catch (NoSuchAlgorithmException e) {\n        // This should never happen.\n        throw new RuntimeException(\"Failed to generate fingerprint\", e);\n    }\n    // Return the compact representation of the fingerprint.\n    return fingerprint.replaceAll(\"[^A-Z0-9]\", \"\");\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement this method\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement the fingerprint generation\n    return null;\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long maxPos = archive.size() - maxDistanceFromEnd;\n        final long minPos = archive.size() - minDistanceFromEnd;\n        long pos = archive.size() - minDistanceFromEnd;\n        while (pos >= maxPos) {\n            archive.position(pos);\n            archive.read(shortBuf);\n            if (shortBuf[0] == sig[0] && shortBuf[1] == sig[1]) {\n                archive.position(pos);\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = minDistanceFromEnd;\n    long loc = archive.size() - distance;\n    long max = archive.size() - maxDistanceFromEnd;\n    while (loc >= max) {\n        archive.position((int) loc);\n        archive.read(shortBuf, 0, 2);\n        if (shortBuf[0] == sig[0] && shortBuf[1] == sig[1]) {\n            return true;\n        }\n        loc--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = minDistanceFromEnd;\n        while (distance < maxDistanceFromEnd) {\n            distance = Math.min(distance * 2L, maxDistanceFromEnd);\n            archive.position(archive.size() - distance);\n            if (archive.read(sigBuf, 0, sig.length) != sig.length) {\n                return false;\n            }\n            if (Arrays.equals(sigBuf, sig)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = maxDistanceFromEnd;\n        long pos = archive.size() - distance;\n        while (pos >= minDistanceFromEnd) {\n            archive.position(pos);\n            byte[] sigBuf = new byte[sig.length];\n            archive.readFully(sigBuf);\n            if (Arrays.equals(sigBuf, sig)) {\n                archive.position(pos);\n                return true;\n            }\n            distance -= 1024;\n            pos = archive.size() - distance;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.size() - minDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    long remaining = archive.size() - pos;\n    if (remaining < sig.length) {\n        return false;\n    }\n    while (remaining > maxDistanceFromEnd) {\n        archive.position((int) pos);\n        if (archive.read(sig) == 0) {\n            return true;\n        }\n        pos++;\n        remaining--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = minDistanceFromEnd;\n    long pos = archive.size() - distance;\n    if (pos < 0) {\n        pos = 0;\n    }\n    while (distance <= maxDistanceFromEnd) {\n        archive.position(pos);\n        archive.readFully(shortBuf);\n        if (shortBuf[0] == sig[0] && shortBuf[1] == sig[1]) {\n            return true;\n        }\n        pos++;\n        distance++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = maxDistanceFromEnd;\n        long loc = archive.size() - distance;\n        while (distance >= minDistanceFromEnd) {\n            archive.position(loc);\n            byte[] sigbuf = new byte[sig.length];\n            archive.readFully(sigbuf);\n            if (Arrays.equals(sigbuf, sig)) {\n                return true;\n            }\n            loc--;\n            distance--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long pos = archive.size() - minDistanceFromEnd;\n        long maxPos = archive.size() - maxDistanceFromEnd;\n        while (pos >= maxPos) {\n            archive.position(pos);\n            if (archive.read(sig) == 0) {\n                return true;\n            }\n            pos--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = maxDistanceFromEnd;\n    long loc = archive.size() - distance;\n    if (loc < 0) {\n        loc = 0;\n    }\n    byte[] buf = new byte[4096];\n    int bytesRead = 0;\n    boolean found = false;\n    while (distance >= minDistanceFromEnd) {\n        archive.position(loc);\n        bytesRead = archive.read(buf);\n        for (int i = bytesRead - sig.length; i >= 0; i--) {\n            if (Arrays.equals(buf, i, i + sig.length, sig, 0, sig.length)) {\n                archive.position(loc + i);\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            break;\n        }\n        distance -= bytesRead;\n        loc -= bytesRead;\n        if (loc < 0) {\n            loc = 0;\n        }\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distance = minDistanceFromEnd;\n        while (distance < maxDistanceFromEnd) {\n            distance = Math.min(distance * 2, maxDistanceFromEnd);\n            archive.position(archive.size() - distance);\n            if (readAndVerifySignature(sig)) {\n                return true;\n            }\n        }\n        return false;\n    }"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return Plot.resolveDomainAxisLocation(this.orientation, this.domainAxisLocations, index);\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    // delegate to the plot orientation\n    return this.getOrientation().getDomainAxisEdge(this, index);\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return this.orientation.getDomainAxisEdge(index);\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    if (this.orientation == PlotOrientation.HORIZONTAL) \n    {\n        return RectangleEdge.TOP;\n    } \n    else \n    {\n        return RectangleEdge.BOTTOM;\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    if (this.orientation == PlotOrientation.HORIZONTAL) \n    {\n        return RectangleEdge.TOP;\n    } \n    else if (this.orientation == PlotOrientation.VERTICAL) \n    {\n        return RectangleEdge.BOTTOM;\n    } \n    else \n    {\n        throw new RuntimeException(\"Orientation not recognised.\");\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    if (index == 0) \n    {\n        return RectangleEdge.BOTTOM;\n    } \n    else if (index == 1) \n    {\n        return RectangleEdge.TOP;\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Invalid axis index.\");\n    }\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.TOP;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return this.orientation.getDomainEdge();\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    // TODO: implement this method\n    return null;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPartialConverters;\n    if (set == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    set = set.remove(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        return (PartialConverter) removed[0];\n    }\n    return null;\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    return iPartialConverters.remove(converter, null);\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.remove(converter, new Converter[0]);\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPartialConverters;\n    if (set == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    set = set.remove(converter, removed);\n    if (set == null) {\n        return null;\n    }\n    iPartialConverters = set;\n    return (PartialConverter) removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] converters = iPartialConverters.getConverters();\n    int index = Arrays.asList(converters).indexOf(converter);\n    if (index >= 0) {\n        PartialConverter[] newConverters = new PartialConverter[converters.length - 1];\n        System.arraycopy(converters, 0, newConverters, 0, index);\n        System.arraycopy(converters, index + 1, newConverters, index,\n                newConverters.length - index);\n        iPartialConverters = new ConverterSet(newConverters);\n        return converter;\n    }\n    return null;\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.remove(converter, null);\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    PartialConverterSet set = (PartialConverterSet) iPartialConverters;\n    set.remove(converter, removed);\n    return (PartialConverter) removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        Converter[] removed = new Converter[1];\n        PartialConverter result = (PartialConverter) iPartialConverters.remove(converter, removed);\n        if (result != null) {\n            if (removed[0] != null) {\n                iPartialConverters.add(removed[0], removed);\n            }\n        }\n        return result;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters;\n    set = set.remove(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        return (PartialConverter) removed[0];\n    }\n    return null;\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] converters = iPartialConverters.getConverters();\n    int size = converters.length;\n    for (int i = 0; i < size; i++) {\n        if (converter.equals(converters[i])) {\n            return iPartialConverters.remove(i, new PartialConverter[size]);\n        }\n    }\n    return null;\n}"
    ],
    [
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) {\n        key = dataset.getKey(section);\n    }\n    if (key == null) {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) \n    {\n        key = dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < this.dataset.getItemCount()) {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) {\n        key = \"SECTION_\" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) {\n        key = dataset.getKey(section);\n        if (key == null) {\n            key = \"Section \" + section;\n        }\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) \n    {\n        key = dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) {\n        key = dataset.getKey(section);\n        if (key == null) {\n            key = \"Section \" + section;\n        }\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                return (_numberType == NumberType.BIG_DECIMAL && _numberValue.isNaN());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return (_numberType == NumberType.BIG_DECIMAL && _numberBigDecimal.isNaN());\n            case VALUE_STRING:\n                return _numberBigDecimal.isNaN();\n            default:\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                return _numberType == NumberType.BIG_DECIMAL && _numberValue.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                return (_numberType == NumberType.BIG_DECIMAL && _numberValue.isNaN());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return (_numberType == NumberType.BIG_DECIMAL && _numberValue.isNaN());\n            default:\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return (_numberType == NumberType.BIG_DECIMAL && _numberBigDecimal.isNaN());\n            default:\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            switch (_currToken) {\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return (_numberType == NumberType.BIG_DECIMAL && _numberValue.isNaN());\n            default:\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n  String result;\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = nextNumber();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    switch (p) {\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n        result = peekedString;\n        peekedString = null;\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        return result;\n    case PEEKED_LONG:\n        return Long.toString(peekedLong);\n    case PEEKED_NUMBER:\n        return new String(buffer, pos, peekedNumberLength);\n    case PEEKED_EOF:\n        throw new IllegalStateException(\"Attempted to read JSON value from closed reader.\");\n    default:\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  String result;\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else if (p == PEEKED_BUFFERED) {\n    result = peekedString;\n    peekedString = null;\n  } else if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n  } else if (p == PEEKED_NUMBER) {\n    result = nextNumber();\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = nextNumber();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  String result;\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    else if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    else if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n      return UNMAPPED;\n    }\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n      id = originalNameMap.size();\n      originalNameMap.put(symbolName, id);\n    }\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n  Integer id = originalNameMap.get(symbolName);\n  if (id == null) {\n    id = originalNameMap.size();\n    originalNameMap.put(symbolName, id);\n  }\n  return id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n        return UNMAPPED;\n    }\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n        id = originalNameMap.size();\n        originalNameMap.put(symbolName, id);\n    }\n    return id;\n}",
      "private int getNameId(String symbolName)  {\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n      id = originalNameMap.size();\n      originalNameMap.put(symbolName, id);\n    }\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (originalNameMap.containsKey(symbolName)) {\n      return originalNameMap.get(symbolName);\n    }\n    int id = originalNameMap.size();\n    originalNameMap.put(symbolName, id);\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n      return UNMAPPED;\n    }\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n      id = originalNameMap.size();\n      originalNameMap.put(symbolName, id);\n    }\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n      id = originalNameMap.size();\n      originalNameMap.put(symbolName, id);\n    }\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n        return UNMAPPED;\n    }\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n        id = originalNameMap.size();\n        originalNameMap.put(symbolName, id);\n    }\n    return id;\n}",
      "private int getNameId(String symbolName)  {\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n      id = originalNameMap.size();\n      originalNameMap.put(symbolName, id);\n    }\n    return id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n        return UNMAPPED;\n    }\n    Integer id = originalNameMap.get(symbolName);\n    if (id == null) {\n        id = originalNameMap.size();\n        originalNameMap.put(symbolName, id);\n    }\n    return id;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n    pos += result.length();\n  } else if (p == PEEKED_NUMBER) {\n    result = nextNumber();\n    pos += result.length();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  JsonToken token = peeked;\n  peeked = PEEKED_NONE;\n  double value = Double.parseDouble(result);\n  if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n    throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value + locationString());\n  }\n  pathIndices[stackSize - 1]++;\n  return value;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    return Double.parseDouble(peekedString);\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    return Double.parseDouble(nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'));\n  }\n  if (p == PEEKED_TRUE) {\n    return 1.0;\n  }\n  if (p == PEEKED_FALSE || p == PEEKED_NULL) {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = nextQuotedValue(JsonScope.EMPTY_DOCUMENT);\n    try {\n      JsonReaderInternalAccess.INSTANCE.promoteNameToValue(this);\n      double result = Double.parseDouble(peekedString);\n      if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n        throw new JsonSyntaxException(\"JSON forbids NaN and infinities: \" + result);\n      }\n      return result;\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(\"Expected a double but was \" + peekedString, e);\n    }\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peekedString = nextQuotedValue(JsonScope.EMPTY_DOCUMENT);\n    try {\n      JsonReaderInternalAccess.INSTANCE.promoteNameToValue(this);\n      double result = Double.parseDouble(peekedString);\n      if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n        throw new JsonSyntaxException(\"JSON forbids NaN and infinities: \" + result);\n      }\n      return result;\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(\"Expected a double but was \" + peekedString, e);\n    }\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n    pos += result.length();\n  } else if (p == PEEKED_NUMBER) {\n    result = nextNumber();\n    pos += result.length();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  JsonToken token = peeked;\n  peeked = PEEKED_NONE;\n  double value;\n  try {\n    value = Double.parseDouble(result);\n  } catch (NumberFormatException e) {\n    throw new JsonSyntaxException(\"Expected a double but was \" + result + locationString(), e);\n  }\n  if (token == PEEKED_NUMBER) {\n    // we're just consuming the peeked number here...\n    peekedString = null;\n    peeked = PEEKED_NONE;\n  }\n  return value;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n        pos += result.length();\n    } else if (p == PEEKED_NUMBER) {\n        result = nextNumber();\n        pos += result.length();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    JsonToken token = peeked;\n    peeked = PEEKED_NONE;\n    double value;\n    try {\n        value = Double.parseDouble(result);\n    } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(\"Expected a double but was \" + result + locationString(), e);\n    }\n    if (value >= Double.NEGATIVE_INFINITY && value <= Double.POSITIVE_INFINITY) {\n        return value;\n    }\n    throw new JsonSyntaxException(\"Expected a double but was \" + result + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = nextQuotedValue(peekedString);\n        try {\n            return Double.parseDouble(peekedString);\n        } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(peekedString + \" is not a valid double value as per JSON specification. To override this\"\n                    + \" behavior, use JsonReader.setLenient(true)\");\n        }\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(peekedString);\n        try {\n            return Double.parseDouble(peekedString);\n        } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(peekedString + \" is not a valid double value as per JSON specification. To override this\"\n                    + \" behavior, use JsonReader.setLenient(true)\");\n        }\n    }\n\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        return Double.parseDouble(peekedString);\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        try {\n            return Double.parseDouble(nextString());\n        } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(e);\n        }\n    }\n\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n        pos += result.length();\n    } else if (p == PEEKED_NUMBER) {\n        result = nextNumber();\n        pos += result.length();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    JsonToken token = peeked;\n    peeked = PEEKED_NONE;\n    double value = Double.parseDouble(result);\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n        throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value + locationString());\n    }\n    return value;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n    pos += result.length();\n  } else if (p == PEEKED_NUMBER) {\n    result = nextNumber();\n    pos += result.length();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  JsonToken token = peeked;\n  peeked = PEEKED_NONE;\n  double value = Double.parseDouble(result);\n  if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n    throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value + locationString());\n  }\n  pathIndices[stackSize - 1]++;\n  return value;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n    pos += result.length();\n  } else if (p == PEEKED_NUMBER) {\n    result = nextNumber();\n    pos += result.length();\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  JsonToken token = peeked;\n  peeked = PEEKED_NONE;\n  double value;\n  try {\n    value = Double.parseDouble(result);\n  } catch (NumberFormatException e) {\n    throw new JsonSyntaxException(\"Expected a double but was \" + result + locationString(), e);\n  }\n  if (value >= Double.NEGATIVE_INFINITY && value <= Double.POSITIVE_INFINITY) {\n    return value;\n  }\n  throw new JsonSyntaxException(\"Expected a double but was \" + result + locationString());\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    // Performance tuned for 2.0 (JDK1.4)\n\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> impl = implementations.get(headerId);\n    if (impl == null) {\n        impl = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) impl.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> impl = implementations.get(headerId);\n    if (impl == null) {\n        impl = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) impl.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> impl = implementations.get(headerId);\n    if (impl == null) {\n        impl = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) impl.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        if (CharSet.getInstance(set).contains(ch)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (containsAny(str.substring(i, i + 1), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (containsAny(str.substring(i, i + 1), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (containsAny(str.substring(i, i + 1), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        if (containsAny(str.substring(i, i + 1), set)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (containsAny(String.valueOf(ch), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (containsAny(String.valueOf(ch), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (containsAny(str.substring(i, i + 1), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (containsAny(String.valueOf(c), set)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        if (containsAny(str.substring(i, i + 1), set)) \n        {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator iterator = result.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue(((List) entry.getValue()).clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    Iterator iterator = result.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Object key = iterator.next();\n        result.put(key, cloneMarkerCollection((Collection) map.get(key)));\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    Iterator iterator = result.values().iterator();\n    while (iterator.hasNext()) \n    {\n        Object key = iterator.next();\n        List list = (List) result.get(key);\n        list = (List) list.clone();\n        result.put(key, list);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator iterator = result.keySet().iterator(); iterator.hasNext();) \n    {\n        Object key = iterator.next();\n        result.put(key, cloneMarkerList((List) map.get(key)));\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    Iterator iterator = result.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Object key = iterator.next();\n        Object value = result.get(key);\n        if (value instanceof Cloneable) \n        {\n            result.put(key, ((Cloneable) value).clone());\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    Iterator iterator = result.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Object key = iterator.next();\n        Object value = result.get(key);\n        if (value instanceof Cloneable) \n        {\n            result.put(key, ((Cloneable) value).clone());\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator iterator = result.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue(((List) entry.getValue()).clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator iterator = result.keySet().iterator(); iterator.hasNext();) \n    {\n        Object key = iterator.next();\n        Object value = result.get(key);\n        if (value instanceof Cloneable) \n        {\n            result.put(key, ((Cloneable) value).clone());\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    Iterator iterator = result.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Object key = iterator.next();\n        result.put(key, cloneMarkerList((List) map.get(key)));\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator iterator = result.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue(((List) entry.getValue()).clone());\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (final ZipExtraField element : data) {\n        final byte[] data = element.getCentralDirectoryData();\n        result = Arrays.copyOf(result, result.length + data.length);\n        System.arraycopy(data, 0, result, result.length - data.length, data.length);\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    byte[] result = null;\n    if (data != null) {\n        int total = 0;\n        for (ZipExtraField element : data) {\n            total += element.getCentralDirectoryLength().getValue();\n        }\n        if (total > 0) {\n            result = new byte[total];\n            int pos = 0;\n            for (ZipExtraField element : data) {\n                System.arraycopy(element.getCentralDirectoryData(), 0, result, pos, element.getCentralDirectoryLength().getValue());\n                pos += element.getCentralDirectoryLength().getValue();\n            }\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    final List<byte[]> list = new ArrayList<>();\n    for (final ZipExtraField element : data) {\n        final byte[] cd = element.getCentralDirectoryData();\n        if (cd != null) {\n            list.add(cd);\n        }\n    }\n    return mergeArrays(list);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final byte[] result = new byte[data.length * 4];\n    int offset = 0;\n    for (final ZipExtraField element : data) {\n        final ZipShort fieldLength = element.getCentralDirectoryLength();\n        final byte[] fieldData = element.getCentralDirectoryData();\n        fieldLength.getBytes(result, offset);\n        offset += 2;\n        System.arraycopy(fieldData, 0, result, offset, fieldData.length);\n        offset += fieldData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    int totalLength = 0;\n    for (final ZipExtraField element : data) {\n        totalLength += element.getCentralDirectoryLength().getValue();\n    }\n    final byte[] result = new byte[totalLength];\n    int offset = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] local = element.getCentralDirectoryData();\n        System.arraycopy(local, 0, result, offset, local.length);\n        offset += local.length;\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    final byte[] result = new byte[data.length * WORD];\n    int pos = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] local = element.getCentralDirectoryData();\n        System.arraycopy(local, 0, result, pos, local.length);\n        pos += local.length;\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    byte[] result = null;\n    int total = 0;\n    for (final ZipExtraField element : data) {\n        if (element != null) {\n            final byte[] b = element.getCentralDirectoryData();\n            if (b != null) {\n                total += b.length;\n            }\n        }\n    }\n    if (total > 0) {\n        result = new byte[total];\n        int pos = 0;\n        for (final ZipExtraField element : data) {\n            if (element != null) {\n                final byte[] b = element.getCentralDirectoryData();\n                if (b != null) {\n                    System.arraycopy(b, 0, result, pos, b.length);\n                    pos += b.length;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        byte[] result = new byte[0];\n        for (ZipExtraField field : data) {\n            result = Arrays.copyOf(result, result.length + field.getCentralDirectoryLength().getValue());\n            System.arraycopy(field.getCentralDirectoryData(), 0, result, result.length - field.getCentralDirectoryLength().getValue(), field.getCentralDirectoryLength().getValue());\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    int size = 0;\n    for (final ZipExtraField element : data) {\n        size += element.getCentralDirectoryLength().getValue();\n    }\n    final byte[] result = new byte[size];\n    int pos = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getCentralDirectoryData(), 0, result, pos, element.getCentralDirectoryLength().getValue());\n        pos += element.getCentralDirectoryLength().getValue();\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final List<byte[]> result = new ArrayList<>();\n    for (final ZipExtraField element : data) {\n        final byte[] cd = element.getCentralDirectoryData();\n        if (cd != null) {\n            result.add(cd);\n        }\n    }\n    return mergeArrays(result);\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E e : coll) {\n            if (set.add(e)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        final boolean result = super.addAll(index, coll);\n        final Set<E> set = this.set;\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                super.remove(e);\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (set.addAll(coll)) {\n            super.addAll(index, coll);\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E e : coll) {\n            if (add(index, e)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E e : coll) {\n            if (set.add(e)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E e : coll) {\n            if (add(index, e)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E object : coll) {\n            if (add(index, object)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        final boolean result = super.addAll(index, coll);\n        set.addAll(coll);\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        final boolean changed = super.addAll(index, coll);\n        final Set<E> set = createSetBasedOnList(this.set, this.list);\n        this.set = set;\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        final Set<E> set = createSetBasedOnList(this.set, this.list);\n        return set.addAll(coll);\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    // TODO: implement this method\n    return 0;\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    // TODO\n    return 0;\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    // TODO: implement this method\n    return null;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    //TODO: implement this method\n    return null;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRelationship() == Relationship.LEQ) {\n            normalizedConstraints.add(constraint);\n        } else {\n            // inequality constraint.  Negate the coefficients and change the\n            // relationship to LEQ\n            double[] coefficients = constraint.getCoefficients().toArray();\n            for (int i = 0; i < coefficients.length; ++i) {\n                coefficients[i] = -coefficients[i];\n            }\n            LinearConstraint normalizedConstraint = new LinearConstraint(coefficients, Relationship.LEQ, -constraint.getValue());\n            normalizedConstraints.add(normalizedConstraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    // TODO: implement this method\n    return null;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    // Complete this function\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    // TODO: implement this method\n    return null;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound >= bin.upperBound || this.upperBound <= bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    double lowerBound = getLowerBound();\n    double upperBound = getUpperBound();\n    double otherLowerBound = bin.getLowerBound();\n    double otherUpperBound = bin.getUpperBound();\n    return (lowerBound <= otherUpperBound && upperBound >= otherLowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound) && (this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.upperBound) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) \n    {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) \n            {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } \n        else \n        {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) \n    {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) \n            {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } \n        else \n        {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return parseMillis(text, ISOChronology.getInstance());\n}",
      "public long parseMillis(String text)  {\n    return requireParser().parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ssZ\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    // TODO: implement this method\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    return requireParser().parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return requireParser().parseMillis(text);\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  return MinimizedCondition.fromConditionNode(n);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = new Node(Token.SCRIPT);\n  placeholder.setLength(Integer.MAX_VALUE);\n  return MinimizedCondition.fromConditionNode(n).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return MinimizedCondition.fromConditionNode(n);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n    new MeasuredNode(n, estimateCostOneLevel(n), false),\n    new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return MinimizedCondition.fromConditionNode(n);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return MinimizedCondition.fromConditionNode(n);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n    new MeasuredNode(n, estimateCostOneLevel(n), false),\n    new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return MinimizedCondition.fromConditionNode(n);\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, IterableUtils.toArray(values));\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final List<E> values = new ArrayList<E>();\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(NULL_ELEMENTS_NOT_PERMITTED);\n        }\n        values.add(value);\n    }\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int arraySize = (enumSize + 63) / 64;\n    final long[] result = new long[arraySize];\n    for (int i = 0; i < values.size(); i++) {\n        final long bitVector = 1L << values.get(i).ordinal();\n        final int arrayIndex = values.get(i).ordinal() / 64;\n        result[arrayIndex] |= bitVector;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final List<E> values = Objects.requireNonNull(values, NULL_ELEMENTS_NOT_PERMITTED);\n    final int bitVectorSize = values.size();\n    final long[] bitVectors = new long[bitVectorSize];\n    int i = 0;\n    for (final E value : values) {\n        final long bitVector = 1L << value.ordinal();\n        bitVectors[i] = bitVector;\n        i++;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, IterableUtils.toArray(values));\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(NULL_ELEMENTS_NOT_PERMITTED);\n        }\n        enumSet.add(value);\n    }\n    final long[] result = new long[enumSet.size()];\n    int i = 0;\n    for (final E e : enumSet) {\n        result[i++] = e.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(NULL_ELEMENTS_NOT_PERMITTED);\n        }\n        enumSet.add(value);\n    }\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int arraySize = (enumSize + 63) / 64;\n    final long[] result = new long[arraySize];\n    int i = 0;\n    for (final E e : enumSet) {\n        final int bit = e.ordinal();\n        final int arrayIndex = bit / 64;\n        final int bitIndex = bit % 64;\n        result[arrayIndex] |= 1L << bitIndex;\n        i++;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final List<E> values = new ArrayList<E>();\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(NULL_ELEMENTS_NOT_PERMITTED);\n        }\n        values.add(value);\n    }\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int arraySize = (enumSize + Long.SIZE - 1) / Long.SIZE;\n    final long[] result = new long[arraySize];\n    for (int i = 0; i < values.size(); i++) {\n        final long bit = 1L << values.get(i).ordinal();\n        for (int j = 0; j < arraySize; j++) {\n            result[j] |= bit;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final List<E> values = new ArrayList<E>();\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(NULL_ELEMENTS_NOT_PERMITTED);\n        }\n        values.add(value);\n    }\n    final long[] bitVectors = new long[values.size()];\n    for (int i = 0; i < values.size(); i++) {\n        bitVectors[i] = 1L << values.get(i).ordinal();\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    final long[] result = new long[((EnumUtils.asEnum(enumClass).getEnumConstants().length - 1) / Long.SIZE) + 1];\n    int i = 0;\n    for (final E e : values) {\n        result[i] |= 1L << e.ordinal();\n        i++;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values.toArray(new E[0]));\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        if (set == null) {\n            set = new ConverterSet(new Converter[] {converter});\n            iPartialConverters = set;\n            return null;\n        }\n        return (PartialConverter) set.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.iConverters;\n    int size = converters.length;\n    for (int i = 0; i < size; i++) {\n        Converter existing = converters[i];\n        if (existing.equals(converter)) {\n            return null;\n        }\n    }\n    Converter[] newConverters = new Converter[size + 1];\n    System.arraycopy(converters, 0, newConverters, 0, size);\n    newConverters[size] = converter;\n    iPartialConverters = new ConverterSet(newConverters);\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        if (set == null) {\n            set = new ConverterSet(new Converter[] {converter});\n            iPartialConverters = set;\n            return null;\n        }\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        iPartialConverters = set;\n        return (PartialConverter) removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    PartialConverter[] converters = getPartialConverters();\n    for (int i = 0; i < converters.length; i++) {\n        if (converter.equals(converters[i])) {\n            return null;\n        }\n    }\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPartialConverters();\n        PartialConverter[] converters = getPartialConverters();\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                return null;\n            }\n        }\n        return addPartialConverter(converter, new PartialConverter[converters.length]);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] converters = getPartialConverters();\n        PartialConverter replaced = null;\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                replaced = converters[i];\n                break;\n            }\n        }\n        if (replaced == null) {\n            iPartialConverters = iPartialConverters.add(converter, null);\n        }\n        return replaced;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.iConverters;\n    int size = set.size();\n    for (int i = 0; i < size; i++) {\n        Converter conv = converters[i];\n        if (conv == converter) {\n            return null;\n        }\n        if (conv.getSupportedType() == converter.getSupportedType()) {\n            Converter[] removed = new Converter[1];\n            set = set.remove(i, removed);\n            return (PartialConverter) removed[0];\n        }\n    }\n    Converter[] newConverters = new Converter[size + 1];\n    System.arraycopy(converters, 0, newConverters, 0, size);\n    newConverters[size] = converter;\n    iPartialConverters = set.add(converter, newConverters);\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPartialConverters;\n    if (set == null) {\n        set = new ConverterSet(new Converter[] { converter });\n        iPartialConverters = set;\n        return null;\n    }\n    return set.add(converter, new Converter[0]);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    PartialConverter[] converters = getPartialConverters();\n    PartialConverter[] removed = new PartialConverter[converters.length];\n    PartialConverter replaced = iPartialConverters.add(converter, removed);\n    if (replaced != null) {\n        for (int i = 0; i < removed.length; i++) {\n            if (removed[i] != null) {\n                removePartialConverter(removed[i]);\n            }\n        }\n    }\n    return replaced;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] converters = getPartialConverters();\n        PartialConverter replaced = null;\n        for (int i = 0; i < converters.length; i++) {\n            if (converter.equals(converters[i])) {\n                replaced = converters[i];\n                break;\n            }\n        }\n        if (replaced == null) {\n            PartialConverter[] newArray = new PartialConverter[converters.length + 1];\n            System.arraycopy(converters, 0, newArray, 0, converters.length);\n            newArray[converters.length] = converter;\n            iPartialConverters = new ConverterSet(newArray);\n        }\n        return replaced;\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    return scope.getScopeDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof SymbolScope) {\n    return ((SymbolScope) scope).getScopeDepth();\n  } else if (scope instanceof PropertyScope) {\n    SymbolScope lexicalScope = ((PropertyScope) scope).getLexicalScope();\n    return getLexicalScopeDepth(lexicalScope) + lexicalScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope)  {\n    return scope.getScopeDepth();\n  }\n  else if (scope instanceof PropertyScope)  {\n    return getLexicalScopeDepth(scope.getParentScope()) + scope.getParentScope().getScopeDepth();\n  }\n  else if (scope instanceof DocInfoScope)  {\n    return 0;\n  }\n  else  {\n    throw new IllegalArgumentException(\"Unknown scope type: \" + scope);\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    return scope.getScopeDepth();\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof SymbolScope)  {\n    return scope.getScopeDepth();\n  }\n  else if (scope instanceof PropertyScope)  {\n    return getLexicalScopeDepth(scope.getParentScope()) + scope.getParentScope().getScopeDepth();\n  }\n  else if (scope instanceof DocInfoScope)  {\n    return 0;\n  }\n  else  {\n    throw new RuntimeException(\"Unknown scope type: \" + scope);\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getParentScope();\n    while (!lexicalScope.isLexicalScope()) {\n      lexicalScope = lexicalScope.getParentScope();\n    }\n    return lexicalScope.getScopeDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getParentScope();\n    return getLexicalScopeDepth(lexicalScope) + lexicalScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope)  {\n    return scope.getScopeDepth();\n  }\n  else if (scope instanceof PropertyScope)  {\n    return getLexicalScopeDepth(scope.getParentScope()) +\n        scope.getParentScope().getScopeDepth();\n  }\n  else if (scope instanceof DocInfoScope)  {\n    return 0;\n  }\n  else  {\n    throw new IllegalArgumentException(\"Invalid scope type: \" + scope);\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    final int nBlockRows = nRows / BLOCK_SIZE;\n    final int nBlockCols = nCols / BLOCK_SIZE;\n    final double[][] blocksData = createBlocksLayout(nBlockRows, nBlockCols);\n    for (int blockRow = 0; blockRow < nBlockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow = FastMath.min(startRow + BLOCK_SIZE, nRows);\n        for (int blockCol = 0; blockCol < nBlockCols; ++blockCol) {\n            final int startCol = blockCol * BLOCK_SIZE;\n            final int endCol = FastMath.min(startCol + BLOCK_SIZE, nCols);\n            final double[] block = blocksData[blockRow][blockCol];\n            for (int i = startRow; i < endRow; ++i) {\n                for (int j = startCol; j < endCol; ++j) {\n                    block[i - startRow][j - startCol] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int n = rawData.length;\n    final int m = rawData[0].length;\n    final int blockRows = (int) Math.sqrt(n);\n    final int blockColumns = (int) Math.sqrt(m);\n    final int nBlocks = blockRows * blockColumns;\n    final double[][] blocks = new double[nBlocks][];\n    for (int block = 0; block < nBlocks; ++block) {\n        final int blockRow = block / blockColumns;\n        final int blockColumn = block % blockColumns;\n        final int blockHeight = blockHeight(blockRow, n, blockRows);\n        final int blockWidth = blockWidth(blockColumn, m, blockColumns);\n        final double[] block = new double[blockHeight * blockWidth];\n        for (int i = 0; i < blockHeight; ++i) {\n            final int row = blockRow * blockHeight + i;\n            for (int j = 0; j < blockWidth; ++j) {\n                final int column = blockColumn * blockWidth + j;\n                block[i * blockWidth + j] = rawData[row][column];\n            }\n        }\n        blocks[block] = block;\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int cols = rawData[0].length;\n    final int blockRows = rows / BLOCK_SIZE;\n    final int blockCols = cols / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][];\n    for (int i = 0; i < blockRows; ++i) {\n        blocks[i] = new double[blockCols * BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    for (int i = 0; i < rows; ++i) {\n        final double[] rawRow = rawData[i];\n        for (int j = 0; j < cols; ++j) {\n            final int blockRow = i / BLOCK_SIZE;\n            final int blockCol = j / BLOCK_SIZE;\n            final int blockRowOffset = blockRow * BLOCK_SIZE * BLOCK_SIZE;\n            final int blockColOffset = blockCol * BLOCK_SIZE;\n            final int index = blockRowOffset + blockColOffset + (i % BLOCK_SIZE) * BLOCK_SIZE + (j % BLOCK_SIZE);\n            blocks[blockRow][index] = rawRow[j];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    final int nBlockRows = (nRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int nBlockCols = (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocksData = new double[nBlockRows][];\n    for (int blockRow = 0; blockRow < nBlockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow = Math.min(nRows, startRow + BLOCK_SIZE);\n        final int blockHeight = endRow - startRow;\n        final double[] block = new double[blockHeight * nBlockCols];\n        blocksData[blockRow] = block;\n        for (int blockCol = 0; blockCol < nBlockCols; ++blockCol) {\n            final int startCol = blockCol * BLOCK_SIZE;\n            final int endCol = Math.min(nCols, startCol + BLOCK_SIZE);\n            final int blockWidth = endCol - startCol;\n            int k = blockCol * blockHeight;\n            for (int i = startRow; i < endRow; ++i) {\n                for (int j = startCol; j < endCol; ++j) {\n                    block[k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows    = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows    = rows / BLOCK_SIZE;\n    final int blockColumns = columns / BLOCK_SIZE;\n\n    final double[][] blocksData = createBlocksLayout(blockRows, blockColumns);\n\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startRow    = blockRow * BLOCK_SIZE;\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int endColumn   = FastMath.min(startColumn + BLOCK_SIZE, columns);\n            final int blockLength = endRow - startRow;\n            final int blockWidth  = endColumn - startColumn;\n            final int index       = blockRow * blockColumns + blockColumn;\n            final double[] block = blocksData[index];\n            for (int i = 0; i < blockLength; ++i) {\n                System.arraycopy(rawData[startRow + i], startColumn,\n                                 block, i * blockWidth, blockWidth);\n            }\n        }\n    }\n\n    return blocksData;\n\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows    = rawData.length;\n    final int columns = rawData[0].length;\n\n    // compute number of blocks needed, taking care of edge blocks which may be rectangular\n    final int blockRows    = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate the array in blocks layout\n    final double[][] blocks = createBlocksLayout(blockRows, blockColumns);\n\n    // copy the raw data in the blocks array\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow   = FastMath.min(startRow + BLOCK_SIZE, rows);\n        final int m        = endRow - startRow;\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn   = FastMath.min(startColumn + BLOCK_SIZE, columns);\n            final int n           = endColumn - startColumn;\n            final double[] block = blocks[blockRow][blockColumn];\n            for (int i = 0; i < m; ++i) {\n                System.arraycopy(rawData[startRow + i], startColumn, block, i * n, n);\n            }\n        }\n    }\n\n    return blocks;\n\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // safety checks\n    final int n = rawData.length;\n    if (n == 0) {\n        return new double[0][0];\n    }\n    final int m = rawData[0].length;\n    if (m == 0) {\n        return new double[n][0];\n    }\n    for (int i = 0; i < n; ++i) {\n        if (rawData[i].length != m) {\n            throw new DimensionMismatchException(n, m);\n        }\n    }\n\n    // convert\n    final int blockRows = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (m + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows][];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow = FastMath.min(n, startRow + BLOCK_SIZE);\n        final int blockHeight = endRow - startRow;\n        final double[] block = new double[blockHeight * blockColumns];\n        blocks[blockRow] = block;\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn = FastMath.min(m, startColumn + BLOCK_SIZE);\n            final int blockWidth = endColumn - startColumn;\n            int k = 0;\n            for (int i = startRow; i < endRow; ++i) {\n                for (int j = startColumn; j < endColumn; ++j) {\n                    block[k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    // retrieve dimensions\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n\n    // create the array in blocks layout\n    final double[][] blocksData = createBlocksLayout(nRows, nCols);\n\n    // copy the raw data into the blocks array\n    for (int blockRow = 0; blockRow < nRows; ++blockRow) {\n        final int blockRowHeight = blockHeight(blockRow);\n        final int blockRowStart = blockRow * blockRowHeight;\n        final int blockRowEnd = blockRowStart + blockRowHeight;\n        for (int blockCol = 0; blockCol < nCols; ++blockCol) {\n            final int blockColWidth = blockWidth(blockCol);\n            final int blockColStart = blockCol * blockColWidth;\n            final int blockColEnd = blockColStart + blockColWidth;\n            for (int iBlockRow = blockRowStart; iBlockRow < blockRowEnd; ++iBlockRow) {\n                for (int iBlockCol = blockColStart; iBlockCol < blockColEnd; ++iBlockCol) {\n                    blocksData[iBlockRow][iBlockCol] = rawData[blockRow][blockCol];\n                }\n            }\n        }\n    }\n\n    return blocksData;\n\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows    = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows    = (int) Math.ceil(rows / (double) BLOCK_SIZE);\n    final int blockColumns = (int) Math.ceil(columns / (double) BLOCK_SIZE);\n    final int blockCount   = blockRows * blockColumns;\n\n    final double[][] blocks = new double[blockCount][];\n\n    int blockIndex = 0;\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow   = Math.min(startRow + BLOCK_SIZE, rows);\n        final int rowLength = endRow - startRow;\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn   = Math.min(startColumn + BLOCK_SIZE, columns);\n            final int columnLength = endColumn - startColumn;\n            final int blockLength = rowLength * columnLength;\n            blocks[blockIndex] = new double[blockLength];\n            int blockRowIndex = 0;\n            for (int i = startRow; i < endRow; ++i) {\n                int blockColumnIndex = 0;\n                for (int j = startColumn; j < endColumn; ++j) {\n                    blocks[blockIndex][blockRowIndex + blockColumnIndex] = rawData[i][j];\n                    ++blockColumnIndex;\n                }\n                blockRowIndex += columnLength;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    final int nBlockRows = (nRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int nBlocks = nBlockRows * (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[nBlocks][];\n    int blockIndex = 0;\n    for (int blockRow = 0; blockRow < nBlockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow = FastMath.min(nRows, startRow + BLOCK_SIZE);\n        final int rowLength = endRow - startRow;\n        for (int blockCol = 0; blockCol < (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE; ++blockCol) {\n            final int startCol = blockCol * BLOCK_SIZE;\n            final int endCol = FastMath.min(nCols, startCol + BLOCK_SIZE);\n            final int colLength = endCol - startCol;\n            final double[] block = new double[rowLength * colLength];\n            blocks[blockIndex] = block;\n            for (int i = startRow; i < endRow; ++i) {\n                for (int j = startCol; j < endCol; ++j) {\n                    block[i - startRow + (j - startCol) * rowLength] = rawData[i][j];\n                }\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final long[] bitVectors = generateBitVectors(enumClass, values);\n    if (bitVectors.length != 1) {\n        throw new IllegalArgumentException(String.format(CANNOT_STORE_S_S_VALUES_IN_S_BITS,\n                enumClass.getSimpleName(), values.size(), Long.SIZE));\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        final Class<E> enumClass = checkBitVectorable(enumClass);\n        final long[] bitVectors = generateBitVectors(enumClass, values);\n        return bitVectors[0];\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values.iterator());\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    long bitVector = 0;\n    for (final E value : values) \n    {\n        final long bit = 1L << value.ordinal();\n        if ((bitVector & bit) != 0) \n        {\n            throw new IllegalArgumentException(String.format(\"Duplicate values in the iterable: %s\", value));\n        }\n        bitVector |= bit;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        final Class<E> enumClass = checkBitVectorable(enumClass);\n        final long[] bitVectors = generateBitVectors(enumClass, values);\n        if (bitVectors.length > 1) {\n            throw new IllegalArgumentException(String.format(CANNOT_STORE_S_S_VALUES_IN_S_BITS,\n                    enumClass.getSimpleName(), bitVectors.length, 64));\n        }\n        return bitVectors[0];\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values.toArray(new E[0]));\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, IterableUtils.toArray(values));\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values.toArray(new E[0]));\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values.toArray(new Enum[0]));\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final Class<E> enumClass = checkBitVectorable(enumClass);\n    long result = 0;\n    for (final E e : values) {\n        final long bit = 1L << e.ordinal();\n        if ((result & bit) != 0) {\n            throw new IllegalArgumentException(String.format(\"Element %s already present in BitVector for Enum %s\", e, enumClass.getSimpleName()));\n        }\n        result |= bit;\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = new Dfp(a);\n    Dfp x2 = x.multiply(x);\n    Dfp x3 = x2.multiply(x);\n    Dfp x4 = x3.multiply(x);\n    Dfp x5 = x4.multiply(x);\n    Dfp x6 = x5.multiply(x);\n    Dfp x7 = x6.multiply(x);\n    Dfp x8 = x7.multiply(x);\n    Dfp x9 = x8.multiply(x);\n    Dfp x10 = x9.multiply(x);\n    Dfp x11 = x10.multiply(x);\n    Dfp x12 = x11.multiply(x);\n    Dfp x13 = x12.multiply(x);\n    Dfp x14 = x13.multiply(x);\n    Dfp x15 = x14.multiply(x);\n    Dfp x16 = x15.multiply(x);\n    Dfp x17 = x16.multiply(x);\n    Dfp x18 = x17.multiply(x);\n    Dfp x19 = x18.multiply(x);\n    Dfp x20 = x19.multiply(x);\n    Dfp x21 = x20.multiply(x);\n    Dfp x22 = x21.multiply(x);\n    Dfp x23 = x22.multiply(x);\n    Dfp x24 = x23.multiply(x);\n    Dfp x25 = x24.multiply(x);\n    Dfp x26 = x25.multiply(x);\n    Dfp x27 = x26.multiply(x);\n    Dfp x28 = x27.multiply(x);\n    Dfp x29 = x28.multiply(x);\n    Dfp x30 = x29.multiply(x);\n    Dfp x31 = x30.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(1);\n    Dfp term = a;\n    int i = 1;\n    while (term.abs().greaterThan(result.ulp())) {\n        term = term.multiply(a);\n        result = result.add(term.divide(i));\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = new Dfp(a.getField());\n    Dfp term = new Dfp(a.getField());\n    Dfp one = new Dfp(a.getField(), 1);\n    Dfp two = new Dfp(a.getField(), 2);\n    Dfp factorial = new Dfp(a.getField(), 1);\n    Dfp aSquared = new Dfp(a.getField());\n    Dfp aCubed = new Dfp(a.getField());\n    Dfp aFourth = new Dfp(a.getField());\n    Dfp aFifth = new Dfp(a.getField());\n    Dfp aSixth = new Dfp(a.getField());\n    Dfp aSeventh = new Dfp(a.getField());\n    Dfp aEighth = new Dfp(a.getField());\n    Dfp aNinth = new Dfp(a.getField());\n    Dfp aTenth = new Dfp(a.getField());\n    Dfp aEleventh = new Dfp(a.getField());\n    Dfp aTwelfth = new Dfp(a.getField());\n    Dfp aThirteenth = new Dfp(a.getField());\n    Dfp aFourteenth = new Dfp(a.getField());\n    Dfp aFifteenth = new Dfp(a.getField());\n    Dfp aSixteenth = new Dfp(a.getField());\n    Dfp aSeventeenth = new Dfp(a.getField());\n    Dfp aEighteenth = new Dfp(a.getField());\n    Dfp aNineteenth = new Dfp(a.getField());\n    Dfp aTwentieth = new Dfp(a.getField());\n    Dfp aTwentyFirst = new Dfp(a.getField());\n    Dfp aTwentySecond = new Dfp(a.getField());\n    Dfp aTwentyThird = new Dfp(a.getField());\n    Dfp aTwentyFourth = new Dfp(a.getField());\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    // 1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.newInstance(1);\n    Dfp x = a.newInstance(a);\n    Dfp x2 = x.multiply(x);\n    Dfp x3 = x2.multiply(x);\n    Dfp x4 = x3.multiply(x);\n    Dfp x5 = x4.multiply(x);\n    Dfp x6 = x5.multiply(x);\n    Dfp x7 = x6.multiply(x);\n    Dfp x8 = x7.multiply(x);\n    Dfp x9 = x8.multiply(x);\n    Dfp x10 = x9.multiply(x);\n    Dfp x11 = x10.multiply(x);\n    Dfp x12 = x11.multiply(x);\n    Dfp x13 = x12.multiply(x);\n    Dfp x14 = x13.multiply(x);\n    Dfp x15 = x14.multiply(x);\n    Dfp x16 = x15.multiply(x);\n    Dfp x17 = x16.multiply(x);\n    Dfp x18 = x17.multiply(x);\n    Dfp x19 = x18.multiply(x);\n    Dfp x20 = x19.multiply(x);\n    Dfp x21 = x20.multiply(x);\n    Dfp x22 = x21.multiply(x);\n    Dfp x23 = x22.multiply(x);\n    Dfp x24 = x23.multiply(x);\n    Dfp x25 = x24.multiply(x);\n    Dfp x26 = x25.multiply(x);\n    Dfp x27 = x26.multiply(x);\n    Dfp x28 = x27.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = newInstance(1);\n    Dfp term = newInstance(1);\n    Dfp power = newInstance(a);\n    Dfp factorial = newInstance(1);\n    int i = 1;\n    while (term.compareTo(result) > 0) {\n        factorial = factorial.multiply(newInstance(i));\n        term = power.divide(factorial);\n        result = result.add(term);\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp sum = a.newInstance(1);\n    Dfp term = a;\n    Dfp factorial = a.newInstance(1);\n    for (int i = 2; i < 100; i++) {\n        term = term.multiply(a);\n        factorial = factorial.multiply(i);\n        sum = sum.add(term.divide(factorial));\n    }\n    return sum;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isZero()) {\n        return a.newInstance(1);\n    }\n    if (a.isInfinite()) {\n        return a.newInstance(a.sign);\n    }\n    if (a.isNaN()) {\n        return a.newInstance(a.nans);\n    }\n    Dfp x = a.newInstance(1);\n    Dfp y = a.newInstance(1);\n    Dfp z = a.newInstance(1);\n    Dfp t = a.newInstance(1);\n    int i = 1;\n    while (i < 100) {\n        t = t.multiply(a);\n        z = z.multiply(i);\n        y = y.add(t.divide(z));\n        if (y.equals(x)) {\n            break;\n        }\n        x = y;\n        i++;\n    }\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = newInstance(1);\n    Dfp term = newInstance(1);\n    int i = 1;\n    while (term.abs().greaterThan(result.abs().multiply(1e-15))) {\n        term = a.pow(i);\n        result = result.add(term.divide(newInstance(i)));\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isZero()) {\n        return a.newInstance(1);\n    }\n    Dfp result = a.newInstance(1);\n    Dfp x = a.newInstance(1);\n    Dfp factorial = a.newInstance(1);\n    int i = 1;\n    while (x.abs().greaterThan(0)) {\n        x = x.multiply(a);\n        factorial = factorial.multiply(i);\n        result = result.add(x.divide(factorial));\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isZero()) {\n        return DfpField.ONE;\n    }\n    if (a.isInfinite()) {\n        return a;\n    }\n    if (a.isNaN()) {\n        return a;\n    }\n    if (a.compareTo(DfpField.ONE) < 0) {\n        return DfpField.ONE.divide(expInternal(a.negate()));\n    }\n    if (a.compareTo(DfpField.ONE) > 0) {\n        Dfp x = a.subtract(DfpField.ONE);\n        Dfp x2 = x.multiply(x);\n        Dfp x3 = x2.multiply(x);\n        Dfp x4 = x3.multiply(x);\n        Dfp x5 = x4.multiply(x);\n        Dfp x6 = x5.multiply(x);\n        Dfp x7 = x6.multiply(x);\n        Dfp x8 = x7.multiply(x);\n        Dfp x9 = x8.multiply(x);\n        Dfp x10 = x9.multiply(x);\n        Dfp x11 = x10.multiply(x);\n        Dfp x12 = x11.multiply(x);\n        Dfp x13 = x12.multiply(x);\n        Dfp x14 = x13.multiply(x);\n        Dfp x15 = x14.multiply(x);\n        Dfp x16 = x15.multiply(x);\n        Dfp x17 = x16.multiply(x);\n        Dfp x18 = x17.multiply(x);\n        Dfp x19 = x18.multiply(x);\n        Dfp x20 = x19.multiply(x);\n        Dfp x21 = x20.multiply(x);\n        Dfp x22 = x21.multiply(x);\n        Dfp x23 = x22.multiply(x);\n}\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n        final T x = getX();\n        final T y = getY();\n        final T z = getZ();\n        if (x.getReal() == 0 && y.getReal() == 0 && z.getReal() == 0) {\n            throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        final T invNorm = x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt().reciprocal();\n        return new FieldVector3D<T>(y.negate().multiply(invNorm),\n                                    z.negate().multiply(invNorm),\n                                    x.multiply(invNorm));\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute an arbitrary vector orthogonal to the instance\n    T x = getX();\n    T y = getY();\n    T z = getZ();\n    if (x.getReal() == 0) {\n        if (y.getReal() == 0) {\n            // the instance is colinear with the x axis, return a vector\n            // orthogonal to it such as (1, 0, 0)\n            return new FieldVector3D<T>(x.getField().getOne(), y.getField().getZero(), z.getField().getZero());\n        } else if (z.getReal() == 0) {\n            // the instance is colinear with the y axis, return a vector\n            // orthogonal to it such as (0, 1, 0)\n            return new FieldVector3D<T>(x.getField().getZero(), y.getField().getOne(), z.getField().getZero());\n        }\n    } else if (y.getReal() == 0) {\n        if (z.getReal() == 0) {\n            // the instance is colinear with the x axis, return a vector\n            // orthogonal to it such as (0, 0, 1)\n            return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getOne());\n        }\n    }\n    return new FieldVector3D<T>(y.negate(), z.negate(), x);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T x = getX();\n    final T y = getY();\n    final T z = getZ();\n    if (x.getReal() == 0) {\n        if (y.getReal() == 0) {\n            if (z.getReal() == 0) {\n                throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n            }\n            return new FieldVector3D<T>(z.getField().getZero().add(1),\n                                        z.getField().getZero(),\n                                        z.getField().getZero());\n        }\n        return new FieldVector3D<T>(y.getField().getZero(),\n                                    y.getField().getZero().add(1),\n                                    y.getField().getZero());\n    }\n    return new FieldVector3D<T>(y.getField().getZero(),\n                                z.getField().getZero().subtract(x.getField().getZero()),\n                                x.getField().getZero().subtract(y.getField().getZero()));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute a vector orthogonal to the instance\n    T x = getX();\n    T y = getY();\n    T z = getZ();\n    T norm = getNorm();\n    if (norm.getReal() == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.divide(norm), z.divide(norm).negate(), x.divide(norm));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute an arbitrary vector orthogonal to the instance\n    T x = getX();\n    T y = getY();\n    T z = getZ();\n    T n = getNorm();\n    if (n.getReal() == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    T nx = x.divide(n);\n    T ny = y.divide(n);\n    T nz = z.divide(n);\n    T nx2 = nx.multiply(nx);\n    T ny2 = ny.multiply(ny);\n    T nz2 = nz.multiply(nz);\n    T nxy = nx.multiply(ny);\n    T nxz = nx.multiply(nz);\n    T nyz = ny.multiply(nz);\n    T nx2ny = nx2.multiply(ny);\n    T nx2nz = nx2.multiply(nz);\n    T ny2nz = ny2.multiply(nz);\n    T nx2ny2 = nx2.multiply(ny2);\n    T nx2nz2 = nx2.multiply(nz2);\n    T ny2nz2 = ny2.multiply(nz2);\n    T nx2ny2nz2 = nx2.multiply(ny2.multiply(nz2));\n    T nx2ny2nz2_1 = nx2ny2nz2.subtract(nx2.multiply(ny2).multiply(nz2));\n    T nx2ny2nz2_2 = nx2ny2nz2.subtract(nx2.multiply(ny2).multiply(nz2));\n    T nx2ny2nz2_3 = nx2ny2nz2.subtract(nx2.multiply(ny2).multiply(nz2));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n        // compute an orthogonal vector by reflecting the instance through\n        // a plane with a normal vector orthogonal to the instance\n        // this is equivalent to negate the z coordinate\n        return new FieldVector3D<T>(x, y, x.getField().getZero().subtract(z));\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n        T norm = getNorm();\n        if (norm.getReal() == 0.0) {\n            throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n        }\n        return new FieldVector3D<T>(getY().negate(), getX(), getZ().negate());\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0.0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(x.getField().getOne().divide(norm), y.negate(), z);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute a vector orthogonal to the instance\n    // we know the z axis is orthogonal to the instance, so we use it\n    // to build a frame with the x axis in an arbitrary direction.\n    // we choose the x axis proportional to the y axis of the frame\n    // built with z (this is a right-handed frame).\n    T x = y.multiply(z.getNorm());\n    T y = z.multiply(x.getNorm());\n    return new FieldVector3D<T>(x, y, z);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T x = getX();\n    final T y = getY();\n    final T z = getZ();\n    final T norm2 = x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\n    if (norm2.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    final T invNorm = x.getField().getOne().divide(norm2.sqrt());\n    return new FieldVector3D<T>(y.negate().multiply(invNorm),\n                                x.multiply(invNorm),\n                                z.multiply(invNorm));\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap for an intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T min = getComparator().compare(getMinimum(), other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum();\n    final T max = getComparator().compare(getMaximum(), other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum();\n    return between(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other range must not be null\");\n    }\n    if (!this.isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T thisMin = this.getMinimum();\n    final T thisMax = this.getMaximum();\n    final T otherMin = other.getMinimum();\n    final T otherMax = other.getMaximum();\n    final T min = this.comparator.compare(thisMin, otherMin) <= 0 ? otherMin : thisMin;\n    final T max = this.comparator.compare(thisMax, otherMax) >= 0 ? otherMax : thisMax;\n    return new Range<T>(min, max, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T minimum = getMinimum().compareTo(other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum();\n    final T maximum = getMaximum().compareTo(other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum();\n    return between(minimum, maximum, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.containsRange(other)) {\n        throw new IllegalArgumentException(\"Range must overlap this range\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return new Range<>(this.maximum, other.maximum, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.containsRange(other)) {\n        throw new IllegalArgumentException(\"Range \" + other + \" does not overlap \" + this);\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    final T min = this.getComparator().compare(this.getMinimum(), other.getMinimum()) <= 0 ? this.getMinimum() : other.getMinimum();\n    final T max = this.getComparator().compare(this.getMaximum(), other.getMaximum()) >= 0 ? this.getMaximum() : other.getMaximum();\n    return new Range<T>(min, max, this.getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap for an intersection to exist\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T min = getComparator().compare(other.getMinimum(), getMinimum()) < 0 ? other.getMinimum() : getMinimum();\n    final T max = getComparator().compare(other.getMaximum(), getMaximum()) > 0 ? other.getMaximum() : getMaximum();\n    return between(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.containsRange(other)) {\n        throw new IllegalArgumentException(\"Range \" + other + \" does not overlap \" + this);\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return new Range<T>(this.maximum, other.maximum, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = getComparator().compare(other.getMinimum(), getMinimum()) < 0 ? other.getMinimum() : getMinimum();\n    final T max = getComparator().compare(other.getMaximum(), getMaximum()) > 0 ? other.getMaximum() : getMaximum();\n    return between(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    T min = getMinimum();\n    T max = getMaximum();\n    if (other.isBefore(min)) {\n        min = other.getMinimum();\n    }\n    if (other.isAfter(max)) {\n        max = other.getMaximum();\n    }\n    return between(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = getComparator().compare(getMinimum(), other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum();\n    final T max = getComparator().compare(getMaximum(), other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum();\n    return between(min, max, getComparator());\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt, _charBuffer, _byteBuffer, _encoding);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt, JsonEncoding.UTF8);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // 11-May-2017, tatu: As per [core#130], need to check for this\n    if (out instanceof EncodedOutputStream) {\n        EncodedOutputStream eos = (EncodedOutputStream) out;\n        if (eos.getEncoding().equals(JsonEncoding.UTF8)) {\n            return _createGenerator(eos, ctxt);\n        }\n    }\n    return _createGenerator(new EncodedOutputStream(out, JsonEncoding.UTF8), ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // 10-Jun-2019, tatu: As per [core#501], let's try to be more efficient\n    //   here, to avoid some unnecessary buffering.\n    return new JsonGenerator(out, ctxt, _objectCodec, _characterEscapes,\n            _generatorFeatures, _outputDecorator);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt, _charBuffer, _byteBuffer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(this, out, ctxt, Charset.forName(\"UTF-8\"));\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive()) {\n        return primitiveEquals(type, o1, o2);\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } else if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == null && o2 == null) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Class.class)) {\n        return o1.equals(o2);\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } else if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } \n    else if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    } \n    else if (type.isEnum()) \n    {\n        return o1.equals(o2);\n    } \n    else \n    {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == null) {\n        return o2 == null;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive()) {\n        return primitiveMemberEquals(type, o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } else if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } \n    else if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    } \n    else \n    {\n        return o1.equals(o2);\n    }\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isUnknownType())  {\n      return type;\n    }\n    return JSType.join(unionType.getAlternates());\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  return type.getLeastSupertype(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  } else if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  } else {\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    ImmutableList.Builder<JSType> filteredBuilder = ImmutableList.builder();\n    for (JSType alternative : unionType.getAlternates())  {\n      filteredBuilder.add(filterNoResolvedType(alternative));\n    }\n    return JSType.join(filteredBuilder.build());\n  }\n  return JSType.noResolvedType();\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isUnknownType()) {\n      return type;\n    }\n    if (unionType.isLiteralObject() && unionType.getAlternates().size() == 2) {\n      JSType first = unionType.getAlternates().get(0);\n      JSType second = unionType.getAlternates().get(1);\n      if (first.isNoResolvedType() && second.isNoResolvedType()) {\n        return type;\n      }\n    }\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    return type.toMaybeUnionType().filterNoResolvedType();\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isUnknownType())  {\n      return type;\n    }\n    boolean hasNoResolved = false;\n    for (JSType alt : unionType.getAlternates())  {\n      if (alt.isNoResolvedType())  {\n        hasNoResolved = true;\n        break;\n      }\n    }\n    if (hasNoResolved)  {\n      return typeRegistry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isUnknownType())  {\n      return type;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n    for (JSType alt : unionType.getAlternates())  {\n      if (alt.isNoResolvedType())  {\n        changed = true;\n      }\n      else  {\n        builder.add(alt);\n      }\n    }\n    if (changed)  {\n      return registry.createUnionType(builder.build());\n    }\n  }\n  return registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType.isUnknownType())  {\n      return type;\n    }\n    ImmutableList.Builder<JSType> filteredBuilder = ImmutableList.builder();\n    for (JSType alternative : unionType.getAlternates())  {\n      if (!alternative.isNoResolvedType())  {\n        filteredBuilder.add(alternative);\n      }\n    }\n    if (filteredBuilder.build().isEmpty())  {\n      return JSType.noResolvedType;\n    }\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType())  {\n    return type;\n  }\n  if (type.isUnionType())  {\n    UnionType unionType = type.toMaybeUnionType();\n    ImmutableList.Builder<JSType> filteredBuilder = ImmutableList.builder();\n    for (JSType alternative : unionType.getAlternates())  {\n      if (!alternative.isNoResolvedType())  {\n        filteredBuilder.add(alternative);\n      }\n    }\n    ImmutableList<JSType> filteredAlternates = filteredBuilder.build();\n    if (filteredAlternates.isEmpty())  {\n      return registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return registry.createUnionType(filteredAlternates);\n  }\n  return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType.isBottom()) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    return restrictScope(blindScope, node, restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (node.isName() && restrictedType != null && !restrictedType.equals(originalType)) {\n      return restrictScopeToName(blindScope, node, restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null ||\n        restrictedType.equals(originalType) ||\n        !restrictedType.isInhabitable()) {\n      return blindScope;\n    }\n\n    Preconditions.checkArgument(node.isName());\n    Preconditions.checkArgument(node.getParent().isVar());\n    Preconditions.checkNotNull(blindScope);\n    Preconditions.checkNotNull(restrictedType);\n\n    if (blindScope.isDeclared(node.getString(), false)) {\n      return blindScope;\n    }\n\n    FlowScope scope = blindScope.createChildFlowScope();\n    scope.inferSlotType(node.getString(), restrictedType);\n    return scope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      // We need to create a new flow scope with the restricted type.\n      return restrictScope(blindScope, node, restrictedType);\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (node.isName() && restrictedType != null && !restrictedType.equals(originalType)) {\n      return blindScope.inferSlotType(node.getString(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    return maybeRestrictTwoNames(\n        blindScope, node, originalType, restrictedType, null, null, null);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    Preconditions.checkArgument(node.isName());\n    String name = node.getString();\n    FlowScope scope = blindScope.createChildFlowScope();\n    scope.inferSlotType(name, restrictedType);\n    return scope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      return blindScope.inferSlotType(node.getString(), restrictedType);\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null ||\n        restrictedType.equals(originalType) ||\n        node.getType() != Token.NAME) {\n      return blindScope;\n    }\n\n    String name = node.getString();\n    if (blindScope.isDeclared(name, false)) {\n      return blindScope;\n    }\n\n    return blindScope.inferSlotType(name, restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (node.isName() && restrictedType != null && !restrictedType.equals(originalType)) {\n      return restrictScope(blindScope, node.getString(), restrictedType);\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n  // Parse 'function'\n  if (!match(token, JsDocToken.FUNCTION)) {\n    return null;\n  }\n\n  // Parse TypeParameters\n  Node typeParameters = parseTypeParameters(next());\n\n  // Parse '('\n  if (!match(next(), JsDocToken.LP)) {\n    return null;\n  }\n\n  // Parse 'this'\n  if (!match(next(), JsDocToken.THIS)) {\n    return null;\n  }\n\n  // Parse ':'\n  if (!match(next(), JsDocToken.COLON)) {\n    return null;\n  }\n\n  // Parse TypeName\n  Node typeName = parseTypeName(next());\n\n  // Parse ')'\n  if (!match(next(), JsDocToken.RP)) {\n    return null;\n  }\n\n  // Parse ParametersType\n  Node parametersType = parseParametersType(next());\n\n  // Parse ResultType\n  Node resultType = parseResultType(next());\n\n  return createTemplateNode();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION, token);\n    Node parametersType = parseParametersType(next());\n    Node resultType = parseResultType(next());\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  // Parse the 'function' keyword.\n  if (!match(token, JsDocToken.FUNCTION)) {\n    return null;\n  }\n\n  // Parse the type parameters.\n  List<String> typeParameters = new ArrayList<String>();\n  token = parseTypeParameters(token, typeParameters);\n\n  // Parse the 'this' keyword.\n  if (!match(token, JsDocToken.THIS)) {\n    return null;\n  }\n\n  // Parse the colon.\n  if (!match(token, JsDocToken.COLON)) {\n    return null;\n  }\n\n  // Parse the 'this' type.\n  Node thisType = parseTypeName(token);\n  if (thisType == null) {\n    return null;\n  }\n\n  // Parse the opening parenthesis.\n  if (!match(token, JsDocToken.LPAREN)) {\n    return null;\n  }\n\n  // Parse the parameters.\n  List<ExtendedTypeInfo> parameters = new ArrayList<ExtendedTypeInfo>();\n  token = parseParametersType(token, parameters);\n\n  // Parse the closing parenthesis.\n  if (!match(token, JsDocToken.RPAREN)) {\n    return null;\n  }\n\n  // Parse the result type.\n  Node resultType = parseTypeName(token);\n  if (resultType == null) {\n    return null;\n  }\n\n  // Create the function type.\n  FunctionType functionType = new FunctionType(thisType, parameters, resultType);\n  functionType.setTypeParameters(typeParameters);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION, token.lineno, token.charno);\n    functionType.putProp(Node.FUNCTION_TYPE, token.lineno, token.charno);\n\n    // Parse type parameters\n    token = next();\n    if (token.type == JsDocToken.LANGLE) {\n        functionType.putProp(Node.TYPE_PARAMS, parseTypeName(token));\n        token = next();\n        if (token.type != JsDocToken.RANGLE) {\n            reportTypeSyntaxWarning(\"Missing closing '>'\");\n        }\n        token = next();\n    }\n\n    // Parse 'this' parameter\n    if (token.type != JsDocToken.THIS) {\n        reportTypeSyntaxWarning(\"Missing 'this' parameter\");\n    }\n    functionType.putProp(Node.THIS_TYPE, parseTypeName(token));\n\n    // Parse parameters\n    token = next();\n    if (token.type != JsDocToken.LPAREN) {\n        reportTypeSyntaxWarning(\"Missing opening '('\");\n    }\n    functionType.putProp(Node.PARAMS, parseParametersType(token));\n\n    // Parse result type\n    token = next();\n    if (token.type != JsDocToken.RPAREN) {\n        reportTypeSyntaxWarning(\"Missing closing ')'\");\n    }\n    functionType.putProp(Node.RESULT_TYPE, parseResultType(token));\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    // Check for 'function' keyword\n    if (!match(JsDocToken.FUNCTION)) {\n        return null;\n    }\n\n    // Check for '('\n    if (!match(JsDocToken.LPAREN)) {\n        return null;\n    }\n\n    // Check for 'this' keyword\n    if (!match(JsDocToken.THIS)) {\n        return null;\n    }\n\n    // Check for ':'\n    if (!match(JsDocToken.COLON)) {\n        return null;\n    }\n\n    // Parse type name\n    Node typeName = parseAndRecordTypeNode(next(), getLineno(), getCharno(), false);\n    if (typeName == null) {\n        return null;\n    }\n\n    // Check for ')'\n    if (!match(JsDocToken.RPAREN)) {\n        return null;\n    }\n\n    // Parse parameters type\n    Node parametersType = parseAndRecordTypeNode(next(), getLineno(), getCharno(), false);\n    if (parametersType == null) {\n        return null;\n    }\n\n    // Parse result type\n    Node resultType = parseAndRecordTypeNode(next(), getLineno(), getCharno(), false);\n    if (resultType == null) {\n        return null;\n    }\n\n    // Create function type node\n    return newNode(Token.FUNCTION, typeName, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    // TODO: Implement this\n    return null;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    // Parse function keyword.\n    token = eat(JsDocToken.FUNCTION);\n    // Parse type parameters.\n    List<Node> typeParameters = parseTypeParameters();\n    // Parse 'this' keyword.\n    token = eat(JsDocToken.THIS);\n    // Parse ':' keyword.\n    token = eat(JsDocToken.COLON);\n    // Parse 'this' type.\n    Node thisType = parseTypeName();\n    // Parse '(' keyword.\n    token = eat(JsDocToken.LPAREN);\n    // Parse parameters type.\n    List<Node> parametersType = parseParametersType();\n    // Parse ')' keyword.\n    token = eat(JsDocToken.RPAREN);\n    // Parse result type.\n    Node resultType = parseResultType();\n    // Create a function type node.\n    Node functionType = newNode(Node.FUNCTION, thisType, parametersType, resultType);\n    // Set type parameters.\n    functionType.setTypeParameters(typeParameters);\n    // Return the function type node.\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node node = newNode(Token.FUNCTION);\n  node.addChildToBack(parseTypeNameAnnotation(token));\n  node.addChildToBack(parseParametersType(token));\n  node.addChildToBack(parseResultType(token));\n  return node;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  // TODO: Implement this\n  return null;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  // Parse 'function' keyword.\n  if (!match(token, JsDocToken.FUNCTION)) {\n    return null;\n  }\n\n  // Parse type parameters.\n  List<Node> typeParameters = new ArrayList<>();\n  if (match(next(), JsDocToken.LT)) {\n    do {\n      typeParameters.add(parseTypeName(next()));\n    } while (match(next(), JsDocToken.COMMA));\n    if (!match(next(), JsDocToken.GT)) {\n      return null;\n    }\n  }\n\n  // Parse 'this' keyword.\n  if (!match(next(), JsDocToken.THIS)) {\n    return null;\n  }\n  if (!match(next(), JsDocToken.COLON)) {\n    return null;\n  }\n\n  // Parse 'this' type.\n  Node thisType = parseTypeName(next());\n  if (thisType == null) {\n    return null;\n  }\n\n  // Parse parameters.\n  if (!match(next(), JsDocToken.LP)) {\n    return null;\n  }\n  List<Node> parameters = new ArrayList<>();\n  do {\n    parameters.add(parseTypeName(next()));\n  } while (match(next(), JsDocToken.COMMA));\n  if (!match(next(), JsDocToken.RP)) {\n    return null;\n  }\n\n  // Parse result type.\n  Node resultType = parseTypeName(next());\n  if (resultType == null) {\n    return null;\n  }\n\n  // Create function type node.\n  Node functionType = newNode(Token.FUNCTION);\n  functionType.addChildToFront(thisType);\n  functionType.addChildrenToBack(parameters);\n  functionType.addChildToBack(resultType);\n  functionType.setLength(thisType.getLength() + parameters.getLength() + resultType.getLength());\n  return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (isEmpty(str)) \n        {\n            return str;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) \n        {\n            if (!Character.isWhitespace(str.charAt(i))) \n            {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) \n        {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        // TODO: implement this method\n        return null;\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double sum = 0;\n        double sumsq = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        double sumLog = 0;\n        long n = 0;\n\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            sumLog += stat.getSumOfLogs();\n        }\n\n        return new StatisticalSummaryValues(sum / n, sumsq / n, n, max, min, sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        // TODO: implement this method\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLog = 0;\n    long n = 0;\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLog += stat.getSumOfLogs();\n    }\n    double mean = sum / n;\n    double variance = sumsq / n - mean * mean;\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        // COMPLETE THIS METHOD\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        SummaryStatistics summary = new SummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            summary.addValue(stat.getMean());\n        }\n        return new StatisticalSummaryValues(summary.getMean(), summary.getVariance(), summary.getN(), summary.getMax(), summary.getMin(), summary.getSum());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // Create a new SummaryStatistics to store the aggregated values\n    SummaryStatistics aggregate = new SummaryStatistics();\n\n    // Iterate over the SummaryStatistics and add their values to the aggregate\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat.getMean());\n        aggregate.addValue(stat.getVariance());\n        aggregate.addValue(stat.getN());\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getMin());\n        aggregate.addValue(stat.getSum());\n    }\n\n    // Return the aggregated values as a StatisticalSummaryValues object\n    return new StatisticalSummaryValues(aggregate.getMean(), aggregate.getVariance(), aggregate.getN(),\n                                        aggregate.getMax(), aggregate.getMin(), aggregate.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLog = 0;\n    long n = 0;\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLog += stat.getSumOfLogs();\n    }\n    return new StatisticalSummaryValues(sum / n, sumsq / n, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0;\n    double sumsq = 0;\n    long n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    double sumLog = 0;\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sumLog += stat.getSumOfLogs();\n    }\n    double mean = sum / n;\n    double variance = sumsq / n - mean * mean;\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // TODO\n    return null;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_MEAN_AND_VARIANCE,\n                    2, sample1.length, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_MEAN_DIFFERENCE,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double diff = sample1[i] - sample2[i];\n            sum += diff * diff;\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA,\n                    sample1.length, 2, true);\n        }\n        double sumSqDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double difference = sample1[i] - sample2[i];\n            sumSqDifferences += difference * difference;\n        }\n        return sumSqDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        double[] diff = new double[sample1.length];\n        for (int i = 0; i < sample1.length; i++) {\n            diff[i] = sample1[i] - sample2[i];\n        }\n        return variance(diff, meanDifference);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA,\n                    sample1.length, 2, true);\n        }\n\n        double sumSqDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            final double difference = sample1[i] - sample2[i] - meanDifference;\n            sumSqDifferences += difference * difference;\n        }\n        return sumSqDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSqDiff = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            final double diff = sample1[i] - sample2[i] - meanDifference;\n            sumSqDiff += diff * diff;\n        }\n        return sumSqDiff / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COMPUTING_VARIANCE,\n                    sample1.length, 2, true);\n        }\n        double sumSqDiff = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            sumSqDiff += diff * diff;\n        }\n        return sumSqDiff / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_TEST,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number n = dataset.getValue(i);\n        if (n != null) \n        {\n            double v = n.doubleValue();\n            if (v >= 0.0) \n            {\n                result += v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) \n        {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number n = dataset.getValue(i);\n        if (n != null) \n        {\n            double v = n.doubleValue();\n            if (v >= 0.0) \n            {\n                result = result + v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v >= 0.0) {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double result = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number n = dataset.getValue(i);\n        if (n != null) \n        {\n            double v = n.doubleValue();\n            if (v >= 0.0) \n            {\n                result += v;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) {\n            total += value;\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n  String result;\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IOException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IOException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IOException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextName() throws IOException  {\n  String result = nextString();\n  if (result == null) {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n  }\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    String result = peekedString;\n    if (result == null) {\n        if (peeked != PEEKED_NONE) {\n            if (peeked == PEEKED_BEGIN_OBJECT) {\n                // Consume the '{'\n                peeked = PEEKED_NONE;\n                pathIndices[stackSize - 1]++;\n                // Read the name that's expected to follow the '{'\n                result = nextString();\n            } else if (peeked == PEEKED_BEGIN_ARRAY) {\n                // Consume the '['\n                peeked = PEEKED_NONE;\n                pathIndices[stackSize - 1]++;\n                // Read the name that's expected to follow the '['\n                result = nextString();\n            } else {\n                throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n            }\n        } else {\n            int p = 0;\n            // Look for the opening quote\n            while (p < buffer.length) {\n                char c = buffer[p];\n                if (c == '\\'' || c == '\\\"') {\n                    break;\n                }\n                p++;\n            }\n            if (p == buffer.length) {\n                // Handle a slow path for the unlikely case of a quoted name\n                // that doesn't fit in our buffer\n                result = nextQuotedValue('\\'');\n            } else {\n                // We found the opening quote, now look for the closing quote\n                int nameStart = p;\n                while (p < buffer.length) {\n                    char c = buffer[p];\n                    if (c == '\\'' || c == '\\\"') {\n                        // We found the closing quote, now look for the colon\n                        for (int i = p - 1; i >= nameStart; i--) {\n                            if (buffer[i] == ':') {\n                                // We found the colon, now look for the opening quote\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IOException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    String result = nextString();\n    if (result == null) {\n        throw new IOException(\"Expected a name but was \" + peek());\n    }\n    return result;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk == null) {\n            return -1;\n        }\n        return currentCompressedChunk.read(b, off, len);\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk == null) {\n            return -1;\n        }\n        return currentCompressedChunk.read(b, off, len);\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    Node node = site.node;\n    switch (node.getType()) {\n        case Token.CALL:\n            arg = node.getChildAtIndex(argIndex + 1);\n            break;\n        case Token.NEW:\n            arg = node.getChildAtIndex(argIndex);\n            break;\n        case Token.GETPROP:\n            arg = node.getChildAtIndex(argIndex + 1);\n            break;\n        default:\n            throw new IllegalArgumentException(\n                    \"Unexpected node type: \" + node.getType());\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node callNode = site.node;\n        Node parent = callNode.getParent();\n        if (parent.isCall()) {\n            // call(func, arg1, ..., argN)\n            return parent.getChildAtIndex(argIndex + 1);\n        } else if (parent.isNew()) {\n            // new func(arg1, ..., argN)\n            return parent.getChildAtIndex(argIndex);\n        } else if (parent.isGetProp() && parent.getFirstChild() == callNode) {\n            // func.call(this, arg1, ..., argN)\n            return callNode.getChildAtIndex(argIndex);\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNew = site.node;\n    Node arg = callOrNew.getFirstChild().getNext();\n    for (int i = 0; i < argIndex; i++) {\n        arg = arg.getNext();\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callNode = site.node;\n    if (callNode.isCall()) {\n        return callNode.getSecondChild().getFirstChild().getNext().getFirstChild();\n    } else if (callNode.isNew()) {\n        return callNode.getFirstChild().getNext().getFirstChild();\n    } else {\n        return callNode.getFirstChild().getNext().getFirstChild();\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node call = site.node;\n        if (call.getType() == Token.CALL || call.getType() == Token.NEW) {\n            return call.getChildAtIndex(argIndex + 1);\n        } else if (call.getType() == Token.GETELEM) {\n            return call.getLastChild();\n        } else {\n            throw new IllegalArgumentException(\"Unexpected call node type: \" + call.getType());\n        }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        // Function.prototype.call() or Function.prototype.apply()\n        if (node.getFirstChild().matchesQualifiedName(\"Function.prototype.call\") ||\n            node.getFirstChild().matchesQualifiedName(\"Function.prototype.apply\")) {\n            // Skip the first argument (the function to call)\n            argIndex++;\n        }\n        return node.getChildAtIndex(argIndex);\n    } else {\n        return node.getFirstChild().getNext().getChildAtIndex(argIndex);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (NodeUtil.isCallOrNew(node)) {\n        return node.getLastChild().getNext().getNext().getChildAtIndex(argIndex);\n    } else {\n        return node.getNext().getChildAtIndex(argIndex);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.getType() == Token.CALL) {\n        // For a direct call, the argument is the nth child.\n        return call.getChildAtIndex(argIndex);\n    } else if (call.getType() == Token.GETELEM) {\n        // For a func.call() call, the argument is the nth child of the GETELEM\n        // node.\n        return call.getChildAtIndex(argIndex);\n    } else {\n        // For a .call() call, the argument is the nth child of the first child\n        // of the GETELEM node.\n        return call.getFirstChild().getChildAtIndex(argIndex);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    Node parent = node.getParent();\n    if (parent.isCall()) {\n        if (node.isFirstChildOf(parent)) {\n            // Direct call.\n            return parent.getChildAtIndex(argIndex + 1);\n        } else if (node.isString() && node.getString().equals(\"call\")) {\n            // func.call(this, arg1, arg2, ...)\n            return parent.getChildAtIndex(argIndex + 2);\n        }\n    } else if (parent.isNew()) {\n        // new func(arg1, arg2, ...)\n        return parent.getChildAtIndex(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node arg = null;\n        if (site.node.isCall()) {\n            arg = site.node.getChildAtIndex(argIndex + 1);\n        } else if (site.node.isNew()) {\n            arg = site.node.getLastChild();\n        } else if (site.node.isGetProp()) {\n            arg = site.node.getNext();\n        }\n        return arg;\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    return info.getDeprecationReason();\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo jsDoc = type.getJSDocInfo();\n    if (jsDoc != null && jsDoc.isDeprecated()) {\n        return jsDoc.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        return info.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        return info.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) \n    {\n        return type.getDeprecationReason();\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        return info.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    return info.getDeprecationReason();\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        return info.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isDeprecated()) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null) \n    {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationInfo();\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null)  {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null)  {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.underlying != null) \n    {\n        result = this.underlying.getColumnIndex(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (this.underlying.getColumnKeys().contains(key)) \n    {\n        result = this.underlying.getColumnIndex(key);\n        if (result >= this.firstCategoryIndex) \n        {\n            result = result - this.firstCategoryIndex;\n        }\n        else \n        {\n            result = result + this.maximumCategoryCount - this.firstCategoryIndex;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index < this.lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    else \n    {\n        return -1;\n    }\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance && point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= upper + tolerance && point >= lower - tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance || point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < getLower() - tolerance || point > getUpper() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= getUpper() + tolerance && point >= getLower() - tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance || point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance || point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance && point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance && point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // Find the most negative coefficient in the objective function row.\n        int minCol = -1;\n        double minValue = Double.MAX_VALUE;\n        for (int col = 0; col < tableau.getWidth(); col++) {\n            double value = tableau.getEntry(0, col);\n            if (value < minValue) {\n                minValue = value;\n                minCol = col;\n            }\n        }\n        return minCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // TODO: implement this method\n        return null;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int col = 0; col < tableau.getWidth(); col++) {\n        if (tableau.getEntry(0, col) < minCoefficient) {\n            minCoefficient = tableau.getEntry(0, col);\n            pivotColumn = col;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double min = Double.POSITIVE_INFINITY;\n        int col = 0;\n        for (int i = 0; i < tableau.getWidth(); i++) {\n            double entry = tableau.getEntry(0, i);\n            if (entry < min) {\n                min = entry;\n                col = i;\n            }\n        }\n        return col;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        double value = tableau.getEntry(0, i);\n        if (value > max) {\n            max = value;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int pivotCol = -1;\n        double minCoeff = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < tableau.getWidth(); i++) {\n            if (tableau.getEntry(0, i) < minCoeff) {\n                minCoeff = tableau.getEntry(0, i);\n                pivotCol = i;\n            }\n        }\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double minValue = Double.POSITIVE_INFINITY;\n        Integer minCol = null;\n        for (int col = 0; col < tableau.getWidth(); col++) {\n            if (tableau.getEntry(0, col) < minValue) {\n                minValue = tableau.getEntry(0, col);\n                minCol = col;\n            }\n        }\n        return minCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double minValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(0, i) < minValue) {\n            minValue = tableau.getEntry(0, i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}