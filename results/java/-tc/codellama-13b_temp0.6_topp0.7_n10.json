{
  "benchmark": "javaeval-tc",
  "lastest_eval": {
    "compile@1": 0.6713567839195983,
    "pass@1": 0.3949748743718594,
    "compile@3": 0.8033082077051927,
    "pass@3": 0.4948073701842544,
    "compile@5": 0.8479700087740286,
    "pass@5": 0.5337800111669458
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register key serializer for\");\n        _checkNotNull(ser, \"key serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register key serializer for\");\n         _checkNotNull(ser, \"key serializer\");\n         if (_keySerializers == null) {\n             _keySerializers = new SimpleSerializers();\n         }\n         _keySerializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // Get the start and end values\n    Number start = getStartValue(rowKey, columnKey);\n    Number end = getEndValue(rowKey, columnKey);\n\n    // Calculate the percentage complete\n    double percent = 0;\n    if (start != null && end != null) \n    {\n        double duration = end.doubleValue() - start.doubleValue();\n        double elapsed = new Date().getTime() - start.doubleValue();\n        percent = (elapsed / duration) * 100;\n    }\n\n    // Return the percentage complete\n    return new Double(percent);\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    int subinterval = 0;\n    GanttCategoryDataset dataset = (GanttCategoryDataset) this.data;\n    result = dataset.getPercentComplete(row, column, subinterval);\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    if (row >= 0 && column >= 0) {\n        result = getPercentComplete(row, column);\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    int subinterval = 0;\n    GanttCategoryDataset dataset = (GanttCategoryDataset) getDataset();\n    Number startValue = dataset.getStartValue(row, column, subinterval);\n    Number endValue = dataset.getEndValue(row, column, subinterval);\n    if (startValue != null && endValue != null) {\n        long start = startValue.longValue();\n        long end = endValue.longValue();\n        long duration = end - start;\n        if (duration > 0) {\n            result = new Double(100.0 * (end - System.currentTimeMillis())\n                    / duration);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    return getPercentComplete(row, column);\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        return new IteratorIterable<E>(iterator, false);\n    }",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) {\n        return m;\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == m.getColumnDimension()) {\n        return m;\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) {\n            d[i][0] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            for (int j = 0; j < m.getColumnDimension(); j++) {\n                d[i][j] = i == j ? m.getEntry(i, j) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"input matrix must be a column or row vector\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1) {\n            final int n = m.getRowDimension();\n            final double[][] d = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final int n = m.getColumnDimension();\n            final double[] d = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) {\n        return new DiagonalMatrix(m.getColumnDimension(), m.getColumn(0));\n    } else {\n        return new DiagonalMatrix(m.getRowDimension(), m.getRow(0));\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getRowDimension() == 1) {\n            final double[][] d = new double[m.getColumnDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(0, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                for (int j = 0; j < m.getColumnDimension(); j++) {\n                    d[i][j] = i == j ? m.getEntry(i, j) : 0;\n                }\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"m must be a column or row matrix\");\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        try {\n            return forOffsetMillis(Integer.parseInt(id));\n        } catch (NumberFormatException ex) {\n            throw new IllegalArgumentException(\"Invalid id: \" + id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // Parse offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Parse offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        //-----------------------------------------------------------------------\n\n        // Parse offset\n        if (id.length() >= 5 && id.charAt(3) == ':' && id.charAt(2) == ':') {\n            int hours = parseNumber(id, 0, 2);\n            int minutes = parseNumber(id, 4, 2);\n            int seconds = 0;\n            int millis = 0;\n            if (id.length() >= 7 && id.charAt(6) == ':') {\n                seconds = parseNumber(id, 7, 2);\n                if (id.length() >= 9 && id.charAt(9) == '.') {\n                    millis = parseNumber(id, 10, 3);\n                }\n            }\n            return forOffsetMillis(hours * (60 * 60 * 1000) + minutes * (60 * 1000) + seconds * 1000 + millis);\n        }\n        throw new IllegalArgumentException(\"Invalid ID for DateTimeZone, invalid format: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        dtz = cProvider.getZone(getConvertedId(id));\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) \n        {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) \n        {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) \n        {\n            return dtz;\n        }\n        try \n        {\n            return forOffsetMillis(Integer.parseInt(id));\n        } \n        catch (NumberFormatException e) \n        {\n            throw new IllegalArgumentException(\"Invalid id: \" + id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Parse offset\n        if (id.length() > 2 && id.charAt(0) == '+' && id.charAt(3) == ':') {\n            int offset = (id.charAt(1) - '0') * 3600000\n                    + (id.charAt(2) - '0') * 360000\n                    + (id.charAt(4) - '0') * 60000\n                    + (id.charAt(5) - '0') * 6000\n                    + (id.charAt(7) - '0') * 1000\n                    + (id.charAt(8) - '0') * 100\n                    + (id.charAt(10) - '0') * 10\n                    + (id.charAt(11) - '0') * 1;\n            if (id.charAt(0) == '-') {\n                offset = -offset;\n            }\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            result.mant[mant.length-1] = rl;\n            result.exp++;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            result.exp++;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            result.mant[mant.length-1] = rl;\n            result.exp++;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild();\n        child != null;\n        child = child.getNext()) {\n      // TODO(user): handle getters or setters?\n      if (child.isStringKey()) {\n        function.addChildToBack(\n            IR.param(\n                IR.name(child.getString()),\n                IR.number(index++)));\n      }\n    }\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    // Copy the parameters from the original function\n    for (Node child = exportedFunction.getFirstChild().getNext();\n         child != null;\n         child = child.getNext()) {\n      function.addChildToBack(child.cloneTree());\n    }\n\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    // Copy over the parameters\n    for (Node param = exportedFunction.getFirstChild().getNext();\n         param != null;\n         param = param.getNext()) {\n      function.addChildToBack(param.cloneTree());\n    }\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    function.setJSDocInfo(new JSDocInfo());\n\n    Node paramList = function.getFirstChild();\n    Node param;\n    Node originalParam;\n    for (Node child = exportedFunction.getFirstChild().getNext();\n         child != null;\n         child = child.getNext()) {\n      if (child.isParamList()) {\n        for (Node grandchild = child.getFirstChild();\n             grandchild != null;\n             grandchild = grandchild.getNext()) {\n          param = IR.param(IR.name(grandchild.getString()), null, null);\n          param.setJSType(grandchild.getJSType());\n          paramList.addChildToBack(param);\n        }\n      }\n    }\n\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.param(\n              IR.name(child.getString()),\n              IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(exportedFunction.getJSDocInfo());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    externFunction.copyInformationFrom(exportedFunction);\n\n    // Copy the type information\n    JSType functionType = exportedFunction.getJSType();\n    if (functionType != null) {\n      externFunction.setJSType(functionType);\n    } else {\n      compiler.report(JSError.make(exportedFunction,\n          \"Function to export does not have a type\"));\n    }\n\n    // Copy the parameter types\n    for (Node param : NodeUtil.getFunctionParameters(exportedFunction)) {\n      Node externParam = IR.name(param.getString());\n      externParam.copyInformationFrom(param);\n\n      JSType paramType = param.getJSType();\n      if (paramType != null) {\n        externParam.setJSType(paramType);\n      } else {\n        compiler.report(JSError.make(exportedFunction,\n            \"Function to export does not have a type\"));\n      }\n\n      externFunction.addChildToBack(externParam);\n    }\n\n    return externFunction;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    function.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  // TODO(user): handle getters or setters?\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    if (child.isParamList()) {\n      for (Node grandchild = child.getFirstChild();\n           grandchild != null;\n           grandchild = grandchild.getNext()) {\n        function.addChildToBack(\n            IR.param(IR.name(grandchild.getString()),\n                     IR.number(index++)));\n      }\n    }\n  }\n  return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // compute covariance matrix\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n\n        // compute standard deviation\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] errors = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return errors;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] errors = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return errors;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] errors = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return errors;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null && priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null && priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is recursively defined\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalStateException(\"The variable \" + varName + \" is part of a cycle of variable substitution.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null && priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"The variable: \" + varName + \" is part of a cyclic substitution.\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) \n    {\n        for (final String var : priorVariables) \n        {\n            if (var.equals(varName)) \n            {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n            }\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalStateException(\"Cyclic substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> inputs = Lists.newArrayList(roots);\n  List<INPUT> sortedList = Lists.newArrayList();\n  Set<INPUT> visited = Sets.newHashSet();\n  while (!inputs.isEmpty()) {\n    INPUT input = inputs.remove(0);\n    if (!visited.contains(input)) {\n      sortedList.add(input);\n      visited.add(input);\n      inputs.addAll(getDependencies(input));\n    }\n  }\n  return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> subGraph = new HashSet<INPUT>();\n    subGraph.addAll(roots);\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT input : roots) {\n      result.addAll(getDependenciesOf(input, subGraph));\n    }\n    if (sorted) {\n      return getSortedDependenciesOf(result);\n    } else {\n      return result;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Use a LinkedHashSet to preserve the order of the inputs.\n  Set<INPUT> subGraph = new LinkedHashSet<INPUT>(roots);\n  List<INPUT> sortedList = new ArrayList<INPUT>();\n  while (!subGraph.isEmpty()) {\n    INPUT input = subGraph.iterator().next();\n    subGraph.remove(input);\n    sortedList.add(input);\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (candidate != null) {\n        subGraph.add(candidate);\n      }\n    }\n  }\n  return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO(nicksantos): Make this faster.\n    List<INPUT> allInputs = Lists.newArrayList(inputs);\n    allInputs.removeAll(roots);\n    List<INPUT> result = Lists.newArrayList(roots);\n    result.addAll(getDependenciesOf(allInputs, sorted));\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n    Deque<INPUT> queue = Lists.newLinkedList();\n    queue.addAll(roots);\n    while (!queue.isEmpty()) {\n      INPUT input = queue.removeFirst();\n      if (visited.contains(input)) {\n        continue;\n      }\n      visited.add(input);\n      result.add(input);\n      for (INPUT dep : getDependencies(input)) {\n        if (!visited.contains(dep)) {\n          queue.add(dep);\n        }\n      }\n    }\n    if (sorted) {\n      Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> subGraph = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      subGraph.addAll(getDependenciesOf(root));\n    }\n    if (sorted) {\n      return getSortedDependenciesOf(subGraph);\n    } else {\n      return getInputsWithoutProvides();\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Set<INPUT> visited = new HashSet<INPUT>();\n  List<INPUT> result = new ArrayList<INPUT>();\n  for (INPUT root : roots) {\n    getDependenciesOf(root, visited, result);\n  }\n  if (sorted) {\n    Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n    Deque<INPUT> worklist = Lists.newLinkedList();\n    for (INPUT root : roots) {\n      worklist.add(root);\n    }\n    while (!worklist.isEmpty()) {\n      INPUT input = worklist.pop();\n      if (visited.contains(input)) {\n        continue;\n      }\n      visited.add(input);\n      result.add(input);\n      for (INPUT dep : getDependencies(input)) {\n        worklist.add(dep);\n      }\n    }\n    if (sorted) {\n      return Lists.newArrayList(result);\n    } else {\n      return result;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      result.addAll(getDependenciesOf(root, sorted));\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // 1. Create a new graph with the same nodes as the original graph.\n    // 2. Add edges from each root to every node that it requires.\n    // 3. Remove all nodes that are not reachable from the roots.\n    // 4. Return the remaining nodes.\n\n    // 1.\n    Graph<INPUT> newGraph = new Graph<INPUT>();\n    for (INPUT node : graph.getNodes()) {\n      newGraph.createNode(node);\n    }\n\n    // 2.\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT required = provideMap.get(symbol);\n        newGraph.connect(root, required);\n      }\n    }\n\n    // 3.\n    newGraph.prune(new PruneDependencies<INPUT>(roots));\n\n    // 4.\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT node : newGraph.getNodes()) {\n      result.add(node);\n    }\n    return result;\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    int radixDigits = a.getField().getRadixDigits();\n    int sig = 0;\n    int sp = 0;\n    boolean leading = true;\n    char[] buf = new char[a.toString().length()];\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (radixDigits / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = a.toString().toCharArray();\n\n    for (int i = 0; i < buf.length; i++) {\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = new Dfp(a.getField(), new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = new Dfp(a.getField(), new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getField().newDfp(a.getField().split(a.toString())[0]);\n    result[1] = a.getField().newDfp(a.getField().split(a.toString())[1]);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n\n    result[0] = a.getZero();\n    result[1] = a.getOne();\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.toString().length()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(a.getField().getTwo()));\n\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        y = y.add(num.divide(i+2));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    result[0] = y.multiply(a.getField().getTwo());\n    result[1] = a.subtract(result[0]);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n\n    result[0] = a.getField().newDfp(a.toString().split(\"\\\\.\")[0]);\n    result[1] = a.getField().newDfp(a.toString().split(\"\\\\.\")[1]);\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() == null)\n        return tagName();\n    else {\n        Elements siblings = parent().children();\n        String tag = tagName();\n        String base = (siblings.size() > 1) ? tag + \":nth-child(\" + (siblings.indexOf(this) + 1) + \")\" : tag;\n        if (className().length() > 0)\n            base += \".\" + className().replaceAll(\"\\\\s+\", \".\");\n        return parent().cssSelector() + \" > \" + base;\n    }\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null) {\n        selector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            selector = parent().cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (className() != null) {\n            selector += \".\" + className();\n        }\n        if (siblingIndex() != 0) {\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null && !id().isEmpty()) {\n        selector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            selector = parent().cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (classNames().size() > 0) {\n            selector += \".\" + classNames().get(0);\n        }\n        if (siblingIndex() > 0) {\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    // Implement this method\n    String cssSelector = \"\";\n    if (id() != null) {\n        cssSelector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            cssSelector = parent().cssSelector() + \" > \";\n        }\n        cssSelector += tagName();\n        if (classNames().size() > 0) {\n            cssSelector += \".\" + String.join(\".\", classNames());\n        }\n        if (siblingIndex() > 0) {\n            cssSelector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return cssSelector;\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty())\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + uniqueSelector();\n    else\n        return uniqueSelector();\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0) {\n        selector = \"#\" + id();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            selector = parent.cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (classNames().size() > 0) {\n            selector += \".\" + classNames().get(0);\n        }\n        if (siblingIndex() > 0) {\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null)\n        selector = \"#\" + id();\n    else {\n        Element parent = parent();\n        if (parent != null)\n            selector = parent.cssSelector() + \" > \";\n        selector += tagName();\n        if (className() != null)\n            selector += \".\" + className();\n        if (siblingIndex() != 0)\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0) \n    {\n        return \"#\" + id();\n    } \n    else \n    {\n        String cssPath = \"\";\n        if (parent() != null) \n        {\n            cssPath = parent().cssSelector();\n        }\n        if (cssPath.length() > 0) \n        {\n            cssPath += \" > \";\n        }\n        cssPath += tagName();\n        if (classNames().size() > 0) \n        {\n            cssPath += \".\" + classNames().get(0);\n        }\n        if (siblingIndex() > 0) \n        {\n            cssPath += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n        return cssPath;\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n    else if (parent() == null)\n        return tagName();\n    else {\n        Elements siblings = parent().children();\n        String nth = String.valueOf(siblings.indexOf(this) + 1);\n        String selector = tagName() + (hasClass() ? \".\" + className().replace('.', ' ') : \"\");\n        return parent().cssSelector() + \" > \" + selector + (siblings.size() > 1 ? \":\" + nth : \"\");\n    }\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id().length() > 0) {\n        selector = \"#\" + id();\n    } else {\n        if (parent() != null) {\n            selector = parent().cssSelector() + \" > \";\n        }\n        selector += tagName();\n        if (className().length() > 0) {\n            selector += \".\" + className().replace(\" \", \".\");\n        }\n        if (siblingIndex() > 0) {\n            selector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n    }\n    return selector;\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 4;\n        break;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        cost = 5;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        cost = 6;\n        break;\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        cost = 7;\n        break;\n      default:\n        cost = 0;\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 4;\n        break;\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        cost = 5;\n        break;\n      case Token.INSTANCEOF:\n        cost = 6;\n        break;\n      case Token.IN:\n        cost = 7;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        cost = 8;\n        break;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        cost = 9;\n        break;\n      case Token.DEC:\n      case Token.INC:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.EMPTY:\n      case Token.NOT:\n        cost = 10;\n        break;\n      case Token.GETELEM:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return 1;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return 2;\n      default:\n        return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.HOOK:\n        cost = 1;\n        break;\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.AND:\n        cost = 3;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 4;\n        break;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n        cost = 5;\n        break;\n      case Token.INSTANCEOF:\n        cost = 6;\n        break;\n      case Token.IN:\n        cost = 7;\n        break;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        cost = 8;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        cost = 9;\n        break;\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n        cost = 10;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 4;\n        break;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        cost = 5;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        cost = 6;\n        break;\n      default:\n        cost = 0;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 4;\n        break;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n        cost = 5;\n        break;\n      case Token.INSTANCEOF:\n        cost = 6;\n        break;\n      case Token.IN:\n        cost = 7;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        cost = 8;\n        break;\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        cost = 9;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return 1;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return 2;\n      default:\n        return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.COMMA:\n        cost = 1;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 2;\n        break;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        cost = 3;\n        break;\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        cost = 4;\n        break;\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        cost = 5;\n        break;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        cost = 6;\n        break;\n      case Token.ASSIGN:\n        cost = 7;\n        break;\n      case Token.INC:\n      case Token.DEC:\n        cost = 8;\n        break;\n      case Token.VOID:\n        cost = 9;\n        break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return 1;\n      case Token.AND:\n      case Token.OR:\n        return 2;\n      case Token.HOOK:\n        return 3;\n      case Token.COMMA:\n        return 1;\n      default:\n        return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost = 2;\n        break;\n      case Token.HOOK:\n        cost = 3;\n        break;\n      case Token.COMMA:\n        cost = 1;\n        break;\n      case Token.PAREN:\n        cost = 2;\n        break;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost = 2;\n        break;\n      default:\n        cost = 1;\n        break;\n    }\n    return cost;\n  }"
    ],
    [
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left] = rightChar;\n        buffer[right] = leftChar;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size <= 1) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left++] = rightChar;\n        buffer[right--] = leftChar;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size <= 1) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char swap = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size <= 1) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left++] = rightChar;\n        buffer[right--] = leftChar;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size < 2) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left++] = rightChar;\n        buffer[right--] = leftChar;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char[] buf = buffer;\n    while (j > i) \n    {\n        char swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size < 2) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left++] = rightChar;\n        buffer[right--] = leftChar;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n    TextNode tail = new TextNode(coreValue().substring(offset));\n    coreValue(coreValue().substring(0, offset));\n    parentNode.addChildren(siblingIndex() + 1, Collections.singletonList(tail));\n    return tail;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n\n    String head = coreValue().substring(0, offset);\n    String tail = coreValue().substring(offset);\n\n    coreValue(head);\n    TextNode tailNode = new TextNode(tail);\n    if (parent() != null)\n        parent().addChildren(siblingIndex() + 1, tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.replaceWith(headNode);\n    headNode.addSibling(tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.coreValue(head);\n    this.parentNode.addChildren(this.siblingIndex() + 1, Collections.singletonList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    coreValue(head);\n    TextNode tailNode = new TextNode(tail);\n    if (parent() != null) {\n        parent().addChildren(siblingIndex() + 1, tailNode);\n    }\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.replaceWith(headNode);\n    headNode.addSibling(tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < coreValue().length(), \"Split offset must not be greater than current text length\");\n\n    String head = coreValue().substring(0, offset);\n    String tail = coreValue().substring(offset);\n\n    coreValue(head);\n    TextNode tailNode = new TextNode(tail);\n    parentNode.addChildren(siblingIndex() + 1, Collections.singletonList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.replaceWith(headNode);\n    headNode.addSibling(tailNode);\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > getWholeText().length())\n        throw new IndexOutOfBoundsException(\"Split offset must be in bounds\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode tailNode = new TextNode(tail);\n    this.text(head);\n    this.parentNode.addChildren(this.siblingIndex() + 1, Collections.singletonList(tailNode));\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.coreValue(head);\n    this.parentNode.addChildren(this.siblingIndex() + 1, Collections.singletonList(tailNode));\n\n    return tailNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final Collection<O> union = CollectionUtils.union(a, b);\n        final Collection<O> intersection = CollectionUtils.intersection(a, b);\n        return CollectionUtils.subtract(union, intersection);\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = CollectionUtils.union(a, b);\n    final Collection<O> intersection = CollectionUtils.intersection(a, b);\n    return CollectionUtils.subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        final Collection<O> union = union(a, b);\n        final Collection<O> intersection = intersection(a, b);\n        return subtract(union, intersection);\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        return subtract(union(a, b), intersection(a, b));\n    }",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = union(a, b);\n    final Collection<O> intersection = intersection(a, b);\n    final Collection<O> disjunction = subtract(union, intersection);\n    return disjunction;\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value, 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value, 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int start = bytes.length > 8 ? bytes.length - 8 : 0;\n    for (int i = start, j = 0; j < 8; j++, i++) \n    {\n        result[j] = bytes[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n// Delete",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n// Delete",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n    }",
      "public RealMatrix getSquareRoot()  {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n    }",
      "public RealMatrix getSquareRoot()  {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n    }",
      "public RealMatrix getSquareRoot()  {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n    }",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC, getMatrix());\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE, getMatrix());\n    }\n\n    // compute the Cholesky decomposition\n    final CholeskyDecomposition cholesky = new CholeskyDecomposition(getMatrix());\n    final RealMatrix l = cholesky.getL();\n\n    // compute the square-root of the diagonal elements\n    final int n = l.getRowDimension();\n    final double[] d = new double[n];\n    for (int i = 0; i < n; ++i) {\n        d[i] = FastMath.sqrt(l.getEntry(i, i));\n    }\n\n    // compute the square-root of the matrix\n    final RealMatrix sqrt = MatrixUtils.createRealMatrix(n, n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            sqrt.setEntry(i, j, l.getEntry(i, j) / d[i]);\n        }\n        sqrt.setEntry(i, i, d[i]);\n    }\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSPD()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return new CholeskyDecomposition(getSymmetricMatrix(),\n                                     DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n                                     DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return new Solver(realEigenvalues, imagEigenvalues, eigenvectors).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_MATRIX,\n                getClass().getSimpleName());\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX,\n                getClass().getSimpleName());\n    }\n    return new CholeskyDecomposition(this).getSquareRoot();\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn p.getText();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn p.getIntValue();\n    \t\t}\n    \t\treturn null;\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         if (t == JsonToken.VALUE_STRING) {\n             return p.getText();\n         }\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n             return p.getIntValue();\n         }\n         if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n             return p.getDoubleValue();\n         }\n         if (t == JsonToken.VALUE_TRUE) {\n             return Boolean.TRUE;\n         }\n         if (t == JsonToken.VALUE_FALSE) {\n             return Boolean.FALSE;\n         }\n         if (t == JsonToken.VALUE_NULL) {\n             return null;\n         }\n         // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n         return _delegate.deserialize(p, ctxt, value);\n     }\n\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getIntValue();\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         switch (t) {\n         case VALUE_STRING:\n             if (base.isAssignableFrom(String.class)) {\n                 return p.getText();\n             }\n             break;\n         case VALUE_NUMBER_INT:\n             if (base.isAssignableFrom(Integer.class)) {\n                 return p.getIntValue();\n             }\n             break;\n         }\n         return null;\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getIntValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        default:\n            return null;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getIntValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        default:\n            throw ctxt.mappingException(\"Don't know how to convert \"+t+\" into a POJO\");\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getIntValue();\n        default:\n            return null;\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getIntValue();\n        default:\n            return null;\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         if (t == JsonToken.VALUE_STRING) {\n             return p.getText();\n         }\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n             return p.getIntValue();\n         }\n         return null;\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getDoubleValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase START_ARRAY:\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\tcase END_ARRAY:\n    \t\tcase END_OBJECT:\n    \t\tcase FIELD_NAME:\n    \t\tcase NOT_AVAILABLE:\n    \t\tdefault:\n    \t\t\tthrow ctxt.mappingException(\"Can not deserialize instance of \" + getMapClass() + \" out of \" + t);\n    \t\t}\n    \t}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 1) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullSize = fullChunk.length;\n         int newSize = _size + fullSize;\n         Object[] result = new Object[newSize];\n         _copyTo(result, newSize, fullChunk, fullSize);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _add(fullChunk);\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int chunkSize = fullChunk.length;\n         int totalSize = chunkSize + _size;\n         Object[] result = new Object[totalSize];\n         _copyTo(result, totalSize, fullChunk, chunkSize);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int lastChunkEntries = fullChunk.length;\n         int totalSize = lastChunkEntries + _size;\n         Object[] result = new Object[totalSize];\n         _copyTo(result, totalSize, fullChunk, lastChunkEntries);\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int len = fullChunk.length;\n         if (_freeBuffer == null || _freeBuffer.length < len) {\n             _freeBuffer = new Object[len];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, len);\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int chunkLen = fullChunk.length;\n         if (chunkLen == 0) {\n             return fullChunk;\n         }\n         int newSize = _size + chunkLen;\n         if (newSize > _freeBuffer.length) {\n             int newLen = Math.max(newSize, _freeBuffer.length + Math.max(newSize, 12));\n             Object[] newBuffer = new Object[newLen];\n             _copyTo(newBuffer, newSize, fullChunk, chunkLen);\n             _freeBuffer = newBuffer;\n         } else {\n             System.arraycopy(fullChunk, 0, _freeBuffer, _size, chunkLen);\n             _freeBuffer = fullChunk;\n         }\n         _size = newSize;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int len = fullChunk.length;\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[Math.max(12, len)];\n         } else if (_freeBuffer.length < len) {\n             _freeBuffer = new Object[Math.max(12, len)];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, len);\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int chunkLen = fullChunk.length;\n         _size += chunkLen;\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[Math.max(12, chunkLen)];\n         } else if (_freeBuffer.length < chunkLen) {\n             _freeBuffer = new Object[chunkLen];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkLen);\n         return _freeBuffer;\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return newStringNode(stream.getString(), stream.getLineno(), stream.getCharno());\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LT) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(next());\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseUnionType(token);\n    case LB:\n      return parseArrayType(token);\n    case LT:\n      return parseRecordType(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseUnionType(token);\n    case LB:\n      return parseArrayType(token);\n    case LT:\n      return parseRecordType(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return newStringNode(stream.getString(), stream.getLineno(), stream.getCharno());\n    } else if (token == JsDocToken.LP) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else if (token == JsDocToken.QMARK) {\n        return newNode(Token.QMARK);\n    } else if (token == JsDocToken.BANG) {\n        return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return newStringNode(stream.getString(), stream.getLineno(), stream.getCharno());\n    } else if (token == JsDocToken.LC) {\n        return parseUnionType(next());\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(next());\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(next());\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseUnionType(next());\n    case LB:\n      return parseArrayType(next());\n    case LT:\n      return parseRecordType(next());\n    case FUNCTION:\n      return parseFunctionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  this.deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        return new Double(minimum);\n    }\n    return null;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        return new Double(minimum);\n    }\n    return null;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    }\n    return null;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / delimLen + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) \n    {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else if (lastWasGap) \n        {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } \n        else \n        {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) \n    {\n        Number n = data.getValue(row, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) \n    {\n        Number n = data.getValue(row, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (range != null) {\n                if (result == null) {\n                    result = range;\n                }\n                else {\n                    result = result.add(range);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null)  {\n                if (result == null)  {\n                    result = subplotRange;\n                }\n                else  {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null) {\n                if (result == null) {\n                    result = subplotRange;\n                }\n                else {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (range != null) \n            {\n                if (result == null) \n                {\n                    result = range;\n                } \n                else \n                {\n                    result = result.add(range);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) \n    {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range r = plot.getDataRange(axis);\n        if (r != null) \n        {\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null) \n            {\n                if (result == null) \n                {\n                    result = subplotRange;\n                } \n                else \n                {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (this.subplots == null) {\n        return null;\n    }\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range subrange = plot.getDataRange(axis);\n        if (subrange != null) {\n            if (result == null) {\n                result = subrange;\n            }\n            else {\n                result = result.add(subrange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (r != null) {\n                if (result == null) {\n                    result = r;\n                }\n                else {\n                    result = result.add(r);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis.equals(getRangeAxis())) \n    {\n        Range result = null;\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (r == null) \n            {\n                continue;\n            }\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n        return result;\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null)  {\n                if (result == null)  {\n                    result = subplotRange;\n                }\n                else  {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / LOG10_VALUE; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) - Math.log(10.0)) / LOG10_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg,\n            entry,\n            implicitReturn,\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n    return test.allPathsSatisfyPredicate();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO(user): Implement fastAllPathsReturnCheck.\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  DiGraphNode<Node, Branch> entry = cfg.getEntry();\n  DiGraphNode<Node, Branch> implicitReturn = cfg.getImplicitReturn();\n\n  // Optimization: Most functions don't contain returns.\n  if (!entry.getAnnotation().hasReturn()) {\n    return true;\n  }\n\n  CheckPathsBetweenNodes<Node, Branch> test =\n      new CheckPathsBetweenNodes<Node, Branch>(\n          cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n  return test.allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // If the graph is empty, then there are no paths.\n    if (cfg.getDirectedGraph().getNodes().isEmpty()) {\n      return true;\n    }\n\n    // If the graph has no return statements, then there are no paths.\n    if (!cfg.getImplicitReturn().getInEdges().isEmpty()) {\n      return true;\n    }\n\n    // If the graph has a single path, then there are no return statements.\n    if (cfg.getDirectedGraph().getNodes().size() == 1) {\n      return false;\n    }\n\n    // If the graph has multiple paths, then there must be a path without a return statement.\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the graph has no return statements, it's definitely not a problem.\n  if (!cfg.getReturnNodes().hasNext()) {\n    return true;\n  }\n\n  // If the graph has a single return statement, it's definitely not a problem.\n  if (cfg.getReturnNodes().hasNext() && !cfg.getReturnNodes().next().hasNext()) {\n    return true;\n  }\n\n  // Otherwise, we have to do a more expensive check.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // If the graph is empty, there are no paths to check.\n    if (cfg.getDirectedGraph().getNodes().isEmpty()) {\n      return true;\n    }\n\n    // If the graph has no return statements, then it is not possible to have\n    // all paths return.\n    if (!cfg.getImplicitReturn().isPresent()) {\n      return false;\n    }\n\n    // If the graph has only one node, then there is only one path to check.\n    if (cfg.getDirectedGraph().getNodes().size() == 1) {\n      return cfg.getImplicitReturn().get().getFirstPredecessor().isPresent();\n    }\n\n    // If the graph has more than one node, then check if all paths from the\n    // entry node to the implicit return node contain a return statement.\n    return cfg.getImplicitReturn().get().getFirstPredecessor().isPresent()\n        && cfg.getEntry().getFirstSuccessor().isPresent()\n        && cfg.getEntry().getFirstSuccessor().get().getFirstPredecessor().isPresent()\n        && cfg.getEntry().getFirstSuccessor().get().getFirstPredecessor().get()\n            .getFirstSuccessor().isPresent()\n        && cfg.getEntry().getFirstSuccessor().get().getFirstPredecessor().get()\n            .getFirstSuccessor().get().getFirstPredecessor().isPresent();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node entry = cfg.getEntry();\n  Node implicitReturn = cfg.getImplicitReturn();\n  return checkAllPathsWithoutBackEdges(entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node entry = cfg.getEntry();\n  Node implicitReturn = cfg.getImplicitReturn();\n  return checkAllPathsWithoutBackEdges(entry, implicitReturn);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n    return test.allPathsSatisfyPredicate();\n  }"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        final Dfp x[] = new Dfp[2];\n        final Dfp x2[] = new Dfp[2];\n        final Dfp y[] = new Dfp[2];\n        final Dfp a2[] = new Dfp[2];\n\n        a2[0] = a[0].copy();\n        a2[1] = a[1].copy();\n\n        // Set X = (a-1)/(a+1)\n        a2[0] += 1.0;\n        a2[0].reciprocal(x);\n        a2[0] -= 2.0;\n        a2[0].multiply(x, x);\n\n        // Square X -> X2\n        x[0].multiply(x, x2);\n\n        // Set Y = 2x + 2/3x^3 + 2/5x^5 + 2/7x^7 + ...\n        y[0] = x[0].copy();\n        y[1] = x[1].copy();\n        y[0].multiply(2.0, y);\n        y[1].multiply(2.0, y);\n\n        for (int i = 2; i < LN_MANT.length; i++) {\n            x[0].multiply(x2, a2);\n            a2[0].add(LN_MANT[i][0], a2);\n            a2[1].add(LN_MANT[i][1], a2);\n            y[0].add(a2[0], y);\n            y[1].add(a2[1], y);\n        }\n\n        // Multiply Y by X\n        x[0].multiply(y, y);\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] x2 = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n\n    a2[0] = a[0];\n    a2[1] = a[1];\n\n    split(a2, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp x2[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp a2[] = new Dfp[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n\n    //x[0] -= 1.0;\n    //resplit(x);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] x2 = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n\n    //x[0] -= 1.0;\n    //resplit(x);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] x2 = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n\n    a[0].split(x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0].add(1.0);\n    x[0].resplit(x);\n    x[0].reciprocal(a2);\n    x[0].subtract(2.0);\n    x[0].resplit(x);\n    x[0].multiply(a2, y);\n    x[0].set(y[0]);\n    x[1].set(y[1]);\n\n    /* Square X -> X2*/\n    x[0].multiply(x, x2);\n\n    y[0].set(LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0]);\n    y[1].set(LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1]);\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        y[0].multiply(x2, a);\n        y[0].set(a[0]);\n        y[1].set(a[1]);\n        y[0].add(LN_SPLIT_COEF[i][0]);\n        y[1].add(LN_SPLIT_COEF[i][1]);\n    }\n\n    y[0].multiply(x, a);\n    y[0].set(a[0]);\n    y[1].set(a[1]);\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        final Dfp x[] = new Dfp[2];\n        final Dfp x2[] = new Dfp[2];\n        final Dfp y[] = new Dfp[2];\n        final Dfp a2[] = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] x2 = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    //x[0] -= 1.0;\n    //resplit(x);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key, false);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = getCollection(key, false);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection coll = (Collection) getMap().get(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}\n\n@Override\nNode processArrayLiteral(ArrayLiteral literalNode) {\n  if (literalNode.isDestructuring()) {\n    reportDestructuringAssign(literalNode);\n  }\n\n  Node node = newNode(Token.ARRAYLIT);\n  for (AstNode child : literalNode.getElements()) {\n    Node c = transformAsString(child);\n    node.addChildToBack(c);\n  }\n  return node;\n}\n\n@Override\nNode processAssignment(Assignment assignmentNode) {\n  Node assign = processInfixExpression(assignmentNode);\n  Node target = assign.getFirstChild();\n  if (!validAssignmentTarget(target)) {\n    errorReporter.error(\n      \"invalid assignment target\",\n      sourceName,\n      target.getLineno(), \"\", 0);\n  }\n  return assign;\n}\n\n@Override\nNode processAstRoot(AstRoot rootNode) {\n  Node node = newNode(Token.SCRIPT);\n  for (com.google.javascript.rhino.head.Node child : rootNode) {\n    node.addChildToBack(transform((AstNode) child));\n  }\n  parseDirectives(node);\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the values for the category...\n    List values = new ArrayList();\n    int column = dataset.getColumnIndex(category);\n    for (int row = 0; row < dataset.getRowCount(); row++) {\n        if (includedRows == null || includedRows.length == 0\n                || Arrays.binarySearch(includedRows, row) >= 0) {\n            Number value = dataset.getValue(row, column);\n            if (value != null) {\n                values.add(value);\n            }\n        }\n    }\n    // add the base value...\n    values.add(new Double(base));\n    // convert to percentages if required...\n    if (asPercentages) {\n        double total = DataUtilities.calculateColumnTotal(dataset, column);\n        for (int i = 0; i < values.size(); i++) {\n            double v = ((Number) values.get(i)).doubleValue();\n            v = v / total;\n            values.set(i, new Double(v));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int column = dataset.getColumnIndex(category);\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, column);\n        double value = 0.0;\n        if (n != null) {\n            value = n.doubleValue();\n        }\n        if (asPercentages) {\n            value = value / base;\n        }\n        result.add(new Double(value));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            double v = base;\n            if (n != null) {\n                v += n.doubleValue();\n            }\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(v));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the total for the category...\n    double total = 0.0;\n    for (int row : includedRows) {\n        double v = dataset.getValue(row, column).doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        total += v;\n    }\n\n    // now create the list of stacked values...\n    List result = new ArrayList();\n    double previous = base;\n    for (int row : includedRows) {\n        double v = dataset.getValue(row, column).doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        double current = previous + v;\n        result.add(new Double(current));\n        previous = current;\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // create a list to hold the stacked values\n    List result = new ArrayList();\n\n    // loop through the rows and calculate the stacked value\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = base;\n        for (int j = 0; j < row; j++) {\n            v += dataset.getValue(row, category).doubleValue();\n        }\n        if (asPercentages) {\n            v = v / DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        result.add(new Double(v));\n    }\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        int column = dataset.getColumnIndex(category);\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, column);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                result.add(new Double(v + base));\n                base += v;\n            }\n            else {\n                result.add(new Double(base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double v = base;\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                v += n.doubleValue();\n            }\n            if (asPercentages) {\n                v /= total;\n            }\n            result.add(new Double(v));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, column);\n            double v = 0.0;\n            if (n != null) {\n                v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n            }\n            result.add(new Double(v + base));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = 0.0;\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                value = n.doubleValue();\n            }\n            if (asPercentages) {\n                value = value / total;\n            }\n            result.add(new Double(value + base));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        // get the value list...\n        List result = new ArrayList();\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            double value = 0.0;\n            Number n = dataset.getValue(row, column);\n            if (n != null) {\n                value = n.doubleValue();\n            }\n            if (asPercentages) {\n                double total = DataUtilities.calculateColumnTotal(dataset,\n                        column);\n                value = value / total;\n            }\n            result.add(new Double(value));\n        }\n\n        // add the base value...\n        result.add(new Double(base));\n\n        // return the result...\n        return result;\n    }"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes)\n        {\n            if (node instanceof Element)\n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes)\n        {\n            if (node instanceof Element)\n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = Collections.unmodifiableList(elements);\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = elements;\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element)\n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = Collections.unmodifiableList(elements);\n    }\n    return shadowChildrenRef;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildrenRef.add((Element) node);\n            }\n        }\n    }\n    return shadowChildrenRef;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    return hash ^ (hash >>> 7) ^ (hash >>> 4);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    if (hash < 0) {\n        hash = -hash;\n    }\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return hash & (buckets.length - 1);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    return hash ^ (hash >>> 7) ^ (hash >>> 4);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}",
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c >= k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c >= k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r < c - k) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r + k < c) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    // Initialize a matrix with the same dimensions as m\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n\n    // Iterate over the rows and columns of m\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            // If the element is on or below the diagonal, set it to 0\n            if (r + c < k) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n\n    // Return the upper triangular part of m\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c > k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    // TODO\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } else if (right.skew == Skew.BALANCED) {\n                    rotateCCW();\n                    skew      = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        // look for small sub-diagonal element\n        for (int i = startIdx; i >= 0; i--) {\n            if (FastMath.abs(matrixT[i][i]) <= epsilon * norm) {\n                return i;\n            }\n        }\n\n        return startIdx;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        final int n = matrixT.length;\n        int iu = startIdx;\n        while (iu > 0) {\n            if (FastMath.abs(matrixT[iu][iu - 1]) < epsilon * norm) {\n                break;\n            }\n            iu--;\n        }\n        return iu;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                    FastMath.abs(z) +\n                                                    FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        final int n = matrixT.length;\n        double lhs = FastMath.abs(matrixT[startIdx][startIdx]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[startIdx - 1][startIdx - 1]) +\n                                              FastMath.abs(z) +\n                                              FastMath.abs(matrixT[startIdx + 1][startIdx + 1]));\n\n        if (lhs < epsilon * rhs) {\n            return startIdx;\n        }\n        return findSmallSubDiagonalElement(startIdx - 1, norm);\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        // find the first small sub-diagonal element\n        int idx = startIdx;\n        while (idx > 0) {\n            final double lhs = FastMath.abs(matrixT[idx][idx - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[idx - 1][idx - 1]) +\n                                                        FastMath.abs(z) +\n                                                        FastMath.abs(matrixT[idx + 1][idx + 1]));\n\n            if (lhs < epsilon * rhs) {\n                break;\n            }\n            idx--;\n        }\n\n        return idx;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        int im = startIdx;\n        while (im >= 0) {\n            if (FastMath.abs(matrixT[im][im]) <= small * norm) {\n                break;\n            }\n            im--;\n        }\n        return im;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // look for small sub-diagonal element\n    int idx = startIdx;\n    while (idx > 0) {\n        if (FastMath.abs(matrixT[idx][idx - 1]) <= epsilon * norm) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // check for small sub-diagonal element\n    int im = startIdx;\n    while (im > 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                    FastMath.abs(z) +\n                                                    FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Look for small sub-diagonal element\n    for (int i = startIdx; i >= 0; i--) {\n        if (FastMath.abs(matrixT[i][i]) <= small * norm) {\n            return i;\n        }\n    }\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        int i = startIdx;\n        while (i > 0) {\n            if (FastMath.abs(matrixT[i][i - 1]) <= epsilon * norm) {\n                break;\n            }\n            i--;\n        }\n        return i;\n    }"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) > 0) {\n            node = node.left;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n        Node node = null;\n        for (Node current = top; current != null;) {\n            if (current.element.compareTo(reference) < 0) {\n                if (current.right == null) {\n                    return node;\n                }\n                current = current.right;\n            } else {\n                node = current;\n                if (current.left == null) {\n                    return node;\n                }\n                current = current.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null)\n    {\n        if (node.element.compareTo(reference) >= 0)\n        {\n            if (node.left != null)\n            {\n                node = node.left;\n            }\n            else\n            {\n                return node;\n            }\n        }\n        else\n        {\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) >= 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = null;\n    for (Node current = top; current != null;) \n    {\n        if (current.element.compareTo(reference) < 0) \n        {\n            if (current.right == null) \n            {\n                return node;\n            }\n            current = current.right;\n        } \n        else \n        {\n            node = current;\n            if (current.left == null) \n            {\n                return node;\n            }\n            current = current.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) >= 0) \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new SetUniqueList<E>(list, set);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        return new SetUniqueList<E>(list, new HashSet<E>(list));\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        return new SetUniqueList<E>(list, new HashSet<E>(list));\n    }"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token != JsDocToken.LS) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.ls\");\n  }\n\n  next();\n\n  Node elementTypeList = parseElementTypeList(next());\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n\n  if (!match(JsDocToken.RS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token != JsDocToken.LB) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node elementTypeList = parseElementTypeList(next());\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token != JsDocToken.LS) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.ls\");\n  }\n\n  next();\n\n  skipEOLs();\n  token = next();\n\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n\n  skipEOLs();\n  if (!match(JsDocToken.RS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n  final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) \n  {\n    return new Vector3D(1, 0, 0);\n  } \n  else if (q0 < 0) \n  {\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n  }\n  return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n  double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) \n  {\n    return new Vector3D(1, 0, 0);\n  } \n  else if (q0 < 0) \n  {\n    return new Vector3D(q1 / squaredSine, q2 / squaredSine, q3 / squaredSine);\n  } \n  else \n  {\n    return new Vector3D(-q1 / squaredSine, -q2 / squaredSine, -q3 / squaredSine);\n  }\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    if (q0 < -0.1 || q0 > 0.1) {\n      return new Vector3D(q1, q2, q3).normalize();\n    } else if (q0 < 0) {\n      return new Vector3D(-q1, -q2, -q3).normalize();\n    }\n    return new Vector3D(q1, q2, q3).normalize();\n  }",
      "public Vector3D getAxis()  {\n  // Fill in the code here\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else if (q0 < 0) \n    {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n    } \n    else \n    {\n        return new Vector3D(-q1 / FastMath.sqrt(squaredSine), -q2 / FastMath.sqrt(squaredSine), -q3 / FastMath.sqrt(squaredSine));\n    }\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else if (q0 < 0) \n    {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine), q2 / FastMath.sqrt(squaredSine), q3 / FastMath.sqrt(squaredSine));\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (byte) ((b1 - '0') * 16 + (b2 - '0'));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (byte) ((b1 - 65) * 16 + (b2 - 65));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (HEX_DECODING[(b1 >> 4) & 0xf] << 4) + HEX_DECODING[b1 & 0xf];\n                    b = (b << 4) + HEX_DECODING[(b2 >> 4) & 0xf];\n                    b = (b << 4) + HEX_DECODING[b2 & 0xf];\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (byte) ((b1 - 65) * 16 + (b2 - 65));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (HEX_DECODING_TABLE[b1] << 4) + HEX_DECODING_TABLE[b2];\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (HEX_CHARS.indexOf(b1) << 4 | HEX_CHARS.indexOf(b2));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (HEX_DECODING[(b1 >> 4) & 0xF] << 4) + HEX_DECODING[b1 & 0xF];\n                b = (b << 4) + HEX_DECODING[(b2 >> 4) & 0xF];\n                b = (b << 4) + HEX_DECODING[b2 & 0xF];\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (HEX_DECODING_TABLE[b1] << 4) + HEX_DECODING_TABLE[b2];\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (byte) ((b1 << 4) + b2 - 528);\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (byte)((b1 << 4) + b2);\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    for (int i = 0; i < types.length - 1; i++) {\n        DateTimeFieldType type = types[i];\n        DateTimeFieldType nextType = types[i + 1];\n        if (type.getRangeDurationField() != nextType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType fieldType = partial.getFieldType(0);\n    DateTimeFieldType nextType = partial.getFieldType(1);\n    if (fieldType.getRangeDurationField() != nextType) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        DateTimeFieldType currentType = partial.getFieldType(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        if (currentType.getRangeDurationField() != nextFieldType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType lastFieldType = partial.getFieldType(size - 1);\n    DateTimeFieldType thisFieldType = partial.getFieldType(size - 2);\n    DurationField lastRangeField = lastFieldType.getRangeDurationField();\n    DurationField thisRangeField = thisFieldType.getRangeDurationField();\n    if (lastRangeField == null || thisRangeField == null) {\n        return false;\n    }\n    return lastRangeField.equals(thisRangeField);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    for (int i = 0; i < types.length; i++) {\n        DateTimeFieldType type = types[i];\n        DateTimeField field = partial.getField(type);\n        if (i + 1 < types.length) {\n            DateTimeFieldType nextType = types[i + 1];\n            if (field.getRangeDurationField() != nextType.getDurationField()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    DateTimeFieldType lastType = types[size - 1];\n    DurationField lastRange = lastType.getRangeDurationField();\n    for (int i = size - 2; i >= 0; i--) {\n        DateTimeFieldType type = types[i];\n        DurationField range = type.getRangeDurationField();\n        if (range == null) {\n            return false;\n        }\n        if (range != lastRange) {\n            return false;\n        }\n        lastType = type;\n        lastRange = range;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    if (types.length < 2) {\n        return false;\n    }\n    DateTimeFieldType lastType = types[0];\n    DateTimeFieldType thisType = types[1];\n    for (int i = 2; i < types.length; i++) {\n        DateTimeFieldType nextType = types[i];\n        if (lastType.getRangeDurationField() != thisType) {\n            return false;\n        }\n        lastType = thisType;\n        thisType = nextType;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    DateTimeFieldType firstType = partial.getFieldType(0);\n    if (lastType == null || firstType == null) {\n        return false;\n    }\n    DurationField lastRange = lastType.getDurationType().getRangeDurationField();\n    DurationField firstRange = firstType.getDurationType().getRangeDurationField();\n    if (lastRange == null || firstRange == null) {\n        return false;\n    }\n    return lastRange.equals(firstRange);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType lastFieldType = partial.getFieldType(size - 1);\n    DateTimeFieldType nextFieldType = partial.getFieldType(0);\n    if (lastFieldType.getRangeDurationField() != nextFieldType) {\n        return false;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeField> fields = partial.getFields();\n    int size = fields.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType type = fields.get(0).getType();\n    DateTimeFieldType nextType = fields.get(1).getType();\n    if (type.getRangeDurationField() != nextType) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        type = nextType;\n        nextType = fields.get(i).getType();\n        if (type.getRangeDurationField() != nextType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeField> fields = partial.getFields();\n    if (fields.size() < 2) {\n        return false;\n    }\n    DateTimeField firstField = fields.get(0);\n    DateTimeField lastField = fields.get(fields.size() - 1);\n    DurationField firstRange = firstField.getRangeDurationField();\n    DurationField lastRange = lastField.getRangeDurationField();\n    if (firstRange == null || lastRange == null) {\n        return false;\n    }\n    return firstRange.equals(lastRange);\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashBag<O>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashBag<O>();\n    for (final O obj : emptyIfNull(a)) {\n        result.add(obj);\n    }\n    for (final O obj : emptyIfNull(b)) {\n        result.add(obj);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashSet<O>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashSet<O>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashBag<O>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n  {\n    strings.add(NodeUtil.newString(Token.NAME, child.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n        strings.add(NodeUtil.newString(param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null;\n      child = child.getNext()) {\n    if (child.isString()) {\n      strings.add(child);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n    strings.add(NodeUtil.newString(Token.NAME, child.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param = params.getFirstChild();\n       param != null;\n       param = param.getNext()) {\n    strings.add(new StringNode(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) \n  {\n    if (child.isString()) \n    {\n      strings.add(child);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null;\n      param = param.getNext()) {\n    Preconditions.checkArgument(param.isString());\n    strings.add(param);\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n    if (param.isString()) {\n      strings.add(param);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str.substring(1), delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str.substring(1), delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str.substring(1), delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return capitalize(str.substring(1), delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = null;\n    if (id != null) \n    {\n        convertedId = iConvertedIds.get(id);\n        if (convertedId == null) \n        {\n            convertedId = convertId(id);\n            iConvertedIds.put(id, convertedId);\n        }\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = (String) iOldIdMap.get(id);\n    if (newId == null) {\n        newId = id;\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = iOldToNew.get(id);\n    if (newId == null) {\n        newId = id;\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String convertedId = null;\n    if (id.startsWith(\"GMT\")) {\n        convertedId = \"UTC\" + id.substring(3);\n    } else if (id.startsWith(\"UTC\")) {\n        convertedId = \"GMT\" + id.substring(3);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = null;\n    if (id.startsWith(\"GMT\")) \n    {\n        convertedId = \"Etc/GMT\" + id.substring(3);\n    } \n    else if (id.startsWith(\"UTC\")) \n    {\n        convertedId = \"Etc/UTC\" + id.substring(3);\n    } \n    else if (id.startsWith(\"MET\")) \n    {\n        convertedId = \"Etc/MET\" + id.substring(3);\n    } \n    else if (id.startsWith(\"WET\")) \n    {\n        convertedId = \"Etc/WET\" + id.substring(3);\n    } \n    else if (id.startsWith(\"EST\")) \n    {\n        convertedId = \"Etc/EST\" + id.substring(3);\n    } \n    else if (id.startsWith(\"MST\")) \n    {\n        convertedId = \"Etc/MST\" + id.substring(3);\n    } \n    else if (id.startsWith(\"HST\")) \n    {\n        convertedId = \"Etc/HST\" + id.substring(3);\n    } \n    else if (id.startsWith(\"ACT\")) \n    {\n        convertedId = \"Etc/ACT\" + id.substring(3);\n    } \n    else if (id.startsWith(\"AET\")) \n    {\n        convertedId = \"Etc/AET\" + id.substring(3);\n    } \n    else if (id.startsWith(\"AGT\")) \n    {\n        convertedId = \"Etc/AGT\" + id.substring(3);\n    } \n    else if (id.startsWith(\"ART\")) \n    {\n        convertedId = \"Etc/ART\" + id.substring(3);\n    } \n    else if (id.startsWith(\"AST\")) \n    {\n        convertedId = \"Etc/AST\" + id.substring(3);\n    } \n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = null;\n    if (id.startsWith(\"GMT\")) \n    {\n        convertedId = \"UTC\" + id.substring(3);\n    } \n    else if (id.startsWith(\"UTC\")) \n    {\n        convertedId = id;\n    } \n    else \n    {\n        convertedId = id;\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = null;\n    if (id != null) \n    {\n        if (id.startsWith(\"GMT\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"UTC\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"UT\")) \n        {\n            convertedId = id.substring(2);\n        } \n        else if (id.startsWith(\"Universal\")) \n        {\n            convertedId = id.substring(10);\n        } \n        else if (id.startsWith(\"Zulu\")) \n        {\n            convertedId = id.substring(4);\n        } \n        else if (id.startsWith(\"UCT\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"ECT\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"EST\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"MST\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"CST\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"AST\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"JST\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"ACT\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"AET\")) \n        {\n            convertedId = id.substring(3);\n        } \n        else if (id.startsWith(\"SST\")) \n        {\n            convertedId = id.substring(3);\n        } \n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"Etc/GMT\")) \n    {\n        return \"GMT\" + id.substring(6);\n    } \n    else if (id.startsWith(\"GMT\")) \n    {\n        return \"GMT\" + id.substring(3);\n    } \n    else if (id.startsWith(\"UTC\")) \n    {\n        return \"UTC\" + id.substring(3);\n    } \n    else if (id.startsWith(\"SystemV/\")) \n    {\n        return id.substring(9);\n    } \n    else if (id.startsWith(\"Canada/\")) \n    {\n        return \"America/Toronto\";\n    } \n    else if (id.startsWith(\"Mexico/\")) \n    {\n        return \"America/Mexico_City\";\n    } \n    else if (id.startsWith(\"US/\")) \n    {\n        return \"America/\" + id.substring(3);\n    } \n    else if (id.startsWith(\"Canada\")) \n    {\n        return \"America/Toronto\";\n    } \n    else if (id.startsWith(\"Mexico\")) \n    {\n        return \"America/Mexico_City\";\n    } \n    else if (id.startsWith(\"US\")) \n    {\n        return \"America/\" + id.substring(2);\n    } \n    else if (id.startsWith(\"Portugal\")) \n    {\n        return \"Europe/Lisbon\";\n    } \n    else if (id.startsWith(\"Asia/Macao\")) \n    {\n        return \"Asia/Macau\";\n    } \n    else if (id.startsWith(\"Asia/Rangoon\")) \n    {\n        return \"Asia/Yangon\";\n    } \n    else if (id.startsWith(\"Asia/Saigon\")) \n    {\n        return \"Asia/Ho_Chi_Minh\";\n    } \n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"GMT\")) \n    {\n        return id;\n    }\n    String newId = iOldToNewIds.get(id);\n    if (newId == null) \n    {\n        newId = parseOffset(id);\n        if (newId == null) \n        {\n            newId = id;\n        }\n        iOldToNewIds.put(id, newId);\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"Etc/GMT\")) \n    {\n        return \"GMT\" + id.substring(6);\n    }\n    if (id.startsWith(\"GMT\")) \n    {\n        return \"GMT\" + id.substring(3);\n    }\n    if (id.startsWith(\"UTC\")) \n    {\n        return \"UTC\" + id.substring(3);\n    }\n    if (id.startsWith(\"SystemV/\")) \n    {\n        return \"GMT\" + id.substring(9);\n    }\n    if (id.startsWith(\"HST\")) \n    {\n        return \"HST\" + id.substring(3);\n    }\n    if (id.startsWith(\"MET\")) \n    {\n        return \"MET\" + id.substring(3);\n    }\n    if (id.startsWith(\"MST\")) \n    {\n        return \"MST\" + id.substring(3);\n    }\n    if (id.startsWith(\"NZST\")) \n    {\n        return \"NZST\" + id.substring(4);\n    }\n    if (id.startsWith(\"PST\")) \n    {\n        return \"PST\" + id.substring(3);\n    }\n    if (id.startsWith(\"ROC\")) \n    {\n        return \"ROC\" + id.substring(3);\n    }\n    if (id.startsWith(\"ACT\")) \n    {\n        return \"ACT\" + id.substring(3);\n    }\n    if (id.startsWith(\"AET\")) \n    {\n        return \"AET\" + id.substring(3);\n    }\n    if (id.startsWith(\"AGT\")) \n    {\n        return \"AGT\" + id.substring(3);\n    }\n    if (id.startsWith(\"ART\")) \n    {\n        return \"ART\" + id.substring(3);\n    }\n    if (id.startsWith(\"AST\")) \n    {\n        return \"AST\" + id.substring(3);\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Compute the Jacobian matrix.\n        final RealMatrix jacobian = computeJacobian(params);\n        // Compute the weight matrix.\n        final RealMatrix weightMatrix = getWeight();\n        // Compute the weighted Jacobian: W^(1/2) J.\n        return weightMatrix.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    // evaluate the objective function and its jacobian\n    final double[] currentObjective = computeObjectiveValue(params);\n    final double[] currentResiduals = computeResiduals(currentObjective);\n    final RealMatrix weightedJacobian = computeWeightedJacobian(params);\n\n    // build the linear problem\n    final double[]   b = new double[nC];\n    final double[][] a = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n\n        final double[] grad   = weightedJacobian.getRow(i);\n        final double weight   = residualsWeights[i];\n        final double residual = currentResiduals[i];\n\n        // compute the normal equation\n        final double wr = weight * residual;\n        for (int j = 0; j < nC; ++j) {\n            b[j] += wr * grad[j];\n        }\n    }\n\n    // solve the linear problem\n    final RealMatrix aT = MatrixUtils.createRealMatrix(a).transpose();\n    final RealMatrix aTa = aT.multiply(MatrixUtils.createRealMatrix(a));\n    final RealMatrix aTb = aT.multiply(MatrixUtils.createRealVector(b));\n    final RealMatrix aTaInv = new LUDecomposition(aTa).getSolver().getInverse();\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Get the weight matrix.\n    RealMatrix weightMatrix = getWeight();\n\n    // Get the dimension of the problem.\n    int nR = weightMatrix.getRowDimension();\n    int nC = weightMatrix.getColumnDimension();\n\n    // Check if the dimensions of the weight matrix match the problem dimension.\n    if (nR != nC) {\n        throw new DimensionMismatchException(nR, nC);\n    }\n\n    // Compute the Jacobian matrix.\n    RealMatrix jacobian = computeJacobian(params);\n\n    // Check if the dimensions of the Jacobian matrix match the problem dimension.\n    if (jacobian.getRowDimension() != nR || jacobian.getColumnDimension() != nC) {\n        throw new DimensionMismatchException(jacobian.getRowDimension(), jacobian.getColumnDimension(), nR, nC);\n    }\n\n    // Compute the weighted Jacobian.\n    return weightMatrix.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // compute the Jacobian matrix\n        final RealMatrix jacobian = computeJacobian(params);\n\n        // compute the weight matrix\n        final RealMatrix weightMatrix = getWeight();\n\n        // compute the weighted Jacobian\n        return weightMatrix.multiply(jacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // TODO: implement this method\n        return null;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        // Initialize the Jacobian matrix.\n        final RealMatrix jacobian = new Array2DRowRealMatrix(getTargetDimension(), getModelDimension());\n        final double[] residuals = computeResiduals(params);\n        final double[] weights = getWeight().getRow(0);\n        for (int i = 0; i < getTargetDimension(); i++) {\n            jacobian.setEntry(i, i, residuals[i] * weights[i]);\n        }\n        return jacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final RealMatrix weightedJacobian = computeJacobian(params);\n        final RealMatrix weight = getWeight();\n        return weightedJacobian.multiply(weight.scalarMultiply(1.0 / Math.sqrt(getIterationCount())));\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    // evaluate the objective function and its jacobian\n    final double[] currentObjective = computeObjectiveValue(params);\n    final double[] currentResiduals = computeResiduals(currentObjective);\n    final RealMatrix weightedJacobian = computeWeightedJacobian(params);\n\n    // build the linear problem\n    final double[]   b = new double[nC];\n    final double[][] a = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n\n        final double[] grad   = weightedJacobian.getRow(i);\n        final double weight   = residualsWeights[i];\n        final double residual = currentResiduals[i];\n\n        // compute the normal equation\n        final double wr = weight * residual;\n        for (int j = 0; j < nC; ++j) {\n            b[j] += wr * grad[j];\n        }\n    }\n\n    // solve the linear problem\n    final RealVector x = new ArrayRealVector(nC);\n    final DecompositionSolver solver = new QRDecomposition(new Array2DRowRealMatrix(a)).getSolver();\n    x.combineToSelf(1.0, solver.solve(new ArrayRealVector(b, false)));\n\n    // update the model parameters\n    for (int i = 0; i < nC; ++i) {\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n}\n}\n}"
    ],
    [
      "private int least()  {\n    if (values == null) {\n        throw new NullPointerException(\"No comparator is set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (values == null) {\n        values = new ArrayList<E>(iterators.size());\n        valueSet = new BitSet(iterators.size());\n        for (int i = 0; i < iterators.size(); i++) {\n            values.add(null);\n        }\n    }\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (set(i)) {\n                least = i;\n            }\n        } else if (least < 0) {\n            least = i;\n        } else if (comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    if (least < 0) {\n        throw new NoSuchElementException(\"There are no more elements\");\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator has been set\");\n        }\n        int least = 0;\n        for (int i = 1; i < values.size(); i++) {\n            if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                least = i;\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(i), values.get(least)) < 0) {\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (values == null) {\n        throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"There are no elements for this iterator to loop on\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) \n    {\n        if (comparator.compare(values.get(i), values.get(least)) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(i), values.get(least)) < 0) {\n                least = i;\n            }\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        NodePointer childPointer = new NodePointer(parentPointer);\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        childPointer.setPropertyName(name.toString());\n        childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n        return childPointer;\n    }\n    // else { it is self::node() }\n    return new NodePointer(parentPointer);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        return new NodePointer(parentPointer, step.getNodeTest());\n    } else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        return new AttributePointer(parentPointer, step.getNodeTest());\n    } else {\n        throw new RuntimeException(\"Unexpected axis: \" + axis);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new NodePointer(parentPointer);\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        childPointer.setPropertyName(name.toString());\n        childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n    } else {\n        childPointer = new NodePointer(parentPointer);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new PropertyPointer(parentPointer);\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        childPointer.setPropertyName(name.toString());\n        childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n    }\n    // else { it is self::node() }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        NodePointer childPointer = new NodePointer(parentPointer);\n        childPointer.setNodeName(\n            ((NodeNameTest) step.getNodeTest()).getNodeName());\n        return childPointer;\n    }\n    // else { it is an attribute }\n    NodePointer childPointer = new NodePointer(parentPointer);\n    childPointer.setNodeName(\n        ((NodeNameTest) step.getNodeTest()).getNodeName());\n    childPointer.setAttribute(true);\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        childPointer = new ChildNodePointer(parentPointer);\n    } else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePointer(parentPointer);\n    } else {\n        // It is self::node()\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new PropertyPointer(parentPointer);\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        childPointer.setPropertyName(name.toString());\n        childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n    } else {\n        // else { it is self::node() }\n        childPointer = new NodePointer(parentPointer);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        childPointer = new NodePointer(parentPointer);\n    } else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePointer(parentPointer);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePointer(parentPointer);\n    } else {\n        childPointer = new ChildPointer(parentPointer);\n    }\n    childPointer.setPropertyName(step.getNodeTest().getNodeName().toString());\n    return childPointer;\n}"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if(inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale= definingCalendar.getTimeZone().getLocale();\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar, locale);\n            final Strategy inCache= cache.putIfAbsent(locale, strategy);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (nextObject == null) {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        if (!predicate.evaluate(nextObject)) {\n            nextObject = null;\n        }\n    }\n    return true;\n}",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            final E next = iterator.next();\n            if (predicate.evaluate(next)) {\n                nextObject = next;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            final E next = iterator.next();\n            if (predicate.evaluate(next)) {\n                nextObject = next;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        final E object = iterator.next();\n        if (predicate.evaluate(object)) {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n        while (nextObjectSet == false) {\n            if (nextObject == null) {\n                nextObject = next();\n            } else {\n                nextObject = nextObject.next();\n            }\n            if (nextObject == null) {\n                return false;\n            }\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return true;\n    }",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    if (predicate == null) {\n        return false;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.min(Math.max(x[i], lB[i]), uB[i]);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.min(Math.max(x[i], lowerBound[i]), upperBound[i]);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        }\n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        }\n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.min(Math.max(x[i], lowerBound[i]), upperBound[i]);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n        final double[] lB = CMAESOptimizer.this.getLowerBound();\n        final double[] uB = CMAESOptimizer.this.getUpperBound();\n        double[] repaired = new double[x.length];\n        for (int i = 0; i < x.length; i++) {\n            if (x[i] < lB[i]) {\n                repaired[i] = lB[i];\n            } else if (x[i] > uB[i]) {\n                repaired[i] = uB[i];\n            } else {\n                repaired[i] = x[i];\n            }\n        }\n        return repaired;\n    }",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    // get the Schur form of the matrix\n    RealMatrix schur = transformer.getT();\n    // compute the eigenvalues of the Schur form\n    findEigenVectorsFromSchur(transformer);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    // Compute the eigenvalues\n    findEigenValues(transformer.getT().getData());\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < matrixT.length; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = matrixT.length - 1; idx >= 0; idx--) {\n        double p = matrixT[idx][idx];\n        double q = matrixT[idx][idx - 1];\n\n        double t = FastMath.abs(p) + FastMath.abs(q);\n        double u = t * Precision.EPSILON;\n        double x = matrixT[idx][idx];\n        double y = matrixT[idx][idx - 1];\n        double d = Precision.SAFE_MIN;\n        double l = matrixT[idx][idx] - matrixT[idx - 1][idx - 1];\n\n        for (int cnt = 0; cnt < MAX_ITERATIONS; cnt++) {\n            if (FastMath.abs(l) < u) {\n                break;\n            }\n            double a = (l / t) * (l / t);\n            double b = a + z - x - q;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    // get the matrices\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n    // compute the eigenvalues\n    final int n = matrixT.length;\n    // initialize the eigen values\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    // compute the eigenvalues\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrixT[i][i];\n        imagEigenvalues[i] = 0;\n    }\n    // return the transformer\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((value & 1) == 1) \n            {\n                result.add(Enum.valueOf(enumClass, Integer.toString(i * Long.SIZE + j)));\n            }\n            value >>>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    //reverse the array\n    ArrayUtils.reverse(values);\n    //create an empty set of enum values\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    //loop through each long value\n    for (int i = 0; i < values.length; i++) \n    {\n        //get the long value\n        long value = values[i];\n        //loop through each bit in the long value\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            //check if the bit is set\n            if ((value & (1 << j)) != 0) \n            {\n                //get the enum value at the position of the bit\n                E enumValue = enumClass.getEnumConstants()[i * Long.SIZE + j];\n                //add the enum value to the set\n                result.add(enumValue);\n            }\n        }\n    }\n    //return the set of enum values\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            int bit = Long.numberOfTrailingZeros(value);\n            value &= ~(1L << bit);\n            result.add(Enum.valueOf(enumClass, bit));\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(Enum.valueOf(enumClass, (i * Long.SIZE + j)));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        Validate.notNull(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (final E constant : enumClass.getEnumConstants()) {\n            if ((values[constant.ordinal() / Long.SIZE] & (1 << (constant.ordinal() % Long.SIZE))) != 0) {\n                result.add(constant);\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    // Reverse the array to ensure that the least significant bits are processed first\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        final int longIndex = ordinal / Long.SIZE;\n        final int bitIndex = ordinal % Long.SIZE;\n        if ((values[longIndex] & (1L << bitIndex)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    //Reverse the array\n    ArrayUtils.reverse(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & 1 << j) != 0) {\n                result.add(Enum.valueOf(enumClass, j));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (E constant : enumClass.getEnumConstants()) {\n        int ordinal = constant.ordinal();\n        int index = ordinal / Long.SIZE;\n        int bit = ordinal % Long.SIZE;\n        if ((values[index] & (1L << bit)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.noNullElements(values);\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (final E constant : enumClass.getEnumConstants()) {\n            final int index = constant.ordinal() / Long.SIZE;\n            final int offset = constant.ordinal() % Long.SIZE;\n            if ((values[index] & (1 << offset)) != 0) {\n                result.add(constant);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(oldInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offset = newZone.getOffset(oldInstant - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offset) \n    {\n        // if strict then always check if in DST gap\n        // otherwise only check if zone in Western hemisphere (as the\n        // value of offset is already correct for Eastern hemisphere)\n        if (strict || offsetLocal < 0) \n        {\n            // determine if we are in the DST gap\n            long nextLocal = nextTransition(oldInstant - offsetLocal);\n            if (nextLocal == (oldInstant - offsetLocal)) \n            {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(oldInstant - offset);\n            if (nextAdjusted == (oldInstant - offset)) \n            {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) \n            {\n                // yes we are in the DST gap\n                if (strict) \n                {\n                    // DST gap is not acceptable\n                    throw new IllegalInstantException(\"Illegal instant due to time zone offset transition: \" + oldInstant);\n                } \n                else \n                {\n                    // DST gap is acceptable\n                    return oldInstant - offsetLocal;\n                }\n            } \n            else \n            {\n                // no we are not in the DST gap\n                return oldInstant - offsetLocal;\n            }\n        } \n        else \n        {\n            // not in DST gap\n            return oldInstant - offsetLocal;\n        }\n    } \n    else \n    {\n        // offsets are the same\n        return oldInstant - offsetLocal;\n    }\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instant = oldInstant - offset;\n    int newOffset = newZone.getOffset(instant);\n    return instant + newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(oldInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offset = newZone.getOffset(oldInstant - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offset) \n    {\n        // if strict then always check if in DST gap\n        // otherwise only check if zone in Western hemisphere (as the\n        // value of offset is already correct for Eastern hemisphere)\n        if (strict || offsetLocal < 0) \n        {\n            // determine if we are in the DST gap\n            long nextLocal = nextTransition(oldInstant - offsetLocal);\n            if (nextLocal == (oldInstant - offsetLocal)) \n            {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(oldInstant - offset);\n            if (nextAdjusted == (oldInstant - offset)) \n            {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) \n            {\n                // yes we are in the DST gap\n                if (strict) \n                {\n                    // DST gap is not acceptable\n                    throw new IllegalArgumentException(\"Instant is in a gap: \" + oldInstant);\n                }\n                else \n                {\n                    // we are in the DST gap, return the first option\n                    return oldInstant - offsetLocal;\n                }\n            }\n        }\n    }\n    return oldInstant - offsetLocal + offset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    if (newOffset != offset) \n    {\n        long nextLocal = newZone.nextTransition(newInstant);\n        if (nextLocal == newInstant) \n        {\n            nextLocal = Long.MAX_VALUE;\n        }\n        long nextOriginal = nextTransition(oldInstant);\n        if (nextOriginal == oldInstant) \n        {\n            nextOriginal = Long.MAX_VALUE;\n        }\n        if (nextLocal != nextOriginal) \n        {\n            newInstant = newZone.convertLocalToUTC(local, false, newInstant);\n        }\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(oldInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offset = newZone.getOffset(oldInstant - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offset) \n    {\n        // if strict then always check if in DST gap\n        // otherwise only check if zone in Western hemisphere (as the\n        // value of offset is already correct for Eastern hemisphere)\n        if (strict || offsetLocal < 0) \n        {\n            // determine if we are in the DST gap\n            long nextLocal = nextTransition(oldInstant - offsetLocal);\n            if (nextLocal == (oldInstant - offsetLocal)) \n            {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(oldInstant - offset);\n            if (nextAdjusted == (oldInstant - offset)) \n            {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) \n            {\n                // yes we are in the DST gap\n                if (strict) \n                {\n                    // DST gap is not acceptable\n                    throw new IllegalArgumentException(\"Instant is in a gap: \" + oldInstant);\n                }\n                else \n                {\n                    // move back to the end of the DST overlap\n                    oldInstant -= (nextLocal - nextAdjusted);\n                }\n            }\n        }\n    }\n    return oldInstant - offset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long local = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(local, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    if (newInstant != local) \n    {\n        throw new IllegalArgumentException(\"The new zone has a different offset than the old zone.\");\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // get the offset at oldInstant (first estimate)\n    int offset = getOffset(oldInstant);\n    // adjust oldInstant using the estimate and recalc the offset\n    offset = newZone.getOffset(oldInstant - offset);\n    // return the corrected instant\n    return oldInstant - offset;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getUnitType() == DateTickUnitType.MILLISECOND) {\n        milliseconds = value + count;\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.SECOND) {\n        seconds = value + count;\n        calendar.set(Calendar.SECOND, seconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) {\n        minutes = value + count;\n        calendar.set(Calendar.MINUTE, minutes);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.HOUR) {\n        hours = value + count;\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.DAY) {\n        days = value + count;\n        calendar.set(Calendar.DAY_OF_MONTH, days);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MONTH) {\n        months = value + count;\n        calendar.set(Calendar.MONTH, months);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.YEAR) {\n        years = value + count;\n        calendar.set(Calendar.YEAR, years);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getUnitType() == DateTickUnitType.MILLISECOND) \n    {\n        milliseconds = value + count;\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.SECOND) \n    {\n        seconds = value + count;\n        calendar.set(Calendar.SECOND, seconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) \n    {\n        minutes = value + count;\n        calendar.set(Calendar.MINUTE, minutes);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.HOUR) \n    {\n        hours = value + count;\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.DAY) \n    {\n        days = value + count;\n        calendar.set(Calendar.DAY_OF_MONTH, days);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MONTH) \n    {\n        months = value + count;\n        calendar.set(Calendar.MONTH, months);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.YEAR) \n    {\n        years = value + count;\n        calendar.set(Calendar.YEAR, years);\n    }\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    switch (unit.getUnitType()) {\n        case MILLISECOND:\n            milliseconds = value + count;\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            break;\n        case SECOND:\n            seconds = value + count;\n            calendar.set(Calendar.SECOND, seconds);\n            break;\n        case MINUTE:\n            minutes = value + count;\n            calendar.set(Calendar.MINUTE, minutes);\n            break;\n        case HOUR:\n            hours = value + count;\n            calendar.set(Calendar.HOUR_OF_DAY, hours);\n            break;\n        case DAY:\n            days = value + count;\n            calendar.set(Calendar.DAY_OF_MONTH, days);\n            break;\n        case WEEK:\n            days = value + count * 7;\n            calendar.set(Calendar.DAY_OF_MONTH, days);\n            break;\n        case MONTH:\n            months = value + count;\n            calendar.set(Calendar.MONTH, months);\n            break;\n        case YEAR:\n            years = value + count;\n            calendar.set(Calendar.YEAR, years);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The 'unit' argument has a \" +\n                    \"value that is not recognised.\");\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getUnitType() == DateTickUnitType.MILLISECOND) \n    {\n        calendar.set(Calendar.MILLISECOND, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.SECOND) \n    {\n        calendar.set(Calendar.SECOND, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) \n    {\n        calendar.set(Calendar.MINUTE, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.HOUR) \n    {\n        calendar.set(Calendar.HOUR_OF_DAY, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.DAY) \n    {\n        calendar.set(Calendar.DAY_OF_MONTH, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.WEEK) \n    {\n        calendar.set(Calendar.WEEK_OF_MONTH, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MONTH) \n    {\n        calendar.set(Calendar.MONTH, value + count);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.YEAR) \n    {\n        calendar.set(Calendar.YEAR, value + count);\n    }\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getUnitType() == DateTickUnitType.MILLISECOND) {\n        milliseconds = value + count;\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.SECOND) {\n        seconds = value + count;\n        calendar.set(Calendar.SECOND, seconds);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) {\n        minutes = value + count;\n        calendar.set(Calendar.MINUTE, minutes);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.HOUR) {\n        hours = value + count;\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.DAY) {\n        days = value + count;\n        calendar.set(Calendar.DAY_OF_MONTH, days);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MONTH) {\n        months = value + count;\n        calendar.set(Calendar.MONTH, months);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.YEAR) {\n        years = value + count;\n        calendar.set(Calendar.YEAR, years);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    switch (unit.getUnit()) \n    {\n        case YEAR:\n            calendar.set(Calendar.YEAR, value);\n            break;\n        case MONTH:\n            calendar.set(Calendar.MONTH, value);\n            break;\n        case DAY:\n            calendar.set(Calendar.DAY_OF_MONTH, value);\n            break;\n        case HOUR:\n            calendar.set(Calendar.HOUR_OF_DAY, value);\n            break;\n        case MINUTE:\n            calendar.set(Calendar.MINUTE, value);\n            break;\n        case SECOND:\n            calendar.set(Calendar.SECOND, value);\n            break;\n        case MILLISECOND:\n            calendar.set(Calendar.MILLISECOND, value);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unrecognised unit: \" + unit);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check if the variable resolver is null\n    if (getVariableResolver() == null) {\n        return null;\n    }\n    // check if the variable resolver can resolve the variable\n    final String value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.length() == 0) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(variableName)) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(buf.substring(startPos, endPos))) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(buf.substring(startPos, endPos).replaceAll(\"\\\\$\", \"\\\\$\\\\$\"))) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(buf.substring(startPos, endPos).replaceAll(\"\\\\$\", \"\\\\$\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\"))) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(buf.substring(startPos, endPos).replaceAll(\"\\\\$\", \"\\\\$\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\"))) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n    if (value.equals(buf.substring(startPos, endPos).replaceAll(\"\\\\$\", \"\\\\$\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\").replaceAll(\"\\\\$\\\\$\\\\$\", \"\\\\$\"))) {\n        return null;\n    }\n    // check if the variable resolver has resolved the variable\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (getVariableResolver() != null) {\n        value = getVariableResolver().lookup(variableName);\n    }\n    if (value == null) {\n        buf.delete(startPos, endPos + getVariableSuffixMatcher().isMatch(variableName) ? 1 : 0);\n    } else {\n        buf.replace(startPos, endPos + getVariableSuffixMatcher().isMatch(variableName) ? 1 : 0, value);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) \n    {\n        value = variableResolver.lookup(variableName);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) \n    {\n        value = variableResolver.lookup(variableName);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // resolve the variable to a value\n    final String value = getVariableResolver().lookup(variableName);\n    \n    // if the value is null, we are asked to remove the variable from\n    // the result, in which case we do not use the default value\n    if (value == null) {\n        return null;\n    }\n    \n    // handle the case where the variable value contains a variable\n    // and the substitution is recursive\n    if (isEnableSubstitutionInVariables() && isEnableSubstitution()) {\n        return substitute(value, startPos, endPos, buf);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // use the resolver to get the value\n    final Object value = getVariableResolver().lookup(variableName);\n    if (value == null) \n    {\n        return null;\n    }\n    else if (value instanceof String) \n    {\n        return (String) value;\n    }\n    else \n    {\n        return value.toString();\n    }\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) \n    {\n        value = variableResolver.lookup(variableName);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // this implementation uses the StrLookup to resolve the variable\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    // handle the case where the variable value contains a variable\n    // and the cycle detection is enabled\n    if (isEnableSubstitutionInVariables() && isEnableSubstitution()) {\n        final StrBuilder working = new StrBuilder(value);\n        if (substitute(working, 0, working.length()) > 0) {\n            return working.toString();\n        }\n    }\n    return value;\n}"
    ],
    [
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final int len = str.length();\n        if (len == 0) {\n            return str;\n        }\n        final char[] in = new char[len];\n        for (int i = 0; i < len; i++) {\n            in[i] = map(str.charAt(i));\n        }\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(in[0]);\n        int count = 1;\n        for (int i = 1; i < len; i++) {\n            final char c = in[i];\n            if (c != '0') {\n                if (count < 4) {\n                    sBuf.append(c);\n                    count++;\n                } else {\n                    break;\n                }\n            }\n        }\n        while (sBuf.length() < 4) {\n            sBuf.append('0');\n        }\n        return sBuf.toString();\n    }",
      "public String soundex(String str)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String soundex(String str)  {\n        str = str.toUpperCase();\n        char[] soundexMapping = {'0', '1', '2', '3', '0', '1', '2', '0', '0', '2', '2', '4', '5', '5', '0', '1', '2', '6', '2', '3', '0', '1', '0', '2', '0', '2'};\n        if (str == null || str.length() == 0) {\n            return str;\n        }\n        char[] chars = str.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        sb.append(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            char ch = chars[i];\n            if (Character.isLetter(ch)) {\n                char mapped = map(ch);\n                if (mapped != sb.charAt(sb.length() - 1)) {\n                    sb.append(mapped);\n                }\n            }\n        }\n        return sb.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    final char[] chars = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(map(chars[0]));\n    for (int i = 1; i < chars.length; i++) {\n        final char ch = chars[i];\n        if (sb.length() < this.maxLength) {\n            sb.append(map(ch));\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    char[] strArray = str.toCharArray();\n    char[] soundexArray = new char[4];\n    int count = 0;\n    for (int i = 0; i < strArray.length; i++) {\n        if (strArray[i] != 'A' && strArray[i] != 'E' && strArray[i] != 'I' && strArray[i] != 'O' && strArray[i] != 'U' && strArray[i] != 'Y') {\n            if (count == 0) {\n                soundexArray[count] = strArray[i];\n                count++;\n            } else if (count == 1) {\n                if (soundexArray[0] != strArray[i]) {\n                    soundexArray[count] = strArray[i];\n                    count++;\n                }\n            } else if (count == 2) {\n                if (soundexArray[1] != strArray[i]) {\n                    soundexArray[count] = strArray[i];\n                    count++;\n                }\n            } else if (count == 3) {\n                if (soundexArray[2] != strArray[i]) {\n                    soundexArray[count] = strArray[i];\n                    count++;\n                }\n            }\n        }\n    }\n    String soundex = new String(soundexArray);\n    return soundex;\n}",
      "public String soundex(String str)  {\n    // TODO: implement this\n    return null;\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final StringBuilder sb = new StringBuilder();\n        sb.append(map(str.charAt(0)));\n        for (int i = 1; i < str.length(); i++) {\n            final char ch = map(str.charAt(i));\n            if (ch != '0') {\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    final char[] chars = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        final char c = chars[i];\n        if (c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U' && c != 'Y' && c != 'H' && c != 'W') {\n            sb.append(map(c));\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    if (str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sBuf = new StringBuilder();\n    sBuf.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        final char mapped = map(ch);\n        if (mapped != '0') {\n            sBuf.append(mapped);\n        }\n    }\n    return sBuf.toString();\n}",
      "public String soundex(String str)  {\n        // TODO: Implement this method\n    }"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_CHAR_SEQUENCE) {\n        return CORE_TYPE_CHAR_SEQUENCE;\n    }\n    if (clz == CLASS_ITERABLE) {\n        return CORE_TYPE_ITERABLE;\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return CORE_TYPE_MAP_ENTRY;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n    //    This may have been due to potential mutability of the instance; but that\n    //    should not be issue any more, and creation is somewhat wasteful. So let's\n    //    try reusing singleton/flyweight instance.\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n    //    This may have been due to potential mutability of the instance; but that\n    //    should not be issue any more, and creation is somewhat wasteful. So let's\n    //    try reusing singleton/flyweight instance.\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == BigInteger.class) {\n        return CORE_TYPE_BIG_INTEGER;\n    } else if (clz == BigDecimal.class) {\n        return CORE_TYPE_BIG_DECIMAL;\n    } else if (clz == Date.class) {\n        return CORE_TYPE_DATE;\n    } else if (clz == java.sql.Date.class) {\n        return CORE_TYPE_SQL_DATE;\n    } else if (clz == java.sql.Timestamp.class) {\n        return CORE_TYPE_SQL_TIMESTAMP;\n    } else if (clz == java.sql.Time.class) {\n        return CORE_TYPE_SQL_TIME;\n    } else if (clz == java.util.Calendar.class) {\n        return CORE_TYPE_CALENDAR;\n    } else if (clz == java.util.GregorianCalendar.class) {\n        return CORE_TYPE_GREGORIAN_CALENDAR;\n    } else if (clz == java.util.UUID.class) {\n        return CORE_TYPE_UUID;\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // TODO: add code to check for well-known types and return them if found\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_STRING || clz == CLASS_CHAR_SEQUENCE) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_ITERABLE) {\n        return CORE_TYPE_ITERABLE;\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return CORE_TYPE_MAP_ENTRY;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_ITERABLE) {\n        return CORE_TYPE_ITERABLE;\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return CORE_TYPE_MAP_ENTRY;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_ITERABLE) {\n        return CORE_TYPE_ITERABLE;\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return CORE_TYPE_MAP_ENTRY;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_ITERABLE) {\n        return CORE_TYPE_ITERABLE;\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return CORE_TYPE_MAP_ENTRY;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n    DeserializationConfig config = ctxt.getConfig();\n    JavaType lt, mt;\n    \n    if (_factoryConfig.hasAbstractTypeResolvers()) {\n        lt = _findRemappedType(config, List.class);\n        mt = _findRemappedType(config, Map.class);\n    } else {\n        lt = mt = null;\n    }\n    return new UntypedObjectDeserializer(lt, mt);\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult()) {\n      Node lhs = n.getFirstChild();\n      if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) \n    {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) {\n      Node lhs = n.getFirstChild().getFirstChild();\n      if (lhs.isGetProp() && lhs.getFirstChild().isName()\n          && lhs.getLastChild().getString().equals(\"prototype\")) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()\n        && n.getFirstChild().getFirstChild().isGetProp()\n        && n.getFirstChild().getFirstChild().getFirstChild().isName()\n        && n.getFirstChild().getFirstChild().getFirstChild().getString().equals(\"prototype\"))\n    {\n        return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) {\n      Node lhs = n.getFirstChild().getFirstChild();\n      if (NodeUtil.isPrototypeProperty(lhs)) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult() && n.getFirstChild().isAssign()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isName()\n            && lhs.getLastChild().getString().equals(\"prototype\")) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult() && n.getFirstChild().isAssign()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign() &&\n      n.getFirstChild().getFirstChild().isGetProp() &&\n      n.getFirstChild().getFirstChild().getFirstChild().isName() &&\n      n.getFirstChild().getFirstChild().getFirstChild().getString().equals(\"prototype\")) {\n    return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isExprResult() && n.getFirstChild().isAssign()) {\n      Node lhs = n.getFirstChild().getFirstChild();\n      if (NodeUtil.isPrototypeProperty(lhs)) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n    return null;\n  }"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix repmat = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            copyColumn(mat, i, repmat, i * mat.getRowDimension() + j * mat.getColumnDimension());\n        }\n    }\n    return repmat;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n        final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n        for (int r = 0; r < mat.getRowDimension(); r++) {\n            for (int c = 0; c < mat.getColumnDimension(); c++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < m; j++) {\n                        d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                    }\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix rep = mat.copy();\n    for (int i = 1; i < n; i++) {\n        rep = rep.append(mat);\n    }\n    rep = rep.transpose();\n    for (int i = 1; i < m; i++) {\n        rep = rep.append(mat);\n    }\n    return rep;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix m1 = ones(mat.getRowDimension(), n);\n    RealMatrix m2 = ones(m, mat.getColumnDimension());\n    RealMatrix m3 = kron(m1, m2);\n    RealMatrix m4 = kron(mat, m3);\n    return m4;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, result, i * mat.getRowDimension() + j * mat.getColumnDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n        final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < m; c++) {\n                for (int i = 0; i < mat.getRowDimension(); i++) {\n                    for (int j = 0; j < mat.getColumnDimension(); j++) {\n                        d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                    }\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    final long available = inf.getBytesRead();\n    final long remaining = inf.getRemaining();\n    final long consumed = available - remaining;\n    if (consumed > available) {\n        return available;\n    }\n    return consumed;\n}",
      "private long getBytesInflated()  {\n    final long totalBytesRead = getBytesRead();\n    final long totalBytesInflated = inf.getBytesRead();\n    final long lastRead = totalBytesRead - current.bytesReadFromStream;\n    if (totalBytesInflated - lastRead > totalBytesRead) {\n        return totalBytesRead;\n    }\n    return totalBytesInflated - lastRead;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < 0) {\n        bytesInflated = 0;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long available = current.bytesReadFromStream;\n    final long consumed = inf.getBytesWritten();\n    if (consumed > available) {\n        return available;\n    }\n    return consumed;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < 0) {\n        bytesInflated += 0x100000000L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long infBytes = inf.getBytesWritten();\n    final long bytesRead = getBytesRead();\n    if (infBytes < bytesRead) {\n        return bytesRead;\n    }\n    return infBytes - (infBytes - bytesRead) % 0x100000000L;\n}",
      "private long getBytesInflated()  {\n    final long infConsumed = inf.getBytesRead();\n    final long streamConsumed = current.bytesReadFromStream;\n    final long streamRemaining = current.entry.getCompressedSize() - streamConsumed;\n    if (infConsumed > streamRemaining) {\n        return streamConsumed;\n    }\n    return infConsumed;\n}",
      "private long getBytesInflated()  {\n    final long available = bytesRead;\n    final long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n    final long consumed = available - remaining;\n    if (consumed > available) {\n        return available;\n    }\n    return consumed;\n}",
      "private long getBytesInflated()  {\n    long inflated = inf.getBytesWritten();\n    if (inflated < 0) {\n        inflated += 0x100000000L;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > 0) {\n        final long bytesRead = getBytesRead();\n        if (bytesRead > 0 && bytesInflated > bytesRead) {\n            bytesInflated = bytesRead;\n        }\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        }\n        if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        }\n        if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        }\n        if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        }\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        }\n        if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        }\n        if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        }\n        if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        }\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*(\\\\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.indexOf('.') == -1 && isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.indexOf('.') == -1 && isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    for (int k = iu; k >= il; k--) {\n        if (k != iu) {\n            p = matrixT[k + 1][k];\n            q = matrixT[k + 2][k];\n            r = k != (iu - 1) ? matrixT[k + 3][k] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != iu) {\n                matrixT[k + 1][k] = -s * shift.x;\n            } else if (il != iu) {\n                matrixT[k + 1][k] = -matrixT[k + 1][k];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = matrixT[k][k];\n            hVec[1] = matrixT[k + 1][k];\n            hVec[2] = matrixT[k + 2][k];\n            for (int i = k + 3; i < n; i++) {\n                hVec[i - k - 2] = matrixT[i][k];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        // initialize the householder vectors for the QR step\n        if (il == iu) {\n            hVec[0] = 1.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n            return il;\n        } else if (il == iu - 1) {\n            hVec[0] = matrixT[il][il];\n            hVec[1] = matrixT[il + 1][il];\n            hVec[2] = 0.0;\n            return il;\n        } else {\n            hVec[0] = matrixT[il][il];\n            hVec[1] = matrixT[il + 1][il];\n            hVec[2] = matrixT[il + 2][il];\n            return il + 1;\n        }\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu;\n    double h = 0.0;\n    double scale = 0.0;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n\n    // initialize householder vector\n    for (int i = im; i >= il; i--) {\n        scale = scale + FastMath.abs(matrixT[i][i]);\n    }\n    if (scale == 0.0) {\n        return im;\n    }\n\n    for (int i = im; i >= il; i--) {\n        matrixT[i][i] = matrixT[i][i] - shift.exShift;\n        h = h + matrixT[i][i] * matrixT[i][i];\n    }\n\n    double f = matrixT[im][im];\n    double g = (f > 0.0 ? -FastMath.sqrt(h) : FastMath.sqrt(h));\n    hVec[0] = f - g;\n    hVec[1] = matrixT[im][im + 1];\n    hVec[2] = 0.0;\n\n    if (im == il) {\n        return im;\n    }\n\n    for (int i = im - 1; i >= il; i--) {\n        p = matrixT[i][i] + hVec[0];\n        q = matrixT[i + 1][i] * hVec[1] + matrixT[i][i + 1] * hVec[2];\n        r = FastMath.abs(p) + FastMath.abs(q);\n        p = p / r;\n        q = q / r;\n        r = FastMath.sqrt(p * p + q * q);\n        if (p < 0.0) {\n            r = -r;\n        }\n        hVec[0] = r;\n        hVec[1] = q / r;\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    if (il == iu) {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    } else {\n        hVec[0] = matrixT[iu - 1][iu - 1] - shift.exShift;\n        hVec[1] = matrixT[iu][iu - 1];\n        hVec[2] = matrixT[iu - 1][iu];\n\n        // Find largest element\n        int imax = iu - 1;\n        double dmax = FastMath.abs(hVec[0]);\n        for (int i = 0; i < 3; i++) {\n            if (FastMath.abs(hVec[i]) > dmax) {\n                imax = i;\n                dmax = FastMath.abs(hVec[i]);\n            }\n        }\n\n        // Compute Householder vector\n        double tau = 0.0;\n        if (imax == 0) {\n            tau = (hVec[0] >= 0.0) ? hVec[0] - dmax : hVec[0] + dmax;\n        } else {\n            double h = FastMath.abs(hVec[imax]) * FastMath.sqrt(hVec[imax - 1] * hVec[imax - 1] + hVec[imax] * hVec[imax]);\n            if (hVec[imax - 1] >= 0.0) {\n                tau = hVec[imax - 1] + h;\n            } else {\n                tau = hVec[imax - 1] - h;\n            }\n        }\n        hVec[imax] = -tau;\n        hVec[imax - 1] = 1.0;\n        hVec[imax - 2] = 0.0;\n\n        // Apply Householder similarity transformation\n        for (int i = 0; i < imax; i++) {\n            hVec[i] = -tau * hVec[i];\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors for the QR step\n    int im = iu;\n    for (int k = iu; k >= il; k--) {\n        double t = 0.0;\n        for (int i = k; i >= il; i--) {\n            t += FastMath.abs(matrixT[i][i - 1]);\n        }\n        if (t == 0.0) {\n            continue;\n        }\n        im = k;\n        if (t >= epsilon * (FastMath.abs(matrixT[k][k - 1]) + FastMath.abs(matrixT[k - 1][k - 2]))) {\n            break;\n        }\n    }\n    if (im == iu) {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    } else if (im == il - 1) {\n        hVec[0] = 0.0;\n        hVec[1] = 1.0;\n        hVec[2] = 0.0;\n    } else {\n        double p = matrixT[im][im - 1];\n        double q = matrixT[im + 1][im - 1];\n        double r = matrixT[im + 2][im - 1];\n        double s = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (Precision.equals(s, 0.0, epsilon)) {\n            hVec[0] = 1.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        } else {\n            hVec[0] = p / s;\n            hVec[1] = q / s;\n            hVec[2] = r / s;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors for the QR step\n    double p = matrixT[iu][iu] - shift.exShift;\n    double q = matrixT[iu - 1][iu - 1] - shift.exShift;\n    double r = matrixT[iu - 2][iu - 2] - shift.exShift;\n    double x = matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n    double y = matrixT[iu - 1][iu - 2] * matrixT[iu - 2][iu - 1];\n    double z = p * q * r;\n    hVec[0] = p + q + r;\n    hVec[1] = z + x + y;\n    hVec[2] = z - x - y;\n    return iu - 2;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors for the QR step\n    hVec[0] = matrixT[iu][iu] - shift.exShift;\n    hVec[1] = matrixT[iu - 1][iu - 1] - shift.exShift;\n    hVec[2] = matrixT[iu - 2][iu - 2] - shift.exShift;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu;\n    for (int k = iu; k >= il; k--) {\n        if (k == il || FastMath.abs(matrixT[k][k - 1]) <= epsilon * (FastMath.abs(matrixT[k - 1][k - 1]) + FastMath.abs(matrixT[k][k]))) {\n            double p = matrixT[k][k];\n            double q = k == il ? 0.0 : matrixT[k - 1][k - 1];\n            double r = k == im ? 0.0 : matrixT[k + 1][k];\n            double s = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(s, 0.0, epsilon)) {\n                p = p / s;\n                q = q / s;\n                r = r / s;\n            }\n            double t = FastMath.sqrt(p * p + q * q + r * r);\n            hVec[0] = t + FastMath.copySign(Precision.SAFE_MIN, t);\n            hVec[1] = p / hVec[0];\n            hVec[2] = q / hVec[0];\n            im = k + 1;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu][iu - 1];\n    double r = matrixT[iu][iu - 2];\n    double x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (x == 0.0) {\n        return im;\n    }\n    p = p / x;\n    q = q / x;\n    r = r / x;\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (k != im) {\n            matrixT[k][k - 1] = -s * x;\n        } else if (il != im) {\n            matrixT[k][k - 1] = -matrixT[k][k - 1];\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the first householder vector\n    hVec[0] = matrixT[il][il];\n    hVec[1] = matrixT[il + 1][il];\n    hVec[2] = matrixT[il + 2][il];\n\n    // Initialize the first column of the matrix T\n    matrixT[il][il] = 1.0;\n    matrixT[il + 1][il] = 0.0;\n    matrixT[il + 2][il] = 0.0;\n\n    // Initialize the shift\n    computeShift(il, iu, 0, shift);\n\n    // Return the start index for the QR step\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n                segment.getSegmentStart() < this.segmentEnd;\n                segment.inc()) {\n            if (!segment.inExceptionSegments()) {\n                return (false);\n            }\n        }\n        return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = chrono.period(zeroInstance).getDifference(end, start);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[startValues.length];\n    for (int i = 0; i < diff.length; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < diff.length; i++) {\n        int value = diff[i];\n        if (value < 0) {\n            value = -value;\n            if (value > zeroValues[i]) {\n                value = zeroValues[i];\n            }\n            amount = Math.addExact(amount, value);\n        } else {\n            if (value > zeroValues[i]) {\n                value = zeroValues[i];\n            }\n            amount = Math.subtractExact(amount, value);\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (start.getChronology() != end.getChronology()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same chronology\");\n    }\n    Chronology chrono = start.getChronology();\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[startValues.length];\n    for (int i = 0; i < diff.length; i++) {\n        diff[i] = endValues[i] - startValues[i];\n        if (diff[i] < 0) {\n            diff[i] += zeroValues[i];\n        }\n    }\n    return chrono.get(diff, 0);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int size = startValues.length;\n    int[] durations = new int[size];\n    for (int i = 0; i < size; i++) {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (zeroValue == 0) {\n            durations[i] = endValue - startValue;\n        } else {\n            if (startValue == endValue) {\n                durations[i] = 0;\n            } else {\n                int diff = endValue - startValue;\n                if (diff < 0) {\n                    diff += zeroValue;\n                }\n                durations[i] = diff / zeroValue;\n            }\n        }\n    }\n    return Arrays.hashCode(durations);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.get(DurationFieldType.years()).getDifference(end, start);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int size = startValues.length;\n    int[] resultValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (startValue != endValue) {\n            if (startValue < endValue) {\n                resultValues[i] = endValue - startValue;\n            } else {\n                resultValues[i] = startValue - endValue;\n            }\n        } else {\n            resultValues[i] = 0;\n        }\n    }\n    return new BaseSingleFieldPeriod(resultValues, zeroInstance).getPeriod();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int size = startValues.length;\n    int[] sum = new int[size];\n    for (int i = 0; i < size; i++) {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (startValue == endValue) {\n            sum[i] = 0;\n        } else if (startValue < endValue) {\n            sum[i] = endValue - startValue;\n        } else {\n            sum[i] = endValue + (zeroValue - startValue);\n        }\n    }\n    return DateTimeUtils.safeMultiply(sum, size);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] startValues = start.getValues();\n    int[] endValues = end.getValues();\n    int[] zeroValues = zeroInstance.getValues();\n    int[] durations = zeroInstance.getFieldTypes();\n    int[] durFields = new int[durations.length];\n    for (int i = 0; i < durations.length; i++) {\n        durFields[i] = durations[i].getDurationType().getField(start.getChronology()).getUnitMillis();\n    }\n    int[] durValues = new int[durations.length];\n    for (int i = 0; i < durations.length; i++) {\n        durValues[i] = (endValues[i] - startValues[i]) * durFields[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < durations.length; i++) {\n        amount += durValues[i];\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.get(DurationFieldType.years()).getDifference(end, start);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.get(chrono).getDifference(end, start);\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    Title subtitle = (Title) this.subtitles.get(index);\n    if (subtitle instanceof LegendTitle) {\n        return (LegendTitle) subtitle;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    //TODO: Implement this method\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    return getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    List subtitleList = getSubtitles();\n    if (subtitleList != null && index < subtitleList.size()) \n    {\n        Object obj = subtitleList.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            legend = (LegendTitle) obj;\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getSubtitleCount()) {\n        return null;\n    }\n    Title title = getSubtitle(index);\n    if (title instanceof LegendTitle) {\n        return (LegendTitle) title;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    List subtitles = getSubtitles();\n    if (subtitles != null && subtitles.size() > 0) \n    {\n        legend = (LegendTitle) subtitles.get(index);\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (this.subtitles != null && this.subtitles.size() > 0) \n    {\n        int i = 0;\n        for (Object subtitle : this.subtitles) \n        {\n            if (subtitle instanceof LegendTitle) \n            {\n                if (i == index) \n                {\n                    legend = (LegendTitle) subtitle;\n                    break;\n                }\n                i++;\n            }\n        }\n    }\n    return legend;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseOptionalParameterType(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTopLevelTypeExpression(token);\n  }\n\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTypeExpression(token);\n  }\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node paramType = null;\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) \n        {\n            paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n        } \n        else \n        {\n            paramType = parseTopLevelTypeExpression(token);\n        }\n\n        if (paramType != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n    } \n    else \n    {\n        paramType = parseTopLevelTypeExpression(token);\n    }\n\n    return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTopLevelTypeExpression(token);\n  }\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node paramTypeExpr = newNode(Token.PARAM_LIST);\n    Node typeExpr = null;\n    boolean isVarArgs = false;\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        isVarArgs = true;\n        token = next();\n      }\n      typeExpr = parseTopLevelTypeExpression(token);\n      if (typeExpr != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n    } else {\n      typeExpr = parseTypeExpression(token);\n    }\n\n    if (typeExpr != null) {\n      paramTypeExpr.addChildToBack(typeExpr);\n      if (isVarArgs) {\n        paramTypeExpr.addChildToBack(wrapNode(Token.ELLIPSIS, typeExpr));\n      }\n    }\n    return paramTypeExpr;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTypeExpression(token);\n  }\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTypeExpression(token);\n  }\n  return paramType;\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = length(str);\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = length(str);\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = length(str);\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = length(str);\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = length(str);\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n        child != null; child = child.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getSecondChild().children()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n        child != null; child = child.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node arg = call.getFirstChild().getNext();\n    while (arg != null) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n         child != null;\n         child = child.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node arg = call.getFirstChild().getNext();\n    while (arg != null) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n      arg = arg.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null;\n        arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean eol = false;\n    boolean eof = false;\n    while (!eol && !eof) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            eof = true;\n        } else if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            eol = true;\n        } else {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        // read until EOL, EOF or delimiter\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEscapeChar(ch)) {\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            }\n            if (isEscapeChar(ch)) {\n                token.content.append(delimiter);\n            } else if (isQuoteChar(ch)) {\n                token.content.append(quoteChar);\n            } else if (isDelimiter(ch)) {\n                token.content.append(delimiter);\n            } else {\n                token.content.append((char) ch);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean eol = false;\n    while (token.type == INVALID) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n        } else if (eol = readEndOfLine(ch)) {\n            token.type = EORECORD;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // add removed blanks when not ignoring whitespace chars...\n            if (!ignoreSurroundingSpaces && isWhitespace(ch)) {\n                token.content.append(' ');\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEscapeChar(ch)) {\n            ch = reader.read();\n            if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else {\n                token.content.append(escapeChar).append((char) ch);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean escaped = false;\n    boolean eol = false;\n    while (!eol) {\n        // get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n        if (isDelimiter(ch)) {\n            // delimiter reached, but is it escaped?\n            if (escaped) {\n                // no, it's not escaped, so the delimiter is part of the token\n                token.content.append((char) ch);\n            } else {\n                // yes, it's escaped, so the delimiter is outside of the token\n                token.type = TOKEN;\n                eol = readEndOfLine(ch);\n            }\n        } else if (isEndOfFile(ch)) {\n            // end of file reached\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            eol = true;\n        } else if (isEol(ch)) {\n            // end of line reached\n            token.type = EORECORD;\n            eol = true;\n        } else if (isEscapeChar(ch)) {\n            // escape char reached\n            escaped = true;\n        } else {\n            // normal character\n            token.content.append((char) ch);\n        }\n        if (!eol) {\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            while (!isDelimiter(ch) && !eol && !isEndOfFile(ch) && !isQuoteChar(ch)) {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n            token.type = TOKEN;\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (eol) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isEscapeChar(ch)) {\n            ch = reader.read();\n            if (isDelimiter(ch)) {\n                token.content.append(delimiter);\n            } else if (eol) {\n                token.content.append(firstEol);\n            } else if (isEndOfFile(ch)) {\n                token.content.append(reader.getLastChar());\n            } else {\n                token.content.append(ch);\n            }\n        } else {\n            token.content.append(ch);\n        }\n        ch = reader.read();\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    counts[last] = index;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        c[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    c[last] = index;\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int remainder = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = remainder / uniCounterOffset[i];\n        remainder = remainder % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int[] counter = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counter[i] = index / uniCounterOffset[i];\n        index -= counter[i] * uniCounterOffset[i];\n    }\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = counter[i] + counter[last];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        c[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    int count = index;\n    for (int i = last; i >= 0; i--) {\n        c[i] = count / uniCounterOffset[i];\n        count = count % uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    int count = index;\n    for (int i = 0; i < dimension; i++) {\n        c[i] = count / uniCounterOffset[i];\n        count %= uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int quotient = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = quotient / uniCounterOffset[i];\n        quotient %= uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) \n    {\n        return this;\n    } \n    else \n    {\n        return _nextSegment.last();\n    }\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (this == EMPTY) {\n        return this;\n    }\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer leaf = this;\n    while (leaf._nextSegment != null) \n    {\n        leaf = leaf._nextSegment;\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) \n    {\n        return this;\n    } \n    else \n    {\n        return _nextSegment.last();\n    }\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj == null) \n        {\n            return null;\n        }\n        if (obj instanceof Cloneable) \n        {\n            final Class<?> cls = obj.getClass();\n            try \n            {\n                final Method clone = cls.getMethod(\"clone\");\n                return cls.cast(clone.invoke(obj));\n            } \n            catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) \n            {\n                throw new CloneFailedException(ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            return cls.cast(cls.getMethod(\"clone\").invoke(obj));\n        } catch (Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) {\n        try {\n            clone = (T) obj.getClass().getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]);\n        } catch (final Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is T\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}\n\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            clone = (T) obj.getClass().getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]);\n        } \n        catch (Exception ex) \n        {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}\n\n    //-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            Class<?> cls = obj.getClass();\n            try {\n                return (T) cls.getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]);\n            } catch (Exception ex) {\n                throw new CloneFailedException(cls, ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            final Method cloneMethod = cls.getMethod(\"clone\");\n            clone = cls.cast(cloneMethod.invoke(obj));\n        } catch (final Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) \n        {\n            return null;\n        }\n        if (obj instanceof Cloneable) \n        {\n            final Class<?> cls = obj.getClass();\n            try \n            {\n                final Method cloneMethod = cls.getMethod(\"clone\");\n                if (cloneMethod != null) \n                {\n                    final Object clone = cloneMethod.invoke(obj);\n                    @SuppressWarnings(\"unchecked\") // OK because obj is checked to be of type Cloneable\n                    final T checkedClone = (T) clone;\n                    return checkedClone;\n                }\n            } \n            catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) \n            {\n                throw new CloneFailedException(ex, cls);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            return cls.cast(cls.getMethod(\"clone\").invoke(obj));\n        } catch (Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n        T clone = null;\n        if (obj instanceof Cloneable) \n        {\n            try \n            {\n                clone = (T) obj.getClass().getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]);\n            } \n            catch (Exception ex) \n            {\n                throw new CloneFailedException(ex);\n            }\n        }\n        return clone;\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Slot slot : type.getAllOwnSlots()) {\n    if (slot.name.equals(paramName)) {\n      return slot.value;\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getOwnPropertyNames()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (String param : type.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return sym.getScope().getQualifiedSlot(param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getProperties().values()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (String param : type.getParameters()) {\n    if (param.equals(paramName)) {\n      return getSymbolForName(type.getSource(), param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (String param : type.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return sym.getScope().getQualifiedSlot(param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  if (type.getParameters() == null) {\n    return null;\n  }\n  for (String param : type.getParameters()) {\n    if (param.equals(paramName)) {\n      return getSymbolForName(sym.getSource(), param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType objType : type.getExtendedInterfaces()) {\n    Symbol param = objType.getSlot(paramName);\n    if (param != null) {\n      return param;\n    }\n  }\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (matrix.getRowDimension() - 1.0));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / matrix.getRowDimension());\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // compute the covariance matrix\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        // divide by the number of observations\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n        // subtract the mean vector from the covariance matrix\n        RealMatrix meanVector = matrix.getColumnMean();\n        covarianceMatrix = covarianceMatrix.subtract(meanVector.multiply(meanVector.transpose()));\n        // bias-correct the covariance matrix\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((matrix.getRowDimension() - 1) / matrix.getRowDimension());\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        RealMatrix covarianceMatrix = new BlockRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double[] dataI = matrix.getRow(i);\n                double[] dataJ = matrix.getRow(j);\n                double covariance = computeCovariance(dataI, dataJ, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean());\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 - 1.0 / n));\n        }\n        return covarianceMatrix.multiply(covarianceMatrix.transpose());\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the input matrix is valid\n        checkSufficientData(matrix);\n\n        // Get the number of rows and columns of the input matrix\n        int rows = matrix.getRowDimension();\n        int cols = matrix.getColumnDimension();\n\n        // Create a new matrix to store the covariance values\n        RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(cols, cols);\n\n        // Compute the covariance values\n        for (int i = 0; i < cols; i++) {\n            for (int j = i; j < cols; j++) {\n                double covariance = computeCovariance(matrix, i, j, biasCorrected);\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n\n        // Return the covariance matrix\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        RealMatrix covarianceMatrix = new BlockRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int j = i; j < matrix.getColumnDimension(); j++) {\n                double[] columnI = matrix.getColumn(i);\n                double[] columnJ = matrix.getColumn(j);\n                double covariance = new Covariance(columnI, columnJ, biasCorrected).getResult();\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        final int nCols = matrix.getColumnDimension();\n        final int nRows = matrix.getRowDimension();\n        final RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double sum = 0;\n                for (int k = 0; k < nRows; k++) {\n                    sum += (matrix.getEntry(k, i) - matrix.getColumnMean(i)) * (matrix.getEntry(k, j) - matrix.getColumnMean(j));\n                }\n                covarianceMatrix.setEntry(i, j, sum / (nRows - (biasCorrected ? 1 : 0)));\n                covarianceMatrix.setEntry(j, i, sum / (nRows - (biasCorrected ? 1 : 0)));\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int nCols = matrix.getColumnDimension();\n        RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(nCols, nCols);\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                double[] columnI = matrix.getColumn(i);\n                double[] columnJ = matrix.getColumn(j);\n                double covariance = new Covariance(columnI, columnJ, biasCorrected).getCovariance();\n                covarianceMatrix.setEntry(i, j, covariance);\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        // Divide by the number of observations (n-1)\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1 / (matrix.getRowDimension() - 1));\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / matrix.getRowDimension());\n        }\n        return covarianceMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE + \" inclusive\");\n    }\n\n    long bits = bitsCached;\n    int bitsCachedSize = this.bitsCachedSize;\n\n    if (bitsCachedSize < count) {\n        final int bytesToRead = (count - bitsCachedSize) / 8;\n        final int bytesToReadMod = (count - bitsCachedSize) % 8;\n        final int bytesRead = in.read(cache, 0, bytesToRead);\n        if (bytesRead == -1) {\n            return -1;\n        }\n        for (int i = 0; i < bytesRead; i++) {\n            bits |= (cache[i] & 0xffl) << bitsCachedSize;\n            bitsCachedSize += 8;\n        }\n        if (bytesToReadMod > 0) {\n            final int b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            bits |= (b & 0xffl) << bitsCachedSize;\n            bitsCachedSize += bytesToReadMod;\n        }\n    }\n\n    bitsCached = bits >> count;\n    bitsCachedSize -= count;\n\n    return bits & MASKS[count];\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize < count) {\n        final int toRead = Math.min(8, count - bitsCachedSize);\n        final int read = in.read(new byte[toRead]);\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached |= (read & 0xFFl) << bitsCachedSize;\n        bitsCachedSize += read;\n    }\n\n    final long bits = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    final int bitsToRead = count - bitsCachedSize;\n    final long bitsOut = (bitsCached << bitsToRead) | (readBitsFromStream(bitsToRead) & MASKS[bitsToRead]);\n    bitsCachedSize = 0;\n    bitsCached = 0;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    // read bits from the cache\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n\n    // read bits from the underlying stream\n    final int toRead = count - bitsCachedSize;\n    final long bitsOut = readBitsFromStream(toRead);\n    if (bitsOut == -1) {\n        return -1;\n    }\n\n    // combine the bits read from the stream with the bits read from the cache\n    final long bitsOutCombined = (bitsCached << toRead) | bitsOut;\n    bitsCachedSize += toRead;\n    return bitsOutCombined;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    long bits = bitsCached;\n    int bitsCachedSize = this.bitsCachedSize;\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            if (bitsCachedSize == 0) {\n                return -1;\n            }\n            break;\n        }\n        bits = (bits << 8) | b;\n        bitsCachedSize += 8;\n    }\n    this.bitsCached = bits >> (bitsCachedSize - count);\n    this.bitsCachedSize = count;\n    return bits & MASKS[count];\n}",
      "public long readBits(final int count) throws IOException  {\n    // utils/BitInputStream.java\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n\n    long bitsOut = 0;\n    int bitsLeft = count;\n\n    // read from cache\n    if (bitsCachedSize >= bitsLeft) {\n        bitsOut = bitsCached & MASKS[bitsLeft];\n        bitsCached >>= bitsLeft;\n        bitsCachedSize -= bitsLeft;\n    } else {\n        bitsOut = bitsCached;\n        bitsLeft -= bitsCachedSize;\n        bitsCached = 0;\n        bitsCachedSize = 0;\n\n        // read from underlying stream\n        final int bytesToRead = (bitsLeft + 7) / 8;\n        final int bytesRead = in.read(cache, 0, bytesToRead);\n        if (bytesRead < 0) {\n            return -1;\n        }\n\n        // process bytes\n        int i = 0;\n        while (bitsLeft > 0 && i < bytesRead) {\n            bitsOut |= (cache[i++] & 0xffl) << (bitsLeft - 8);\n            bitsLeft -= 8;\n        }\n    }\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    // utils/BitInputStream.java\n    final long bitsOut;\n    int overflowBits = 0;\n    long overflow = 0l;\n\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 1 and 63\");\n    }\n    long bitsOut = 0;\n    int bitsLeft = count;\n    while (bitsLeft > 0) {\n        if (bitsCachedSize == 0) {\n            final int b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            bitsCached = b;\n            bitsCachedSize = 8;\n        }\n        final int bitsToRead = Math.min(bitsLeft, bitsCachedSize);\n        bitsOut <<= bitsToRead;\n        bitsOut |= (bitsCached & MASKS[bitsToRead]) >> (bitsCachedSize - bitsToRead);\n        bitsCachedSize -= bitsToRead;\n        bitsCached &= MASKS[bitsCachedSize];\n        bitsLeft -= bitsToRead;\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Number of bits to read must be between 1 and 63\");\n    }\n    long bitsOut;\n    if (bitsCachedSize < count) {\n        final int bytesToRead = (count - bitsCachedSize + 7) / 8;\n        final int readBytes = in.read(cache, cacheSize, bytesToRead);\n        if (readBytes == -1) {\n            return -1;\n        }\n        cacheSize += readBytes;\n        bitsCached = BitInputStream.fromLittleEndian(cache, 0, cacheSize, byteOrder);\n        bitsCachedSize = readBytes * 8;\n    }\n    bitsOut = bitsCached & BitInputStream.MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    long bitsOut = bitsCached & MASKS[bitsCachedSize];\n    bitsCached >>= bitsCachedSize;\n    bitsCachedSize -= count;\n    if (bitsCachedSize < 0) {\n        bitsCachedSize = 0;\n        int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (byteOrder == ByteOrder.BIG_ENDIAN) ? b : b << 8;\n        bitsCachedSize = 8;\n    }\n    bitsOut |= (bitsCached & MASKS[count]) << bitsCachedSize;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector<?> || this instanceof SparseFieldVector<?>) {\n        product = new OpenMapRealMatrix(m, n);\n    } else {\n        product = new Array2DRowRealMatrix(m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n        product = new OpenMapFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector<?>) {\n        product = new OpenMapFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n        product = new OpenMapFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product;\n        if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n            product = new OpenMapFieldMatrix<T>(field, m, n);\n        } else {\n            product = new Array2DRowFieldMatrix<T>(field, m, n);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product;\n        if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n            product = new OpenMapFieldMatrix<T>(field, m, n);\n        } else {\n            product = new Array2DRowFieldMatrix<T>(field, m, n);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector<?> || this instanceof SparseFieldVector<?>) {\n        product = new SparseFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n        product = new OpenMapRealMatrix(m, n);\n    } else {\n        product = new Array2DRowFieldMatrix(m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product;\n        if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n            product = new OpenMapFieldMatrix<T>(field, m, n);\n        } else {\n            product = new Array2DRowFieldMatrix<T>(field, m, n);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> product;\n        if (v instanceof SparseFieldVector || this instanceof SparseFieldVector) {\n            product = new OpenMapFieldMatrix<T>(field, m, n);\n        } else {\n            product = new Array2DRowFieldMatrix<T>(field, m, n);\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return product;\n    }"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null) {\n    return false;\n  }\n  return label.equals(labelNode.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode != null && labelNode.isLabel()) {\n    return labelNode.getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null) {\n    return false;\n  }\n  return label.equals(labelNode.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  if (labelNode == null) {\n    return false;\n  }\n  return labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    if (labelNode == null) {\n      return false;\n    }\n    return labelNode.getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return target.getFirstChild().getString().equals(label);\n  }\n  return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (series < this.urlSeries.size()) \n    {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        result = generator.generateURL(getDataset(), series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) \n    {\n        result = generator.generateURL(getDataset(), series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) \n    {\n        result = generator.generateURL(getDataset(), series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (this.urlSeries != null && this.urlSeries.size() > 0) {\n        List urls = (List) this.urlSeries.get(series);\n        if (urls != null && urls.size() > 0) {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) \n    {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    // Retrieve the URL generator for the specified series.\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        return null;\n    }\n    // Use the URL generator to generate the URL.\n    return generator.generateURL(getDataset(), series, item);\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf(':');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix2 = str.indexOf(':', ix+1);\n    if (ix2 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix3 = str.indexOf(':', ix2+1);\n    if (ix3 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix4 = str.indexOf(':', ix3+1);\n    if (ix4 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix5 = str.indexOf(':', ix4+1);\n    if (ix5 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix6 = str.indexOf(':', ix5+1);\n    if (ix6 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix7 = str.indexOf(':', ix6+1);\n    if (ix7 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix8 = str.indexOf(':', ix7+1);\n    if (ix8 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix9 = str.indexOf(':', ix8+1);\n    if (ix9 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix10 = str.indexOf(':', ix9+1);\n    if (ix10 < 0) {\n        throw new IllegalArgumentException(\"Missing colon in index\");\n    }\n    int ix11 = str.indexOf(':', ix10+1);\n    if (ix11 < 0) {\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1) {\n        throw new IllegalArgumentException(\"Expected string with at least 1 character, got \\\"\" + str + \"\\\"\");\n    }\n    int i = 0;\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        throw new IllegalArgumentException(\"Expected a digit between 0 and 9, got \\\"\" + ch + \"\\\"\");\n    }\n    i = (ch - '0');\n    if (len == 1) {\n        return i;\n    }\n    ch = str.charAt(1);\n    if (ch < '0' || ch > '9') {\n        throw new IllegalArgumentException(\"Expected a digit between 0 and 9, got \\\"\" + ch + \"\\\"\");\n    }\n    i = (i * 10) + (ch - '0');\n    if (len == 2) {\n        return i;\n    }\n    ch = str.charAt(2);\n    if (ch < '0' || ch > '9') {\n        throw new IllegalArgumentException(\"Expected a digit between 0 and 9, got \\\"\" + ch + \"\\\"\");\n    }\n    i = (i * 10) + (ch - '0');\n    return i;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        return -1;\n    }\n    int i1 = (str.charAt(0) - '0') << 16;\n    int i2 = (str.charAt(1) - '0') << 8;\n    int i3 = (str.charAt(2) - '0');\n    return i1 | i2 | i3;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1) {\n        return -1;\n    }\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    int index = ch - '0';\n    if (len == 1) {\n        return index;\n    }\n    ch = str.charAt(1);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    index = (index * 10) + (ch - '0');\n    if (len == 2) {\n        return index;\n    }\n    ch = str.charAt(2);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    index = (index * 10) + (ch - '0');\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    // First: let's verify it's a valid index value\n    int len = str.length();\n    if (len < 1 || len > 3) {\n        throw new IllegalArgumentException(\"Index value \\\"\"+str+\"\\\" has wrong length (should be 1, 2 or 3 digits)\");\n    }\n    int ix = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Index value \\\"\"+str+\"\\\" contains non-digit character '\"+c+\"'\");\n        }\n        ix = (ix * 10) + (c - '0');\n    }\n    return ix;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            index = (index * 10) + (c - '0');\n        } else {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    for (int i = 0; i < str.length(); i++) {\n        index = (index * 10) + (str.charAt(i) - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 3) {\n        return -1;\n    }\n    int index = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    // [Issue#148]: need to check for 0x00 masking\n    int q = str.charAt(0) | (str.charAt(1) << 16);\n    int bytes = 2;\n    if (q < 0x0800) {\n        bytes = 1;\n    } else if (q < 0x010000) {\n        bytes = 2;\n    } else if (q < 0x0200000) {\n        bytes = 3;\n    }\n    return pad(q, bytes);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = str.indexOf(':');\n    if (i < 1) {\n        throw new IllegalArgumentException(\"Index value '\"+str+\"' not valid: can only use colon (:) as separator\");\n    }\n    return Integer.parseInt(str.substring(0, i));\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(NodeUtil.newQName(compiler, methodName));\n      callNode.addChildToBack(argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(NodeUtil.newQName(compiler, methodName),\n                              argumentNode.detach());\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               new Node(Token.GETPROP,\n                                        new Node(Token.THIS),\n                                        Node.newString(compiler.getCodingConvention().getClassesJsName())),\n                               new Node(Token.NAME, methodName));\n      callNode.putBooleanProp(Node.FREE_CALL, true);\n      callNode.addChildToBack(argumentNode);\n      callNode.setSourceFileName(srcref.getSourceFileName());\n      callNode.setSourcePosition(srcref.getSourcePosition());\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodNode = NodeUtil.newQName(compiler, methodName);\n      Node callNode = new Node(Token.CALL, methodNode, argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(NodeUtil.newQName(compiler, methodName));\n      callNode.addChildToBack(argumentNode);\n      callNode.setSourceFileForNode(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               Node.newString(Token.NAME, methodName),\n                               argumentNode);\n      callNode.copyInformationFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               Node.newString(Token.NAME, methodName),\n                               argumentNode);\n      callNode.copyInformationFrom(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = IR.call(IR.getprop(IR.name(\"$jscomp\"),\n                                         IR.string(methodName)));\n      callNode.srcrefTreeIfMissing(srcref);\n      callNode.addChildToBack(argumentNode);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               NodeUtil.newQName(compiler, methodName),\n                               argumentNode.detach());\n      callNode.useSourceInfoIfMissingFromForTree(argumentNode);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node methodCall = IR.call(IR.getprop(IR.name(\"Object\"),\n                                           IR.string(methodName)),\n                                argumentNode);\n      methodCall.useSourceInfoIfMissingFromForTree(srcref);\n      return methodCall;\n    }"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        final DoubleIndex[] d = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            d[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(d);\n        for (int i = 0; i < d.length; i++) {\n            indices[i] = d[i].index;\n        }\n        return indices;\n    }",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            doubleIndices[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(doubleIndices);\n        for (int i = 0; i < doubleIndices.length; i++) {\n            indices[i] = doubleIndices[i].index;\n        }\n        return indices;\n    }",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            doubleIndices[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(doubleIndices);\n        for (int i = 0; i < doubleIndices.length; i++) {\n            indices[i] = doubleIndices[i].index;\n        }\n        return indices;\n    }",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    final DoubleIndex[] d = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        d[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(d);\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = d[i].index;\n    }\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n        if (cachedQT == null) {\n            cachedQT = MatrixUtils.createRealMatrix(householderVectors);\n        }\n        return cachedQT;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        cachedQT = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        final int m = householderVectors.length;\n        final double[][] q = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                q[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQT = MatrixUtils.createRealMatrix(q);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            final double[][] qt = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                if (i > 0) {\n                    // copy the entry of the lower sub-diagonal\n                    qt[i][i - 1] = householderVectors[i][i - 1];\n                }\n\n                // copy upper triangular part of the matrix\n                for (int j = i; j < m; ++j) {\n                    qt[i][j] = householderVectors[i][j];\n                }\n            }\n            cachedQt = MatrixUtils.createRealMatrix(qt);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) \n    {\n        cachedQT = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQT == null) {\n        cachedQT = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQT;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformedSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return TransformedSet.transformedSet(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity << 1];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: implement this method\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Check the hoursOffset is in range\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n\n    // Check the minutesOffset is in range\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n\n    // Check the minutesOffset is not negative when the hoursOffset is positive\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes negative when hours positive: \" + minutesOffset);\n    }\n\n    // Calculate the total offset in milliseconds\n    int totalOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n\n    // Check the total offset is in range\n    if (totalOffset < -23 * 60 * 60 * 1000 || totalOffset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Total offset out of range: \" + totalOffset);\n    }\n\n    // Return the DateTimeZone for the offset\n    return new FixedDateTimeZone(null, totalOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    //check for invalid arguments\n    if (hoursOffset < -23 || hoursOffset > 23)\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23\");\n    if (minutesOffset < -59 || minutesOffset > 59)\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59\");\n    if (hoursOffset > 0 && minutesOffset < 0)\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    //convert to milliseconds\n    int millis = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    //check for overflow\n    if (millis < -23 * 60 * 60 * 1000 || millis > 23 * 60 * 60 * 1000)\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    //return the appropriate DateTimeZone\n    return millis == 0 ? DateTimeZone.UTC : new FixedDateTimeZone(\"\", millis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be zero or positive when hour offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(\"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23 inclusive\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59 inclusive\");\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset <= 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    int totalMinutes = (hoursOffset * 60) + minutesOffset;\n    return forOffsetTotalMillis(totalMinutes * DateTimeConstants.MILLIS_PER_MINUTE);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Check for invalid values\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    // Calculate the total offset in milliseconds\n    int millis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    // Check for invalid total offset\n    if (millis < -23 * 60 * 60 * 1000 || millis > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Total offset out of range: \" + millis);\n    }\n    // Return the offset\n    return new FixedDateTimeZone(millis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    //check for hours offset\n    if (hoursOffset < -23 || hoursOffset > 23)\n    {\n        throw new IllegalArgumentException(\"Hours offset out of range\");\n    }\n\n    //check for minutes offset\n    if (minutesOffset < -59 || minutesOffset > 59)\n    {\n        throw new IllegalArgumentException(\"Minutes offset out of range\");\n    }\n\n    //check for minutes and hours combination\n    if (hoursOffset > 0 && minutesOffset < 0)\n    {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n\n    //check for resulting offset\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -23 * 60 || totalMinutes > 23 * 60)\n    {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n\n    //return DateTimeZone object\n    return new DateTimeZone(totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    //check if the hours and minutes are within the range\n    if (hoursOffset < -23 || hoursOffset > 23 || minutesOffset < -59 || minutesOffset > 59)\n    {\n        throw new IllegalArgumentException(\"The hours and minutes are out of range\");\n    }\n    //check if the minutes are negative when the hours are positive\n    if (hoursOffset > 0 && minutesOffset < 0)\n    {\n        throw new IllegalArgumentException(\"The minutes are negative when the hours are positive\");\n    }\n    //check if the resulting offset exceeds +/- 23:59:59.000\n    if (hoursOffset * 3600 + minutesOffset * 60 > 23 * 3600 + 59 * 60 || hoursOffset * 3600 + minutesOffset * 60 < -23 * 3600 - 59 * 60)\n    {\n        throw new IllegalArgumentException(\"The resulting offset exceeds +/- 23:59:59.000\");\n    }\n    //return the DateTimeZone object for the offset\n    return new DateTimeZone(hoursOffset * 3600 + minutesOffset * 60);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    //TODO: Implement this method\n    return null;\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // check if hoursOffset is in range\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    // check if minutesOffset is in range\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    // check if minutesOffset is negative when hoursOffset is positive\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive: \" + minutesOffset);\n    }\n    // calculate total offset in milliseconds\n    int totalOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    // check if total offset is within range\n    if (totalOffset < -23 * 60 * 60 * 1000 || totalOffset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset out of range: \" + totalOffset);\n    }\n    // return a DateTimeZone with the given offset\n    return new DateTimeZone(\"UTC\" + (hoursOffset >= 0 ? \"+\" : \"-\") + hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset, totalOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(\"OffsetHoursMinutes\", offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    //initialise variables\n    int depth = 0;\n    StringBuilder chomp = new StringBuilder();\n    char c;\n    \n    //loop through queue\n    while (!isEmpty()) \n    {\n        c = consume();\n        if (c == ESC) \n        {\n            chomp.append(c);\n            chomp.append(consume());\n        } \n        else if (c == open) \n        {\n            depth++;\n            chomp.append(c);\n        } \n        else if (c == close) \n        {\n            depth--;\n            chomp.append(c);\n            if (depth == 0) \n            {\n                break;\n            }\n        } \n        else \n        {\n            chomp.append(c);\n        }\n    }\n    return chomp.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (inQuote) \n        {\n            if (c == last)\n                inQuote = false;\n        }\n        else if (c == ESC) \n        {\n            accum.append(c);\n            if (!isEmpty())\n                accum.append(consume());\n        }\n        else if (c == open) \n        {\n            depth++;\n            accum.append(c);\n        }\n        else if (c == close) \n        {\n            if (depth == 0)\n                break;\n            accum.append(c);\n            depth--;\n        }\n        else \n        {\n            accum.append(c);\n        }\n        last = c;\n    }\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    boolean hitEscape = false;\n    \n    while (!isEmpty()) {\n        char c = consume();\n        if (inQuote) {\n            if (hitEscape) {\n                hitEscape = false;\n                accum.append(c);\n            } else if (c == ESC) {\n                hitEscape = true;\n            } else if (c == inQuote) {\n                inQuote = false;\n            } else {\n                accum.append(c);\n            }\n        } else {\n            if (c == open) {\n                depth++;\n                accum.append(c);\n            } else if (c == close) {\n                depth--;\n                if (depth < 0)\n                    throw new IllegalStateException(\"Unbalanced brackets\");\n                accum.append(c);\n            } else if (c == '\\'' || c == '\"') {\n                inQuote = true;\n                accum.append(c);\n            } else if (c == ESC) {\n                escaped = true;\n            } else {\n                accum.append(c);\n            }\n        }\n    }\n    \n    if (depth != 0)\n        throw new IllegalStateException(\"Unbalanced brackets\");\n    \n    return StringUtil.releaseBuilder(accum);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int depth = 0;\n    StringBuffer buffer = new StringBuffer();\n    while (!this.isEmpty()) \n    {\n        char c = this.consume();\n        if (c == open) \n        {\n            depth++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth <= 0) \n            {\n                break;\n            }\n        }\n        buffer.append(c);\n    }\n    return this.queue.substring(start, this.pos - 1);\n}",
      "public String chompBalanced(char open, char close)  {\n    // start:\n    int start = this.pos;\n    while (!isEmpty()) {\n        char c = this.queue.charAt(pos);\n        if (c == open) { // scan depth ++\n            pos++;\n            continue;\n        }\n        if (c == close) { // scan depth --\n            pos++;\n            return this.queue.substring(start, pos);\n        }\n        if (c == ESC) { // peek ahead for escape\n            pos++;\n            if (pos == this.queue.length()) {\n                throw new IllegalStateException(\"Chomp balanced: Unbalanced\");\n            }\n            pos++;\n        }\n        pos++;\n    }\n    throw new IllegalStateException(\"Chomp balanced: Unbalanced\");\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int end = this.pos;\n    int depth = 0;\n    while (end < this.queue.length())\n    {\n        char c = this.queue.charAt(end);\n        if (c == close)\n        {\n            depth--;\n            if (depth < 0)\n            {\n                break;\n            }\n        }\n        else if (c == open)\n        {\n            depth++;\n        }\n        end++;\n    }\n    if (end >= this.queue.length())\n    {\n        throw new IllegalStateException(\"Unbalanced brackets\");\n    }\n    this.pos = end + 1;\n    return this.queue.substring(start, end);\n}",
      "public String chompBalanced(char open, char close)  {\n    // start from current position\n    int start = pos;\n    // count openers and closers\n    int openCount = 0;\n    // check if queue is empty\n    if (isEmpty())\n        // throw exception if queue is empty\n        throw new IllegalStateException(\"Queue is empty\");\n    // loop until queue is empty\n    while (!isEmpty()) \n    {\n        // get next character\n        char c = consume();\n        // if character is the opener\n        if (c == open)\n            // increase counter\n            openCount++;\n        // if character is the closer\n        else if (c == close)\n            // decrease counter\n            openCount--;\n        // if counter is zero\n        if (openCount == 0)\n            // return substring from start to current position\n            return queue.substring(start, pos);\n    }\n    // throw exception if queue is empty\n    throw new IllegalStateException(\"Queue is empty\");\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int depth = 0;\n    String str = this.queue;\n    int len = str.length();\n    boolean lastBackslash = false;\n    for (; pos < len; pos++) {\n        char c = str.charAt(pos);\n        if (c == ESC) {\n            lastBackslash = !lastBackslash;\n        } else if (c == close) {\n            if (lastBackslash) {\n                lastBackslash = false;\n            } else {\n                depth--;\n                if (depth < 0) {\n                    return str.substring(start, pos);\n                }\n            }\n        } else if (c == open) {\n            if (lastBackslash) {\n                lastBackslash = false;\n            } else {\n                depth++;\n            }\n        } else {\n            lastBackslash = false;\n        }\n    }\n    return str.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder accum = StringUtil.borrowBuilder();\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean inEscape = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (inEscape) \n        {\n            accum.append(c);\n            inEscape = false;\n        } \n        else if (c == ESC) \n        {\n            inEscape = true;\n        } \n        else if (c == open) \n        {\n            depth++;\n            accum.append(c);\n        } \n        else if (c == close) \n        {\n            depth--;\n            accum.append(c);\n            if (depth <= 0)\n                break;\n        } \n        else if (c == '\"' || c == '\\'') \n        {\n            if (!inQuote || c != last)\n                accum.append(c);\n            inQuote = !inQuote;\n        } \n        else if (c != ' ' || !inQuote) \n        {\n            accum.append(c);\n        }\n        last = c;\n    }\n    return StringUtil.releaseBuilder(accum);\n}",
      "public String chompBalanced(char open, char close)  {\n    // TODO: implement\n    return null;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(getX());\n        // R matrix\n        RealMatrix R = qr.getR();\n        // R transpose\n        RealMatrix Rt = qr.getQ().transpose();\n        // RtR\n        RealMatrix RtR = Rt.multiply(R);\n        // RtR inverse\n        RealMatrix RtRinv = new LUDecomposition(RtR).getSolver().getInverse();\n        // Return variance-covariance matrix\n        return RtRinv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // QR decomposition of X^T X\n        final QRDecomposition qr = new QRDecomposition(getX().transpose().multiply(getX()));\n        // QR decomposition of X^T X\n        final RealMatrix r = qr.getR();\n        // Compute (R^T R)^-1\n        final RealMatrix rtR = r.transpose().multiply(r);\n        final RealMatrix rtRInv = new LUDecomposition(rtR).getSolver().getInverse();\n        // Compute (X^T X)^-1\n        final RealMatrix xTX = qr.getSolver().getInverse();\n        // Compute (X^T X)^-1 (R^T R)^-1\n        final RealMatrix xTXrtRInv = xTX.multiply(rtRInv);\n        // Return the top p rows of (X^T X)^-1 (R^T R)^-1\n        return xTXrtRInv.getSubMatrix(0, getBeta().getDimension() - 1, 0, getBeta().getDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final RealMatrix R = qr.getR();\n        final RealMatrix RT = R.transpose();\n        final RealMatrix RTR = RT.multiply(R);\n        final RealMatrix RTRInv = new LUDecomposition(RTR).getSolver().getInverse();\n        final RealMatrix XTXInv = RTRInv.multiply(RT).multiply(RTRInv);\n        return XTXInv.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = qr.getR().getColumnDimension();\n        final int n = qr.getR().getRowDimension();\n        RealMatrix R = qr.getR();\n        RealMatrix RT = R.transpose();\n        RealMatrix RTR = RT.multiply(R);\n        RealMatrix RTRInv = new LUDecomposition(RTR).getSolver().getInverse();\n        return RTRInv.getSubMatrix(0, p - 1, 0, n - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getBeta().getDimension();\n        final RealMatrix R = qr.getR();\n        final RealMatrix RT = R.transpose();\n        final RealMatrix RTR = RT.multiply(R);\n        final RealMatrix RTRInv = new LUDecomposition(RTR).getSolver().getInverse();\n        return RTRInv.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = xMatrix.transpose().multiply(xMatrix);\n        RealMatrix R = qr.getR();\n        RealMatrix RtR = R.transpose().multiply(R);\n        return RtR.getSubMatrix(0, p - 1, 0, p - 1).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the inverse of the upper triangular matrix R\n        RealMatrix R = qr.getR();\n        final int p = qr.getRank();\n        final int n = R.getColumnDimension();\n        RealMatrix RInv = new Array2DRowRealMatrix(n, n);\n        for (int i = 0; i < p; i++) {\n            RInv.setEntry(i, i, 1 / R.getEntry(i, i));\n        }\n\n        // Compute and return variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return RInv.multiply(RInv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the QR decomposition of X\n        final RealMatrix X = getX();\n        final QRDecomposition qr = new QRDecomposition(X);\n        final RealMatrix R = qr.getR();\n\n        // Get the inverse of R\n        final RealMatrix RInverse = qr.getSolver().getInverse();\n\n        // Compute and return Var(b)\n        // No DME advertised - args valid if we get here\n        return RInverse.multiply(RInverse.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = qr.getR().getColumnDimension();\n        RealMatrix R = qr.getR();\n        RealMatrix RT = R.transpose();\n        RealMatrix RTR = RT.multiply(R);\n        RealMatrix RTRInv = new LUDecomposition(RTR).getSolver().getInverse();\n        return RTRInv.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix QR = qr.getR();\n        final int p = getBeta().getDimension();\n        final int n = QR.getRowDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix R = new Array2DRowRealMatrix(n, p);\n        double[][] RData = R.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < p; j++) {\n                if (i < p) {\n                    RData[i][j] = QR.getEntry(i, j);\n                } else {\n                    RData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return R.transpose().multiply(R).inverse();\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    // This code is a copy of the code in DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n    // The code is duplicated here to avoid a dependency on DateTimeFormatter.\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Use the formatter to print the offset\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        buf.append('-');\n        offset = -offset;\n    } else {\n        buf.append('+');\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset - hours * 60 * 60 * 1000) / (60 * 1000);\n    int seconds = (offset - hours * 60 * 60 * 1000 - minutes * 60 * 1000) / 1000;\n    int millis = offset - hours * 60 * 60 * 1000 - minutes * 60 * 1000 - seconds * 1000;\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    buf.append(':');\n    if (seconds < 10) {\n        buf.append('0');\n    }\n    buf.append(seconds);\n    if (millis > 0) {\n        buf.append('.');\n        buf.append(millis);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    // Avoid StringBuffer for performance (do not replace with StringBuilder)\n    StringBuffer buf = new StringBuffer(6);\n    if (offset < 0) \n    {\n        buf.append('-');\n        offset = -offset;\n    } \n    else \n    {\n        buf.append('+');\n    }\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = offset % DateTimeConstants.MILLIS_PER_HOUR;\n    buf.append(hours < 10 ? \"0\" : \"\").append(hours);\n    buf.append(minutes < 10 ? \":0\" : \":\").append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) \n    {\n        buf.append('-');\n        offset = -offset;\n    } \n    else \n    {\n        buf.append('+');\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset - hours * (60 * 60 * 1000)) / (60 * 1000);\n    int seconds = (offset - hours * (60 * 60 * 1000) - minutes * (60 * 1000)) / 1000;\n    int millis = offset - hours * (60 * 60 * 1000) - minutes * (60 * 1000) - seconds * 1000;\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    buf.append(':');\n    if (seconds < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(seconds);\n    if (millis > 0) \n    {\n        buf.append('.');\n        if (millis < 100) \n        {\n            buf.append('0');\n        }\n        if (millis < 10) \n        {\n            buf.append('0');\n        }\n        buf.append(millis);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    // This method is kept separate from the formatting classes to speed and\n    // simplify startup and classloading.\n    return DateTimeZone.forOffsetHours(offset / DateTimeConstants.MILLIS_PER_HOUR).getName(offset);\n}",
      "private static String printOffset(int offset)  {\n    // 1. Convert offset to hours and minutes.\n    int hours = Math.abs(offset) / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (Math.abs(offset) - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    // 2. Build the offset string.\n    String offsetStr = (offset >= 0 ? \"+\" : \"-\") +\n        (hours < 10 ? \"0\" : \"\") + hours + \":\" +\n        (minutes < 10 ? \"0\" : \"\") + minutes;\n    return offsetStr;\n}",
      "private static String printOffset(int offset)  {\n    // If offset is zero, return \"Z\"\n    if (offset == 0) {\n        return \"Z\";\n    }\n    // Calculate the offset in hours and minutes\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset - hours * 60 * 60 * 1000) / (60 * 1000);\n    // Construct the offset string\n    String offsetStr = (offset < 0 ? \"-\" : \"+\") +\n                       (hours < 10 ? \"0\" : \"\") + hours +\n                       (minutes < 10 ? \":0\" : \":\") + minutes;\n    return offsetStr;\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int index = this.underlying.getIndex(key);\n        if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n            return index - this.firstCategoryIndex;\n        }\n        return -1;  // we didn't find the key\n    }",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n        // TODO: implement this method\n        return -1;\n    }",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n        // TODO: implement this method\n        return -1;\n    }",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = Maps.newHashMap();\n    for (LinkedFlowScope current = this;\n        current != null;\n        current = current.parent) {\n      allSlots.putAll(current.slots);\n    }\n    return allSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (StaticSlot<JSType> slot : symbols.values()) {\n      slots.put(slot.getName(), slot);\n    }\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allFlowSlots = Maps.newHashMap();\n    for (StaticSlot<JSType> slot : slots.values()) {\n      if (slot.getType() != null) {\n        allFlowSlots.put(slot.getName(), slot);\n      }\n    }\n    return allFlowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  for (StaticSlot<JSType> slot : this.slots.values()) {\n    if (slot.getType() != null) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  return symbols;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  return symbols;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    // Add all the slots in this scope.\n    for (StaticSlot<JSType> slot : this.slots.values()) {\n      slots.put(slot.getName(), slot);\n    }\n\n    // Add all the slots in the parent scope.\n    if (this.parent != null) {\n      slots.putAll(this.parent.allFlowSlots());\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : symbols.entrySet()) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n\n    if (linkedEquivalent != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : linkedEquivalent.allFlowSlots().entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = Maps.newHashMap();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (StaticSlot<JSType> slot : current.slots.values()) {\n        if (!allSlots.containsKey(slot.getName())) {\n          allSlots.put(slot.getName(), slot);\n        }\n      }\n      current = current.parent;\n    }\n    return allSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (StaticSlot<JSType> slot : linkedEquivalent.slots) {\n      slots.put(slot.getName(), slot);\n    }\n    for (String dirtySymbol : dirtySymbols) {\n      StaticSlot<JSType> slot = symbols.get(dirtySymbol);\n      if (slot != null) {\n        slots.put(dirtySymbol, slot);\n      }\n    }\n    return slots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a < 0.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"Illegal argument: \" + a);\n    }\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    if (a > 0.167) {\n        return FastMath.log(FastMath.sqrt(a * a - 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"Illegal argument: \" + a);\n    }\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == 0.0) {\n        return a;\n    }\n    if (a < 0.0) {\n        return -atanh(-a);\n    }\n    return Math.log((1.0 + a) / (1.0 - a)) / 2.0;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(1 / (a * a) + 1) + 1 / a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(a + FastMath.sqrt(a * a - 1));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < 0) {\n        return -atanh(-a);\n    } else if (a > 1) {\n        return Double.NaN;\n    } else if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    } else if (a == 0) {\n        return 0;\n    } else {\n        return 0.5 * log((1 + a) / (1 - a));\n    }\n}",
      "public static double atanh(double a)  {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n        double absAtanh;\n        if (a > 0.167) {\n            absAtanh = FastMath.log(a + FastMath.sqrt(1 - a * a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else if (a > 0.036) {\n                absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else if (a > 0.0036) {\n                absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n            } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(1 / (a * a) + 1) + 1 / a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    if (a > 0.167) {\n        return FastMath.log(FastMath.sqrt(a * a - 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(a + FastMath.sqrt(a * a - 1));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"abs(a) must be less than 1.0\");\n    }\n    if (a == 0.0) {\n        return a;\n    }\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(1 / (a * a) + 1) + 1 / a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.0036) {\n}\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NORMALIZE_ARRAY_NAN_INFINITE_SUM,\n                    normalizedSum);\n        }\n\n        double[] normalizedValues = new double[values.length];\n        double sum = StatUtils.sum(values);\n        if (sum == 0.0) {\n            throw new MathArithmeticException(\n                    LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n        }\n\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i];\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Sum.of(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_VALUES,\n                                          sum);\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_ZERO_VALUES,\n                                          sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        result[i] = values[i] * normalizedSum / sum;\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double[] normalizedValues = new double[values.length];\n        double sum = Sum.of(values);\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_IS_ZERO);\n        }\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_INFINITE);\n        }\n        if (Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_NAN);\n        }\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i];\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Sum.of(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                normalizedSum);\n    }\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_OR_NAN);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_VALUES_IS_ZERO);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = values[i];\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double[] result = new double[values.length];\n    double sum = Sum.of(values);\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZE_INVALID_TARGET_SUM,\n                normalizedSum);\n    }\n\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(\n                LocalizedFormats.NORMALIZE_INVALID_ARRAY,\n                sum);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(\n                LocalizedFormats.NORMALIZE_DIVIDE_BY_ZERO);\n    }\n\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INF_OR_NAN,\n                                               normalizedSum);\n    }\n    double sum = Sum.of(values);\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_INF_OR_ZERO,\n                                          sum);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = values[i];\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double[] normalizedValues = new double[values.length];\n    double sum = StatUtils.sum(values);\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            LocalizedFormats.NAN_VALUE_FOR_NORMALIZED_SUM, normalizedSum);\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    }\n\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i];\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double[] result = new double[values.length];\n        double sum = StatUtils.sum(values);\n        if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INF_OR_NAN);\n        }\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_SUM);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_AROUND_ZERO);\n        }\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double[] result = new double[values.length];\n    double sum = StatUtils.sum(values);\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_NORMALIZED_SUM);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    }\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double[] normalizedValues = new double[values.length];\n        double sum = Sum.of(values);\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_NAN_OR_INFINITE_SUM,\n                                                   normalizedSum);\n        }\n        if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_NAN_OR_INFINITE_SUM,\n                                              sum);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM,\n                                              sum);\n        }\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i];\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY.getColumnVector(0));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY.getColumnVector(0));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY.getColumnVector(0));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).operate(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) {\n        return this;\n    }\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) {\n        return this;\n    }\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(id()))\n        return this;\n    Elements els = getElementsById(id);\n    return els.size() > 0 ? els.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    if (id.equals(this.id()))\n        return this;\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(id()))\n        return this;\n    else\n        return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id()))\n    {\n        return this;\n    }\n    else\n    {\n        Elements elements = this.getElementsByTag(\"*\");\n        for (Element element : elements)\n        {\n            if (id.equals(element.id()))\n            {\n                return element;\n            }\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    if (id.equals(this.id()))\n        return this;\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    Elements els = Collector.collect(new Evaluator.Id(id), this);\n    return els.size() > 0 ? els.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder stripCustom = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    seekNonWs(pattern, pos);\n    for (int i = 0; i < customPatterns.size(); i++) {\n        final String description = customPatterns.get(i);\n        final String format = parseFormatDescription(description, new ParsePosition(0));\n        stripCustom.append(pattern.substring(pos.getIndex(), pos.getIndex() + description.length()));\n        stripCustom.append(format);\n        pos.setIndex(pos.getIndex() + description.length());\n        seekNonWs(pattern, pos);\n    }\n    stripCustom.append(pattern.substring(pos.getIndex()));\n    return stripCustom.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int pos = 0;\n    int index = 0;\n    while (pos < length) {\n        int next = pattern.indexOf(START_FE, pos);\n        if (next < 0) {\n            next = length;\n        }\n        result.append(pattern.substring(pos, next));\n        pos = next;\n        if (pos < length) {\n            next = pattern.indexOf(END_FE, pos);\n            if (next < 0) {\n                throw new IllegalArgumentException(\n                        \"Unterminated format element at position \" + pos);\n            }\n            result.append(START_FE);\n            result.append(customPatterns.get(index++));\n            result.append(END_FE);\n            pos = next + 1;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder stripCustom = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    for (int i = 0; i < customPatterns.size(); i++) {\n        stripCustom.append(pattern.substring(pos.getIndex(), pos.getIndex() + customPatterns.get(i).length()));\n        pos.setIndex(pos.getIndex() + customPatterns.get(i).length());\n    }\n    stripCustom.append(pattern.substring(pos.getIndex()));\n    return stripCustom.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (final String customPattern : customPatterns) {\n        result.append(pattern.substring(pos, customPattern.indexOf(START_FE)));\n        result.append(START_FE);\n        result.append(customPattern);\n        result.append(END_FE);\n        pos = customPattern.indexOf(END_FE) + 1;\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder stripCustom = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    seekNonWs(pattern, pos);\n    for (int i = 0; i < customPatterns.size(); i++) {\n        stripCustom.append(pattern.substring(pos.getIndex(), customPatterns.get(i).charAt(0)));\n        stripCustom.append(START_FE);\n        stripCustom.append(customPatterns.get(i));\n        stripCustom.append(END_FE);\n        pos.setIndex(customPatterns.get(i).charAt(0) + customPatterns.get(i).length());\n        seekNonWs(pattern, pos);\n    }\n    stripCustom.append(pattern.substring(pos.getIndex()));\n    return stripCustom.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (final String customPattern : customPatterns) \n    {\n        final int start = pattern.indexOf(customPattern, pos);\n        if (start == -1) \n        {\n            break;\n        }\n        result.append(pattern, pos, start);\n        result.append(customPattern);\n        pos = start + customPattern.length();\n    }\n    result.append(pattern, pos, pattern.length());\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder sb = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (int i = 0; i < customPatterns.size(); i++) \n    {\n        sb.append(pattern.substring(pos, customPatterns.get(i).getIndex()));\n        sb.append(START_FE);\n        sb.append(customPatterns.get(i).getValue());\n        sb.append(END_FE);\n        pos = customPatterns.get(i).getIndex() + customPatterns.get(i).getValue().length();\n    }\n    sb.append(pattern.substring(pos));\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (String customPattern : customPatterns) {\n        int start = pattern.indexOf(customPattern, pos);\n        if (start == -1) {\n            break;\n        }\n        result.append(pattern.substring(pos, start));\n        result.append(customPattern);\n        pos = start + customPattern.length();\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int last = 0;\n    int pos = pattern.indexOf(START_FE);\n    if (pos == -1) {\n        return pattern;\n    }\n    while (pos != -1) {\n        result.append(pattern.substring(last, pos));\n        final int end = pattern.indexOf(END_FE, pos);\n        if (end == -1) {\n            throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n        }\n        final String description = pattern.substring(pos + 1, end);\n        final int custom = customPatterns.indexOf(description);\n        if (custom != -1) {\n            result.append(START_FE).append(custom).append(END_FE);\n        } else {\n            result.append(START_FE).append(description).append(END_FE);\n        }\n        last = end + 1;\n        pos = pattern.indexOf(START_FE, last);\n    }\n    result.append(pattern.substring(last));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder sb = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (String customPattern : customPatterns) \n    {\n        int index = pattern.indexOf(customPattern, pos);\n        if (index < 0) \n        {\n            break;\n        }\n        sb.append(pattern, pos, index);\n        sb.append('{').append(customPattern).append('}');\n        pos = index + customPattern.length();\n    }\n    sb.append(pattern, pos, pattern.length());\n    return sb.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(v.getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(v.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(v.getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(v.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // Check that to and from are parameterized types\n  if (to == null || from == null) {\n    return false;\n  }\n\n  // Check that the raw types are equal\n  if (!to.getRawType().equals(from.getRawType())) {\n    return false;\n  }\n\n  // Check that the owner types are equal\n  if (!$Gson$Types.equals(to.getOwnerType(), from.getOwnerType())) {\n    return false;\n  }\n\n  // Check that the type arguments are equal\n  Type[] toArgs = to.getActualTypeArguments();\n  Type[] fromArgs = from.getActualTypeArguments();\n  if (toArgs.length != fromArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < toArgs.length; i++) {\n    Type toArg = toArgs[i];\n    Type fromArg = fromArgs[i];\n\n    // Check if the type arguments are the same\n    if (!$Gson$Types.equals(toArg, fromArg)) {\n      return false;\n    }\n\n    // Check if the type arguments are equivalent under a variable mapping\n    if (toArg instanceof TypeVariable<?>) {\n      TypeVariable<?> toVar = (TypeVariable<?>) toArg;\n      TypeVariable<?> fromVar = (TypeVariable<?>) fromArg;\n      if (!toVar.getName().equals(fromVar.getName())) {\n        return false;\n      }\n      Type toVarType = typeVarMap.get(toVar.getName());\n      Type fromVarType = typeVarMap.get(fromVar.getName());\n      if (!$Gson$Types.equals(toVarType, fromVarType)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (from.equals(to)) {\n      return true;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    while (toArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) toArg;\n      toArg = typeVarMap.get(v.getName());\n    }\n    if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    if (!matches(fromArg, toArg, typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // First check if the raw types are equal\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Next check if the owner types are equal\n    if (from.getOwnerType() != null) {\n      if (!to.getOwnerType().equals(from.getOwnerType())) {\n        return false;\n      }\n    } else if (to.getOwnerType() != null) {\n      return false;\n    }\n\n    // Next check if the type arguments are equal\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      // Check if the type arguments are equivalent under our current mapping\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n\n    while (fromArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) fromArg;\n      fromArg = typeVarMap.get(v.getName());\n    }\n\n    while (toArg instanceof TypeVariable<?>) {\n      TypeVariable<?> v = (TypeVariable<?>) toArg;\n      toArg = typeVarMap.get(v.getName());\n    }\n\n    if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n\n  return true;\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter);\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  N colorNode = colorToNodeMap[color.value];\n  if (colorNode == null) {\n    colorToNodeMap[color.value] = node;\n    return node;\n  } else {\n    return colorNode;\n  }\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  N colorNode = colorToNodeMap[color.value];\n  if (colorNode == null) {\n    colorToNodeMap[color.value] = node;\n    return node;\n  } else {\n    return colorNode;\n  }\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getDirectedGraphNode(node).getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = superNode;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = superNode;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = node;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getDirectedGraphNode(node).getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = superNode;\n  }\n  return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(i);\n            }\n        }\n        return nanPositions;\n    }"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += f.value(points[i]) * weights[i];\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += f.value(points[i]) * weights[i];\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += f.value(points[i]) * weights[i];\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keySet = map1.keySet();\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size())\n    {\n        result = false;\n    }\n    else\n    {\n        Set keySet = map1.keySet();\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext())\n        {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2))\n            {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Object key : keys) {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) \n    {\n        return true;\n    }\n    else if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    else \n    {\n        Set keys1 = map1.keySet();\n        Set keys2 = map2.keySet();\n        if (!keys1.equals(keys2)) \n        {\n            return false;\n        }\n        Iterator iterator = keys1.iterator();\n        while (iterator.hasNext()) \n        {\n            Comparable key = (Comparable) iterator.next();\n            Paint paint1 = (Paint) map1.get(key);\n            Paint paint2 = (Paint) map2.get(key);\n            if (!paint1.equals(paint2)) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size())\n    {\n        result = false;\n    }\n    else\n    {\n        for (Object key : map1.keySet())\n        {\n            if (!map2.containsKey(key))\n            {\n                result = false;\n                break;\n            }\n            if (!map1.get(key).equals(map2.get(key)))\n            {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size())\n        return false;\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext())\n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key))\n            return false;\n        if (!map1.get(key).equals(map2.get(key)))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    for (Object key : map1.keySet()) {\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) \n    {\n        result = false;\n    }\n    else \n    {\n        for (Object key : map1.keySet()) \n        {\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) \n            {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String key = expr.getString();\n      if (key.length() > 0) {\n        String replacement = getReplacement(key);\n        if (replacement != null) {\n          Node replacementNode = IR.string(replacement);\n          replacementNode.copyInformationFrom(expr);\n          parent.replaceChild(expr, replacementNode);\n          expr = replacementNode;\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    if (key.length() > 10) {\n      String replacement = nameGenerator.generateNextName();\n      result = new Result(key, replacement);\n      results.put(key, result);\n      return IR.string(replacement);\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    Preconditions.checkState(\n        expr.isString() || expr.isAdd());\n\n    if (expr.isString()) {\n      String key = expr.getString();\n      String replacement = nameGenerator.generateNextName();\n      Result result = new Result(key, replacement);\n      results.put(key, result);\n\n      Node replacementNode = IR.name(replacement);\n      replacementNode.srcrefTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    } else {\n      // Add\n      Preconditions.checkState(expr.getChildCount() == 2);\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      Preconditions.checkState(left.isString() || left.isAdd());\n      Preconditions.checkState(right.isString());\n\n      String key = left.getString();\n      String replacement = nameGenerator.generateNextName();\n      Result result = new Result(key, replacement);\n      results.put(key, result);\n\n      Node replacementNode = IR.add(\n          IR.name(replacement),\n          right.cloneTree());\n      replacementNode.srcrefTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    Preconditions.checkArgument(expr.isString());\n    Preconditions.checkArgument(parent.isExprResult() || parent.isCall());\n\n    // TODO(johnlenz): support other types of expressions.\n    if (!expr.isString()) {\n      return expr;\n    }\n\n    // TODO(johnlenz): support other types of expressions.\n    if (parent.isCall()) {\n      Node grandparent = parent.getParent();\n      if (grandparent.isExprResult()) {\n        Node greatGrandparent = grandparent.getParent();\n        if (greatGrandparent.isScript() || greatGrandparent.isBlock()) {\n          return expr;\n        }\n      }\n    }\n\n    // TODO(johnlenz): support other types of expressions.\n    if (parent.isExprResult()) {\n      Node grandparent = parent.getParent();\n      if (grandparent.isScript() || grandparent.isBlock()) {\n        return expr;\n      }\n    }\n\n    String key = expr.getString();\n    if (key.length() > MAX_LENGTH) {\n      return expr;\n    }\n\n    String replacement = nameGenerator.generateNextName();\n    Result result = new Result(key, replacement);\n    results.put(key, result);\n\n    Node replacementNode = IR.name(replacement);\n    replacementNode.copyInformationFrom(expr);\n\n    if (parent.isCall()) {\n      Node grandparent = parent.getParent();\n      grandparent.replaceChild(parent, replacementNode);\n      t.reportCodeChange();\n    } else {\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n    }\n\n    return replacementNode;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    if (results.containsKey(key)) {\n      Result result = results.get(key);\n      Node replacement = IR.string(result.replacement);\n      replacement.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacement);\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): Replace with a more efficient algorithm.\n    String key = expr.toString();\n    if (results.containsKey(key)) {\n      Node replacement = IR.string(results.get(key).replacement);\n      replacement.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacement);\n      return replacement;\n    } else {\n      return expr;\n    }\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String key = expr.getString();\n      if (results.containsKey(key)) {\n        Result result = results.get(key);\n        Node replacement = IR.string(result.replacement);\n        replacement.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    if (key.length() > 1) {\n      String replacement = nameGenerator.generateNextName();\n      Result result = new Result(key, replacement);\n      results.put(key, result);\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFrom(expr);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    if (key.length() > 0) {\n      String replacement = nameGenerator.generateNextName();\n      Result result = new Result(key, replacement);\n      results.put(key, result);\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction()) {\n      JSDocInfo docInfo = node.getJSDocInfo();\n      if (docInfo != null) {\n        if (docInfo.isNoSideEffects()) {\n          builder.setIsPure(true);\n        }\n        if (docInfo.getModifies().contains(\"this\")) {\n          builder.setModifiesThis(true);\n        }\n        if (docInfo.getModifies().size() > 1) {\n          builder.setModifiesArguments(true);\n        }\n        if (docInfo.getDescription() != null) {\n          builder.setDesc(docInfo.getDescription());\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  String desc = info.getDescription();\n  if (desc == null) {\n    return false;\n  }\n  if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n    builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n    builder.setIsHidden(true);\n  } else {\n    builder.setDesc(desc);\n  }\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.isFunction()) {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      if (docInfo.isDeprecated()) {\n        builder.setIsDeprecated(true);\n      }\n      if (docInfo.isHidden()) {\n        builder.setIsHidden(true);\n      }\n      if (docInfo.isTranslationConstant()) {\n        builder.setIsTranslationConstant(true);\n      }\n      if (docInfo.getDescription() != null) {\n        builder.setDesc(docInfo.getDescription());\n        return true;\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null && docInfo.isDefine()) {\n      String desc = docInfo.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.getJSDocInfo() != null) {\n    String desc = node.getJSDocInfo().getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null && docInfo.getDescription() != null) {\n      builder.setDesc(docInfo.getDescription());\n      return true;\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.isFunction()) {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      if (docInfo.hasDescription()) {\n        builder.setDesc(docInfo.getDescription());\n        return true;\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      if (docInfo.hasDescription()) {\n        builder.setDesc(docInfo.getDescription());\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumOfProducts = 0;\n        double sumOfX = 0;\n        double sumOfY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sumOfProducts += xArray[i] * yArray[i];\n            sumOfX += xArray[i];\n            sumOfY += yArray[i];\n        }\n        double covariance = (sumOfProducts - (sumOfX * sumOfY / xArray.length)) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n    return biasCorrected ? sum / (xArray.length - 1) : sum / xArray.length;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n    return sum / (xArray.length - 1);\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.DIMENSIONS_MISMATCH,\n                    xArray.length, yArray.length);\n        } else if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    xArray.length, 2);\n        }\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n        }\n        return biasCorrected ? sum / (xArray.length - 1) : sum / xArray.length;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.ARRAY_LENGTHS_DIFFER,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += xArray[i] * yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double n = xArray.length;\n    double cov = (sum - sumX * sumY / n) / (n - 1);\n    if (biasCorrected) {\n        cov *= n / (n - 1);\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double covariance = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            covariance += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n        }\n        if (biasCorrected) {\n            covariance /= (xArray.length - 1);\n        } else {\n            covariance /= xArray.length;\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    // check if arrays have the same length\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    // check if arrays have at least two elements\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    // compute mean\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    // compute sum of squares\n    double sumOfSquares = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumOfSquares += (xArray[i] - xMean) * (xArray[i] - xMean);\n    }\n    // compute covariance\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    // return covariance\n    if (biasCorrected) {\n        return covariance / (xArray.length - 1);\n    } else {\n        return covariance / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                    xArray.length, yArray.length);\n        } else if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    xArray.length, 2);\n        }\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumYY = 0;\n        double sumXY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum++;\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double meanX = sumX / sum;\n        double meanY = sumY / sum;\n        double covariance = (sumXY - sum * meanX * meanY) / (sum - 1);\n        if (biasCorrected) {\n            covariance = covariance * sum / (sum - 1);\n        }\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.ARRAYS_DIFFERENT_LENGTH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sumOfDiffs = 0;\n    double sumOfX = 0;\n    double sumOfY = 0;\n    double sumOfXSquared = 0;\n    double sumOfYSquared = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        sumOfDiffs += (x - sumOfX) * (y - sumOfY);\n        sumOfX += x;\n        sumOfY += y;\n        sumOfXSquared += x * x;\n        sumOfYSquared += y * y;\n    }\n    double covariance = sumOfDiffs / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance *= (xArray.length * (xArray.length - 1)) / (xArray.length - 2);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.ARRAYS_DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n    } else {\n        throw new IllegalArgumentException();\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = readOneByte();\n        if (x == -1) {\n            return;\n        }\n        skipped += 1;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = readOneByte();\n        if (x == -1) {\n            return;\n        }\n        skipped += 1;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                return;\n            }\n            skipped += 1;\n        }\n    } else {\n        throw new IllegalArgumentException();\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return String.valueOf(FP.fingerprint(sb.toString()));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return String.valueOf(FP.fingerprint(sb.toString()));\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          sb.append(CaseFormat.LOWER_CAMEL.to(\n              CaseFormat.UPPER_UNDERSCORE,\n              ((PlaceholderReference) part).getName()));\n        } else {\n          sb.append(part);\n        }\n      }\n      return String.valueOf(FP.fingerprint(sb.toString()));\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          sb.append(CaseFormat.LOWER_CAMEL.to(\n              CaseFormat.UPPER_UNDERSCORE,\n              ((PlaceholderReference) part).getName()));\n        } else {\n          sb.append(part);\n        }\n      }\n      String tcValue = sb.toString();\n      return String.valueOf(FP.fingerprint(tcValue));\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(FP.fingerprint(tcValue));\n  }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          sb.append(CaseFormat.LOWER_CAMEL.to(\n              CaseFormat.UPPER_UNDERSCORE,\n              ((PlaceholderReference) part).getName()));\n        } else {\n          sb.append(part);\n        }\n      }\n      return String.valueOf(FP.fingerprint(sb.toString()));\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fp = fingerprint(tcValue);\n    return Long.toString(fp, Character.MAX_RADIX).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long endOfArchive = archive.size();\n        final long startOfArchive = endOfArchive - maxDistanceFromEnd;\n        long currentPosition = endOfArchive - minDistanceFromEnd;\n        if (currentPosition < startOfArchive) {\n            currentPosition = startOfArchive;\n        }\n        archive.position(currentPosition);\n        byte[] buf = new byte[sig.length];\n        while (currentPosition >= startOfArchive) {\n            archive.read(buf);\n            if (Arrays.equals(buf, sig)) {\n                return true;\n            }\n            currentPosition--;\n            archive.position(currentPosition);\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    long pos = archive.size() - distance;\n    if (pos < 0) {\n        return false;\n    }\n    while (pos >= 0) {\n        archive.position(pos);\n        byte[] buf = new byte[WORD];\n        IOUtils.readFully(archive, buf);\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long currentPosition = archive.position();\n        long newPosition = currentPosition - minDistanceFromEnd;\n        if (newPosition < 0) {\n            newPosition = 0;\n        }\n        archive.position(newPosition);\n        final byte[] b = new byte[sig.length];\n        IOUtils.readFully(archive, b);\n        if (Arrays.equals(sig, b)) {\n            return true;\n        }\n        newPosition = currentPosition - maxDistanceFromEnd;\n        if (newPosition < 0) {\n            newPosition = 0;\n        }\n        archive.position(newPosition);\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    byte[] buffer = new byte[WORD];\n    while (archive.position() < maxDistanceFromEnd) {\n        archive.read(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long currentPosition = archive.position();\n        long newPosition = currentPosition - minDistanceFromEnd;\n        if (newPosition < 0) {\n            newPosition = 0;\n        }\n        archive.position(newPosition);\n        while (archive.position() < maxDistanceFromEnd) {\n            wordBbuf.rewind();\n            IOUtils.readFully(archive, wordBbuf);\n            if (Arrays.equals(sig, wordBuf)) {\n                return true;\n            }\n            archive.position(archive.position() + 1);\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long currentPosition = archive.position();\n        long newPosition = currentPosition - minDistanceFromEnd;\n        if (newPosition < 0) {\n            newPosition = 0;\n        }\n        archive.position(newPosition);\n        byte[] buffer = new byte[WORD];\n        int bytesRead = 0;\n        while (archive.position() < maxDistanceFromEnd) {\n            IOUtils.readFully(archive, buffer);\n            bytesRead = bytesRead + buffer.length;\n            if (Arrays.equals(buffer, sig)) {\n                archive.position(archive.position() - bytesRead);\n                return true;\n            }\n        }\n        archive.position(currentPosition);\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long minDistance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    final long maxDistance = Math.max(minDistanceFromEnd, maxDistanceFromEnd);\n    final long end = archive.size();\n    final long start = end - maxDistance;\n    if (start < 0) {\n        return false;\n    }\n    archive.position(start);\n    final byte[] buf = new byte[WORD];\n    long currentPosition = archive.position();\n    while (currentPosition < end) {\n        IOUtils.readFully(archive, buf);\n        if (Arrays.equals(buf, sig)) {\n            archive.position(currentPosition);\n            return true;\n        }\n        currentPosition++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    while (archive.position() < maxDistanceFromEnd) {\n        archive.readFully(sigBuf, 0, sig.length);\n        if (Arrays.equals(sig, sigBuf)) {\n            return true;\n        }\n        archive.position(archive.position() + 1);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long currentPosition = archive.position();\n        long newPosition = currentPosition - minDistanceFromEnd;\n        if (newPosition < 0) {\n            newPosition = 0;\n        }\n        if (newPosition > archive.size() - maxDistanceFromEnd) {\n            newPosition = archive.size() - maxDistanceFromEnd;\n        }\n        archive.position(newPosition);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxDistance = Math.min(maxDistanceFromEnd, archive.size());\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    final int sigLen = sig.length;\n    byte[] buf = new byte[sigLen];\n    int readBytes = 0;\n    while (newPosition < maxDistance) {\n        readBytes = archive.read(buf);\n        if (readBytes < sigLen) {\n            break;\n        }\n        for (int i = 0; i < sigLen; i++) {\n            if (buf[i] != sig[i]) {\n                break;\n            }\n            if (i == sigLen - 1) {\n                archive.position(newPosition);\n                return true;\n            }\n        }\n        newPosition++;\n        archive.position(newPosition);\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < getSeriesCount()) \n    {\n        result = getSeriesKey(section);\n    }\n    else \n    {\n        result = \"Section \" + section;\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section >= 0 && section < this.values.getColumnCount()) {\n        result = this.values.getColumnKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < getSeriesCount()) {\n        result = getSeriesKey(section);\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.values.getColumnCount()) {\n        key = this.values.getColumnKey(section);\n    }\n    else {\n        key = createSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getSeriesCount()) \n    {\n        key = this.dataset.getSeriesKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < this.dataset.getSeriesCount()) \n    {\n        result = this.dataset.getSeriesKey(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSeriesCount()) \n    {\n        key = getSeriesKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // check if there is a key defined for this section...\n    if (section < this.sectionKeys.size()) {\n        result = this.sectionKeys.get(section);\n    }\n    // if there is no key defined, generate one...\n    if (result == null) {\n        result = Integer.valueOf(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    // if the section is valid, we return the key for the section\n    if (section >= 0 && section < this.dataset.getSeriesCount()) \n    {\n        result = this.dataset.getSeriesKey(section);\n    }\n    // if the section is invalid, we generate a key\n    else \n    {\n        result = \"Section \" + section;\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (section < getSeriesCount()) {\n        result = getSeriesKey(section);\n    }\n    return result;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonStreamContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            if (ctxt instanceof TokenBufferReadContext) {\n                try {\n                    return ((TokenBufferReadContext) ctxt).isNaN();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonStreamContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            if (ctxt instanceof TokenBufferReadContext) {\n                try {\n                    return ((TokenBufferReadContext) ctxt).isNaN();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT ||\n                _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n                if (ob instanceof BigDecimal) {\n                    return ((BigDecimal) ob).compareTo(BD_NAN) == 0;\n                }\n                if (ob instanceof BigInteger) {\n                    return false;\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT && _numberType == NumberType.BIG_DECIMAL)\n                    && ((BigDecimal) _numberValue).equals(BigDecimal.valueOf(Double.NaN));\n        }",
      "@Override\n        public boolean isNaN()  {\n            // for non-number types, can only return false\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT && _currToken != JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            // and then need to check value itself\n            Number n = _currentNumber();\n            return (n == null) ? false : n.isNaN();\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_NAME) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastName) {\n      lastName = symbolName;\n      Integer index = nameMap.get(symbolName);\n      if (index != null) {\n        lastNameIndex = index;\n      } else {\n        lastNameIndex = nameMap.size();\n        nameMap.put(symbolName, lastNameIndex);\n      }\n    }\n    return lastNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n  Integer index = originalNameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  } else {\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = originalNameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = originalNameMap.size();\n  originalNameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = originalNameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = originalNameMap.size();\n  originalNameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastName) {\n      lastName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastNameIndex = index;\n      } else {\n        lastNameIndex = originalNameMap.size();\n        originalNameMap.put(symbolName, lastNameIndex);\n      }\n    }\n    return lastNameIndex;\n  }",
      "private int getNameId(String symbolName)  {\n  Integer index = originalNameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  }\n  index = originalNameMap.size();\n  originalNameMap.put(symbolName, index);\n  return index;\n}",
      "private int getNameId(String symbolName)  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }",
      "private int getNameId(String symbolName)  {\n  Integer index = originalNameMap.get(symbolName);\n  if (index != null) {\n    return index;\n  } else {\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbol) {\n    lastSymbol = symbolName;\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolIndex = index;\n    } else {\n      lastSymbolIndex = originalNameMap.size();\n      originalNameMap.put(symbolName, lastSymbolIndex);\n    }\n  }\n  return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peeked = PEEKED_NONE;\n    peekedString = null;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_LONG) {\n      peekedString = Long.toString(peekedLong);\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null)\n    {\n        return null;\n    }\n    else if(repeat <= 0)\n    {\n        return \"\";\n    }\n    else\n    {\n        final int inputLength = str.length();\n        if(repeat == 1 || inputLength == 0)\n        {\n            return str;\n        }\n        else if(inputLength == 1 && repeat <= PAD_LIMIT)\n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch(inputLength)\n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for(int i = repeat * 2 - 2; i >= 0; i--, i--)\n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for(int i = 0; i < repeat; i++)\n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null)\n    {\n        return null;\n    }\n    else if(repeat <= 0)\n    {\n        return \"\";\n    }\n    else\n    {\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        else if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null)\n    {\n        return null;\n    }\n    if(repeat < 0)\n    {\n        return \"\";\n    }\n    if(repeat == 1)\n    {\n        return str;\n    }\n    final int inputLength = str.length();\n    if(inputLength == 0)\n    {\n        return repeat(EMPTY, repeat) + str;\n    }\n    else\n    {\n        final int outputLength = inputLength * repeat;\n        switch(inputLength)\n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for(int i = repeat * 2 - 2; i >= 0; i--, i--)\n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for(int i = 0; i < repeat; i++)\n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder repeated = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                repeated.append(str);\n            }\n            return repeated.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n    } else if (headerId.equals(UnixStat.HEADER_ID)) {\n        ze = new UnixStat();\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    for (final ZipExtraField ze : ZIP_EXTRA_FIELD_IMPLEMENTATIONS) {\n        if (ze.getHeaderId().equals(headerId)) {\n            return ze.getClass().newInstance();\n        }\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort type = headerId;\n    final ZipShort id = headerId;\n    final String className = getExtraFieldClassName(type, id);\n    if (className == null) {\n        return new UnrecognizedExtraField(type, id);\n    }\n    final Class<?> clazz = Class.forName(className);\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    for (final ZipExtraField zei : ZIP_EXTRA_FIELD_INSTANCES) {\n        if (zei.getHeaderId().equals(headerId)) {\n            ze = zei.getClass().newInstance();\n            break;\n        }\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n    }\n    ze.setHeaderId(headerId);\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<? extends ZipExtraField> clazz = REGISTERED_EXTRA_FIELDS.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = null;\n    final Class<?> clazz = EXTRA_FIELD_CLASSES.get(headerId);\n    if (clazz != null) {\n        extraField = (ZipExtraField) clazz.newInstance();\n    } else {\n        extraField = new UnrecognizedExtraField();\n    }\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = null;\n    // Check if the field is one of the known fields\n    if (headerId.equals(UnixStat.ID)) {\n        extraField = new UnixStat();\n    } else if (headerId.equals(UnixExtraField.ID)) {\n        extraField = new UnixExtraField();\n    } else if (headerId.equals(NTFSExtraField.ID)) {\n        extraField = new NTFSExtraField();\n    } else if (headerId.equals(ExtendedTimestamp.ID)) {\n        extraField = new ExtendedTimestamp();\n    } else if (headerId.equals(InfoZipUnixExtraField.ID)) {\n        extraField = new InfoZipUnixExtraField();\n    } else if (headerId.equals(InfoZipUnixExtraFieldData.ID)) {\n        extraField = new InfoZipUnixExtraFieldData();\n    } else if (headerId.equals(NewInfoZipUnixExtraField.ID)) {\n        extraField = new NewInfoZipUnixExtraField();\n    } else if (headerId.equals(NewInfoZipUnixExtraFieldData.ID)) {\n        extraField = new NewInfoZipUnixExtraFieldData();\n    } else if (headerId.equals(AsiExtraField.ID)) {\n        extraField = new AsiExtraField();\n    } else if (headerId.equals(JarMarker.ID)) {\n        extraField = new JarMarker();\n    } else if (headerId.equals(NtfsExtraField.ID)) {\n        extraField = new NtfsExtraField();\n    } else if (headerId.equals(OldUnixExtraField.ID)) {\n        extraField = new OldUnixExtraField();\n    } else if (headerId.equals(UnixExtraField.ID)) {\n        extraField = new UnixExtraField();\n    } else if (headerId.equals(UnixStatExtraField.ID)) {\n        extraField = new UnixStatExtraField();\n    } else if (headerId.equals(Zip64ExtendedInfoExtraField.ID)) {\n        extraField = new Zip64ExtendedInfoExtraField();\n}\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = EXTRA_FIELD_MAP.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort headerId = headerId;\n    final Class<? extends ZipExtraField> clazz =\n        HEADER_TO_EXTRA_FIELD_CLASS.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    for (final ZipExtraField ze : ZIP_EXTRA_FIELD_IMPLEMENTATIONS) {\n        if (ze.getHeaderId().equals(headerId)) {\n            return ze.getClass().newInstance();\n        }\n    }\n    return new UnrecognizedExtraField();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.clone(map);\n    Iterator iterator = clone.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Marker marker = (Marker) clone.get(key);\n        if (marker instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) marker;\n            Marker cloneMarker = (Marker) pc.clone();\n            clone.put(key, cloneMarker);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.clone(map);\n    for (Iterator iterator = clone.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getValue();\n        if (marker instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) marker;\n            Marker cloneMarker = (Marker) pc.clone();\n            entry.setValue(cloneMarker);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // add elements to list\n        for (final E e : toAdd) {\n            super.add(index, e);\n            set.add(e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        for (final E e : toAdd) {\n            super.add(index, e);\n            set.add(e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                toAdd.add(e);\n            }\n        }\n        // add elements in the correct order\n        for (final E e : toAdd) {\n            super.add(index++, e);\n            set.add(e);\n        }\n        return toAdd.size() > 0;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements at once\n        super.addAll(index, toAdd);\n        // add all elements to the set\n        set.addAll(toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        if (changed) {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            if (constraint.getValue() < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                            constraint.getRelationship().oppositeRelationship(),\n                                                            -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                                            constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            if (constraint.getValue() < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) {\n            if (constraint.getValue() < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                           constraint.getRelationship().oppositeRelationship(),\n                                                           -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                                           constraint.getRelationship(),\n                                                           constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                           constraint.getRelationship().oppositeRelationship(),\n                                                           -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                                           constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) {\n            if (constraint.getValue() < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n        for (LinearConstraint constraint : originalConstraints) {\n            if (constraint.getValue() < 0) {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n            } else {\n                normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                        constraint.getRelationship(), constraint.getValue()));\n            }\n        }\n        return normalizedConstraints;\n    }"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    // lower bounds are the same\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.upperBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.upperBound && bin.lowerBound <= this.upperBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.lowerBound) \n    {\n        return (this.upperBound >= bin.lowerBound);\n    } \n    else if (this.lowerBound > bin.lowerBound) \n    {\n        return (bin.upperBound >= this.lowerBound);\n    } \n    else \n    {\n        return (this.upperBound >= bin.lowerBound);\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.upperBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.lowerBound) \n    {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    if (this.upperBound > bin.upperBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound < bin.lowerBound) \n    {\n        if (this.upperBound < bin.lowerBound) \n        {\n            return false;\n        }\n        else \n        {\n            return true;\n        }\n    }\n    else if (this.lowerBound > bin.lowerBound) \n    {\n        if (this.lowerBound > bin.upperBound) \n        {\n            return false;\n        }\n        else \n        {\n            return true;\n        }\n    }\n    else \n    {\n        return true;\n    }\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) \n    {\n        int type = Character.getType(c[pos]);\n        if (type != currentType) \n        {\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n            {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) \n                {\n                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } \n            else \n            {\n                list.add(new String(c, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n        char[] chars = str.toCharArray();\n        List<String> list = new ArrayList<String>();\n        int tokenStart = 0;\n        int currentType = Character.getType(chars[tokenStart]);\n        for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n            int type = Character.getType(chars[pos]);\n            if (type == currentType) {\n                continue;\n            }\n            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n                int newTokenStart = pos - 1;\n                if (newTokenStart != tokenStart) {\n                    list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                    tokenStart = newTokenStart;\n                }\n            } else {\n                list.add(new String(chars, tokenStart, pos - tokenStart));\n                tokenStart = pos;\n            }\n            currentType = type;\n        }\n        list.add(new String(chars, tokenStart, chars.length - tokenStart));\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    return new DateTime(text, DateTimeZone.UTC).getMillis();\n}",
      "public long parseMillis(String text)  {\n    return new DateTime(text, DateTimeZone.UTC).getMillis();\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n            throw new IllegalArgumentException(\"Invalid format: \" + text.substring(newPos));\n        }\n    }",
      "public long parseMillis(String text)  {\n    return new DateTime(text, DateTimeZone.UTC).getMillis();\n}",
      "public long parseMillis(String text)  {\n        return parseLocalDateTime(text).toDateTimeAtStartOfDay().getMillis();\n    }",
      "public long parseMillis(String text)  {\n        return parseDateTime(text).getMillis();\n    }",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(newPos) + \"\\\"\");\n}",
      "public long parseMillis(String text)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid text: \" + text);\n        }\n    }"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n.cloneTree()),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n).setLength(1000)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n).setLength(1000)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n).setLength(1000)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n).setLength(1000)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = MeasuredNode.fromNode(n);\n    MeasuredNode negative = MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), new Node(Token.SCRIPT).srcref(n)),\n        MeasuredNode.addNode(n.cloneTree(), new Node(Token.SCRIPT).srcref(n)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), n.getParent()),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), n.getParent())\n            .setLength(Integer.MAX_VALUE));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n).setLength(1000)));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        MeasuredNode.fromNode(n),\n        MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n)));\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n        checkBitVectorable(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E value : values) {\n            Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(value);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E value : values) {\n            Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(value);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E value : values) {\n            Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(value);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        checkAlterPartialConverters();\n        iPartialConverters = set;\n    }\n    return (PartialConverter)removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        Converter[] removed = new Converter[1];\n        ConverterSet set = iPartialConverters.add(converter, removed);\n        if (set != iPartialConverters) {\n            iPartialConverters = set;\n            return (PartialConverter)removed[0];\n        }\n        return null;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        if (removed[0] != null) {\n            removePartialConverter((PartialConverter)removed[0]);\n        }\n        iPartialConverters = set;\n        return (PartialConverter)removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        iPartialConverters = set;\n        return (PartialConverter)removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        iPartialConverters = set;\n        return (PartialConverter)removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (set == iPartialConverters) {\n        return (PartialConverter)removed[0];\n    }\n    checkAlterPartialConverters();\n    iPartialConverters = set;\n    return (PartialConverter)removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        // Remove from the other sets.\n        iDurationConverters = iDurationConverters.remove(removed[0]);\n        iIntervalConverters = iIntervalConverters.remove(removed[0]);\n        iInstantConverters = iInstantConverters.remove(removed[0]);\n    }\n    iPartialConverters = set;\n    return (PartialConverter)removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (set != iPartialConverters) {\n        checkAlterPartialConverters();\n        iPartialConverters = set;\n    }\n    return (PartialConverter)removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        if (set != iPartialConverters) {\n            iPartialConverters = set;\n            return (PartialConverter)removed[0];\n        }\n        return null;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        if (removed[0] instanceof PartialConverter) {\n            removePartialConverter((PartialConverter) removed[0]);\n        }\n    }\n    return (PartialConverter)removed[0];\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n      return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n      return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n      return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parentScope = scope.getParentScope();\n    return getLexicalScopeDepth(parentScope) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n      return 0;\n    }\n  }"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert the raw data to blocks layout\n        final double[][] blockData = new double[blockRows][blockColumns * BLOCK_SIZE];\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iOffset = iBlock * BLOCK_SIZE;\n            final int iEnd = iOffset + BLOCK_SIZE;\n            final int jOffset = iBlock * BLOCK_SIZE * columns;\n            for (int i = iOffset; i < iEnd; ++i) {\n                for (int j = 0; j < columns; ++j) {\n                    blockData[iBlock][jOffset + j] = rawData[i][j];\n                }\n            }\n        }\n\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            final int startRow = blockRow * BLOCK_SIZE;\n            final int endRow = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int rowLength = endRow - startRow;\n            blocks[blockRow] = new double[rowLength * blockColumns];\n            for (int blockCol = 0; blockCol < blockColumns; ++blockCol) {\n                final int startCol = blockCol * BLOCK_SIZE;\n                final int endCol = FastMath.min(startCol + BLOCK_SIZE, columns);\n                final int colLength = endCol - startCol;\n                for (int i = 0; i < rowLength; ++i) {\n                    System.arraycopy(rawData[startRow + i], startCol,\n                                     blocks[blockRow], i * blockColumns + blockCol,\n                                     colLength);\n                }\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blockData = new double[blockRows][];\n        for (int i = 0; i < blockRows; ++i) {\n            blockData[i] = new double[blockColumns * BLOCK_SIZE];\n        }\n\n        for (int i = 0; i < rows; ++i) {\n            final int blockI = i / BLOCK_SIZE;\n            final int indexI = i % BLOCK_SIZE;\n            for (int j = 0; j < columns; ++j) {\n                final int blockJ = j / BLOCK_SIZE;\n                final int indexJ = j % BLOCK_SIZE;\n                blockData[blockI][blockJ * BLOCK_SIZE + indexJ] = rawData[i][j];\n            }\n        }\n\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows][];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow    = blockRow * BLOCK_SIZE;\n        final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n        final int blockHeight = endRow - startRow;\n        blocks[blockRow] = new double[blockHeight * blockColumns];\n        for (int blockCol = 0; blockCol < blockColumns; ++blockCol) {\n            final int startCol    = blockCol * BLOCK_SIZE;\n            final int endCol      = FastMath.min(startCol + BLOCK_SIZE, columns);\n            final int blockWidth  = endCol - startCol;\n            final int blockOffset = blockCol * blockHeight;\n            for (int iBlock = 0; iBlock < blockHeight; ++iBlock) {\n                final int i = startRow + iBlock;\n                final int base = blockOffset + iBlock * blockColumns;\n                for (int jBlock = 0; jBlock < blockWidth; ++jBlock) {\n                    final int j = startCol + jBlock;\n                    blocks[blockRow][base + jBlock] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // create the blocks layout\n        final double[][] blocksData = new double[blockRows][];\n        for (int i = 0; i < blockRows; ++i) {\n            blocksData[i] = new double[blockColumns * BLOCK_SIZE];\n        }\n\n        // copy the data in the blocks layout\n        for (int i = 0; i < rows; ++i) {\n            final int blockI = i / BLOCK_SIZE;\n            final int indexI = i - blockI * BLOCK_SIZE;\n            for (int j = 0; j < columns; ++j) {\n                final int blockJ = j / BLOCK_SIZE;\n                final int indexJ = j - blockJ * BLOCK_SIZE;\n                blocksData[blockI][blockJ * BLOCK_SIZE + indexI] = rawData[i][j];\n            }\n        }\n\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocksData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            final int startRow    = blockRow * BLOCK_SIZE;\n            final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int blockHeight = endRow    - startRow;\n            final int blockWidth  = FastMath.min(BLOCK_SIZE, columns);\n            blocksData[blockRow] = new double[blockHeight * blockWidth];\n            int blockRowOffset = 0;\n            for (int row = startRow; row < endRow; ++row) {\n                System.arraycopy(rawData[row], 0, blocksData[blockRow], blockRowOffset, blockWidth);\n                blockRowOffset += blockWidth;\n            }\n        }\n\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocksData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            final int startRow    = blockRow * BLOCK_SIZE;\n            final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int rowLength   = endRow - startRow;\n            final int blockLength = rowLength * BLOCK_SIZE;\n            blocksData[blockRow]  = new double[blockLength];\n            for (int blockCol = 0; blockCol < blockColumns; ++blockCol) {\n                final int startCol    = blockCol * BLOCK_SIZE;\n                final int endCol      = FastMath.min(startCol + BLOCK_SIZE, columns);\n                final int colLength   = endCol - startCol;\n                final int index       = blockCol * BLOCK_SIZE;\n                for (int i = startRow; i < endRow; ++i) {\n                    System.arraycopy(rawData[i], startCol, blocksData[blockRow], index + (i - startRow) * BLOCK_SIZE, colLength);\n                }\n            }\n        }\n\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert the raw data array in blocks layout\n        final double[][] blockData = new double[blockRows][];\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int i0 = iBlock * BLOCK_SIZE;\n            final int i1 = FastMath.min(i0 + BLOCK_SIZE, rows);\n            final int j0 = 0;\n            final int j1 = FastMath.min(j0 + BLOCK_SIZE, columns);\n            blockData[iBlock] = new double[i1 * j1];\n            int k = 0;\n            for (int i = i0; i < i1; ++i) {\n                for (int j = j0; j < j1; ++j) {\n                    blockData[iBlock][k] = rawData[i][j];\n                    ++k;\n                }\n            }\n        }\n\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows][];\n        for (int i = 0; i < blockRows; ++i) {\n            blocks[i] = new double[blockColumns * BLOCK_SIZE];\n        }\n\n        for (int i = 0; i < rows; ++i) {\n            final int blockI = i / BLOCK_SIZE;\n            final int indexI = i % BLOCK_SIZE;\n            for (int j = 0; j < columns; ++j) {\n                final int blockJ = j / BLOCK_SIZE;\n                final int indexJ = j % BLOCK_SIZE;\n                blocks[blockI][blockJ * BLOCK_SIZE + indexJ] = rawData[i][j];\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // create the output array\n        final double[][] blocks = new double[blockRows][];\n        for (int i = 0; i < blockRows; ++i) {\n            blocks[i] = new double[blockColumns * BLOCK_SIZE];\n        }\n\n        // fill the output array\n        for (int i = 0; i < rows; ++i) {\n            final int blockI = i / BLOCK_SIZE;\n            final int indexI = i % BLOCK_SIZE;\n            for (int j = 0; j < columns; ++j) {\n                final int blockJ = j / BLOCK_SIZE;\n                final int indexJ = j % BLOCK_SIZE;\n                blocks[blockI][blockJ * BLOCK_SIZE + indexJ] = rawData[i][j];\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << (value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << (value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        long result = 0;\n        for (final E value : condensed) {\n            result |= 1 << value.ordinal();\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        long result = 0;\n        for (final E value : condensed) {\n            result |= 1 << value.ordinal();\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        long result = 0;\n        for (final E value : condensed) {\n            result |= 1 << value.ordinal();\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        long result = 0;\n        for (final E value : condensed) {\n            result |= 1 << value.ordinal();\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp y = a;\n    Dfp c = a.multiply(a);\n    Dfp x = y;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n    final Dfp three = two.add(one);\n    final Dfp four = two.add(two);\n    final Dfp five = four.add(one);\n    final Dfp six = five.add(one);\n    final Dfp seven = six.add(one);\n    final Dfp eight = seven.add(one);\n    final Dfp nine = eight.add(one);\n    final Dfp ten = nine.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n    final Dfp zero = a.getZero();\n\n    if (a.lessThan(zero)) {\n        // return 1/exp(-a)\n        return one.divide(expInternal(a.negate()));\n    }\n\n    if (a.equals(zero)) {\n        // return 1\n        return one;\n    }\n\n    if (a.greaterThan(two)) {\n        // return exp(2*a)/exp(a)\n        return expInternal(a.multiply(two)).divide(expInternal(a));\n    }\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a.multiply(a).divide(two);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) \n    {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) \n        {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n    final Dfp zero = a.getZero();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n    final Dfp zero = a.getZero();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n    final Dfp zero = a.getZero();\n\n    if (a.equals(zero)) {\n        return one;\n    }\n\n    if (a.compare(zero) < 0) {\n        return one.divide(expInternal(a.negate()));\n    }\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold.getReal()) \n    {\n        final T inverse = getNorm().reciprocal();\n        return new FieldVector3D<T>(0, inverse.multiply(z), inverse.multiply(y.negate()));\n    } \n    else if (FastMath.abs(y) <= threshold.getReal()) \n    {\n        final T inverse = getNorm().reciprocal();\n        return new FieldVector3D<T>(inverse.multiply(z.negate()), 0, inverse.multiply(x));\n    }\n    final T inverse = getNorm().reciprocal();\n    return new FieldVector3D<T>(inverse.multiply(y), inverse.multiply(x.negate()), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    T dot = dotProduct(this);\n    if (dot.getReal() < ((2.0e-15 - 1.0) * threshold.getReal())) \n    {\n        // special case u = -v: we select a PI angle rotation around\n        // an arbitrary vector orthogonal to u\n        FieldVector3D<T> w = orthogonal();\n        q0 = 0.0;\n        q1 = -w.getX();\n        q2 = -w.getY();\n        q3 = -w.getZ();\n    } \n    else \n    {\n        // general case: (u, v) defines a plane, we select\n        // the shortest possible rotation: axis orthogonal to this plane\n        q0 = FastMath.sqrt(0.5 * (1.0 + dot.getReal() / threshold.getReal()));\n        T coeff = 1.0 / (2.0 * q0 * threshold);\n        FieldVector3D<T> q = crossProduct(this);\n        q1 = coeff * q.getX();\n        q2 = coeff * q.getY();\n        q3 = coeff * q.getZ();\n    }\n\n    return new FieldVector3D<T>(q0, q1, q2, q3);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold.getReal()) {\n        final T inverse  = getNorm().reciprocal();\n        return new FieldVector3D<T>(x.getField().getZero(), inverse.multiply(z), inverse.multiply(x.getField().getNegative(y)));\n    } else if (FastMath.abs(y.getReal()) <= threshold.getReal()) {\n        final T inverse  = getNorm().reciprocal();\n        return new FieldVector3D<T>(x.getField().getZero(), inverse.multiply(z), inverse.multiply(x.getField().getNegative(y)));\n    }\n    final T inverse  = getNorm().reciprocal();\n    return new FieldVector3D<T>(inverse.multiply(y), inverse.multiply(x.getField().getNegative(x)), x.getField().getZero());\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<T>(\n        minimum.compareTo(other.minimum) <= 0 ? minimum : other.minimum,\n        maximum.compareTo(other.maximum) >= 0 ? maximum : other.maximum\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) \n    {\n        return this;\n    }\n    return between(\n        (minimum.compareTo(other.minimum) < 0 ? other.minimum : minimum),\n        (maximum.compareTo(other.maximum) > 0 ? other.maximum : maximum),\n        comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    return new Range<>(\n        maximum(minimum, other.minimum),\n        minimum(maximum, other.maximum),\n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!other.isOverlappedBy(this)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (this.equals(other)) \n    {\n        return this;\n    }\n    final T min = (this.isBefore(other.minimum)) ? other.minimum : this.minimum;\n    final T max = (this.isAfter(other.maximum)) ? other.maximum : this.maximum;\n    return new Range<>(min, max, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = (contains(other.minimum)) ? other.minimum : minimum;\n    final T max = (contains(other.maximum)) ? other.maximum : maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    final T newMin = (minimum.compareTo(other.minimum) <= 0) ? minimum : other.minimum;\n    final T newMax = (maximum.compareTo(other.maximum) >= 0) ? maximum : other.maximum;\n    return between(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = (compare(other.minimum) <= 0) ? other.minimum : minimum;\n    final T max = (compare(other.maximum) >= 0) ? other.maximum : maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range to intersect must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range to intersect must overlap this range\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    final T min = minimum.compareTo(other.minimum) < 0 ? other.minimum : minimum;\n    final T max = maximum.compareTo(other.maximum) > 0 ? other.maximum : maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!other.isOverlappedBy(this)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return new Range<>(\n        (this.isBefore(other.minimum)) ? other.minimum : this.minimum,\n        (this.isAfter(other.maximum)) ? other.maximum : this.maximum\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<T>(\n        getMinimum().compareTo(other.getMinimum()) <= 0 ? getMinimum() : other.getMinimum(),\n        getMaximum().compareTo(other.getMaximum()) >= 0 ? getMaximum() : other.getMaximum(),\n        getComparator()\n    );\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createGenerator(out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, StandardCharsets.UTF_8));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      if (unionType.isUnknownType()) {\n        return type;\n      }\n      JSType filteredType = null;\n      for (JSType alternate : unionType.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          if (filteredType == null) {\n            filteredType = alternate;\n          } else {\n            filteredType = JSType.join(filteredType, alternate);\n          }\n        }\n      }\n      if (filteredType != null) {\n        return filteredType;\n      }\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isObject() && type.isObject()) {\n      return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n    for (JSType alternate : unionType.getAlternates()) {\n      builder.add(filterNoResolvedType(alternate));\n    }\n    return JSType.join(builder.build());\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      for (JSType alt : unionType.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          return type;\n        }\n      }\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      if (unionType.isUnknownType() ||\n          unionType.isNoResolvedType() ||\n          unionType.hasAnyTemplateTypes()) {\n        return type;\n      } else {\n        return unionType.filterNoResolvedType();\n      }\n    } else {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  } else if (type.isObject() && type.toMaybeObjectType().isUnresolved()) {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  } else {\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isObject() && type.toMaybeObjectType().getImplicitPrototype() != null) {\n      return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isObject() && type.toMaybeObjectType().getRawType().isNoResolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isObject() && type.toMaybeObjectType().getRawType().isNoResolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isObject() && type.isObject()) {\n      return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n  }\n// javascript/jscomp/type/ChainableReverseAbstractInterpreter.java"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    // Parse the function type.\n    Node functionType = newNode(Token.FUNCTION);\n\n    // Parse the type parameters.\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n\n    // Parse the function signature.\n    Node functionSignature = parseFunctionSignature(next());\n    if (functionSignature == null) {\n      return null;\n    }\n    functionType.addChildToBack(functionSignature);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(typeParameters);\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(typeName);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(parametersType);\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeName);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(typeParameters);\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(typeName);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(parametersType);\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(typeParameters);\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(typeName);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(parametersType);\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters == null) {\n    return null;\n  }\n  functionType.addChildToBack(typeParameters);\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return null;\n  }\n  functionType.addChildToBack(typeName);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    Node parametersType = parseParametersType(next());\n    Node resultType = parseResultType(next());\n\n    if (typeParameters == null || parametersType == null || resultType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToBack(typeParameters);\n  }\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n  functionType.addChildToBack(typeName);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    Node parametersType = parseParametersType(next());\n    Node resultType = parseResultType(next());\n    if (typeParameters == null || parametersType == null || resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    StringBuilder builder = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            builder.append(str.charAt(i));\n        }\n    }\n    return builder.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // this is the size of the buffer we'll build\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            count++;\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    // this is the size of the buffer we'll build\n    final char[] chs = new char[count];\n    int pos = 0;\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            chs[pos++] = ch;\n        }\n    }\n    return new String(chs);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // StringBuffer is faster than StringBuilder\n    StringBuffer buffer = new StringBuffer(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // This is the length of the input String without whitespace\n    int start = 0;\n    int end = sz - 1;\n    while (start < sz && Character.isWhitespace(str.charAt(start))) {\n        start++;\n    }\n    while (end > start && Character.isWhitespace(str.charAt(end))) {\n        end--;\n    }\n    return str.substring(start, end + 1);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // StringBuffer is faster than StringBuilder\n    StringBuffer buffer = new StringBuffer(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    //StringBuilder builder = new StringBuilder(sz);\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            builder.append(str.charAt(i));\n        }\n    }\n    return builder.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    StringBuffer buffer = new StringBuffer(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    // This is a copy of the code in the String.trim() method, but\n    // optimized for just whitespace\n    int start = 0;\n    int end = sz - 1;\n    while ((start < sz) && (Character.isWhitespace(str.charAt(start)))) {\n        start++;\n    }\n    while ((end > start) && (Character.isWhitespace(str.charAt(end)))) {\n        end--;\n    }\n    if ((start > 0) || (end < sz - 1)) {\n        return str.substring(start, end + 1);\n    }\n    return str;\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        int sz = str.length();\n        StringBuffer buffer = new StringBuffer(sz);\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                buffer.append(str.charAt(i));\n            }\n        }\n        return buffer.toString();\n    }"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        SummaryStatistics.copy(stat, aggregatedStatistics);\n    }\n    return aggregatedStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double[] values = new double[statistics.size()];\n        int i = 0;\n        for (SummaryStatistics stat : statistics) {\n            values[i++] = stat.getMax();\n        }\n        return new StatisticalSummaryValues(StatUtils.max(values),\n                                            StatUtils.min(values),\n                                            StatUtils.sum(values),\n                                            StatUtils.sumsq(values),\n                                            values.length);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Use the first SummaryStatistics as a prototype to avoid\n    // having to check for nulls in the loop below.\n    SummaryStatistics prototype = statistics.iterator().next();\n    StatisticalSummaryValues values = new StatisticalSummaryValues();\n    values.setN(0);\n    values.setMax(prototype.getMax());\n    values.setMin(prototype.getMin());\n    values.setSum(prototype.getSum());\n    values.setSumsq(prototype.getSumsq());\n\n    for (SummaryStatistics stat : statistics) {\n        values.setN(values.getN() + stat.getN());\n        values.setMax(Math.max(values.getMax(), stat.getMax()));\n        values.setMin(Math.min(values.getMin(), stat.getMin()));\n        values.setSum(values.getSum() + stat.getSum());\n        values.setSumsq(values.getSumsq() + stat.getSumsq());\n    }\n\n    return values;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new AggregatingSummaryStatistics(null);\n    for (SummaryStatistics stat : statistics) {\n        SummaryStatistics.copy(stat, aggregatedStatistics);\n    }\n    return aggregatedStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n        }\n\n        return new StatisticalSummaryValues(n, sum, sumsq, min, max);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double[] values = new double[statistics.size()];\n        int i = 0;\n        for (SummaryStatistics stat : statistics) {\n            values[i++] = stat.getMax();\n        }\n        return new StatisticalSummaryValues(StatUtils.max(values));\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        SummaryStatistics aggregator = new AggregatingSummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            SummaryStatistics.copy(stat, aggregator);\n        }\n        return aggregator.getSummary();\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n\n        for (SummaryStatistics stat : statistics) {\n            if (stat == null) {\n                continue;\n            }\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n        }\n\n        return new StatisticalSummaryValues(n, sum, sumsq, min, max);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    int n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    return new StatisticalSummaryValues(n, sum, sumsq, min, max);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double[] values = new double[statistics.size()];\n        int i = 0;\n        for (SummaryStatistics stat : statistics) {\n            values[i++] = stat.getMax();\n        }\n        return new StatisticalSummaryValues(\n            new Max().evaluate(values),\n            new Mean().evaluate(values),\n            new GeometricMean().evaluate(values),\n            new Sum().evaluate(values),\n            new Variance().evaluate(values, new Mean().evaluate(values), i),\n            new StandardDeviation().evaluate(values, new Mean().evaluate(values), i),\n            new Kurtosis().evaluate(values, new Mean().evaluate(values), new Variance().evaluate(values, new Mean().evaluate(values), i), i),\n            new Skewness().evaluate(values, new Mean().evaluate(values), new Variance().evaluate(values, new Mean().evaluate(values), i), i)\n        );\n    }"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSquaredDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double difference = sample1[i] - sample2[i];\n            sumSquaredDifferences += (difference - meanDifference) * (difference - meanDifference);\n        }\n        return sumSquaredDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        return sumSqDifference(sample1, sample2) / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSquaredDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sumSquaredDifferences += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sumSquaredDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSq = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sumSq += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sumSq / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSquaredDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double difference = sample1[i] - sample2[i];\n            sumSquaredDifferences += (difference - meanDifference) * (difference - meanDifference);\n        }\n        return sumSquaredDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(key);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int bytesRead = IOUtils.readFully(in, b, off, readable);\n                count(bytesRead);\n                uncompressedBytesRemaining -= bytesRead;\n                return bytesRead;\n            } else {\n                return -1;\n            }\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.read(b, off, len));\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.read(b, off, len));\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int read = in.read(b, off, readable);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading literal\");\n                }\n                count(read);\n                uncompressedBytesRemaining -= read;\n                return read;\n            }\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int read = in.read(b, off, readable);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading uncompressed data\");\n                }\n                count(read);\n                uncompressedBytesRemaining -= read;\n                return read;\n            } else {\n                return -1;\n            }\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int bytesRead = in.read(b, off, readable);\n                if (bytesRead == -1) {\n                    throw new IOException(\"Premature end of stream reading literal\");\n                }\n                count(bytesRead);\n                uncompressedBytesRemaining -= bytesRead;\n                return bytesRead;\n            }\n            return 0;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return Math.min(uncompressedBytesRemaining,\n                            in.read(b, off, len));\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int read = in.read(b, off, readable);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading literal\");\n                }\n                uncompressedBytesRemaining -= read;\n                return read;\n            }\n            return 0;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    Preconditions.checkArgument(isCallOrNew(call) || isFunctionObjectCall(call)\n        || isFunctionObjectApply(call),\n        \"Node must be a call or new.\");\n\n    if (isFunctionObjectCall(call) || isFunctionObjectApply(call)) {\n      return getArgumentForCallOrNewOrDotCall(call.getFirstChild(), argIndex);\n    }\n\n    return getNthSibling(call.getFirstChild().getNext(), argIndex);\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getSite();\n    if (isFunctionObjectCall(call)) {\n      return call.getLastChild().getFirstChild();\n    } else if (isFunctionObjectApply(call)) {\n      return call.getLastChild().getFirstChild().getNext();\n    } else {\n      return getNthSibling(call.getFirstChild().getNext(), argIndex);\n    }\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isFunctionObjectCall(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (NodeUtil.isFunctionObjectApply(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex + 1);\n      } else if (NodeUtil.isObjectCallMethod(call, \"call\")) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (NodeUtil.isObjectCallMethod(call, \"apply\")) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex + 1);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + call +\n            \"\\n parent:\" + call.getParent());\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      Node arg = null;\n      if (isFunctionObjectCall(call)) {\n        arg = getArgumentForCallOrNew(call, argIndex);\n      } else if (isFunctionObjectApply(call)) {\n        arg = getArgumentForCallOrNew(call, argIndex + 1);\n      } else if (call.isGetProp()) {\n        arg = getArgumentForCallOrNew(call, argIndex);\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isFunctionObjectCall(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (NodeUtil.isFunctionObjectApply(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex + 1);\n      } else if (NodeUtil.isCallOrNew(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + call +\n            \"\\n parent:\" + call.getParent());\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.getSite();\n      if (isFunctionObjectCall(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n      } else if (isFunctionObjectApply(call)) {\n        return getArgumentForCallOrNew(call, argIndex + 1);\n      } else {\n        return getNthSibling(call.getFirstChild(), argIndex);\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getSite();\n    Preconditions.checkArgument(\n        NodeUtil.isCallOrNew(call) || isFunctionObjectCall(call)\n        || isFunctionObjectApply(call),\n        \"Node must be a call or new.\");\n\n    if (isFunctionObjectCall(call)) {\n      return getNthSibling(call.getFirstChild().getNext(), argIndex);\n    } else if (isFunctionObjectApply(call)) {\n      return getNthSibling(call.getFirstChild().getNext().getNext(), argIndex);\n    } else {\n      return getNthSibling(call.getFirstChild().getNext(), argIndex);\n    }\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    Node arg = null;\n    if (NodeUtil.isFunctionObjectCall(call)) {\n      arg = getNthSibling(call.getFirstChild().getNext(), argIndex);\n    } else if (NodeUtil.isFunctionObjectApply(call)) {\n      arg = getNthSibling(call.getFirstChild().getNext().getNext(), argIndex);\n    } else if (NodeUtil.isCallOrNew(call)) {\n      arg = getNthSibling(call.getFirstChild().getNext(), argIndex);\n    }\n    return arg;\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isFunctionObjectCall(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (NodeUtil.isFunctionObjectApply(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex + 1);\n      } else {\n        return call.getFirstChild().getNext().getChildAtIndex(argIndex);\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (NodeUtil.isFunctionObjectCall(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      } else if (NodeUtil.isFunctionObjectApply(call)) {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex + 1);\n      } else {\n        return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n      }\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) {\n        result = this.data.getColumnIndex(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    for (int i = 0; i < getColumnCount(); i++) \n    {\n        if (getColumnKey(i).equals(key)) \n        {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    for (int i = 0; i < this.data.getColumnCount(); i++) \n    {\n        Comparable colKey = this.data.getColumnKey(i);\n        if (colKey.equals(key)) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        List keys = getColumnKeys();\n        result = keys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.data.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    for (int i = 0; i < getColumnCount(); i++) \n    {\n        Comparable columnKey = getColumnKey(i);\n        if (columnKey.equals(key)) \n        {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        result = this.data.getIndex(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        result = this.columnKeys.indexOf(key);\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.data.getColumnIndex(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        } else if (point > getSup()) {\n            return Location.OUTSIDE;\n        } else if (point < getInf() + tolerance) {\n            return Location.BOUNDARY;\n        } else if (point > getSup() - tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getSup()) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getInf()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getSup()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getSup()) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getInf()) < tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getSup()) < tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        } else if (point > getSup()) {\n            return Location.OUTSIDE;\n        } else if (FastMath.abs(point - getInf()) <= tolerance) {\n            return Location.BOUNDARY;\n        } else if (FastMath.abs(point - getSup()) <= tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    // check if the point is in the interval\n    if (point >= getInf() && point <= getSup()) {\n        return Location.INSIDE;\n    }\n\n    // check if the point is in the boundary\n    if (point <= getInf() && FastMath.abs(point - getInf()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= getSup() && FastMath.abs(point - getSup()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n\n    // the point is outside the interval\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getInf()) {\n        return Location.OUTSIDE;\n    }\n    if (point > getSup()) {\n        return Location.OUTSIDE;\n    }\n    if (FastMath.abs(point - getInf()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (FastMath.abs(point - getSup()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getSup()) {\n            return Location.OUTSIDE;\n        }\n        if (point < getInf() + tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (point > getSup() - tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= getInf() - tolerance && point <= getSup() + tolerance) {\n        return Location.INSIDE;\n    } else if (point < getInf() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getSup() + tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getSup()) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getInf()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getSup()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < getInf()) {\n            return Location.OUTSIDE;\n        }\n        if (point > getSup()) {\n            return Location.OUTSIDE;\n        }\n        if (FastMath.abs(point - getInf()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (FastMath.abs(point - getSup()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Find the column with the most negative coefficient in the objective function row\n    int minCol = 0;\n    double minVal = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double val = tableau.getEntry(0, i);\n        if (val < minVal) \n        {\n            minVal = val;\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minValue = Double.MAX_VALUE;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double entry = tableau.getEntry(0, i);\n        if (entry < minValue) \n        {\n            minValue = entry;\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double entry = tableau.getEntry(0, i);\n        if (entry < min) {\n            min = entry;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double min = Double.MAX_VALUE;\n        Integer minCol = null;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            double entry = tableau.getEntry(0, i);\n            if (entry < min) {\n                min = entry;\n                minCol = i;\n            }\n        }\n        return minCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int col = 0;\n        double min = Double.MAX_VALUE;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            double entry = tableau.getEntry(0, i);\n            if (entry < min) {\n                min = entry;\n                col = i;\n            }\n        }\n        return col;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int pivotCol = 0;\n        double min = Double.MAX_VALUE;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            if (tableau.getEntry(0, i) < min) {\n                min = tableau.getEntry(0, i);\n                pivotCol = i;\n            }\n        }\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry / tableau.getEntry(0, tableau.getWidth() - 1);\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // choose the column with the smallest index\n        return Collections.min(minRatioPositions);\n    } else {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n            return null;\n        } else {\n            return minRatioPositions.get(0);\n        }\n    }"
    ]
  ]
}