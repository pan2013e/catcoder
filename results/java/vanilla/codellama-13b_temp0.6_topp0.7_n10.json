{
  "benchmark": "javaeval_basic",
  "lastest_eval": {
    "compile@1": 0.33567839195979904,
    "pass@1": 0.1492462311557789,
    "compile@3": 0.4938442211055272,
    "pass@3": 0.22072864321608043,
    "compile@5": 0.5624351918321767,
    "pass@5": 0.25205392039562896
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     ",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     ",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        //TODO: Implement this method\n        return null;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     ",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        return null;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        if (type == null) {\n            throw new IllegalArgumentException(\"type cannot be null\");\n        }\n        if (ser == null) {\n            throw new IllegalArgumentException(\"serializer cannot be null\");\n        }\n        _serializers.put(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     ",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     ",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        return addSerializer(type, ser, false);\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     "
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    return 0;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO add implementation\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    // TODO: implement this method\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + strLen);\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index < 0) \n    {\n        return this;\n    }\n    return delete(index, index + str.length());\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) \n    {\n        delete(index, index + strLen);\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        delete(index, index + str.length());\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new Iterable<E>() \n    {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return m.getMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } else {\n        return m.getMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    //TODO: Implement this method\n    return null;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    // Check if m is a column matrix\n    if (m.getColumnDimension() == 1) {\n        // If so, return the diagonal n-by-n matrix\n        return MatrixUtils.createRealDiagonalMatrix(m.getColumn(0));\n    } else {\n        // If m is a n-by-n matrix, return the column matrix representing the diagonal\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        return m.getMatrixFactory().createDiagonalMatrix(m.getRowDimension(), m.getColumnDimension());\n    } \n    else if (m.getRowDimension() == 1) \n    {\n        return m.getMatrixFactory().createMatrix(m.getRowDimension(), m.getColumnDimension(), m.getData());\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"m must be a column or a row matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return MatrixUtils.createRealDiagonalMatrix(m.getColumn(0));\n    } else if (m.getRowDimension() == 1) {\n        return MatrixUtils.createRealMatrix(m.getRow(0));\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a row matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final int n = m.getRowDimension();\n        final RealMatrix m2 = MatrixUtils.createRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            m2.setEntry(i, i, m.getEntry(i, 0));\n        }\n        return m2;\n    } else {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return MatrixUtils.createRealDiagonalMatrix(m.getColumn(0));\n    } else {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, 0);\n    } \n    else if (m.getRowDimension() == 1) \n    {\n        return m.getSubMatrix(0, 0, 0, m.getColumnDimension() - 1);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"m must be a column or row vector\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    // Your code here\n    return null;\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final double[][] blocks = new double[rows][];\n    for (int i = 0; i < rows; ++i) {\n        blocks[i] = new double[columns];\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final double[][] blocks = new double[rows][columns];\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < columns; ++j) {\n            blocks[i][j] = 0;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final double[][] blocks = new double[rows][columns];\n        for (int r = 0; r < rows; ++r) {\n            for (int c = 0; c < columns; ++c) {\n                blocks[r][c] = 0;\n            }\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final double[][] blocks = new double[rows][];\n    for (int i = 0; i < rows; ++i) {\n        blocks[i] = new double[columns];\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final double[][] blocks = new double[rows][];\n        for (int r = 0; r < rows; ++r) {\n            blocks[r] = new double[columns];\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    return new double[rows][columns];\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final double[][] blocks = new double[rows][];\n        for (int r = 0; r < rows; ++r) {\n            blocks[r] = new double[columns];\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final double[][] blocks = new double[rows][];\n        for (int r = 0; r < rows; ++r) {\n            blocks[r] = new double[columns];\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final double[][] blocks = new double[rows][];\n        for (int r = 0; r < rows; ++r) {\n            blocks[r] = new double[columns];\n        }\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final double[][] blocks = new double[rows][];\n    for (int i = 0; i < rows; ++i) {\n        blocks[i] = new double[columns];\n    }\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field '%s' is not static\", field.getName());\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readStaticField(field, forceAccess ? null : field.getDeclaringClass(), forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field %s.%s is not static\", field.getDeclaringClass().getName(), field.getName());\n    return readStaticField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readStaticField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field '%s' is not static\", field.getName());\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field '%s' is not static\", field.getName());\n    return readStaticField(field, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    if (Modifier.isStatic(field.getModifiers())) \n    {\n        return field.get(null);\n    }\n    throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(field != null, \"The field must not be null\");\n    Validate.isTrue(Modifier.isStatic(field.getModifiers()), \"The field '%s' is not static\", field.getName());\n    return readStaticField(field, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readStaticField(field, forceAccess ? null : field.getDeclaringClass(), forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        final int modifiers = field.getModifiers();\n        if (!Modifier.isPublic(modifiers) || !Modifier.isStatic(modifiers)) {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        return new DateTimeZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return FixedDateTimeZone.forOffset(id);\n        }\n        else \n        {\n            return Provider.getInstance().getZone(id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return FixedDateTimeZone.forOffset(id);\n        }\n        return ZoneInfoProvider.getZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        int slashPos = id.indexOf('/');\n        if (slashPos > 0) \n        {\n            String groupID = id.substring(0, slashPos);\n            String subgroupID = id.substring(slashPos + 1);\n            return new DateTimeZone(groupID, subgroupID);\n        }\n        else \n        {\n            return new DateTimeZone(id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return FixedDateTimeZone.forOffset(id);\n        }\n        else \n        {\n            return Provider.getInstance().getZone(id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return FixedDateTimeZone.forOffset(id);\n        }\n        else \n        {\n            return Provider.getInstance().getZone(id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        if (id.equals(\"GMT\")) \n        {\n            return DateTimeZone.GMT;\n        }\n        if (id.equals(\"GMT0\")) \n        {\n            return DateTimeZone.GMT0;\n        }\n        if (id.equals(\"WET\")) \n        {\n            return DateTimeZone.WET;\n        }\n        if (id.equals(\"WST\")) \n        {\n            return DateTimeZone.WST;\n        }\n        if (id.equals(\"BST\")) \n        {\n            return DateTimeZone.BST;\n        }\n        if (id.equals(\"ART\")) \n        {\n            return DateTimeZone.ART;\n        }\n        if (id.equals(\"CAT\")) \n        {\n            return DateTimeZone.CAT;\n        }\n        if (id.equals(\"EAT\")) \n        {\n            return DateTimeZone.EAT;\n        }\n        if (id.equals(\"MET\")) \n        {\n            return DateTimeZone.MET;\n        }\n        if (id.equals(\"NET\")) \n        {\n            return DateTimeZone.NET;\n        }\n        if (id.equals(\"PLT\")) \n        {\n            return DateTimeZone.PLT;\n        }\n        if (id.equals(\"IST\")) \n        {\n            return DateTimeZone.IST;\n        }\n        if (id.equals(\"SST\")) \n        {\n            return DateTimeZone.SST;\n        }\n        if (id.equals(\"VST\")) \n        {\n            return DateTimeZone.VST;\n        }\n        if (id.equals(\"CTT\")) \n        {\n            return DateTimeZone.CTT;\n        }\n        if (id.equals(\"JST\")) \n        {\n            return DateTimeZone.JST;\n        }\n        if (id.equals(\"ACT\")) \n        {\n            return DateTimeZone.ACT;\n        }\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) \n        {\n            return new FixedDateTimeZone(id);\n        }\n        return forID(id, null);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        return new DateTimeZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        else if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n        else if (id.equals(\"GMT\")) \n        {\n            return GMT;\n        }\n        else if (id.equals(\"GMT-0\")) \n        {\n            return GMT;\n        }\n        else if (id.equals(\"GMT+0\")) \n        {\n            return GMT;\n        }\n        else if (id.equals(\"GMT0\")) \n        {\n            return GMT;\n        }\n        else if (id.equals(\"WET\")) \n        {\n            return WET;\n        }\n        else if (id.equals(\"EET\")) \n        {\n            return EET;\n        }\n        else if (id.equals(\"MET\")) \n        {\n            return MET;\n        }\n        else if (id.equals(\"MEST\")) \n        {\n            return MEST;\n        }\n        else if (id.equals(\"MESZ\")) \n        {\n            return MESZ;\n        }\n        else if (id.equals(\"MIT\")) \n        {\n            return MIT;\n        }\n        else if (id.equals(\"HST\")) \n        {\n            return HST;\n        }\n        else if (id.equals(\"AST\")) \n        {\n            return AST;\n        }\n        else if (id.equals(\"ADT\")) \n        {\n            return ADT;\n        }\n        else if (id.equals(\"NST\")) \n        {\n            return NST;\n        }\n        else if (id.equals(\"NDT\")) \n        {\n            return NDT;\n        }\n        else if (id.equals(\"GST\")) \n        {\n            return GST;\n        }\n        else if (id.equals(\"GDT\")) \n        {\n            return GDT;\n        }\n        else if (id.equals(\"BST\")) \n        {\n            return BST;\n        }\n}"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return new Dfp(0);\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == -1) {\n        return negate();\n    }\n    if (x == radix - 1) {\n        return new Dfp(2 * mantissa);\n    }\n    if (x == radix + 1) {\n        return new Dfp(2 * mantissa + 1);\n    }\n    if (x == radix - 2) {\n        return new Dfp(mantissa + 1);\n    }\n    if (x == radix + 2) {\n        return new Dfp(mantissa + 2);\n    }\n    return multiply(new Dfp(x));\n}",
      "private Dfp multiplyFast(final int x)  {\n    // TODO: implement this\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return Dfp.ZERO;\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == -1) {\n        return negate();\n    }\n    if (x == radix - 1) {\n        return shiftLeft(1);\n    }\n    if (x == radix + 1) {\n        return shiftLeft(1).negate();\n    }\n    if (x == radix - radix) {\n        return shiftLeft(1).negate();\n    }\n    if (x == radix + radix) {\n        return shiftLeft(1);\n    }\n    if (x < 0 || x >= radix) {\n        throw new IllegalArgumentException(\"x out of range\");\n    }\n    if (x < radix / 2) {\n        return multiplyFast(radix - x);\n    }\n    int[] m = new int[mant.length];\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        int product = mant[i] * x + carry;\n        m[i] = product % radix;\n        carry = product / radix;\n    }\n    return new Dfp(m, exponent);\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) \n    {\n        return Dfp.ZERO;\n    } \n    else if (x == 1) \n    {\n        return this;\n    } \n    else if (x == -1) \n    {\n        return negate();\n    } \n    else \n    {\n        Dfp product = Dfp.ZERO;\n        int n = Math.abs(x);\n        for (int i = 0; i < getExponent(); i++) \n        {\n            if ((getUnsignedFraction() & (1 << i)) != 0) \n            {\n                product = product.add(Dfp.valueOf(n, getExponent() - i));\n            }\n        }\n        if (x < 0) \n        {\n            product = product.negate();\n        }\n        return product;\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Multiply this by a single digit 0 <= x < radix.\n    // There are speed advantages in this special case.\n    if (x == 0) {\n        return new Dfp(0);\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == radix - 1) {\n        return new Dfp(this.getUnscaledValue());\n    }\n    final int[] thisValue = this.getUnscaledValue();\n    final int[] product = new int[thisValue.length];\n    int carry = 0;\n    for (int i = thisValue.length - 1; i >= 0; i--) {\n        final int productCarry = (int) (((long) thisValue[i] * x) + carry);\n        product[i] = productCarry % radix;\n        carry = productCarry / radix;\n    }\n    return new Dfp(product);\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Implement this method\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Check for zero\n    if (x == 0) \n    {\n        return new Dfp(0, getRadix());\n    }\n    // Check for 1\n    if (x == 1) \n    {\n        return this;\n    }\n    // Check for -1\n    if (x == -1) \n    {\n        return negate();\n    }\n    // Check for radix\n    if (x == getRadix()) \n    {\n        return square();\n    }\n    // Check for -radix\n    if (x == -getRadix()) \n    {\n        return square().negate();\n    }\n    // Otherwise, use the general multiply\n    return multiply(new Dfp(x, getRadix()));\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) \n    {\n        return new Dfp(0);\n    }\n    else if (x == 1) \n    {\n        return this;\n    }\n    else if (x == -1) \n    {\n        return negate();\n    }\n    else if (x == radix) \n    {\n        return new Dfp(2 * value);\n    }\n    else if (x == -radix) \n    {\n        return new Dfp(-2 * value);\n    }\n    else if (x == radix / 2) \n    {\n        return new Dfp(value + 1);\n    }\n    else if (x == -radix / 2) \n    {\n        return new Dfp(value - 1);\n    }\n    else if (x == 1 / radix) \n    {\n        return new Dfp(value / 2);\n    }\n    else if (x == -1 / radix) \n    {\n        return new Dfp(-value / 2);\n    }\n    else if (x == 1 / radix / 2) \n    {\n        return new Dfp(value / 4);\n    }\n    else if (x == -1 / radix / 2) \n    {\n        return new Dfp(-value / 4);\n    }\n    else if (x == 1 / radix / 4) \n    {\n        return new Dfp(value / 8);\n    }\n    else if (x == -1 / radix / 4) \n    {\n        return new Dfp(-value / 8);\n    }\n    else if (x == 1 / radix / 8) \n    {\n        return new Dfp(value / 16);\n    }\n    else if (x == -1 / radix / 8) \n    {\n        return new Dfp(-value / 16);\n    }\n    else if (x == 1 / radix / 16) \n    {\n        return new Dfp(value / 32);\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return new Dfp(0, 0);\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == -1) {\n        return negate();\n    }\n    final int[] m = mantissa;\n    final int[] r = new int[m.length];\n    for (int i = 0; i < m.length; i++) {\n        r[i] = m[i] * x;\n    }\n    return new Dfp(r, exponent);\n}",
      "private Dfp multiplyFast(final int x)  {\n    final int[] m = this.mant;\n    final int[] result = new int[m.length];\n    int carry = 0;\n    for (int i = 0; i < m.length; i++) \n    {\n        final int product = x * (m[i] & 0xFFFF) + carry;\n        result[i] = product & 0xFFFF;\n        carry = product >>> 16;\n    }\n    if (carry != 0) \n    {\n        result[result.length - 1] = carry;\n    }\n    return new Dfp(result, this.exp);\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> result = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> result = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> result = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) {\n            return null;\n        }\n        final Map<K, V> result = new HashMap<K, V>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            result.put(key, value);\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        return (Map<K, V>) map;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> result = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        return (Map<K, V>) map;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> result = new HashMap<>();\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map == null) \n        {\n            return null;\n        }\n        Map<K, V> result = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(entry.getKey(), transform(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.useSourceInfoIfMissingFromForTree(exportedFunction);\n    NodeUtil.copyName(exportedFunction.getFirstChild(), function.getFirstChild());\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    externFunction.useSourceInfoIfMissingFromForTree(exportedFunction);\n    externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n    externFunction.setStaticSourceFileInfo(exportedFunction);\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node with the same name as the exported function\n    Node externFunction = new Node(Token.FUNCTION);\n    externFunction.putBooleanProp(Node.IS_EXPORTED, true);\n    externFunction.setSourceFileName(exportedFunction.getSourceFileName());\n    externFunction.setStaticSourceFile(exportedFunction.getStaticSourceFile());\n    externFunction.setLineno(exportedFunction.getLineno());\n    externFunction.setCharno(exportedFunction.getCharno());\n\n    // Copy the name and parameters from the exported function\n    externFunction.setOriginalName(exportedFunction.getOriginalName());\n    externFunction.setLength(exportedFunction.getLength());\n    externFunction.setType(exportedFunction.getType());\n    externFunction.setSourceFileName(exportedFunction.getSourceFileName());\n    externFunction.setStaticSourceFile(exportedFunction.getStaticSourceFile());\n    externFunction.setLineno(exportedFunction.getLineno());\n    externFunction.setCharno(exportedFunction.getCharno());\n\n    // Copy the parameters from the exported function\n    for (Node param : exportedFunction.children()) {\n        if (param.getType() == Token.PARAM_LIST) {\n            for (Node child : param.children()) {\n                externFunction.addChildToBack(child.cloneNode());\n            }\n        }\n    }\n\n    // Create a new function body\n    Node block = new Node(Token.BLOCK);\n    externFunction.addChildToBack(block);\n\n    // Create a new return node\n    Node returnNode = new Node(Token.RETURN);\n    block.addChildToBack(returnNode);\n\n    // Create a new return value\n    Node returnValue = new Node(Token.RETURN);\n    returnNode.addChildToBack(returnValue);\n\n    // Create a new null node\n    Node nullNode = new Node(Token.NULL);\n    returnValue.addChildToBack(nullNode);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = new Node(Token.FUNCTION);\n    Node name = exportedFunction.getFirstChild();\n    Node params = name.getNext();\n    Node body = params.getNext();\n    Node returnType = body.getNext();\n    Node type = exportedFunction.getFirstChild();\n    Node param = type.getNext();\n    Node paramName = param.getFirstChild();\n    Node paramType = paramName.getNext();\n    Node paramTypeName = paramType.getFirstChild();\n    Node paramTypeNameName = paramTypeName.getFirstChild();\n    Node paramTypeNameNameName = paramTypeNameName.getFirstChild();\n    Node paramTypeNameNameNameName = paramTypeNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameName = paramTypeNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameName = paramTypeNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameName = paramTypeNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameNameNameNameNameName.getFirstChild();\n    Node paramTypeNameNameNameNameNameNameNameNameNameNameNameNameNameName = paramTypeNameNameNameNameNameNameNameNameNameNameNameNameName.getFirstChild();\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node.\n    Node newFunction = new Node(Token.FUNCTION);\n\n    // Set the function name.\n    newFunction.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n\n    // Copy the function name.\n    newFunction.setStringProp(Node.ORIGINALNAME_PROP,\n        exportedFunction.getStringProp(Node.ORIGINALNAME_PROP));\n\n    // Copy the function parameters.\n    for (Node param : exportedFunction.children()) \n    {\n        // Create a new parameter node.\n        Node newParam = new Node(Token.PARAM_LIST);\n\n        // Copy the parameter name.\n        newParam.setStringProp(Node.ORIGINALNAME_PROP,\n            param.getStringProp(Node.ORIGINALNAME_PROP));\n\n        // Add the parameter to the new function.\n        newFunction.addChildToBack(newParam);\n    }\n\n    // Copy the function return type.\n    newFunction.setStringProp(Node.RETURN_TYPE_PROP,\n        exportedFunction.getStringProp(Node.RETURN_TYPE_PROP));\n\n    // Copy the function parameter types.\n    newFunction.setStringProp(Node.PARAMETER_TYPES_PROP,\n        exportedFunction.getStringProp(Node.PARAMETER_TYPES_PROP));\n\n    // Copy the function return type.\n    newFunction.setStringProp(Node.RETURN_TYPE_PROP,\n        exportedFunction.getStringProp(Node.RETURN_TYPE_PROP));\n\n    // Copy the function parameter types.\n    newFunction.setStringProp(Node.PARAMETER_TYPES_PROP,\n        exportedFunction.getStringProp(Node.PARAMETER_TYPES_PROP));\n\n    // Copy the function parameter names.\n    newFunction.setStringProp(Node.PARAMETER_NAMES_PROP,\n        exportedFunction.getStringProp(Node.PARAMETER_NAMES_PROP));\n\n    // Copy the function parameter types.\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // create the function node\n    Node function = IR.function(\n        IR.name(\"\"),\n        IR.paramList(IR.empty()),\n        IR.block());\n\n    // copy the function name\n    function.putBooleanProp(Node.IS_NAMESPACE, exportedFunction.getBooleanProp(Node.IS_NAMESPACE));\n    function.setOriginalName(exportedFunction.getOriginalName());\n\n    // copy the parameter names\n    Node exportedParams = exportedFunction.getSecondChild();\n    Node params = function.getSecondChild();\n    for (Node param = exportedParams.getFirstChild(); param != null;\n        param = param.getNext()) {\n      Node newParam = IR.name(param.getString());\n      newParam.copyInformationFrom(param);\n      params.addChildToBack(newParam);\n    }\n\n    // copy the return type\n    function.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n    // copy the function body\n    function.getLastChild().setJSType(exportedFunction.getLastChild().getJSType());\n\n    return function;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    checkState(exportedFunction.isFunction());\n    FunctionType functionType = exportedFunction.getJSType().toMaybeFunctionType();\n    checkNotNull(functionType);\n\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList());\n    externFunction.setJSType(functionType);\n\n    if (functionType.getReturnType() == null) {\n      compiler.report(JSError.make(exportedFunction, EXTERNS_WITH_MISSING_TYPE));\n    }\n\n    for (Node param : exportedFunction.getSecondChild().children()) {\n      Node name = param.getFirstChild();\n      if (name.isName()) {\n        Node paramNode = IR.param(name.getString(), IR.empty());\n        externFunction.getSecondChild().addChildToBack(paramNode);\n        if (functionType.getParameterType(name.getString()) == null) {\n          compiler.report(JSError.make(exportedFunction, EXTERNS_WITH_MISSING_TYPE));\n        }\n      } else {\n        compiler.report(JSError.make(exportedFunction, EXTERNS_WITH_MISSING_TYPE));\n      }\n    }\n\n    return externFunction;\n  }",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Check if the function has a return type\n    if (exportedFunction.getReturnType() == null) {\n        compiler.report(JSError.make(exportedFunction, EXTERNS_MISSING_RETURN_TYPE));\n    }\n\n    // Create a new function node with the same name and parameters\n    // as the exported function\n    Node newFunction = new Node(Token.FUNCTION);\n    newFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n    newFunction.setSourceFileName(exportedFunction.getSourceFileName());\n    newFunction.setIsSyntheticExtern(true);\n    newFunction.setIsExtern(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n    newFunction.setIsFromExterns(true);\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(exportedFunction.getFirstChild(), exportedFunction.getSecondChild(), IR.paramList());\n  externFunction.useSourceInfoIfMissingFromForTree(exportedFunction);\n  externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n  externFunction.setDeclaredTypeExpression(exportedFunction.getDeclaredTypeExpression());\n  externFunction.setDeclaredTypeExpressionInfo(exportedFunction.getDeclaredTypeExpressionInfo());\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getToken(),\n        exportedFunction.getFirstChild().cloneNode(),\n        IR.paramList(exportedFunction.getSecondChild().cloneNode()));\n\n    JSDocInfoBuilder jsDocBuilder = new JSDocInfoBuilder(true);\n    jsDocBuilder.recordType(exportedFunction.getJSDocInfo().getType());\n    jsDocBuilder.recordParameter(exportedFunction.getSecondChild().getString(),\n        exportedFunction.getJSDocInfo().getType());\n    jsDocBuilder.recordReturnType(exportedFunction.getJSDocInfo().getType());\n    externFunction.setJSDocInfo(jsDocBuilder.build());\n\n    return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final RealMatrix covariance = computeCovariances(params, covarianceSingularityThreshold);\n        final int n = covariance.getRowDimension();\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(covariance.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariances = computeCovariances(params,\n                                                    covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(computeCovariances(params,\n                                                    covarianceSingularityThreshold)[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final double[][] covariances = computeCovariances(params,\n                                                      covarianceSingularityThreshold);\n    final double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final double[][] covariances = computeCovariances(params,\n                                                          covarianceSingularityThreshold);\n        final int n = covariances.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = Math.sqrt(getCovariances(params, covarianceSingularityThreshold)[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n        final int n = cov.getRowDimension();\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(cov.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariances = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // compute covariance matrix\n    final double[][] covariance = computeCovariances(params,\n                                                     covarianceSingularityThreshold);\n    // extract diagonal coefficients\n    final double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(computeCovariances(params, covarianceSingularityThreshold)[i][i]);\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"cyclic substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"cyclic substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"cyclic substitution\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected\");\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    Deque<INPUT> stack = new ArrayDeque<INPUT>();\n    stack.addAll(roots);\n\n    while (!stack.isEmpty()) {\n        INPUT input = stack.pop();\n        if (visited.add(input)) {\n            result.add(input);\n            stack.addAll(getDependencies(input));\n        }\n    }\n\n    if (sorted) {\n        Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this method.\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    Queue<INPUT> queue = new LinkedList<INPUT>();\n    for (INPUT root : roots) {\n      queue.add(root);\n    }\n    while (!queue.isEmpty()) {\n      INPUT current = queue.remove();\n      if (visited.add(current)) {\n        result.add(current);\n        for (INPUT dep : getDependencies(current)) {\n          queue.add(dep);\n        }\n      }\n    }\n    if (sorted) {\n      Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    if (sorted) {\n        // Use a topological sort to get them in the correct order.\n        result.addAll(topologicalSort(roots));\n    } else {\n        // Just return them in the order they were passed in.\n        result.addAll(roots);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this.\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // TODO: Implement this method.\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // TODO: Implement this method\n  return null;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Implement this method\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n\n    boolean uncapitalizeNext = true;\n    for (int offset = 0, codePoint = 0; offset < strLen; offset += Character.charCount(codePoint)) \n    {\n        codePoint = str.codePointAt(offset);\n        if (uncapitalizeNext || (delimLen > 0 && isDelimiter(codePoint, delimiters))) \n        {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            newCodePoints[outOffset++] = codePoint;\n        }\n\n        if (Character.isHighSurrogate(codePoint)) \n        {\n            offset++;\n        }\n    }\n\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n\n    final int len = str.length();\n    final int[] uncapitalizeArray = new int[len];\n    for (int i = 0; i < len; i++) {\n        uncapitalizeArray[i] = Character.isUpperCase(str.charAt(i)) ? 1 : 0;\n    }\n\n    for (final char delimiter : delimiters) {\n        int j = 0;\n        while (j < len) {\n            j = str.indexOf(delimiter, j);\n            if (j != -1) {\n                if (j + 1 < uncapitalizeArray.length) {\n                    uncapitalizeArray[j + 1] = 1;\n                }\n                j++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    final StringBuilder uncapitalizedBuilder = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        if (i == 0 || uncapitalizeArray[i - 1] == 1) {\n            uncapitalizedBuilder.append(Character.toLowerCase(str.charAt(i)));\n        } else {\n            uncapitalizedBuilder.append(str.charAt(i));\n        }\n    }\n    return uncapitalizedBuilder.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    boolean uncapitalizeNext = true;\n    int cp;\n    for (int offset = 0; offset < strLen;) {\n        cp = str.codePointAt(offset);\n        offset += Character.charCount(cp);\n        if (uncapitalizeNext || (delimLen > 0 && Character.isWhitespace(cp))) {\n            newCodePoints[outOffset++] = Character.toLowerCase(cp);\n            uncapitalizeNext = false;\n        } else if (delimLen > 0 && Arrays.binarySearch(delimiters, cp) >= 0) {\n            newCodePoints[outOffset++] = cp;\n            uncapitalizeNext = true;\n        } else {\n            newCodePoints[outOffset++] = cp;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) \n    {\n        codePoint = str.codePointAt(offset);\n        boolean isDelimiter = false;\n        if (delimLen > 0) \n        {\n            for (int i = 0; i < delimLen; i++) \n            {\n                if (Character.toLowerCase(delimiters[i]) == Character.toLowerCase(codePoint)) \n                {\n                    isDelimiter = true;\n                    break;\n                }\n            }\n        }\n        if (Character.isTitleCase(codePoint) && !isDelimiter) \n        {\n            codePoint = Character.toLowerCase(codePoint);\n        }\n        newCodePoints[outOffset++] = codePoint;\n    }\n    if (outOffset == strLen) \n    {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = 0;\n    if (delimiters != null && delimiters.length > 0) \n    {\n        delimLen = delimiters.length;\n    }\n\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n\n    char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        char ch = buffer[i];\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (delimLen == 0) {\n        return str.substring(0, 1).toLowerCase(Locale.ROOT) + str.substring(1);\n    }\n\n    final int len = str.length();\n    final int[] newCodePoints = new int[len];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < len; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        if (offset == 0 || isDelimiter(codePoint, delimiters)) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n    int len = str.length();\n    int strPos = 0;\n    char[] buffer = new char[len];\n    boolean capitalizeNext = true;\n    while (strPos < len) \n    {\n        char ch = str.charAt(strPos);\n        if (isDelimiter(ch, delimiters)) \n        {\n            buffer[strPos] = ch;\n            strPos++;\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[strPos] = Character.toLowerCase(ch);\n            strPos++;\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[strPos] = ch;\n            strPos++;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = (delimiters == null ? -1 : delimiters.length);\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        if (offset == 0 || isDelimiter(codePoint, delimiters)) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return Character.toLowerCase(str.charAt(0)) + str.substring(1);\n    }\n    int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer[i] = ch;\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    int delimLen = 0;\n    if (delimiters != null && delimiters.length > 0) \n    {\n        delimLen = delimiters.length;\n    }\n\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n\n    boolean capitalizeNext = true;\n    int cp;\n    for (int offset = 0; offset < strLen;) \n    {\n        cp = str.codePointAt(offset);\n        offset += Character.charCount(cp);\n\n        if (Character.isWhitespace(cp) || StringUtils.contains(delimiters, cp)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            newCodePoints[outOffset++] = Character.toLowerCase(cp);\n            capitalizeNext = false;\n        } \n        else \n        {\n            newCodePoints[outOffset++] = cp;\n        }\n    }\n\n    return new String(newCodePoints, 0, outOffset);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.multiply(0.5);\n    result[1] = a.multiply(0.5);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.div(2);\n    result[1] = a.div(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.div(2);\n    result[1] = a.div(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.div(2);\n    result[1] = a.div(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.div(2);\n    result[1] = a.div(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[] {a, a};\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.divide(2);\n    result[1] = a.divide(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.divide(2);\n    result[1] = a.divide(2);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[] {a.divide(2), a.divide(2)};\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return new Dfp[]{a.divide(2), a.divide(2)};\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id != null) \n    {\n        return \"#\" + id;\n    }\n    else \n    {\n        if (parent == null) \n        {\n            return tagName;\n        }\n        else \n        {\n            return parent.cssSelector() + \">\" + tagName;\n        }\n    }\n}",
      "public String cssSelector()  {\n    String cssSelector = \"\";\n    if (this.getId() != null && !this.getId().isEmpty())\n    {\n        cssSelector = \"#\" + this.getId();\n    }\n    else\n    {\n        if (this.getParent() != null)\n        {\n            cssSelector = this.getParent().cssSelector();\n        }\n        cssSelector += \">\" + this.getTagName();\n        if (this.getClasses().size() > 0)\n        {\n            cssSelector += \".\" + String.join(\".\", this.getClasses());\n        }\n        if (this.getNthChildIndex() > 0)\n        {\n            cssSelector += \":nth-child(\" + this.getNthChildIndex() + \")\";\n        }\n    }\n    return cssSelector;\n}",
      "public String cssSelector()  {\n    String cssSelector = \"\";\n    if (this.id != null) \n    {\n        cssSelector = \"#\" + this.id;\n    }\n    else \n    {\n        if (this.parent != null) \n        {\n            cssSelector = this.parent.cssSelector() + \" > \";\n        }\n        cssSelector += this.tagName;\n        if (this.classes.size() > 0) \n        {\n            cssSelector += \".\" + String.join(\".\", this.classes);\n        }\n        if (this.parent != null && this.parent.children.indexOf(this) != this.parent.children.size() - 1) \n        {\n            cssSelector += \":nth-child(\" + (this.parent.children.indexOf(this) + 1) + \")\";\n        }\n    }\n    return cssSelector;\n}",
      "public String cssSelector()  {\n    if (id != null) {\n        return \"#\" + id;\n    }\n    String parentCss = parent == null ? \"\" : parent.cssSelector();\n    String tagName = tag == null ? \"\" : tag;\n    String className = className == null ? \"\" : \".\" + className;\n    String classNames = className == null ? \"\" : className.replace(\".\", \".\");\n    String nthChild = \"\";\n    if (parent != null) {\n        int count = 1;\n        for (Element sibling : parent.children) {\n            if (sibling.tag.equals(tag) && sibling.className.equals(className)) {\n                count++;\n            }\n        }\n        nthChild = \":nth-child(\" + count + \")\";\n    }\n    return parentCss + \">\" + tagName + className + nthChild;\n}",
      "public String cssSelector()  {\n    if (id != null) {\n        return \"#\" + id;\n    }\n    String cssSelector = tagName;\n    if (className != null) {\n        cssSelector += \".\" + className;\n    }\n    if (parent != null) {\n        cssSelector = parent.cssSelector() + \" > \" + cssSelector;\n    }\n    return cssSelector;\n}",
      "public String cssSelector()  {\n    String cssSelector = \"\";\n    if (id != null) {\n        cssSelector = \"#\" + id;\n    } else {\n        cssSelector = parent == null ? tag : parent.cssSelector() + \">\" + tag;\n        if (classes != null) {\n            for (String clazz : classes) {\n                cssSelector += \".\" + clazz;\n            }\n        }\n        if (attributes != null) {\n            for (String key : attributes.keySet()) {\n                cssSelector += \"[\" + key + \"=\\\"\" + attributes.get(key) + \"\\\"]\";\n            }\n        }\n        cssSelector += \":nth-child(\" + nthChild + \")\";\n    }\n    return cssSelector;\n}",
      "public String cssSelector()  {\n    if (id != null) {\n        return \"#\" + id;\n    }\n    if (parent == null) {\n        return tagName;\n    }\n    return parent.cssSelector() + \" > \" + tagName;\n}",
      "public String cssSelector()  {\n        if (id != null) {\n            return \"#\" + id;\n        }\n        else {\n            if (parent == null) {\n                return tagName;\n            }\n            else {\n                return parent.cssSelector() + \">\" + tagName;\n            }\n        }\n    }",
      "public String cssSelector()  {\n        if (id != null) {\n            return \"#\" + id;\n        }\n        if (parent == null) {\n            return tagName;\n        }\n        String parentCss = parent.cssSelector();\n        String myCss = tagName;\n        if (classes.size() > 0) {\n            myCss += \".\" + String.join(\".\", classes);\n        }\n        if (parentCss.equals(myCss)) {\n            return parentCss;\n        }\n        return parentCss + \">\" + myCss;\n    }",
      "public String cssSelector()  {\n    if (id != null && !id.isEmpty()) {\n        return \"#\" + id;\n    }\n    if (parent == null) {\n        return tagName;\n    }\n    String parentCss = parent.cssSelector();\n    if (parentCss.isEmpty()) {\n        return tagName;\n    }\n    return parentCss + \">\" + tagName;\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n instanceof Not) {\n        cost = 1;\n    } else if (n instanceof And || n instanceof Or) {\n        cost = 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Node.NOT) {\n        return 1;\n    }\n    else if (n.getType() == Node.AND || n.getType() == Node.OR) {\n        return 2;\n    }\n    else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n instanceof Not) {\n        cost = 1;\n    } else if (n instanceof And || n instanceof Or) {\n        cost = 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n instanceof Not) {\n        return 1;\n    } else if (n instanceof And || n instanceof Or) {\n        return 2;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n instanceof Not) {\n        cost++;\n    }\n    if (n instanceof Parentheses) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n instanceof Not) \n    {\n        cost = 1;\n    } \n    else if (n instanceof And || n instanceof Or) \n    {\n        cost = 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n instanceof Not) \n    {\n        return 1;\n    }\n    else if (n instanceof And || n instanceof Or) \n    {\n        return 2;\n    }\n    else if (n instanceof Parentheses) \n    {\n        return 1;\n    }\n    else \n    {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n instanceof Not) {\n        cost++;\n    } else if (n instanceof And || n instanceof Or) {\n        cost += 2;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n instanceof Not) {\n        return 1;\n    }\n    if (n instanceof And || n instanceof Or) {\n        return 2;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n instanceof Not) \n    {\n        return 1;\n    } \n    else if (n instanceof And || n instanceof Or) \n    {\n        return 2;\n    } \n    else if (n instanceof Parentheses) \n    {\n        return 1;\n    } \n    else \n    {\n        return 0;\n    }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    if (size() < 2) \n    {\n        return this;\n    }\n    int half = size() / 2;\n    for (int i = 0, j = size() - 1; i < half; i++, j--) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size() < 2) \n    {\n        return this;\n    }\n    int half = size() / 2;\n    for (int i = 0, j = size() - 1; i < half; i++, j--) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int size = size();\n    for (int i = 0, j = size - 1; j > i; i++, j--) \n    {\n        swap(i, j);\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int size = size();\n    if (size <= 1) {\n        return this;\n    }\n    int mid = size / 2;\n    for (int i = 0, j = size - 1; i < mid; i++, j--) {\n        swap(i, j);\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int size = size();\n    for (int i = 0; i < size / 2; i++) \n    {\n        int other = size - i - 1;\n        char c = buffer[i];\n        buffer[i] = buffer[other];\n        buffer[other] = c;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size() - 1;\n    while (j > i) \n    {\n        swap(i++, j--);\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (buffer.length < 2) {\n        return this;\n    }\n    int half = buffer.length / 2;\n    for (int i = 0, j = buffer.length - 1; i < half; i++, j--) {\n        char temp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size() - 1;\n    while (j > i) \n    {\n        swap(i++, j--);\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int size = size();\n    if (size <= 1) {\n        return this;\n    }\n    int mid = size / 2;\n    for (int i = 0, j = size - 1; j > mid; i++, j--) {\n        swap(i, j);\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size() - 1;\n    while (j > i) \n    {\n        swap(i, j);\n        j--;\n        i++;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == y;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if (x == null || y == null) {\n        return x == null && y == null;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; i++) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    TextNode newTextNode = new TextNode(this.getOwnerDocument(), this.getNodeValue().substring(offset));\n    this.setNodeValue(this.getNodeValue().substring(0, offset));\n    this.getParentNode().insertBefore(newTextNode, this.getNextSibling());\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    TextNode newTextNode = new TextNode(this.getOwnerDocument(), this.getNodeValue().substring(offset));\n    this.setNodeValue(this.getNodeValue().substring(0, offset));\n    this.getParentNode().insertBefore(newTextNode, this.getNextSibling());\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public TextNode splitText(int offset)  {\n    // Create a new text node with the remaining text after the offset\n    TextNode newTextNode = new TextNode(this.text.substring(offset));\n    // Set the text of this node to the original text up to the offset\n    this.text = this.text.substring(0, offset);\n    // Add the new node after this node\n    this.parentNode.insertAfter(newTextNode, this);\n    // Return the new node\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > this.getNodeValue().length()) \n    {\n        throw new IndexOutOfBoundsException(\"offset \" + offset + \" is outside the bounds of the node\");\n    }\n    String text = this.getNodeValue();\n    String splitText = text.substring(offset);\n    this.setNodeValue(text.substring(0, offset));\n    TextNode newNode = this.getOwnerDocument().createTextNode(splitText);\n    this.getParentNode().insertBefore(newNode, this.getNextSibling());\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    // TODO: Implement this method\n}",
      "public TextNode splitText(int offset)  {\n    // Create a new text node with the remaining text after the offset\n    TextNode newTextNode = new TextNode(this.text.substring(offset));\n\n    // Update this node to contain the original text up to the offset\n    this.text = this.text.substring(0, offset);\n\n    // Add the new text node as a sibling after this node\n    this.parentNode.appendChild(newTextNode);\n\n    // Return the new text node\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public TextNode splitText(int offset)  {\n    // Split this text node into two nodes at the specified string offset.\n    // After splitting, this node will contain the original text up to the offset,\n    // and will have a new text node sibling containing the text after the offset.\n    // Return the newly created text node containing the text after the offset.\n    // \n    // Hint: You can use the TextNode constructor to create a new text node with the text after the offset.\n    // Hint: You can use the Node.insertBefore() method to insert the new text node after this node.\n    // Hint: You can use the Node.setNodeValue() method to set the text of this node to the original text up to the offset.\n    // Hint: You can use the Node.getNodeValue() method to get the text of this node.\n    // Hint: You can use the Node.getParentNode() method to get the parent node of this node.\n    // Hint: You can use the Node.getNextSibling() method to get the next sibling of this node.\n    // Hint: You can use the Node.appendChild() method to append the new text node to the parent node.\n    // Hint: You can use the Node.insertBefore() method to insert the new text node before the next sibling of this node.\n    // Hint: You can use the Node.getNodeValue() method to get the text of the new text node.\n    // Hint: You can use the Node.setNodeValue() method to set the text of the new text node.\n    // Hint: You can use the Node.getParentNode() method to get the parent node of the new text node.\n    // Hint: You can use the Node.getNextSibling() method to get the next sibling of the new text node.\n    // Hint: You can use the Node.insertBefore() method to insert the new text node before the next sibling of the new text node.\n    // Hint: You can use the Node.getNodeValue() method to get the text of the new text node.\n    // Hint: You can use the Node.setNodeValue() method to set the text of the new text node.\n}",
      "public TextNode splitText(int offset)  {\n    // TODO: Implement this method\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = union(a, b);\n    final Collection<O> intersection = intersection(a, b);\n    return subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new HashSet<O>();\n    for (final O o : a) {\n        if (Collections.frequency(a, o) > Collections.frequency(b, o)) {\n            result.add(o);\n        }\n    }\n    for (final O o : b) {\n        if (Collections.frequency(b, o) > Collections.frequency(a, o)) {\n            result.add(o);\n        }\n    }\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    for (final O o : a) \n    {\n        if (Collections.frequency(a, o) > Collections.frequency(b, o)) \n        {\n            result.add(o);\n        }\n    }\n    for (final O o : b) \n    {\n        if (Collections.frequency(b, o) > Collections.frequency(a, o)) \n        {\n            result.add(o);\n        }\n    }\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] tmp = value.toByteArray();\n    int bytesLength = tmp.length;\n    if (bytesLength > 8) {\n        throw new IllegalArgumentException(\"Input too large to convert to byte array of length 8\");\n    }\n    int bytesOffset = 8 - bytesLength;\n    for (int i = 0; i < bytesLength; i++) {\n        bytes[i + bytesOffset] = tmp[i];\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[i] = value.byteValue();\n        value.shiftRight(8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length == 16) {\n        return bytes;\n    } else if (bytes.length > 16) {\n        byte[] tmp = new byte[16];\n        System.arraycopy(bytes, bytes.length - 16, tmp, 0, 16);\n        return tmp;\n    } else {\n        byte[] tmp = new byte[16];\n        System.arraycopy(bytes, 0, tmp, 16 - bytes.length, bytes.length);\n        return tmp;\n    }\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] == 0) \n    {\n        byte[] temp = new byte[bytes.length - 1];\n        System.arraycopy(bytes, 1, temp, 0, temp.length);\n        return temp;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length == 8) {\n        return bytes;\n    }\n    if (bytes.length > 8) {\n        throw new IllegalArgumentException(\"Input too large to convert to eight bytes\");\n    }\n    byte[] paddedBytes = new byte[8];\n    int offset = paddedBytes.length - bytes.length;\n    System.arraycopy(bytes, 0, paddedBytes, offset, bytes.length);\n    return paddedBytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] == 0) \n    {\n        byte[] temp = new byte[bytes.length - 1];\n        System.arraycopy(bytes, 1, temp, 0, temp.length);\n        return temp;\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    return value.toByteArray();\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (str == null || set == null || set.length == 0) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (chars.contains(c)) {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || set == null || set.length == 0) \n    {\n        return str;\n    }\n    return evaluateSet(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || set == null || set.length == 0) {\n        return str;\n    }\n    final CharSet keepSet = CharSet.getInstance(set);\n    return evaluateSet(str, keepSet);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || str.length() == 0 || set == null || set.length == 0) \n    {\n        return str;\n    }\n    final int sz = set.length;\n    final char[] chs = new char[sz];\n    for (int i = 0; i < sz; i++) \n    {\n        chs[i] = set[i].charAt(0);\n    }\n    return keep(str, chs);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || str.length() == 0 || set == null || set.length == 0) \n    {\n        return str;\n    }\n    final CharSet keep = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) \n    {\n        if (keep.contains(str.charAt(i))) \n        {\n            builder.append(str.charAt(i));\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || set == null || set.length == 0) {\n        return str;\n    }\n    final CharSet keep = CharSet.getInstance(set);\n    return keep.retain(str);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || str.length() == 0 || set == null || set.length == 0) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) \n    {\n        if (chars.contains(str.charAt(i))) \n        {\n            builder.append(str.charAt(i));\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || str.isEmpty() || set == null || set.length == 0) {\n        return str;\n    }\n    final StringBuilder builder = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (CharSet.getInstance(set).contains(c)) {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || set == null || set.length == 0) {\n        return str;\n    }\n    final String[] accept = set;\n    return evaluateSet(str, accept, false);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (str == null || str.isEmpty() || set == null || set.length == 0) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    return evaluateSet(str, chars, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    return new CholeskyDecomposition(this).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC,\n            getClass().getSimpleName());\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE,\n            getClass().getSimpleName());\n    }\n    final RealMatrix sqrt = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final double[] eigenValues = eigen.getRealEigenvalues();\n    final RealMatrix eigenVectors = eigen.getV();\n    for (int i = 0; i < eigenValues.length; ++i) {\n        final double eigenValue = eigenValues[i];\n        final RealMatrix eigenVector = eigenVectors.getSubMatrix(i, i, 0, eigenVectors.getColumnDimension() - 1);\n        final RealMatrix sqrtEigenVector = new Array2DRowRealMatrix(eigenVector.getColumnDimension(), eigenVector.getColumnDimension());\n        for (int j = 0; j < eigenVector.getColumnDimension(); ++j) {\n            sqrtEigenVector.setEntry(j, j, Math.sqrt(eigenValue));\n        }\n        sqrt.setSubMatrix(sqrtEigenVector.multiply(eigenVector.transpose()).getData(), i, 0);\n    }\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Compute the Cholesky decomposition of the matrix.\n    RealMatrix l = new CholeskyDecomposition(this).getL();\n\n    // Compute the inverse of the matrix.\n    RealMatrix inv = new LUDecomposition(l).getSolver().getInverse();\n\n    // Compute the square-root of the matrix.\n    RealMatrix sqrt = new LUDecomposition(inv).getSolver().getInverse();\n\n    // Return the square-root of the matrix.\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n\n    RealMatrix result = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n\n    for (int i = 0; i < getRowDimension(); i++) {\n        for (int j = 0; j < getColumnDimension(); j++) {\n            result.setEntry(i, j, FastMath.sqrt(getEntry(i, j)));\n        }\n    }\n\n    return result;\n}",
      "public RealMatrix getSquareRoot()  {\n\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // Compute the Cholesky decomposition\n    final RealMatrix l = new CholeskyDecomposition(this).getL();\n\n    // Compute the square-root of the diagonal elements\n    final double[] sqrtDiag = new double[l.getRowDimension()];\n    for (int i = 0; i < sqrtDiag.length; ++i) {\n        sqrtDiag[i] = FastMath.sqrt(l.getEntry(i, i));\n    }\n\n    // Compute the square-root of the matrix\n    final RealMatrix sqrt = new Array2DRowRealMatrix(l.getRowDimension(),\n            l.getColumnDimension());\n    for (int i = 0; i < sqrt.getRowDimension(); ++i) {\n        for (int j = 0; j < i; ++j) {\n            sqrt.setEntry(i, j, l.getEntry(i, j));\n        }\n        sqrt.setEntry(i, i, sqrtDiag[i]);\n    }\n\n    return sqrt.multiply(sqrt.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n\n    // Retrieve the Cholesky decomposition of the matrix\n    CholeskyDecomposition cholesky = new CholeskyDecomposition(this);\n\n    // Compute the square-root of the Cholesky decomposition\n    RealMatrix squareRoot = cholesky.getL().getPower(0.5);\n\n    // Return the square-root of the matrix\n    return squareRoot;\n\n}",
      "public RealMatrix getSquareRoot()  {\n    // check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC);\n    }\n\n    // compute the Cholesky decomposition\n    RealMatrix l = new CholeskyDecomposition(this).getL();\n\n    // compute the Cholesky decomposition of the inverse\n    RealMatrix lInv = new CholeskyDecomposition(this.inverse()).getL();\n\n    // compute the matrix square-root\n    RealMatrix sqrt = l.multiply(lInv.transpose());\n\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n\n    // Compute the Cholesky decomposition of the matrix.\n    RealMatrix l = new CholeskyDecomposition(this).getL();\n\n    // Compute the square-root of the diagonal elements of the Cholesky\n    // decomposition.\n    for (int i = 0; i < l.getRowDimension(); ++i) {\n        l.setEntry(i, i, FastMath.sqrt(l.getEntry(i, i)));\n    }\n\n    // Compute the inverse of the Cholesky decomposition.\n    RealMatrix lT = l.transpose();\n    RealMatrix invL = new LUDecomposition(lT).getSolver().getInverse();\n\n    // Compute the square-root of the matrix.\n    return invL.multiply(l);\n\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    final RealMatrix sqrt = new Array2DRowRealMatrix(getRowDimension(), getColumnDimension());\n    final double[][] data = getData();\n    final double[][] sqrtData = sqrt.getData();\n    for (int i = 0; i < getRowDimension(); i++) {\n        for (int j = i; j < getColumnDimension(); j++) {\n            sqrtData[i][j] = Math.sqrt(data[i][j]);\n            sqrtData[j][i] = sqrtData[i][j];\n        }\n    }\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    return new CholeskyDecomposition(this).getSquareRoot();\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return _parseArray(p, ctxt, t);\n        case START_OBJECT:\n            return _parseObject(p, ctxt, t);\n        case END_ARRAY:\n        case END_OBJECT:\n        case FIELD_NAME:\n        case NOT_AVAILABLE:\n            return _handleUnexpectedToken(p, ctxt, t, \"current token not value\");\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_NULL:\n            return _deserializeNull(p, ctxt);\n        }\n        return null;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case START_ARRAY:\n            return _deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return _deserializeFromObject(p, ctxt);\n        default:\n        }\n        throw ctxt.mappingException(handledType(), t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            String str = p.getText().trim();\n            if (str.length() == 0) {\n                if (_features.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                    return getNullValue(ctxt);\n                }\n                if (_features.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                    return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n                }\n            }\n            return str;\n        }\n        if (t == JsonToken.START_ARRAY) {\n            if (_valueTypeDeserializer != null) {\n                return _deserializeWithType(p, ctxt);\n            }\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            if (_valueTypeDeserializer != null) {\n                return _deserializeWithType(p, ctxt);\n            }\n            return _deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return _coerceIntegral(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return getNullValue(ctxt);\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case START_ARRAY:\n            return _deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return _deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n            // should not get these\n            throw ctxt.wrongTokenException(p, handledType(), t,\n                    \"Attempted to unwrap '%s' value\",\n                    t);\n        case FIELD_NAME:\n            // 18-Mar-2019, tatu: [databind#2128]\n            return _handleUnknown(p, ctxt, t);\n        default:\n        }\n        throw ctxt.wrongTokenException(p, handledType(), t,\n                \"Current token (%s), not VALUE_STRING, not VALUE_NUMBER_INT, not VALUE_NUMBER_FLOAT, not VALUE_TRUE, not VALUE_FALSE, not VALUE_NULL, not START_ARRAY, not START_OBJECT (%s)\",\n                t, _coercionDesc());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText();\n            if (_hasTextualNull(text)) {\n                return getNullValue(ctxt);\n            }\n            if (_checkFromString(ctxt, text)) {\n                return _fromString(p, ctxt, text);\n            }\n        }\n        return _deserialize(p, ctxt);\n    }\n    \n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText();\n            if (_hasTextualNull(text)) {\n                return getNullValue(ctxt);\n            }\n            if (_checkFromString(ctxt, text)) {\n                return _fromString(p, ctxt, text);\n            }\n        }\n        return _deserialize(p, ctxt);\n    }\n    \n    protected Object _fromString(JsonParser p, DeserializationContext ctxt, String text) throws IOException {\n        if (_checkFromString(ctxt, text)) {\n            return _fromString(p, ctxt, text);\n        }\n        return _deserialize(p, ctxt);\n    }\n    \n    protected Object _fromString(JsonParser p, DeserializationContext ctxt, String text) throws IOException {\n        if (_checkFromString(ctxt, text)) {\n            return _fromString(p, ctxt, text);\n        }\n        return _deserialize(p, ctxt);\n    }\n    \n    protected Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText();\n            if (_hasTextualNull(text)) {\n                return getNullValue(ctxt);\n            }\n            if (_checkFromString(ctxt, text)) {\n                return _fromString(p, ctxt, text);\n            }\n        }\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        case START_ARRAY:\n            return _deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return _deserializeFromObject(p, ctxt);\n        default:\n        }\n        throw ctxt.mappingException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return _deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return _deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n            // should not get these\n            break;\n        case FIELD_NAME:\n            // should not get this\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_NULL:\n            return null;\n        default:\n        }\n        throw ctxt.mappingException(_valueClass, t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return _parseArray(p, ctxt, t);\n        case START_OBJECT:\n            return _parseObject(p, ctxt, t);\n        case END_ARRAY:\n        case END_OBJECT:\n        case FIELD_NAME:\n        case NOT_AVAILABLE:\n            return _handleUnexpectedToken(p, ctxt, t,\n                    \"Current token (\"+t+\") not applicable for deserialization\");\n        }\n        return _handleUnexpectedToken(p, ctxt, t,\n                \"Current token (\"+t+\") not applicable for deserialization\");\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return _parseString(p, ctxt, t);\n        case VALUE_NUMBER_INT:\n            return _parseInteger(p, ctxt, t);\n        case VALUE_NUMBER_FLOAT:\n            return _parseFloat(p, ctxt, t);\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return _deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return _deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n            return _handleEndArray(p, ctxt);\n        case END_OBJECT:\n            return _handleEndObject(p, ctxt);\n        case FIELD_NAME:\n            return _handleFieldName(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return _handleEmbeddedObject(p, ctxt);\n        case VALUE_NULL:\n            return _handleNullValue(p, ctxt);\n        case NOT_AVAILABLE: // should only get this for START_OBJECT?\n            break;\n        }\n        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            String text = p.getText();\n            if (text.length() == 0) {\n                return _coerceEmptyString(ctxt, false);\n            }\n            if (_hasTextualNull(text)) {\n                return _coerceTextualNull(ctxt, false);\n            }\n            if (_cfgHandleTwoSlashes && text.startsWith(\"//\")) {\n                return _deserializeFromDoubleSlashes(p, ctxt, text);\n            }\n            if (_cfgHandleSingleSlash && text.startsWith(\"/\")) {\n                return _deserializeFromSlash(p, ctxt, text);\n            }\n            if (_cfgHandlePeriod) {\n                return _deserializeFromPeriod(p, ctxt, text);\n            }\n        }\n        return _deserializeOther(p, ctxt);\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // TODO: Implement this method\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // Check that arrays are non-empty\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n\n    // Check that arrays are of the same length\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException();\n    }\n\n    // Compute sum of paired differences\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // TODO: Implement this method\n        return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n     // TODO: Implement this method\n     return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // TODO: Implement this method\n        return null;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] newChunk = new Object[fullChunk.length];\n         return newChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // TODO: Implement this method\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] newChunk = new Object[chunkSize];\n         return newChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         Object[] result = null;\n         synchronized (this) {\n             if (fullChunk == null) {\n                 throw new IllegalArgumentException(\"null fullChunk\");\n             }\n             if (fullChunk.length != _chunkSize) {\n                 throw new IllegalArgumentException(\"fullChunk.length (\"+fullChunk.length+\") != _chunkSize (\"+_chunkSize+\")\");\n             }\n             if (_fullChunks == null) {\n                 throw new IllegalStateException(\"_fullChunks == null\");\n             }\n             if (_fullChunks.size() >= _maxFullChunks) {\n                 throw new IllegalStateException(\"_fullChunks.size() (\"+_fullChunks.size()+\") >= _maxFullChunks (\"+_maxFullChunks+\")\");\n             }\n             _fullChunks.add(fullChunk);\n             if (_fullChunks.size() == _maxFullChunks) {\n                 result = _fullChunks.get(0);\n                 _fullChunks.remove(0);\n             } else {\n                 result = new Object[_chunkSize];\n             }\n         }\n         return result;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     ",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     "
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n\n    if (pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern must not be empty\");\n    }\n\n    // parse pattern\n    int[] indexRef = new int[1];\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    List<String> patternParts = new ArrayList<>();\n    List<String> patternFields = new ArrayList<>();\n    while (indexRef[0] < pattern.length()) {\n        int[] index = indexRef;\n        String part = parsePattern(pattern, indexRef);\n        patternParts.add(part);\n        if (part.startsWith(\"'\") && part.endsWith(\"'\")) {\n            // literal\n            builder.appendLiteral(part.substring(1, part.length() - 1));\n        } else if (part.startsWith(\"[\") && part.endsWith(\"]\")) {\n            // optional\n            builder.appendOptional(createFormatterForPattern(part.substring(1, part.length() - 1)));\n        } else {\n            // field\n            patternFields.add(part);\n            builder.appendPattern(part);\n        }\n    }\n\n    // check for any remaining text\n    if (indexRef[0] < pattern.length()) {\n        throw new IllegalArgumentException(\"Pattern is not complete\");\n    }\n\n    // check for any remaining fields\n    if (patternFields.size() > 0) {\n        throw new IllegalArgumentException(\"Pattern contains unsupported fields: \" + patternFields);\n    }\n\n    // return formatter\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    return new DateTimeFormatterBuilder()\n        .appendPattern(pattern)\n        .toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n        // validate pattern\n        if (pattern.indexOf('%') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses old '%' style: \" + pattern);\n        }\n        if (pattern.indexOf('u') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'u' for year of era: \" + pattern);\n        }\n        if (pattern.indexOf('g') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'g' for era: \" + pattern);\n        }\n        if (pattern.indexOf('U') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'U' for year: \" + pattern);\n        }\n        if (pattern.indexOf('W') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'W' for week of year: \" + pattern);\n        }\n        if (pattern.indexOf('K') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'K' for hour of half-day: \" + pattern);\n        }\n        if (pattern.indexOf('V') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'V' for time zone ID: \" + pattern);\n        }\n        if (pattern.indexOf('Z') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'Z' for time zone: \" + pattern);\n        }\n        if (pattern.indexOf('z') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'z' for time zone: \" + pattern);\n        }\n        if (pattern.indexOf('X') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'X' for zone offset: \" + pattern);\n        }\n        if (pattern.indexOf('x') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'x' for zone offset: \" + pattern);\n        }\n        if (pattern.indexOf('O') >= 0) {\n            throw new IllegalArgumentException(\"Pattern uses 'O' for localized zone offset: \" + pattern);\n        }\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"pattern must not be null\");\n    }\n    if (pattern.length() == 0) {\n        throw new IllegalArgumentException(\"pattern must not be empty\");\n    }\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    char[] chars = pattern.toCharArray();\n    int length = chars.length;\n    int[] indexRef = new int[1];\n    for (int i = 0; i < length; i++) {\n        char c = chars[i];\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // pattern letter\n            String letter = String.valueOf(c);\n            int j = i + 1;\n            while (j < length) {\n                char peek = chars[j];\n                if (peek == c) {\n                    j++;\n                    letter += peek;\n                } else {\n                    break;\n                }\n            }\n            i = j - 1;\n            builder.appendPattern(letter);\n        } else if (c == '[') {\n            // optional section\n            StringBuilder buf = new StringBuilder();\n            int j = i + 1;\n            while (j < length) {\n                char peek = chars[j];\n                if (peek == '[') {\n                    buf.append(peek);\n                    j++;\n                } else if (peek == ']') {\n                    buf.append(peek);\n                    j++;\n                    break;\n                } else {\n                    buf.append(peek);\n                    j++;\n                }\n            }\n            builder.appendOptional(createFormatterForPattern(buf.toString()));\n        } else if (c == '(') {\n            // alternative section\n            StringBuilder buf = new StringBuilder();\n            int j = i + 1;\n            while (j < length) {\n                char peek = chars[j];\n                if (peek == '(') {\n                    buf.append(peek);\n                    j++;\n}\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    //-----------------------------------------------------------------------\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n    if (pattern.isEmpty()) {\n        throw new IllegalArgumentException(\"Pattern must not be empty\");\n    }\n    return new DateTimeFormatterBuilder()\n            .appendPattern(pattern)\n            .toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n\n    return new DateTimeFormatterBuilder()\n            .appendPattern(pattern)\n            .toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token.type == JsDocTokenType.STAR) {\n        return new StarNode();\n    } else if (token.type == JsDocTokenType.NULL) {\n        return new NullNode();\n    } else if (token.type == JsDocTokenType.UNDEFINED) {\n        return new UndefinedNode();\n    } else if (token.type == JsDocTokenType.TYPE_NAME) {\n        return new TypeNameNode(token.value);\n    } else if (token.type == JsDocTokenType.FUNCTION_TYPE) {\n        return parseFunctionType(token);\n    } else if (token.type == JsDocTokenType.UNION_TYPE) {\n        return parseUnionType(token);\n    } else if (token.type == JsDocTokenType.RECORD_TYPE) {\n        return parseRecordType(token);\n    } else if (token.type == JsDocTokenType.ARRAY_TYPE) {\n        return parseArrayType(token);\n    } else {\n        throw new JsDocParserException(\"Invalid basic type expression: \" + token.value);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.type) {\n        case JsDocToken.Type.STAR:\n            return new StarNode();\n        case JsDocToken.Type.NULL:\n            return new NullNode();\n        case JsDocToken.Type.UNDEFINED:\n            return new UndefinedNode();\n        case JsDocToken.Type.TYPE_NAME:\n            return new TypeNameNode(token.value);\n        case JsDocToken.Type.FUNCTION_TYPE:\n            return parseFunctionType();\n        case JsDocToken.Type.UNION_TYPE:\n            return parseUnionType();\n        case JsDocToken.Type.RECORD_TYPE:\n            return parseRecordType();\n        case JsDocToken.Type.ARRAY_TYPE:\n            return parseArrayType();\n        default:\n            throw new IllegalStateException(\"Unexpected token: \" + token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token.type == JsDocToken.Type.STAR) {\n        return new BasicTypeExpression(BasicTypeExpression.Type.ANY);\n    } else if (token.type == JsDocToken.Type.NULL) {\n        return new BasicTypeExpression(BasicTypeExpression.Type.NULL);\n    } else if (token.type == JsDocToken.Type.UNDEFINED) {\n        return new BasicTypeExpression(BasicTypeExpression.Type.UNDEFINED);\n    } else if (token.type == JsDocToken.Type.IDENTIFIER) {\n        return new BasicTypeExpression(BasicTypeExpression.Type.TYPE_NAME, token.value);\n    } else if (token.type == JsDocToken.Type.FUNCTION) {\n        return parseFunctionType();\n    } else if (token.type == JsDocToken.Type.UNION) {\n        return parseUnionType();\n    } else if (token.type == JsDocToken.Type.RECORD) {\n        return parseRecordType();\n    } else if (token.type == JsDocToken.Type.ARRAY) {\n        return parseArrayType();\n    } else {\n        throw new JsDocParseException(\"Expected basic type expression, found \" + token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) {\n        case JsDocTokenType.ASTERISK:\n            return new BasicTypeExpression(BasicType.ANY);\n        case JsDocTokenType.NULL:\n            return new BasicTypeExpression(BasicType.NULL);\n        case JsDocTokenType.UNDEFINED:\n            return new BasicTypeExpression(BasicType.UNDEFINED);\n        case JsDocTokenType.TYPE_NAME:\n            return new BasicTypeExpression(new TypeName(token.getValue()));\n        case JsDocTokenType.FUNCTION_TYPE:\n            return parseFunctionType();\n        case JsDocTokenType.UNION_TYPE:\n            return parseUnionType();\n        case JsDocTokenType.RECORD_TYPE:\n            return parseRecordType();\n        case JsDocTokenType.ARRAY_TYPE:\n            return parseArrayType();\n        default:\n            throw new JsDocParseException(\n                    \"Unexpected token: \" + token.getValue());\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token.isStar()) {\n    return new Node(Node.Kind.BASIC_TYPE_EXPRESSION, \"*\");\n  } else if (token.isNull()) {\n    return new Node(Node.Kind.BASIC_TYPE_EXPRESSION, \"null\");\n  } else if (token.isUndefined()) {\n    return new Node(Node.Kind.BASIC_TYPE_EXPRESSION, \"undefined\");\n  } else if (token.isTypeName()) {\n    return new Node(Node.Kind.BASIC_TYPE_EXPRESSION, token.getTypeName());\n  } else if (token.isFunctionType()) {\n    return parseFunctionType(token);\n  } else if (token.isUnionType()) {\n    return parseUnionType(token);\n  } else if (token.isRecordType()) {\n    return parseRecordType(token);\n  } else if (token.isArrayType()) {\n    return parseArrayType(token);\n  }\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token.getType()) {\n    case JsDocTokenType.STAR:\n      return new JsDocAllType();\n    case JsDocTokenType.NULL:\n      return new JsDocNullType();\n    case JsDocTokenType.UNDEFINED:\n      return new JsDocUndefinedType();\n    case JsDocTokenType.IDENTIFIER:\n      return parseTypeName(token);\n    case JsDocTokenType.FUNCTION:\n      return parseFunctionType(token);\n    case JsDocTokenType.LBRACE:\n      return parseRecordType(token);\n    case JsDocTokenType.LBRACKET:\n      return parseArrayType(token);\n    default:\n      throw new JsDocSyntaxError(token, \"Expected basic type expression\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token.getType()) {\n        case JsDocTokenType.ASTERISK:\n            return new JsDocAnyType();\n        case JsDocTokenType.NULL:\n            return new JsDocNullType();\n        case JsDocTokenType.UNDEFINED:\n            return new JsDocUndefinedType();\n        case JsDocTokenType.TYPE_NAME:\n            return new JsDocTypeName(token.getText());\n        case JsDocTokenType.FUNCTION_TYPE:\n            return parseFunctionType(token);\n        case JsDocTokenType.UNION_TYPE:\n            return parseUnionType(token);\n        case JsDocTokenType.RECORD_TYPE:\n            return parseRecordType(token);\n        case JsDocTokenType.ARRAY_TYPE:\n            return parseArrayType(token);\n        default:\n            throw new JsDocParseException(token, \"Unexpected token\");\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token.type) {\n    case JsDocToken.Type.STAR:\n      return new BasicTypeExpression(BasicType.ANY);\n    case JsDocToken.Type.NULL:\n      return new BasicTypeExpression(BasicType.NULL);\n    case JsDocToken.Type.UNDEFINED:\n      return new BasicTypeExpression(BasicType.UNDEFINED);\n    case JsDocToken.Type.IDENTIFIER:\n      return new BasicTypeExpression(BasicType.NAME, token.value);\n    case JsDocToken.Type.FUNCTION:\n      return parseFunctionType(token);\n    case JsDocToken.Type.UNION:\n      return parseUnionType(token);\n    case JsDocToken.Type.RECORD:\n      return parseRecordType(token);\n    case JsDocToken.Type.ARRAY:\n      return parseArrayType(token);\n    default:\n      throw new IllegalArgumentException(\"Invalid token type: \" + token.type);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token.is(JsDocTokenType.STAR)) {\n    return new BasicTypeExpression(BasicType.ANY);\n  } else if (token.is(JsDocTokenType.NULL)) {\n    return new BasicTypeExpression(BasicType.NULL);\n  } else if (token.is(JsDocTokenType.UNDEFINED)) {\n    return new BasicTypeExpression(BasicType.UNDEFINED);\n  } else if (token.is(JsDocTokenType.IDENTIFIER)) {\n    return new BasicTypeExpression(token.value);\n  } else if (token.is(JsDocTokenType.LEFT_PAREN)) {\n    return parseFunctionType();\n  } else if (token.is(JsDocTokenType.LEFT_BRACE)) {\n    return parseRecordType();\n  } else if (token.is(JsDocTokenType.LEFT_BRACKET)) {\n    return parseArrayType();\n  } else {\n    throw new JsDocParseException(\"Unexpected token: \" + token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token.type) {\n    case JsDocTokenType.MULTIPLY:\n      return new JsDocAllType();\n    case JsDocTokenType.NULL:\n      return new JsDocNullType();\n    case JsDocTokenType.UNDEFINED:\n      return new JsDocUndefinedType();\n    case JsDocTokenType.TYPE_NAME:\n      return new JsDocTypeName(token.value);\n    case JsDocTokenType.FUNCTION_TYPE:\n      return parseFunctionType();\n    case JsDocTokenType.UNION_TYPE:\n      return parseUnionType();\n    case JsDocTokenType.RECORD_TYPE:\n      return parseRecordType();\n    case JsDocTokenType.ARRAY_TYPE:\n      return parseArrayType();\n    default:\n      throw new JsDocParseException(\"Unexpected token: \" + token);\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  beforeName();\n  string(name);\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name\");\n    }\n    beforeName();\n    string(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    int categoryCount = dataset.getColumnCount();\n    int seriesCount = dataset.getRowCount();\n    double minimum = Double.POSITIVE_INFINITY;\n    for (int item = 0; item < seriesCount; item++) \n    {\n        for (int category = 0; category < categoryCount; category++) \n        {\n            double value = dataset.getValue(item, category).doubleValue();\n            if (value < minimum) \n            {\n                minimum = value;\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // loop through each category and find the minimum value\n    double min = Double.MAX_VALUE;\n    for (int c = 0; c < dataset.getColumnCount(); c++) {\n        double sum = 0.0;\n        for (int r = 0; r < dataset.getRowCount(); r++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                sum += value.doubleValue();\n            }\n        }\n        if (sum < min) {\n            min = sum;\n        }\n    }\n    return min;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the minimum value\n    double minimum = Double.POSITIVE_INFINITY;\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n        for (int c = 0; c < dataset.getColumnCount(); c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                double v = value.doubleValue();\n                if (v < minimum) {\n                    minimum = v;\n                }\n            }\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    int seriesCount = dataset.getSeriesCount();\n    int itemCount = dataset.getItemCount();\n    double result = Double.POSITIVE_INFINITY;\n    for (int item = 0; item < itemCount; item++) \n    {\n        double total = 0.0;\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number value = dataset.getValue(series, item);\n            if (value == null) \n            {\n                continue;\n            }\n            total += value.doubleValue();\n        }\n        result = Math.min(result, total);\n    }\n    return new Double(result);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    for (int i = 0; i < dataset.getColumnCount(); i++) \n    {\n        double currentMin = 0.0;\n        for (int j = 0; j < dataset.getRowCount(); j++) \n        {\n            Number value = dataset.getValue(j, i);\n            if (value != null) \n            {\n                double v = value.doubleValue();\n                if (v < currentMin) \n                {\n                    currentMin = v;\n                }\n            }\n        }\n        if (currentMin < minimum) \n        {\n            minimum = currentMin;\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // check arguments...\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // get the number of series and categories...\n    int seriesCount = dataset.getSeriesCount();\n    int categoryCount = dataset.getColumnCount();\n\n    // create a working array to hold the stacked values...\n    double[] stackedValues = new double[categoryCount];\n\n    // initialise the stacked values...\n    for (int i = 0; i < categoryCount; i++) \n    {\n        stackedValues[i] = 0.0;\n    }\n\n    // iterate through the series and categories...\n    for (int s = 0; s < seriesCount; s++) \n    {\n        for (int c = 0; c < categoryCount; c++) \n        {\n            // get the value for this series and category...\n            Number value = dataset.getValue(s, c);\n\n            // if the value is not null, add it to the stacked values...\n            if (value != null) \n            {\n                stackedValues[c] += value.doubleValue();\n            }\n        }\n    }\n\n    // find the minimum stacked value...\n    double min = Double.MAX_VALUE;\n    for (int i = 0; i < categoryCount; i++) \n    {\n        if (stackedValues[i] < min) \n        {\n            min = stackedValues[i];\n        }\n    }\n\n    // return the minimum value...\n    return new Double(min);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    int seriesCount = dataset.getSeriesCount();\n    int itemCount = dataset.getItemCount();\n    Number minimum = null;\n    for (int item = 0; item < itemCount; item++) {\n        Number current = dataset.getValue(item, 0);\n        if (current != null) {\n            minimum = current;\n            break;\n        }\n    }\n    for (int item = 1; item < itemCount; item++) {\n        Number current = dataset.getValue(item, 0);\n        if (current != null) {\n            if (minimum == null) {\n                minimum = current;\n            }\n            else {\n                minimum = Math.min(minimum, current);\n            }\n        }\n    }\n    return minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    int seriesCount = dataset.getSeriesCount();\n    if (seriesCount == 0) \n    {\n        return null;\n    }\n    int itemCount = dataset.getItemCount();\n    if (itemCount == 0) \n    {\n        return null;\n    }\n    Number result = null;\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number current = dataset.getValue(i, 0);\n        if (current != null) \n        {\n            if (result == null) \n            {\n                result = current;\n            } \n            else \n            {\n                result = result.doubleValue() + current.doubleValue();\n            }\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n        for (int c = 0; c < dataset.getColumnCount(); c++) {\n            Number value = dataset.getValue(r, c);\n            if (result == null) {\n                result = value;\n            }\n            else {\n                if (value.doubleValue() < result.doubleValue()) {\n                    result = value;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    // TODO: implement this method\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Boolean array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"Array contains null object at index: \" + ArrayUtils.indexOf(array, element));\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Boolean array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array contains null object\");\n    }\n    for (final Boolean b : array) {\n        if (b) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    else if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    else \n    {\n        for (final Boolean b : array) \n        {\n            if (b == null) \n            {\n                throw new IllegalArgumentException(\"Array cannot contain null\");\n            }\n            else if (b) \n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be null or empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array cannot contain null\");\n    }\n    return Arrays.stream(array).reduce(Boolean::logicalOr).get();\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) \n    {\n        throw new IllegalArgumentException(\"Array cannot be null or empty\");\n    }\n    for (final Boolean b : array) \n    {\n        if (b == null) \n        {\n            throw new IllegalArgumentException(\"Array cannot contain null\");\n        }\n        if (b) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array cannot contain null\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be null or empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array cannot contain null\");\n    }\n    return Arrays.stream(array).reduce(Boolean.FALSE, Boolean::logicalOr);\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"Array cannot contain null\");\n        }\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    if (ArrayUtils.contains(array, null)) {\n        throw new IllegalArgumentException(\"Array contains null\");\n    }\n    return Arrays.stream(array).reduce(Boolean::logicalOr).get();\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (ArrayUtils.isEmpty(array)) {\n        throw new IllegalArgumentException(\"Array cannot be empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"Array cannot contain null\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    final int len = delimiters.length;\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n\n            lastWasGap = false;\n        }\n    }\n\n    if (count == 0) {\n        return str.substring(0,1);\n    }\n\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int[] delims = WordUtils.toCharArray(delimiters);\n    final StringBuilder sb = new StringBuilder(strLen / 5);\n    char c = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        c = str.charAt(i);\n        if (WordUtils.isDelimiter(c, delims)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            sb.append(Character.toTitleCase(c));\n            lastWasGap = false;\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    if (delimiters == null) \n    {\n        return str.substring(0, 1);\n    }\n\n    final int strLen = str.length();\n    final int delLen = delimiters.length;\n    if (delLen == 0) \n    {\n        return str;\n    }\n\n    final char[] buf = new char[strLen / delLen + 1];\n    int count = 0;\n    char prev = ' ';\n    char c = 0;\n\n    for (int i = 0; i < strLen; i++) \n    {\n        c = str.charAt(i);\n        if (isDelimiter(prev, c, delimiters)) \n        {\n            if (count > 0) \n            {\n                buf[count] = Character.toTitleCase(c);\n                count++;\n            }\n        }\n        prev = c;\n    }\n\n    if (count > 0) \n    {\n        buf[0] = Character.toTitleCase(buf[0]);\n    }\n\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n    final int strLen = str.length();\n    final int delLen = delimiters.length;\n    if (delLen == 0) {\n        return str;\n    }\n    final StringBuilder buf = new StringBuilder(strLen / 5);\n    char[] chars = str.toCharArray();\n    char c = chars[0];\n    boolean lastWasGap = true;\n    for (int i = 0; i < chars.length; i++) {\n        if (isDelimiter(chars[i], delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf.append(Character.toTitleCase(c));\n                lastWasGap = false;\n            }\n        }\n    }\n    return buf.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null) {\n        return str.substring(0,1);\n    }\n\n    int len = 0;\n    for (int i = 0; i < str.length(); i++) {\n        boolean isDelimiter = false;\n        for (int j = 0; j < delimiters.length; j++) {\n            if (delimiters[j] == str.charAt(i)) {\n                isDelimiter = true;\n                break;\n            }\n        }\n        if (!isDelimiter) {\n            len++;\n        }\n    }\n\n    if (len == 0) {\n        return \"\";\n    }\n\n    final char[] initials = new char[len];\n    int pos = 0;\n    for (int i = 0; i < str.length(); i++) {\n        boolean isDelimiter = false;\n        for (int j = 0; j < delimiters.length; j++) {\n            if (delimiters[j] == str.charAt(i)) {\n                isDelimiter = true;\n                break;\n            }\n        }\n        if (!isDelimiter) {\n            initials[pos++] = str.charAt(i);\n        }\n    }\n    return new String(initials);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n\n            lastWasGap = false;\n        }\n    }\n\n    if (count == 0) {\n        return str;\n    }\n\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buffer[count++] = Character.toTitleCase(ch);\n                lastWasGap = false;\n            } else {\n                buffer[count++] = ch;\n            }\n        }\n    }\n\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null) {\n        return str.substring(0, 1);\n    }\n\n    final int strLen = str.length();\n    final int delLen = delimiters.length;\n    if (delLen == 0) {\n        return str;\n    }\n    final String[] words = str.split(\"[\\\\s]+\");\n    final StringBuilder result = new StringBuilder(strLen / 5 + 1);\n    char firstChar = 0;\n    for (final String word : words) {\n        final char firstWordChar = word.charAt(0);\n        if (firstWordChar != firstChar) {\n            for (final char delimiter : delimiters) {\n                if (firstWordChar == delimiter) {\n                    firstChar = firstWordChar;\n                    break;\n                }\n            }\n        }\n        if (firstChar != 0) {\n            result.append(firstChar);\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int r = 0; r < data.getRowCount(); r++) \n    {\n        double value = data.getDouble(r, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        double value = data.getDouble(i, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        double value = data.getDouble(i, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int r = 0; r < data.getRowCount(); r++) \n    {\n        double value = data.getDouble(r, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        double value = data.getValue(i, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getDouble(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0;\n    for (int i = 0; i < data.getRowCount(); i++) \n    {\n        total += data.getValue(i, column);\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D p = new Point2D.Double();\n    Point2D p1 = new Point2D.Double();\n    Point2D p2 = new Point2D.Double();\n    Point2D p3 = new Point2D.Double();\n    Point2D p4 = new Point2D.Double();\n    Point2D p5 = new Point2D.Double();\n    Point2D p6 = new Point2D.Double();\n    Point2D p7 = new Point2D.Double();\n    Point2D p8 = new Point2D.Double();\n    Point2D p9 = new Point2D.Double();\n    Point2D p10 = new Point2D.Double();\n    Point2D p11 = new Point2D.Double();\n    Point2D p12 = new Point2D.Double();\n    Point2D p13 = new Point2D.Double();\n    Point2D p14 = new Point2D.Double();\n    Point2D p15 = new Point2D.Double();\n    Point2D p16 = new Point2D.Double();\n    Point2D p17 = new Point2D.Double();\n    Point2D p18 = new Point2D.Double();\n    Point2D p19 = new Point2D.Double();\n    Point2D p20 = new Point2D.Double();\n    Point2D p21 = new Point2D.Double();\n    Point2D p22 = new Point2D.Double();\n    Point2D p23 = new Point2D.Double();\n    Point2D p24 = new Point2D.Double();\n    Point2D p25 = new Point2D.Double();\n    Point2D p26 = new Point2D.Double();\n    Point2D p27 = new Point2D.Double();\n    Point2D p28 = new Point2D.Double();\n    Point2D p29 = new Point2D.Double();\n    Point2D p30 = new Point2D.Double();\n    Point2D p31 = new Point2D.Double();\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D p = new Point2D.Double();\n    Rectangle2D bounds = getBounds();\n    p.setLocation(screenPoint.getX() - bounds.getX(),\n                  screenPoint.getY() - bounds.getY());\n    return p;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = null;\n    if (this.panel != null) {\n        Point2D p = this.panel.getLocationOnScreen();\n        result = new Point2D.Double(screenPoint.x - p.getX(), screenPoint.y - p.getY());\n    }\n    return result;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = null;\n    if (this.panel != null) \n    {\n        result = this.panel.getGraphicsConfiguration().getDefaultTransform().transform(screenPoint, null);\n    }\n    return result;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // TODO: Implement this method\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = null;\n    Point2D p = new Point2D.Double(screenPoint.getX(), screenPoint.getY());\n    Point2D t = getInsets().getTranslate();\n    Point2D s = getInsets().getScale();\n    result = new Point2D.Double(p.getX() * s.getX() + t.getX(), p.getY() * s.getY() + t.getY());\n    return result;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D p = new Point2D.Double(screenPoint.getX(), screenPoint.getY());\n    return p;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D p = new Point2D.Double(screenPoint.getX(), screenPoint.getY());\n    Point2D p2 = new Point2D.Double(0, 0);\n    Rectangle2D bounds = getBounds();\n    Rectangle2D rect = new Rectangle2D.Double(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight());\n    getInsets().createInsets(rect);\n    p2 = getInsets().transform(p, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n    p2 = getInsets().transform(p2, p2);\n    p2 = getInsets().createInsets(p2);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = null;\n    if (screenPoint != null) \n    {\n        Point2D p = getJava2DCoordinates(screenPoint.x, screenPoint.y);\n        result = new Point2D.Double(p.getX(), p.getY());\n    }\n    return result;\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D p = new Point2D.Double();\n    Point2D p2 = new Point2D.Double();\n    p.setLocation(screenPoint.getX(), screenPoint.getY());\n    p2 = this.getChartPanel().translateScreenToJava2D(p);\n    return p2;\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, \"Wrong format\");\n        }\n        try {\n            final int numerator = Integer.parseInt(parts[0]);\n            final int denominator = Integer.parseInt(parts[1]);\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(source, BigFraction.class, \"Wrong format\");\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] split = source.split(\"/\");\n        if (split.length != 2) {\n            throw new MathParseException(source, BigFraction.class, null);\n        }\n        try {\n            final int num = Integer.parseInt(split[0]);\n            final int den = Integer.parseInt(split[1]);\n            return new BigFraction(num, den);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(source, BigFraction.class, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if (source == null) {\n            throw new MathParseException(LocalizedFormats.NULL_NOT_ALLOWED);\n        }\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, 0, \"invalid format\", 0);\n        }\n        try {\n            final BigInteger numerator = new BigInteger(parts[0]);\n            final BigInteger denominator = new BigInteger(parts[1]);\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException nfe) {\n            throw new MathParseException(source, 0, \"invalid format\", 0);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: implement this method\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] split = source.split(\"/\");\n        if (split.length != 2) {\n            throw new MathParseException(source, BigFraction.class);\n        }\n        final int numerator = Integer.parseInt(split[0]);\n        final int denominator = Integer.parseInt(split[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if (source == null) {\n            throw new MathParseException(LocalizedFormats.NULL_NOT_ALLOWED);\n        }\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, 0, \"Invalid format. Should be of the form 'a/b'.\");\n        }\n        final BigInteger numerator = new BigInteger(parts[0]);\n        final BigInteger denominator = new BigInteger(parts[1]);\n        if (denominator.equals(BigInteger.ZERO)) {\n            throw new MathParseException(source, 0, \"Denominator cannot be zero.\");\n        }\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class, \"Invalid format\");\n        }\n        try {\n            final int numerator = Integer.parseInt(parts[0]);\n            final int denominator = Integer.parseInt(parts[1]);\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(source, BigFraction.class, \"Invalid format\");\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if (source == null) {\n            throw new MathParseException(LocalizedFormats.NULL_NOT_ALLOWED);\n        }\n        if (source.length() == 0) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_EMPTY_STRING);\n        }\n        final int[] parts = new int[2];\n        int index = 0;\n        int sign = 1;\n        if (source.charAt(index) == '-') {\n            sign = -1;\n            index++;\n        }\n        while (index < source.length() && source.charAt(index) == '0') {\n            index++;\n        }\n        if (index == source.length()) {\n            return BigFraction.ZERO;\n        }\n        parts[0] = sign;\n        parts[1] = 1;\n        while (index < source.length() && source.charAt(index) >= '0' && source.charAt(index) <= '9') {\n            parts[0] = parts[0] * 10 + (source.charAt(index) - '0');\n            parts[1] *= 10;\n            index++;\n        }\n        if (index == source.length()) {\n            return new BigFraction(parts[0], parts[1]);\n        }\n        if (source.charAt(index) != '/') {\n            throw new MathParseException(source, index, LocalizedFormats.UNEXPECTED_TOKEN, source.charAt(index));\n        }\n        index++;\n        if (index == source.length()) {\n            throw new MathParseException(source, index, LocalizedFormats.UNEXPECTED_END_OF_STRING);\n        }\n        if (source.charAt(index) == '0') {\n            index++;\n            if (index == source.length()) {\n                throw new MathParseException(source, index, LocalizedFormats.UNEXPECTED_END_OF_STRING);\n            }\n            if (source.charAt(index) == '/') {\n}\n}\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        // TODO: implement this method\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final String[] parts = source.split(\"/\");\n        if (parts.length != 2) {\n            throw new MathParseException(source, BigFraction.class);\n        }\n        try {\n            return new BigFraction(new BigInteger(parts[0]), new BigInteger(parts[1]));\n        } catch (NumberFormatException nfe) {\n            throw new MathParseException(source, BigFraction.class, nfe);\n        }\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        Plot plot = this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r == null) \n        {\n            continue;\n        }\n        if (result == null) \n        {\n            result = r;\n        } \n        else \n        {\n            result = result.add(r);\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        XYPlot plot = (XYPlot) this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r != null) \n        {\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis == getDomainAxis())  {\n        result = getDomainAxis().getRange();\n    }\n    else if (axis == getRangeAxis())  {\n        result = getRangeAxis().getRange();\n    }\n    else  {\n        // axis not recognised\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        XYPlot plot = (XYPlot) this.subplots.get(i);\n        if (plot.getDomainAxis() == axis) \n        {\n            Range r = plot.getDataRange(plot.getDomainAxis());\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n        if (plot.getRangeAxis() == axis) \n        {\n            Range r = plot.getDataRange(plot.getRangeAxis());\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < subplots.size(); i++) {\n        Plot p = subplots.get(i);\n        if (p instanceof XYPlot) {\n            XYPlot xyPlot = (XYPlot) p;\n            if (xyPlot.getDomainAxis() == axis) {\n                Range r = xyPlot.getDataRange(axis);\n                if (result == null) {\n                    result = r;\n                }\n                else {\n                    result = result.add(r);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        XYPlot plot = (XYPlot) this.subplots.get(i);\n        if (plot.getDataset(axis) != null) \n        {\n            Range r = plot.getDataRange(axis);\n            if (r == null) \n            {\n                return null;\n            }\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\n    Range result = null;\n    if (axis == getDomainAxis()) {\n        result = getDomainAxis().getRange();\n    }\n    else {\n        result = getRangeAxis().getRange();\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        XYPlot subplot = this.subplots.get(i);\n        if (subplot.getDataset(axis) != null) \n        {\n            Range subplotRange = subplot.getDataRange(axis);\n            if (subplotRange != null) \n            {\n                if (result == null) \n                {\n                    result = subplotRange;\n                } \n                else \n                {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < subplots.size(); i++) \n    {\n        XYPlot subplot = (XYPlot) subplots.get(i);\n        Range subplotRange = subplot.getDataRange(axis);\n        if (subplotRange != null) \n        {\n            if (result == null) \n            {\n                result = subplotRange;\n            } \n            else \n            {\n                result = result.add(subplotRange);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        XYPlot plot = this.subplots.get(i);\n        Range r = plot.getDataRange(axis);\n        if (r != null) \n        {\n            if (result == null) \n            {\n                result = r;\n            } \n            else \n            {\n                result = result.add(r);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    double ret;\n\n    if (val < 0) {\n        ret = Math.log10(-val);\n    } else {\n        ret = Math.log10(val);\n    }\n\n    if (val < 1) {\n        ret += Math.log10(10);\n    }\n\n    if (val < 0) {\n        ret = -ret;\n    }\n\n    return ret;\n}",
      "public double adjustedLog10(double val)  {\n    double scale = 0;\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        scale = 10 - val;\n        val += scale;\n    }\n    return -Math.log10(val) + scale;\n}",
      "public double adjustedLog10(double val)  {\n    double log10 = Math.log10(Math.abs(val));\n    if (val < 10) {\n        double scale = (10 - val) / 9;\n        log10 += scale;\n    }\n    if (val < 0) {\n        log10 = -log10;\n    }\n    return log10;\n}",
      "public double adjustedLog10(double val)  {\n    double result = 0;\n    if (val < 0) {\n        result = -Math.log10(-val);\n    } else if (val > 0) {\n        result = Math.log10(val);\n    }\n    if (val < 10) {\n        result += Math.log10(1 + val);\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double result;\n    if (val < 0)  {\n        result = Math.log10(-val);\n        result = -result;\n    }  else  {\n        result = Math.log10(val);\n    }\n    if (val < 10)  {\n        result = result + (10 - val) / 10;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double ret = 0;\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        ret = Math.log10(val) + Math.log10(1 + val);\n    } else {\n        ret = Math.log10(val);\n    }\n    if (val < 0) {\n        ret = -ret;\n    }\n    return ret;\n}",
      "public double adjustedLog10(double val)  {\n    double adjusted = 0;\n    if (val < 0)  {\n        adjusted = -val;\n    }\n    else  {\n        adjusted = val;\n    }\n    if (adjusted < 10)  {\n        adjusted = adjusted / 10 + 1;\n    }\n    return -Math.log10(adjusted);\n}",
      "public double adjustedLog10(double val)  {\n    double log10 = Math.log10(Math.abs(val));\n    if (val < 10) {\n        log10 += (10 - val) / 10;\n    }\n    if (val < 0) {\n        log10 = -log10;\n    }\n    return log10;\n}",
      "public double adjustedLog10(double val)  {\n    double result;\n\n    if (val <= 0)  {\n        result = Math.log10(-val);\n        result = -result;\n    }\n    else  {\n        result = Math.log10(val);\n    }\n\n    if (val < 1)  {\n        result = result - Math.log10(val);\n    }\n\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val <= 0)  {\n        val = -val;\n        return -Math.log10(val);\n    }\n    else if (val < 10)  {\n        return Math.log10(val) - Math.log10(10);\n    }\n    else  {\n        return Math.log10(val);\n    }\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Your code here\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check if all paths from the entry node to the exit node contain a return statement.\n  return cfg.allPathsFromEntryToExit().stream()\n      .map(path -> path.stream()\n          .filter(node -> node instanceof ReturnNode)\n          .findAny())\n      .allMatch(Optional::isPresent);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check that all paths from the entry node to the exit node contain a return statement.\n  // The entry node is the first node in the graph.\n  Node entry = cfg.getNodes().get(0);\n  // The exit node is the last node in the graph.\n  Node exit = cfg.getNodes().get(cfg.getNodes().size() - 1);\n  // A set of nodes that have been visited.\n  Set<Node> visited = new HashSet<>();\n  // A stack of nodes to visit.\n  Deque<Node> stack = new ArrayDeque<>();\n  // Add the entry node to the stack.\n  stack.addLast(entry);\n  // While there are nodes to visit.\n  while (!stack.isEmpty()) {\n    // Get the next node to visit.\n    Node node = stack.removeLast();\n    // If the node has not been visited.\n    if (!visited.contains(node)) {\n      // Mark the node as visited.\n      visited.add(node);\n      // If the node is a return node.\n      if (node instanceof ReturnNode) {\n        // Return true.\n        return true;\n      }\n      // Add the node's successors to the stack.\n      stack.addAll(node.getSuccessors());\n    }\n  }\n  // If the exit node has been visited.\n  if (visited.contains(exit)) {\n    // Return true.\n    return true;\n  }\n  // Return false.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: implement\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO: implement\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Implement this method\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    //TODO: Implement the method\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node n : cfg) {\n        if (n instanceof ReturnNode) {\n            continue;\n        }\n        if (n instanceof IfNode) {\n            IfNode ifn = (IfNode) n;\n            if (!allPathsReturn(cfg, ifn.getTrueSuccessor()) ||\n                !allPathsReturn(cfg, ifn.getFalseSuccessor())) {\n                return false;\n            }\n        } else if (n instanceof WhileNode) {\n            WhileNode whn = (WhileNode) n;\n            if (!allPathsReturn(cfg, whn.getBodySuccessor())) {\n                return false;\n            }\n        } else if (n instanceof DoWhileNode) {\n            DoWhileNode whn = (DoWhileNode) n;\n            if (!allPathsReturn(cfg, whn.getBodySuccessor())) {\n                return false;\n            }\n        } else if (n instanceof TryNode) {\n            TryNode tn = (TryNode) n;\n            if (!allPathsReturn(cfg, tn.getBodySuccessor()) ||\n                !allPathsReturn(cfg, tn.getFinallySuccessor())) {\n                return false;\n            }\n        } else if (n instanceof CatchNode) {\n            CatchNode cn = (CatchNode) n;\n            if (!allPathsReturn(cfg, cn.getBodySuccessor())) {\n                return false;\n            }\n        } else if (n instanceof SwitchNode) {\n            SwitchNode sn = (SwitchNode) n;\n            for (Node s : sn.getSuccessors()) {\n                if (!allPathsReturn(cfg, s)) {\n                    return false;\n                }\n            }\n        } else if (n instanceof ReturnNode) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    boolean allPathsReturn = true;\n    for (Node n : cfg.getNodes()) {\n        if (n.getType() == NodeType.RETURN) {\n            continue;\n        }\n        if (n.getType() == NodeType.THROW) {\n            continue;\n        }\n        if (n.getType() == NodeType.EXIT) {\n            continue;\n        }\n        if (n.getType() == NodeType.ENTRY) {\n            continue;\n        }\n        if (n.getType() == NodeType.CATCH) {\n            continue;\n        }\n        if (n.getType() == NodeType.FINALLY) {\n            continue;\n        }\n        if (n.getType() == NodeType.IF) {\n            IfNode ifNode = (IfNode) n;\n            if (ifNode.getTrueSuccessor() == null || ifNode.getFalseSuccessor() == null) {\n                allPathsReturn = false;\n                break;\n            }\n            continue;\n        }\n        if (n.getType() == NodeType.SWITCH) {\n            SwitchNode switchNode = (SwitchNode) n;\n            if (switchNode.getDefaultSuccessor() == null) {\n                allPathsReturn = false;\n                break;\n            }\n            continue;\n        }\n        if (n.getType() == NodeType.LOOP) {\n            LoopNode loopNode = (LoopNode) n;\n            if (loopNode.getBodySuccessor() == null) {\n                allPathsReturn = false;\n                break;\n            }\n            continue;\n        }\n        if (n.getType() == NodeType.TRY) {\n            TryNode tryNode = (TryNode) n;\n            if (tryNode.getBodySuccessor() == null) {\n                allPathsReturn = false;\n                break;\n            }\n            continue;\n        }\n        allPathsReturn = false;\n        break;\n    }\n    return allPathsReturn;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] log = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        Dfp x = a[i].subtract(Dfp.ONE).divide(a[i].add(Dfp.ONE));\n        Dfp[] logTerms = new Dfp[3];\n        logTerms[0] = x.multiply(Dfp.TWO);\n        logTerms[1] = x.multiply(x).multiply(Dfp.THREE);\n        logTerms[2] = x.multiply(x).multiply(x).multiply(Dfp.FIVE);\n        log[i] = logTerms[0].add(logTerms[1]).add(logTerms[2]);\n    }\n    return log;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] result = new Dfp[a.length];\n    final Dfp[] x = new Dfp[a.length];\n    final Dfp[] x2 = new Dfp[a.length];\n    final Dfp[] x3 = new Dfp[a.length];\n    final Dfp[] x4 = new Dfp[a.length];\n    final Dfp[] x5 = new Dfp[a.length];\n    final Dfp[] x6 = new Dfp[a.length];\n    final Dfp[] x7 = new Dfp[a.length];\n    final Dfp[] x8 = new Dfp[a.length];\n    final Dfp[] x9 = new Dfp[a.length];\n    final Dfp[] x10 = new Dfp[a.length];\n    final Dfp[] x11 = new Dfp[a.length];\n    final Dfp[] x12 = new Dfp[a.length];\n    final Dfp[] x13 = new Dfp[a.length];\n    final Dfp[] x14 = new Dfp[a.length];\n    final Dfp[] x15 = new Dfp[a.length];\n    final Dfp[] x16 = new Dfp[a.length];\n    final Dfp[] x17 = new Dfp[a.length];\n    final Dfp[] x18 = new Dfp[a.length];\n    final Dfp[] x19 = new Dfp[a.length];\n    final Dfp[] x20 = new Dfp[a.length];\n    final Dfp[] x21 = new Dfp[a.length];\n    final Dfp[] x22 = new Dfp[a.length];\n    final Dfp[] x23 = new Dfp[a.length];\n    final Dfp[] x24 = new Dfp[a.length];\n    final Dfp[] x25 = new Dfp[a.length];\n    final Dfp[] x26 = new Dfp[a.length];\n    final Dfp[] x27 = new Dfp[a.length];\n    final Dfp[] x28 = new Dfp[a.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].subtract(1).divide(a[i].add(1));\n    }\n    Dfp[] ln = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        ln[i] = x[i].multiply(2).add(1).divide(x[i].multiply(2).subtract(1));\n    }\n    return ln;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        result[i] = new Dfp(a[i].getField(), a[i].getRadix());\n    }\n    Dfp x = new Dfp(a[0].getField(), a[0].getRadix());\n    Dfp y = new Dfp(a[0].getField(), a[0].getRadix());\n    Dfp[] xPlus1 = new Dfp[a.length];\n    Dfp[] xMinus1 = new Dfp[a.length];\n    Dfp[] xSquared = new Dfp[a.length];\n    Dfp[] xCubed = new Dfp[a.length];\n    Dfp[] xToTheFourth = new Dfp[a.length];\n    Dfp[] xToTheSixth = new Dfp[a.length];\n    Dfp[] xToTheEighth = new Dfp[a.length];\n    Dfp[] xToTheTenth = new Dfp[a.length];\n    Dfp[] xToTheTwelfth = new Dfp[a.length];\n    Dfp[] xToTheFourteenth = new Dfp[a.length];\n    Dfp[] xToTheSixteenth = new Dfp[a.length];\n    Dfp[] xToTheEighteenth = new Dfp[a.length];\n    Dfp[] xToTheTwentieth = new Dfp[a.length];\n    Dfp[] xToTheTwentySecond = new Dfp[a.length];\n    Dfp[] xToTheTwentyFourth = new Dfp[a.length];\n    Dfp[] xToTheTwentySixth = new Dfp[a.length];\n    Dfp[] xToTheTwentyEighth = new Dfp[a.length];\n    Dfp[] xToTheThirtieth = new Dfp[a.length];\n    Dfp[] xToTheThirtySecond = new Dfp[a.length];\n    Dfp[] xToTheThirtyFourth = new Dfp[a.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].subtract(Dfp.ONE).divide(a[i].add(Dfp.ONE));\n    }\n    Dfp[] ln = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        ln[i] = x[i].multiply(x[i].add(Dfp.TWO)).divide(x[i].subtract(Dfp.TWO));\n    }\n    return ln;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        x[i] = a[i].subtract(Dfp.ONE).divide(a[i].add(Dfp.ONE));\n    }\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[a.length];\n    Dfp[] ln = new Dfp[a.length];\n    Dfp[] ln1 = new Dfp[a.length];\n    Dfp[] ln2 = new Dfp[a.length];\n    Dfp[] ln3 = new Dfp[a.length];\n    Dfp[] ln4 = new Dfp[a.length];\n    Dfp[] ln5 = new Dfp[a.length];\n    Dfp[] ln6 = new Dfp[a.length];\n    Dfp[] ln7 = new Dfp[a.length];\n    Dfp[] ln8 = new Dfp[a.length];\n    Dfp[] ln9 = new Dfp[a.length];\n    Dfp[] ln10 = new Dfp[a.length];\n    Dfp[] ln11 = new Dfp[a.length];\n    Dfp[] ln12 = new Dfp[a.length];\n    Dfp[] ln13 = new Dfp[a.length];\n    Dfp[] ln14 = new Dfp[a.length];\n    Dfp[] ln15 = new Dfp[a.length];\n    Dfp[] ln16 = new Dfp[a.length];\n    Dfp[] ln17 = new Dfp[a.length];\n    Dfp[] ln18 = new Dfp[a.length];\n    Dfp[] ln19 = new Dfp[a.length];\n    Dfp[] ln20 = new Dfp[a.length];\n    Dfp[] ln21 = new Dfp[a.length];\n    Dfp[] ln22 = new Dfp[a.length];\n    Dfp[] ln23 = new Dfp[a.length];\n    Dfp[] ln24 = new Dfp[a.length];\n    Dfp[] ln25 = new Dfp[a.length];\n    Dfp[] ln26 = new Dfp[a.length];\n    Dfp[] ln27 = new Dfp[a.length];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] log = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        Dfp x = (a[i].subtract(Dfp.ONE)).divide(a[i].add(Dfp.ONE));\n        log[i] = x.multiply(x).multiply(x).divide(Dfp.THREE).add(x.multiply(x).multiply(Dfp.TWO)).divide(Dfp.FIVE).add(x.multiply(x).multiply(Dfp.THREE).divide(Dfp.SEVEN)).divide(Dfp.SEVEN);\n    }\n    return log;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[a.length];\n    for (int i = 0; i < a.length; i++) {\n        Dfp x = a[i].subtract(Dfp.ONE).divide(a[i].add(Dfp.ONE));\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[1];\n    x[0] = a[0].divide(a[1]).add(1).divide(a[0].divide(a[1]).subtract(1));\n    final Dfp[] ln = new Dfp[1];\n    ln[0] = x[0].multiply(2).subtract(1).divide(x[0].multiply(2).add(1));\n    return ln;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            return false;\n        }\n        final Object[] values = get(key);\n        if (values == null) \n        {\n            return false;\n        }\n        final int index = Arrays.asList(values).indexOf(value);\n        if (index == -1) \n        {\n            return false;\n        }\n        return removeMapping(key, index);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Object[] values = map.get(key);\n        if (values == null) {\n            return false;\n        }\n        final int index = Arrays.asList(values).indexOf(value);\n        if (index == -1) {\n            return false;\n        }\n        final Object[] copy = new Object[values.length - 1];\n        System.arraycopy(values, 0, copy, 0, index);\n        System.arraycopy(values, index + 1, copy, index, values.length - index - 1);\n        map.put(key, copy);\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final Object[] values = this.get(key);\n        if (values == null) {\n            return false;\n        }\n        final int index = Arrays.asList(values).indexOf(value);\n        if (index == -1) {\n            return false;\n        }\n        final Object[] newValues = new Object[values.length - 1];\n        System.arraycopy(values, 0, newValues, 0, index);\n        System.arraycopy(values, index + 1, newValues, index, values.length - index - 1);\n        this.put(key, newValues);\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) \n        {\n            throw new NullPointerException(\"key\");\n        }\n        if (value == null) \n        {\n            throw new NullPointerException(\"value\");\n        }\n        final List<Object> list = map.get(key);\n        if (list == null) \n        {\n            return false;\n        }\n        final boolean result = list.remove(value);\n        if (list.isEmpty()) \n        {\n            map.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        final List<Object> list = get(key);\n        if (list == null) {\n            return false;\n        }\n        final boolean result = list.remove(value);\n        if (list.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = get(key);\n        if (coll == null) \n        {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Object[] values = get(key);\n        if (values == null) {\n            return false;\n        }\n        final int index = Arrays.asList(values).indexOf(value);\n        if (index == -1) {\n            return false;\n        }\n        if (values.length == 1) {\n            remove(key);\n        } else {\n            final Object[] newValues = new Object[values.length - 1];\n            System.arraycopy(values, 0, newValues, 0, index);\n            System.arraycopy(values, index + 1, newValues, index, values.length - index - 1);\n            put(key, newValues);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        List<Object> list = map.get(key);\n        if (list == null) {\n            return false;\n        }\n        if (list.remove(value)) {\n            if (list.isEmpty()) {\n                map.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"key\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"value\");\n        }\n        final Map<Object, Object> map = getMap(key);\n        if (map != null) {\n            return map.remove(value) != null;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setType(Token.STRING);\n        n.setQuotedString();\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.STRING) {\n        return n;\n    }\n    Node newNode = transform(n);\n    if (newNode.getType() == Token.STRING) {\n        return newNode;\n    }\n    newNode.setType(Token.STRING);\n    return newNode;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node result = transform(n);\n    if (result.getType() == Token.NAME) {\n        result.setType(Token.STRING);\n    } else if (result.getType() == Token.STRING) {\n        result.setType(Token.STRING);\n    }\n    return result;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setType(Token.STRING);\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    }\n    if (n.getType() == Token.STRING) {\n        n.setType(Token.STRING);\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    n = transform(n);\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setType(Token.STRING);\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    n = transform(n);\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setType(Token.STRING);\n    }\n    return n;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // first, get the total for the category...\n    double total = 0.0;\n    for (int r = 0; r < includedRows.length; r++) {\n        int row = includedRows[r];\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n\n    // now, get the values for the category and the base value...\n    List result = new ArrayList();\n    for (int r = 0; r < includedRows.length; r++) {\n        int row = includedRows[r];\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(base + v));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        if (includedRows[r]) {\n            Number value = dataset.getValue(r, dataset.getColumnIndex(category));\n            double v = value.doubleValue();\n            if (asPercentages) {\n                v = (v / base) * 100.0;\n            }\n            result.add(new Double(v));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    int itemCount = dataset.getColumnCount();\n    for (int i = 0; i < itemCount; i++) {\n        double total = 0.0;\n        for (int r = 0; r < includedRows.length; r++) {\n            int row = includedRows[r];\n            double v = dataset.getValue(row, i);\n            if (!Double.isNaN(v)) {\n                total += v;\n            }\n        }\n        double value = dataset.getValue(category, i);\n        if (!Double.isNaN(value)) {\n            total += value;\n        }\n        if (asPercentages) {\n            result.add(new Double(total / base * 100.0));\n        }\n        else {\n            result.add(new Double(total));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // check arguments...\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n    // calculate the total value for the category...\n    double total = 0.0;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        if (includedRows[r]) {\n            double v = dataset.getValue(r, dataset.getColumnIndex(category));\n            if (!Double.isNaN(v)) {\n                total += v;\n            }\n        }\n    }\n    // create the list of values...\n    List result = new java.util.ArrayList();\n    for (int r = 0; r < rowCount; r++) {\n        if (includedRows[r]) {\n            double v = dataset.getValue(r, dataset.getColumnIndex(category));\n            if (!Double.isNaN(v)) {\n                if (asPercentages) {\n                    v = v / total;\n                }\n                result.add(new Double(v + base));\n            }\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // work out the total value for the category...\n    double total = 0.0;\n    for (int r = 0; r < includedRows.length; r++) {\n        int row = includedRows[r];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        total += v;\n    }\n\n    // now create the list of stacked values...\n    List result = new ArrayList();\n    for (int r = 0; r < includedRows.length; r++) {\n        int row = includedRows[r];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        double p = v / total;\n        if (asPercentages) {\n            p = p * 100.0;\n        }\n        result.add(new Double(base + p));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (v > 0.0) {\n            total += v;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (asPercentages) {\n            v = v / total;\n        }\n        v = v + base;\n        result.add(new Double(v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        if (includedRows[r]) {\n            double value = dataset.getValue(r, dataset.getColumnIndex(category));\n            if (asPercentages) {\n                value = value / base;\n            }\n            result.add(new Double(value));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (v > 0.0) {\n            total += v;\n        }\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (asPercentages) {\n            v = (v / total) * 100.0;\n        }\n        result.add(new Double(base + v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new java.util.ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        double v = dataset.getValue(row, category);\n        if (v >= 0.0) {\n            result.add(new Double(v));\n            total += v;\n        }\n    }\n    if (asPercentages) {\n        for (int i = 0; i < result.size(); i++) {\n            double v = ((Double) result.get(i)).doubleValue();\n            result.set(i, new Double(v / total));\n        }\n    }\n    result.add(0, new Double(base));\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        if (includedRows.length == 0 ||\n            ArrayUtilities.contains(includedRows, r)) \n        {\n            double value = dataset.getValue(r, dataset.getColumnIndex(\n                    category));\n            if (asPercentages) {\n                value = (value / dataset.getRowCount()) * 100.0;\n            }\n            result.add(new Double(value + base));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) {\n            Node n = childNodes.get(i);\n            if (n instanceof Element) {\n                childElements.add((Element) n);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) \n        {\n            Node node = childNodes.get(i);\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) \n        {\n            Node n = childNodes.get(i);\n            if (n instanceof Element) \n            {\n                childElements.add((Element) n);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) \n        {\n            Node node = childNodes.get(i);\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) {\n            Node node = childNodes.get(i);\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) \n        {\n            Node n = childNodes.get(i);\n            if (n instanceof Element) \n            {\n                childElements.add((Element) n);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    // If the list is null, we need to populate it.\n    if (childElements == null) {\n        // Create the list\n        childElements = new ArrayList<Element>();\n        // Loop through the children, adding each one to the list\n        for (int i = 0; i < getChildNodes().getLength(); i++) {\n            Node child = getChildNodes().item(i);\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        NodeList childNodes = getChildNodes();\n        for (int i = 0; i < childNodes.getLength(); i++) {\n            Node child = childNodes.item(i);\n            if (child instanceof Element) {\n                childElements.add((Element) child);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < childNodes.size(); i++) {\n            Node node = childNodes.get(i);\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<Element>();\n        for (int i = 0; i < getChildCount(); i++) {\n            Node n = getChild(i);\n            if (n instanceof Element) {\n                childElements.add((Element) n);\n            }\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % hashTable.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash += ~(hash << 9);\n    hash ^=  (hash >>> 14);\n    hash +=  (hash << 4);\n    hash ^=  (hash >>> 10);\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    //-----------------------------------------------------------------------\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    return hash ^ (hash >>> 7) ^ (hash >>> 4);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash & (this.buckets.length - 1);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash % _buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int h = key.hashCode();\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}",
      "private int getHash(final Object key)  {\n    //-----------------------------------------------------------------------\n    //  This is the simplistic hash algorithm:\n    //\n    //  He = |Hk mod n|\n    //\n    //  He is the entry's hashCode, Hk is the key's hashCode, and n is\n    //  the number of buckets.\n    //-----------------------------------------------------------------------\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    //-----------------------------------------------------------------------\n    int hash = 0;\n    hash = key.hashCode() % table.length;\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    //-----------------------------------------------------------------------\n    //  Calculate the hashCode of the key.\n    //-----------------------------------------------------------------------\n    int hash = 0;\n    if (key != null) \n    {\n        hash = key.hashCode();\n    }\n\n    //-----------------------------------------------------------------------\n    //  Calculate the entry's hashCode.\n    //-----------------------------------------------------------------------\n    hash = Math.abs(hash);\n    hash %= this.buckets.length;\n\n    //-----------------------------------------------------------------------\n    //  Return the entry's hashCode.\n    //-----------------------------------------------------------------------\n    return hash;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    // check if k is valid\n    if (k < 0 || k >= m.getRowDimension()) {\n        throw new IllegalArgumentException(\"Invalid diagonal position\");\n    }\n    // create new matrix with same dimensions as m\n    RealMatrix res = MatrixUtils.createRealMatrix(m.getRowDimension(), m.getColumnDimension());\n    // copy upper triangular part of m to res\n    for (int i = 0; i < m.getRowDimension(); i++) {\n        for (int j = 0; j < m.getColumnDimension(); j++) {\n            if (i - j < k) {\n                res.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix triu = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i - j < k) {\n                triu.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return triu;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        k = -k;\n    }\n    if (k == 0) {\n        return m;\n    }\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix res = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i - j >= k) {\n                res.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i - j < k) {\n                result.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) \n    {\n        k = 0;\n    }\n    if (k > m.getRowDimension()) \n    {\n        k = m.getRowDimension();\n    }\n    RealMatrix res = m.getSubMatrix(0, m.getRowDimension() - 1, 0, k - 1);\n    for (int i = 0; i < res.getRowDimension(); i++) \n    {\n        for (int j = i + k; j < res.getColumnDimension(); j++) \n        {\n            res.setEntry(i, j, 0);\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        throw new IllegalArgumentException(\"k must be positive\");\n    }\n    if (k > m.getColumnDimension()) {\n        throw new IllegalArgumentException(\"k must be less than or equal to the number of columns\");\n    }\n    int n = m.getRowDimension();\n    RealMatrix res = MatrixUtils.createRealMatrix(n, k);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            if (i >= j) {\n                res.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        throw new IllegalArgumentException(\"k must be non-negative\");\n    }\n    if (k >= m.getRowDimension()) {\n        throw new IllegalArgumentException(\"k must be less than the number of rows\");\n    }\n    final int rowDim = m.getRowDimension();\n    final int colDim = m.getColumnDimension();\n    final RealMatrix res = MatrixUtils.createRealMatrix(rowDim, colDim);\n    for (int i = 0; i < rowDim; i++) {\n        for (int j = 0; j < colDim; j++) {\n            if (i - j < k) {\n                res.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return res;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int n = m.getRowDimension();\n    int p = m.getColumnDimension();\n    RealMatrix result = new Array2DRowRealMatrix(n, p);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < p; j++) {\n            if (i < j - k) {\n                result.setEntry(i, j, 0.0);\n            } else {\n                result.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        k = 0;\n    }\n    int n = m.getRowDimension();\n    int p = k + 1;\n    RealMatrix result = m.getSubMatrix(0, n - 1, 0, p - 1);\n    for (int i = 0; i < n; i++) {\n        for (int j = p; j < n; j++) {\n            result.setEntry(i, j, 0);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k < 0) {\n        throw new IllegalArgumentException(\"k must be non-negative\");\n    }\n    if (k > m.getColumnDimension()) {\n        throw new IllegalArgumentException(\"k must be less than or equal to the number of columns\");\n    }\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i - j < k) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            }\n        }\n    }\n    return out;\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    if (isSkew(right)) {\n        if (isSkew(right.right)) {\n            right.rotateLeft();\n        }\n        rotateRight();\n        return true;\n    }\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (this.parent == null) {\n        return false;\n    }\n    if (this.parent.right == this) {\n        if (this.parent.left.height() >= this.parent.height()) {\n            this.parent.rightRotate();\n            return true;\n        } else {\n            this.parent.leftRotate();\n            this.parent.rightRotate();\n            return true;\n        }\n    } else {\n        if (this.parent.right.height() >= this.parent.height()) {\n            this.parent.leftRotate();\n            return true;\n        } else {\n            this.parent.rightRotate();\n            this.parent.leftRotate();\n            return true;\n        }\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (parent == null) {\n        return false;\n    }\n    if (parent.right == this) {\n        if (parent.left.height() > parent.right.height()) {\n            parent.leftRotate();\n            return true;\n        } else {\n            parent.rightRotate();\n            return true;\n        }\n    } else {\n        if (parent.left.height() > parent.right.height()) {\n            parent.rightRotate();\n            return false;\n        } else {\n            parent.leftRotate();\n            return false;\n        }\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    // if right child is empty, this node is a leaf, so no rebalancing needed\n    if (right == null)\n        return false;\n\n    // if right child is not empty, and its left child is empty,\n    // this node is a right-heavy node, so rebalance it\n    if (right.left == null) {\n        // re-balance this node by rotating it to the left\n        rotateLeft();\n        return false;\n    }\n\n    // if right child is not empty, and its left child is not empty,\n    // this node is a right-left-heavy node, so rebalance it\n    if (right.left != null) {\n        // re-balance this node by rotating it to the left\n        rotateLeft();\n        // re-balance the right child by rotating it to the right\n        right.rotateRight();\n        return false;\n    }\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (isLeftHeavy()) {\n        // right sub-tree has shrunk, left sub-tree is too heavy\n        if (left.isLeftHeavy()) {\n            // left sub-tree is left heavy, rotate right\n            rotateRight();\n            return false;\n        } else {\n            // left sub-tree is right heavy, rotate left-right\n            left.rotateLeft();\n            rotateRight();\n            return false;\n        }\n    } else {\n        // right sub-tree has shrunk, left sub-tree is not heavy\n        if (left.isRightHeavy()) {\n            // left sub-tree is right heavy, rotate left\n            left.rotateLeft();\n            return false;\n        } else {\n            // left sub-tree is balanced, rotate right\n            rotateRight();\n            return true;\n        }\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (right.isSkew()) \n    {\n        right.rebalanceRightShrunk();\n        if (right.isSkew()) \n        {\n            right.rebalanceLeftShrunk();\n            rebalanceLeftShrunk();\n        }\n        return true;\n    }\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (this.right.height == 0) \n    {\n        // the right sub-tree is empty\n        // the current node is the new root\n        return false;\n    }\n    else if (this.right.height == 1) \n    {\n        // the right sub-tree is a singleton\n        // the current node is the new root\n        return false;\n    }\n    else \n    {\n        // the right sub-tree is a tree\n        // the current node is the new root\n        return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    // TODO: implement this method\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    if (parent == null) \n    {\n        return false;\n    }\n    if (parent.right == this) \n    {\n        return parent.rebalanceRightShrunk();\n    }\n    if (parent.left == this) \n    {\n        parent.rebalanceLeftShrunk();\n        return false;\n    }\n    return false;\n}",
      "private boolean rebalanceRightShrunk()  {\n    // If the parent tree is BALANCED, we need to reSkew.BALANCED it.\n    if (parent.isBALANCED()) {\n        return true;\n    }\n    // If the parent tree is RIGHT_HEAVY, we need to reSkew.BALANCED it.\n    if (parent.isRIGHT_HEAVY()) {\n        return true;\n    }\n    // If the parent tree is LEFT_HEAVY, we need to reSkew.BALANCED it.\n    if (parent.isLEFT_HEAVY()) {\n        return true;\n    }\n    // If the parent tree is SKEWED_LEFT, we need to reSkew.BALANCED it.\n    if (parent.isSKEWED_LEFT()) {\n        return true;\n    }\n    // If the parent tree is SKEWED_RIGHT, we need to reSkew.BALANCED it.\n    if (parent.isSKEWED_RIGHT()) {\n        return true;\n    }\n    // If the parent tree is SKEWED_LEFT_HEAVY, we need to reSkew.BALANCED it.\n    if (parent.isSKEWED_LEFT_HEAVY()) {\n        return true;\n    }\n    // If the parent tree is SKEWED_RIGHT_HEAVY, we need to reSkew.BALANCED it.\n    if (parent.isSKEWED_RIGHT_HEAVY()) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Your code here\n    int idx = startIdx;\n    double value = 0;\n    while (idx < norm) {\n        value = get(idx, idx);\n        if (value < 0.00000001) {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < this.n; i++) \n    {\n        final double element = this.get(i, i - 1);\n        if (Math.abs(element) <= norm * EPS) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < norm; i++) {\n        if (Math.abs(matrix[i][i - 1]) < Math.abs(matrix[i + 1][i])) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < this.n && Math.abs(this.get(i, i)) < norm * EPS) {\n        i++;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < n - 1 && Math.abs(norm - Math.abs(get(i, i))) < Math.abs(get(i, i + 1))) {\n        i++;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < n; i++) {\n        if (Math.abs(A[i][i]) < norm * epsilon) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < this.size && this.get(idx, idx) / norm > 1e-10) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // Find the first small sub-diagonal element\n    for (int i = startIdx; i < norm; i++) \n    {\n        if (Math.abs(matrix[i][i - 1]) < TOLERANCE) \n        {\n            return i;\n        }\n    }\n\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < this.size() - 1) {\n        if (Math.abs(this.get(idx, idx + 1)) < norm * EPSILON) {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // TODO: Implement this method\n    return -1;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    if (root == null)\n        return null;\n    Node current = root;\n    while (current != null)\n    {\n        if (comparator.compare(current.element, reference) >= 0)\n            current = current.left;\n        else\n            current = current.right;\n    }\n    return current;\n}",
      "public Node getNotSmaller(final T reference)  {\n    //TODO: implement this method\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (isEmpty()) {\n        return null;\n    }\n    Node current = root;\n    while (current.getNext() != null) {\n        if (current.getNext().getElement().compareTo(reference) >= 0) {\n            current = current.getNext();\n        } else {\n            current = current.getNext().getNext();\n        }\n    }\n    return current;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = root;\n    while (node != null) \n    {\n        if (reference.compareTo(node.element) < 0) \n        {\n            node = node.left;\n        } \n        else \n        {\n            if (reference.compareTo(node.element) > 0) \n            {\n                node = node.right;\n            } \n            else \n            {\n                return node;\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = root;\n    while (node != null) {\n        if (reference.compareTo(node.element) < 0) {\n            node = node.left;\n        } else if (reference.compareTo(node.element) > 0) {\n            node = node.right;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = root;\n    while (current != null) {\n        if (comparator.compare(reference, current.element) < 0) {\n            current = current.left;\n        } else if (comparator.compare(reference, current.element) > 0) {\n            current = current.right;\n        } else {\n            return current;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    //TODO: implement\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (root == null) {\n        return null;\n    }\n    Node node = root;\n    while (node.getNext() != null) {\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = root;\n    Node result = null;\n    while (current != null) {\n        if (comparator.compare(current.element, reference) >= 0) {\n            result = current;\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return result;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = getRoot();\n    while (node != null) \n    {\n        final int comparison = comparator.compare(reference, node.element);\n        if (comparison < 0) \n        {\n            node = node.left;\n        } \n        else if (comparison > 0) \n        {\n            node = node.right;\n        } \n        else \n        {\n            return node;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    int pos = indexOf(str);\n    while (pos != -1) \n    {\n        delete(pos, pos + str.length());\n        pos = indexOf(str, pos);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int sz = str.length();\n    if (sz == 0) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) \n    {\n        delete(index, index + sz);\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    int pos = indexOf(str);\n    if (pos < 0) \n    {\n        return this;\n    }\n    int len = str.length();\n    int size = size();\n    while (pos < size) \n    {\n        delete(pos, pos + len);\n        int nextPos = indexOf(str, pos);\n        if (nextPos < 0) \n        {\n            break;\n        }\n        pos = nextPos;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) \n    {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        delete(index, index + str.length());\n        index = indexOf(str, index);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    final int strLen = str.length();\n    int pos = indexOf(str, 0);\n    while (pos >= 0) {\n        delete(pos, pos + strLen);\n        pos = indexOf(str, pos);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    final int strLen = str.length();\n    int pos = indexOf(str, 0);\n    while (pos >= 0) {\n        delete(pos, pos + strLen);\n        pos = indexOf(str, pos);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // TODO(nicksantos): Implement this.\n    return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node result = node.detach();\n  if (node.isName()) {\n    String name = node.getString();\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null && info.containsDeclaration()) {\n      // The inline type annotation for a declaration overrides any\n      // other type annotation.\n      JSTypeExpression typeExpr = info.getType();\n      if (typeExpr != null) {\n        JSType type = typeExpr.evaluate(scope, typeRegistry);\n        if (type != null) {\n          result = new DeclaredNameNode(name, type);\n        }\n      }\n    } else {\n      // If there is no type annotation, use the type of the definition.\n      Var var = scope.getVar(name);\n      if (var != null) {\n        JSType type = var.getType();\n        if (type != null) {\n          result = new DeclaredNameNode(name, type);\n        }\n      }\n    }\n  }\n  return result;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    if (node.getType() == Token.NAME) {\n      String name = node.getString();\n      JSDocInfo info = node.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSTypeExpression texpr = info.getType();\n        JSType type = texpr.evaluate(scope);\n        if (type != null) {\n          Var var = scope.getVar(name);\n          if (var != null) {\n            var.setType(type);\n          } else {\n            scope.declare(name, type);\n          }\n        }\n      }\n    }\n    return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node.getType() == Token.NAME) {\n    String name = node.getString();\n    Node type = NodeUtil.getBestJSDocInfo(node).getType();\n    if (type != null) {\n      // We're not going to actually use the type, but we need to\n      // parse it to make sure it's well-formed.\n      NodeUtil.getJSTypeExpression(type);\n    }\n  }\n  return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node.getType() == Token.NAME) {\n    // This is a NAME node.\n    Node parent = node.getParent();\n    if (parent.getType() == Token.VAR) {\n      // This is a NAME node in a VAR declaration.\n      // We need to check if it has an inline JSDoc comment.\n      Node grandparent = parent.getParent();\n      if (grandparent.getType() == Token.SCRIPT) {\n        // This is a NAME node in a VAR declaration in the global scope.\n        // We need to check if it has an inline JSDoc comment.\n        Node firstChild = grandparent.getFirstChild();\n        if (firstChild.getType() == Token.BLOCK) {\n          // This is a NAME node in a VAR declaration in the global scope,\n          // and the BLOCK node is the first child of the SCRIPT node.\n          // We need to check if it has an inline JSDoc comment.\n          Node firstGrandchild = firstChild.getFirstChild();\n          if (firstGrandchild.getType() == Token.EXPR_RESULT) {\n            // This is a NAME node in a VAR declaration in the global scope,\n            // and the EXPR_RESULT node is the first child of the BLOCK node.\n            // We need to check if it has an inline JSDoc comment.\n            Node firstGreatGrandchild = firstGrandchild.getFirstChild();\n            if (firstGreatGrandchild.getType() == Token.FUNCTION) {\n              // This is a NAME node in a VAR declaration in the global scope,\n              // and the FUNCTION node is the first child of the EXPR_RESULT node.\n              // We need to check if it has an inline JSDoc comment.\n              Node firstGreatGreatGrandchild = firstGreatGrandchild.getFirstChild();\n              if (firstGreatGreatGrandchild.getType() == Token.NAME) {\n                // This is a NAME node in a VAR declaration in the global scope,\n                // and the NAME node is the first child of the FUNCTION node.\n}\n}\n}\n}\n}\n}\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node result = null;\n  Node parent = node.getParent();\n  Node grandparent = parent.getParent();\n\n  if (parent.isName() && grandparent.isParamList()) \n  {\n    // Function parameter.\n    result = transformFunctionParamWithInlineJsDoc(node);\n  } else if (parent.isName() && grandparent.isVar()) \n  {\n    // Variable declaration.\n    result = transformVariableDeclarationWithInlineJsDoc(node);\n  } else if (parent.isName() && grandparent.isMemberFunctionDef()) \n  {\n    // Method definition.\n    result = transformMethodDefWithInlineJsDoc(node);\n  }\n\n  return result;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  // This function is called for all nodes in the AST.\n  // It is a good place to start to learn about the structure of the AST.\n  // You can view the AST structure by running the following command:\n  //   java -jar jsdoc-toolkit/jsdoc-toolkit.jar -n -f -p -r -t templates/jsdoc-toolkit/ ast.js\n  //\n  // The AST is a tree of nodes. Each node has a type, which is a string.\n  // The type of a node is important, because it determines the properties\n  // and children of the node.\n  //\n  // For example, the type of a FUNCTION node is 'FunctionDeclaration'.\n  // This means that a FUNCTION node will have properties like 'name' and\n  // 'parameters', and children like a BLOCK node.\n  //\n  // The AST also has a property called 'parent', which is a reference to\n  // the parent node in the tree.\n  //\n  // The AST is a general representation of the code, and it is not specific\n  // to JavaScript. The same AST can be used to represent code in other\n  // programming languages.\n  //\n  // The AST is a powerful tool for understanding the structure of code,\n  // and it is a key part of the JavaScript compiler.\n  //\n  // You can find more information about the AST in the following links:\n  //   http://code.google.com/p/closure-compiler/wiki/AstTour\n  //   http://code.google.com/p/closure-compiler/wiki/AstExplanation\n  //\n  // In this exercise, you will need to use the AST to understand the code\n  // and make changes to it.\n  //\n  // You can use the following functions to help you understand the AST:\n  //   getType(): Returns the type of a node.\n  //   getChildNodes(): Returns the children of a node.\n  //   getFirstChild(): Returns the first child of a node.\n  //   getLastChild(): Returns the last child of a node.\n  //   getNext(): Returns the next sibling of a node.\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node n = node.getFirstChild();\n  while (n != null) {\n    if (n.getType() == Token.NAME) {\n      Node next = n.getNext();\n      if (next != null && next.getType() == Token.TYPEOF) {\n        // This is a type annotation.\n        String type = next.getFirstChild().getString();\n        n.setJSType(type);\n        node.removeChild(next);\n      }\n    }\n    n = n.getNext();\n  }\n  return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  // The node is the first child of the FUNCTION node.\n  Node fnNode = node.getFirstChild();\n  Node nameNode = fnNode.getFirstChild();\n  String name = nameNode.getString();\n  Node params = nameNode.getNext();\n  Node body = params.getNext();\n  Node returnType = body.getNext();\n\n  // If there is a return type, it is the last child of the FUNCTION node.\n  if (returnType != null) {\n    Node returnTypeNode = fnNode.getLastChild();\n    String returnTypeString = returnTypeNode.getString();\n    // TODO: Use returnTypeString to set the return type of the function.\n  }\n\n  // If there are parameters, they are the second child of the FUNCTION node.\n  if (params != null) {\n    Node paramList = params.getFirstChild();\n    for (Node param = paramList.getFirstChild();\n         param != null;\n         param = param.getNext()) {\n      // Each parameter is a NAME node.\n      String paramName = param.getString();\n      Node typeNode = param.getFirstChild();\n      String typeString = typeNode.getString();\n      // TODO: Use paramName and typeString to set the type of the parameter.\n    }\n  }\n\n  // If there is a body, it is the third child of the FUNCTION node.\n  if (body != null) {\n    // TODO: Use body to set the function body.\n  }\n\n  return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node result = node.detach();\n    if (node.isName()) {\n      JSDocInfo info = node.getJSDocInfo();\n      if (info != null) {\n        // If the NAME has an inline JSDoc, then it is a declaration.\n        // Create a VAR declaration with the inline JSDoc.\n        Node var = IR.var(node.cloneNode(), null);\n        var.setJSDocInfo(info);\n        result = var;\n      }\n    }\n    return result;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node node = new Node(NodeType.ARRAY_TYPE);\n    node.addChild(parseElementTypeList(token));\n    return node;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = new Node(token.getTokenType());\n    arrayType.addChild(parseElementTypeList());\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node node = new Node(NodeType.ARRAY_TYPE);\n    node.setToken(token);\n    node.addChild(parseElementTypeList());\n    return node;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    //TODO: Implement this method\n    return null;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node node = new Node(token);\n    node.type = Node.ARRAY_TYPE;\n    node.left = parseTypeExpression(token);\n    if (token.value == \"...\") {\n        token = token.next;\n        node.right = parseTypeExpression(token);\n    }\n    return node;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    // Parse '['\n    if (token.getType() != JsDocTokenType.LBRACKET) {\n        throw new JsDocParseException(\"Expected '['\");\n    }\n    token = token.next();\n\n    // Parse ElementTypeList\n    Node elementTypeList = parseElementTypeList(token);\n\n    // Parse ']'\n    if (token.getType() != JsDocTokenType.RBRACKET) {\n        throw new JsDocParseException(\"Expected ']'\");\n    }\n    token = token.next();\n\n    return new ArrayType(elementTypeList);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = new Node(NodeType.ARRAY_TYPE);\n    arrayType.addChild(token);\n    token = nextToken();\n    if (token.type == JsDocTokenType.ELLIPSIS) {\n        arrayType.addChild(token);\n        token = nextToken();\n    }\n    arrayType.addChild(parseTypeExpression(token));\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    // [TODO]\n    return null;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node node = new Node(token.image);\n  node.addChild(parseElementTypeList(token.next));\n  return node;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node node = new Node(token);\n  node.type = Node.ARRAY_TYPE;\n  token = token.next;\n  if (token.type == JsDocToken.TYPE_ELEMENT_LIST) {\n    node.addChild(parseElementTypeList(token));\n  }\n  return node;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n  return axis;\n}",
      "public Vector3D getAxis()  {\n  return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n  return axis;\n}",
      "public Vector3D getAxis()  {\n  return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    final int length = bytes.length;\n    final byte[] buffer = new byte[length];\n    int position = 0;\n    for (int i = 0; i < length; i++) \n    {\n        final byte b = bytes[i];\n        if (b == '+') \n        {\n            buffer[position++] = (byte) ' ';\n        } \n        else if (b == '%') \n        {\n            try \n            {\n                final byte[] sub = new byte[2];\n                System.arraycopy(bytes, i + 1, sub, 0, 2);\n                buffer[position++] = (byte) Integer.parseInt(new String(sub), 16);\n                i += 2;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } \n        else \n        {\n            buffer[position++] = b;\n        }\n    }\n    final byte[] out = new byte[position];\n    System.arraycopy(buffer, 0, out, 0, position);\n    return out;\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    return decode(bytes, URL_SAFE);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    return decode(bytes, true);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int b;\n    for (int i = 0; i < bytes.length; i++) {\n        b = bytes[i];\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            try {\n                final int u = Character.digit((char) bytes[++i], 16);\n                final int l = Character.digit((char) bytes[++i], 16);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: \" + bytes[i - 2] + bytes[i - 1]);\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \" + e.getMessage(), e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    return decode(bytes, URL_SAFE_ENCODING);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    final int length = bytes.length;\n    if (length == 0) {\n        return bytes;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream(length);\n    for (int i = 0; i < length; i++) {\n        final int b = bytes[i];\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            try {\n                final int u = Character.digit((char) bytes[++i], 16);\n                final int l = Character.digit((char) bytes[++i], 16);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes, i - 2, 3, \"US-ASCII\"));\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes, i - 1, 1, \"US-ASCII\"));\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    return decode(bytes, URL_SAFE_ENCODING);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    return decode(bytes, URL_SAFE_CHARS, false);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    final byte[] buffer = new byte[bytes.length];\n    int pos = 0;\n\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == '%') {\n            try {\n                buffer[pos++] = (byte) Integer.parseInt(new String(bytes, i + 1, 2), 16);\n                i += 2;\n            } catch (final NumberFormatException e) {\n                throw new DecoderException(\"Invalid URL encoding: \" + e.getMessage(), e);\n            }\n        } else {\n            buffer[pos++] = b;\n        }\n    }\n    return Arrays.copyOf(buffer, pos);\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    return decode(URL_SAFE_ENCODING, bytes);\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converters.contains(converter)) {\n            PeriodConverter removed = converters.remove(converter);\n            if (removed != null) {\n                removed.setTimeZone(null);\n            }\n            return removed;\n        }\n        return null;\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        return (PeriodConverter)converters.remove(converter);\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter result = null;\n        for (PeriodConverter p : this.periodConverters) {\n            if (p.equals(converter)) {\n                result = p;\n                break;\n            }\n        }\n        if (result != null) {\n            this.periodConverters.remove(result);\n        }\n        return result;\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter removed = null;\n    if (converters != null) {\n        removed = converters.remove(converter);\n    }\n    return removed;\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    return periodConverters.remove(converter);\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter removed = null;\n    if (converters.contains(converter)) {\n        removed = converters.remove(converter);\n    }\n    return removed;\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter result = null;\n    for (int i = 0; i < iPeriodConverters.size(); i++) {\n        PeriodConverter c = iPeriodConverters.get(i);\n        if (c.equals(converter)) {\n            result = c;\n            iPeriodConverters.remove(i);\n            break;\n        }\n    }\n    return result;\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter removed = null;\n    if (converters != null) {\n        removed = converters.remove(converter);\n    }\n    return removed;\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter removed = null;\n        synchronized (periodConverters) {\n            removed = periodConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter removed = null;\n        for (int i = 0; i < converters.length; i++) {\n            if (converters[i] == converter) {\n                removed = converters[i];\n                converters[i] = null;\n                break;\n            }\n        }\n        return removed;\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> fields = partial.getFieldTypes();\n    int size = fields.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType last = fields.get(size - 1);\n    DateTimeFieldType next = fields.get(0);\n    if (last.getRangeDurationField().equals(next.getDurationField()) == false) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        DateTimeFieldType field = fields.get(i);\n        if (field.getRangeDurationField().equals(last.getDurationField()) == false) {\n            return false;\n        }\n        last = field;\n        next = fields.get(i + 1);\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    for (int i = 0; i < size - 1; i++) {\n        int min = partial.getMinimumValue(i);\n        int max = partial.getMaximumValue(i);\n        int range = max - min + 1;\n        if (values[i + 1] < min || values[i + 1] > max) {\n            return false;\n        }\n        if (range != partial.getMaximumValue(i + 1) - partial.getMinimumValue(i + 1) + 1) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    int[] values = new int[size];\n    int[] ranges = new int[size];\n    for (int i = 0; i < size; i++) {\n        values[i] = partial.get(i);\n        ranges[i] = partial.getRangeDurationField(i).getUnitMillis();\n    }\n    for (int i = 0; i < size - 1; i++) {\n        if (values[i + 1] != values[i] + ranges[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeField> fields = partial.getFields();\n    if (fields.size() < 2) {\n        return false;\n    }\n    DateTimeField lastField = fields.get(0);\n    for (int i = 1; i < fields.size(); i++) {\n        DateTimeField field = fields.get(i);\n        if (field.getRangeDurationField() != lastField) {\n            return false;\n        }\n        lastField = field;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType fieldType = partial.getFieldType(0);\n    DateTimeFieldType nextFieldType = partial.getFieldType(1);\n    if (fieldType.getRangeDurationField().getUnitMillis() != nextFieldType.getUnitMillis()) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        fieldType = nextFieldType;\n        nextFieldType = partial.getFieldType(i + 1);\n        if (fieldType.getRangeDurationField().getUnitMillis() != nextFieldType.getUnitMillis()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    int[] values = new int[size];\n    partial.get(values);\n    int rangeField = partial.get(0);\n    for (int i = 1; i < size; i++) {\n        if (values[i - 1] != values[i]) {\n            return false;\n        }\n        rangeField = partial.get(i);\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    DateTimeFieldType lastType = types[size - 1];\n    DateTimeFieldType nextType = types[0];\n    if (lastType.getRangeDurationField() != nextType) {\n        return false;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> fields = partial.getFieldTypes();\n    if (fields.size() < 2) {\n        return false;\n    }\n    DateTimeFieldType firstField = fields.get(0);\n    DateTimeFieldType secondField = fields.get(1);\n    if (firstField.getRangeDurationField().equals(secondField)) {\n        return true;\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    DateTimeFieldType lastType = types[size - 1];\n    DateTimeFieldType nextType = types[0];\n    if (lastType.getRangeDurationField() != nextType) {\n        return false;\n    }\n    return isContiguous(partial, 0);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> types = partial.getFieldTypes();\n    if (types.size() < 2) {\n        return true;\n    }\n    DateTimeFieldType lastType = types.get(0);\n    DateTimeFieldType type = types.get(1);\n    DateTimeField lastField = lastType.getField(partial.getChronology());\n    DateTimeField field = type.getField(partial.getChronology());\n    if (lastField.getRangeDurationField().equals(field.getDurationField())) {\n        return isContiguous(partial.getChronology(), types, 1);\n    }\n    return false;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<>();\n    result.addAll(a);\n    result.addAll(b);\n    return result;\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params instanceof PARAM_LIST) \n    {\n        for (Node param : params.children()) \n        {\n            if (param instanceof PARAM) \n            {\n                Node child = param.child(0);\n                if (child instanceof STRING) \n                {\n                    strings.add(child);\n                }\n            }\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.getChildren()) \n    {\n        strings.add(new StringNode(param.getToken()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params != null) {\n        for (Node param : params.getChildren()) {\n            strings.add(new StringNode(param.getTokenImage()));\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.getChildren()) \n    {\n        strings.add(new StringNode(param.getFirstChild().getFirstChild().getImage()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.getChildren()) \n    {\n        strings.add(new StringNode(param.getToken()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params instanceof ParamList) \n    {\n        for (Node param : ((ParamList) params).getParams()) \n        {\n            if (param instanceof Param) \n            {\n                Node type = ((Param) param).getType();\n                if (type instanceof StringType) \n                {\n                    strings.add(type);\n                }\n            }\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        strings.add(new StringNode(param.child(0).token().image()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params instanceof PARAM_LIST) \n    {\n        for (Node param : params.children()) \n        {\n            if (param instanceof PARAM) \n            {\n                Node type = param.child(0);\n                Node name = param.child(1);\n                if (type instanceof STRING && name instanceof STRING) \n                {\n                    strings.add(name);\n                }\n            }\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params instanceof PARAM_LIST) {\n        for (Node param : ((PARAM_LIST) params).getParams()) {\n            if (param instanceof PARAM) {\n                Node paramName = ((PARAM) param).getParamName();\n                if (paramName instanceof STRING) {\n                    strings.add(paramName);\n                }\n            }\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        if (param.getType() == NodeType.PARAM) {\n            strings.add(param.getChild(0));\n        }\n    }\n    return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            this.append(str.substring(strLen - width));\n        } \n        else \n        {\n            this.append(str);\n            for (int i = strLen; i < width; i++) \n            {\n                this.append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str.length() > width) \n        {\n            str = str.substring(0, width);\n        }\n        else \n        {\n            str = str + StringUtils.repeat(padChar, width - str.length());\n        }\n        return append(str);\n    }\n    else \n    {\n        return append(obj);\n    }\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            appendFixedWidthPadRight(getNullText(), width, padChar);\n        } \n        else \n        {\n            final int strLen = str.length();\n            if (strLen >= width) \n            {\n                append(str.substring(strLen - width));\n            } \n            else \n            {\n                append(str);\n                appendFixedWidthPadRight(EMPTY_STRING, width - strLen, padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            this.append(str.substring(strLen - width));\n        } \n        else \n        {\n            this.append(str);\n            for (int i = strLen; i < width; i++) \n            {\n                this.append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            this.append(str.substring(strLen - width));\n        } \n        else \n        {\n            this.append(str);\n            for (int i = strLen; i < width; i++) \n            {\n                this.append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            append(str.substring(strLen - width));\n        } \n        else \n        {\n            append(str);\n            for (int i = strLen; i < width; i++) \n            {\n                append(padChar);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        if (str.length() > width) \n        {\n            this.append(str.substring(0, width));\n        } \n        else \n        {\n            this.append(str);\n            for (int i = str.length(); i < width; i++) \n            {\n                this.append(padChar);\n            }\n        }\n    } \n    else \n    {\n        this.append(obj);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            return this;\n        }\n        final int len = str.length();\n        if (len == 0) \n        {\n            return this;\n        }\n        if (len < width) \n        {\n            for (int i = 0; i < width - len; i++) \n            {\n                append(padChar);\n            }\n        }\n        append(str);\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            appendFixedWidthPadRight(getNullText(), width, padChar);\n        } \n        else \n        {\n            appendFixedWidthPadRight(str, width, padChar);\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        final String str = (obj == null ? getNullText() : obj.toString());\n        if (str.length() > width) \n        {\n            this.append(str.substring(str.length() - width));\n        } \n        else \n        {\n            this.append(str);\n            for (int i = str.length(); i < width; i++) \n            {\n                this.append(padChar);\n            }\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        boolean isDelimiter = false;\n        if (delimLen > 0) {\n            for (int i = 0; i < delimLen; i++) {\n                if (codePoint == delimiters[i]) {\n                    isDelimiter = true;\n                    break;\n                }\n            }\n        }\n        if (isDelimiter) {\n            newCodePoints[outOffset++] = codePoint;\n        } else if (outOffset == 0 || Character.isLowerCase(codePoint) || !Character.isUpperCase(codePoint)) {\n            int titleCaseCodePoint = Character.toTitleCase(codePoint);\n            newCodePoints[outOffset++] = titleCaseCodePoint;\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    if (outOffset != 0) {\n        return new String(newCodePoints, 0, outOffset);\n    } else {\n        return str;\n    }\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return capitalize(str);\n    }\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) \n    {\n        return str;\n    }\n\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        char ch = buffer[i];\n\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    for (int offset = 0, codePoint; offset < strLen; offset += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(offset);\n        boolean isDelimiter = false;\n        if (delimLen == 1) {\n            isDelimiter = codePoint == delimiters[0];\n        } else if (delimLen > 1) {\n            isDelimiter = CharUtils.contains(delimiters, codePoint);\n        }\n        if (isDelimiter) {\n            newCodePoints[outOffset++] = codePoint;\n        } else if (Character.isTitleCase(codePoint) || Character.isUpperCase(codePoint)) {\n            newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n        } else {\n            newCodePoints[outOffset++] = Character.toTitleCase(codePoint);\n        }\n    }\n    if (outOffset == strLen) {\n        return str;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder builder = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            builder.append(ch);\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            builder.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            builder.append(ch);\n        }\n    }\n    return builder.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    boolean capitalizeNext = true;\n    for (int index = 0, codePoint = 0; index < strLen; index += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(index);\n        if (Character.isTitleCase(codePoint)) {\n            // already capitalized\n            newCodePoints[outOffset++] = codePoint;\n            capitalizeNext = false;\n            continue;\n        }\n        if (Character.isUpperCase(codePoint) || Character.isLowerCase(codePoint)) {\n            if (capitalizeNext || (delimLen > 0 && StringUtils.contains(delimiters, codePoint))) {\n                newCodePoints[outOffset++] = Character.toTitleCase(codePoint);\n            } else {\n                newCodePoints[outOffset++] = Character.toLowerCase(codePoint);\n            }\n            capitalizeNext = false;\n            continue;\n        }\n        // preserve codepoints that are neither titlecase, uppercase, lowercase\n        // or delimiters\n        newCodePoints[outOffset++] = codePoint;\n        capitalizeNext = true;\n    }\n    if (outOffset != 0) {\n        return new String(newCodePoints, 0, outOffset);\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    int delimLen = delimiters.length;\n    if (delimLen == 1) {\n        return capitalize(str, delimiters[0]);\n    }\n    int[] positions = new int[delimLen];\n    int len = str.length();\n    int count = 0;\n    boolean contains = false;\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                contains = true;\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n    if (!contains) {\n        return capitalize(str);\n    }\n    if (count == 0) {\n        return str;\n    }\n    StringBuilder result = new StringBuilder(len + count);\n    int prev = 0;\n    for (int i = 0; i < count; i++) {\n        result.append(str, prev, positions[i]);\n        prev = positions[i] + 1;\n        if (prev < len && str.charAt(prev) >= 'a' && str.charAt(prev) <= 'z') {\n            result.append((char) (str.charAt(prev) - ('a' - 'A')));\n            prev++;\n        }\n    }\n    result.append(str, prev, len);\n    return result.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    int strLen = str.length();\n    StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.startsWith(\"0x\")) {\n        id = id.substring(2);\n    }\n    if (id.length() == 8) {\n        id = \"0x\" + id;\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // TODO:\n    // 1. Check if id is null or empty\n    // 2. Check if id is already in the new style format\n    // 3. Check if id is in the old style format\n    // 4. Convert id to new style format\n    // 5. Return the converted id\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.length() == 1) {\n        return id;\n    }\n    if (id.length() == 2) {\n        return id.substring(1);\n    }\n    if (id.length() == 3) {\n        return id.substring(2);\n    }\n    if (id.length() == 4) {\n        return id.substring(3);\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    //-----------------------------------------------------------------------\n    //  CODE GOES HERE\n    //-----------------------------------------------------------------------\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.startsWith(\"_\")) \n    {\n        id = id.substring(1);\n    }\n    if (id.startsWith(\"0x\")) \n    {\n        id = id.substring(2);\n    }\n    if (id.length() == 8) \n    {\n        id = \"00000000\" + id;\n        id = id.substring(id.length() - 8);\n    }\n    if (id.length() == 12) \n    {\n        id = \"00000000\" + id;\n        id = id.substring(id.length() - 12);\n    }\n    if (id.length() == 16) \n    {\n        id = \"00000000\" + id;\n        id = id.substring(id.length() - 16);\n    }\n    if (id.length() == 20) \n    {\n        id = \"00000000\" + id;\n        id = id.substring(id.length() - 20);\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n    //-----------------------------------------------------------------------\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    if (id.length() != 8) \n    {\n        return null;\n    }\n    String newId = null;\n    for (int i = 0; i < 8; i++) \n    {\n        char c = id.charAt(i);\n        if (c >= '0' && c <= '9') \n        {\n            newId += c;\n        } \n        else \n        {\n            newId += ((char) (c - 32));\n        }\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // TODO: Implement this method\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        RealMatrix jacobian = computeJacobian(params);\n        RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(getWeight()));\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n\n    RealMatrix jacobian = computeJacobian(params);\n    RealMatrix weightedJacobian = weight.getSqrt().multiply(jacobian);\n    if (weightedJacobian.getColumnDimension() != getDimension()) {\n        throw new DimensionMismatchException(weightedJacobian.getColumnDimension(),\n                                             getDimension());\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // compute the Jacobian matrix\n    RealMatrix jacobian = computeJacobian(params);\n    // weight the Jacobian matrix\n    RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(getWeight()));\n    // check dimension\n    if (weightedJacobian.getRowDimension() != getProblemDimension()) {\n        throw new DimensionMismatchException(weightedJacobian.getRowDimension(),\n                                             getProblemDimension());\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // get the weighted Jacobian\n    RealMatrix jacobian = computeJacobian(params);\n    RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(weights[0]));\n    for (int i = 1; i < weights.length; i++) {\n        weightedJacobian = weightedJacobian.add(jacobian.scalarMultiply(Math.sqrt(weights[i])));\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix jacobian = computeJacobian(params);\n    RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(getWeight()));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n\n    // compute the Jacobian matrix\n    RealMatrix jacobian = computeJacobian(params);\n\n    // weight the Jacobian matrix\n    RealMatrix weighted = weight.multiply(jacobian);\n\n    // return the weighted Jacobian\n    return weighted;\n\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix jacobian = computeJacobian(params);\n    final RealMatrix weightedJacobian = weight.multiply(jacobian);\n    if (weightedJacobian.getColumnDimension() != getDimension()) {\n        throw new DimensionMismatchException(weightedJacobian.getColumnDimension(),\n                                             getDimension());\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n\n    RealMatrix jacobian = computeJacobian(params);\n    RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(weights[0]));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix jacobian = computeJacobian(params);\n        final RealMatrix weighted = weight.multiply(jacobian);\n        return weighted;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n\n    // Compute the Jacobian\n    RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the weighted Jacobian\n    RealMatrix weightedJacobian = jacobian.scalarMultiply(Math.sqrt(getWeight()));\n\n    return weightedJacobian;\n\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException();\n    }\n\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException();\n    }\n    int least = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] != null && (least == -1 || comparator.compare(values[i], values[least]) < 0)) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] != null && (least < 0 || comparator.compare(values[i], values[least]) < 0)) \n        {\n            least = i;\n        }\n    }\n    if (least < 0) \n    {\n        throw new NoSuchElementException();\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException();\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] != null && (least == -1 || comparator.compare(values[i], values[least]) < 0)) \n        {\n            least = i;\n        }\n    }\n\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            values[i] = initialValue;\n        }\n        if (least == -1 || comparator.compare(values[least], values[i]) > 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException();\n    }\n    int least = -1;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] != null) {\n            if (least == -1 || comparator.compare(values[i], values[least]) < 0) {\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n\n    for (int i = 0; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n        }\n    }\n\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getStepType() == StepType.PROPERTY) {\n        childPointer = new PropertyPointer(\n                parentPointer.getNode(),\n                (Property) step.getStepProperty());\n    } else if (step.getStepType() == StepType.COLLECTION_INDEX) {\n        childPointer = new CollectionPointer(\n                parentPointer.getNode(),\n                (Collection) step.getStepCollection(),\n                step.getStepIndex());\n    } else if (step.getStepType() == StepType.MAP_KEY) {\n        childPointer = new MapPointer(\n                parentPointer.getNode(),\n                (Map) step.getStepMap(),\n                step.getStepKey());\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // Create a new child pointer\n        NodePointer childPointer = new NodePointer();\n\n        // Set the parent pointer\n        childPointer.setParentPointer(parentPointer);\n\n        // Set the step\n        childPointer.setStep(step);\n\n        // Set the node\n        childPointer.setNode(step.getNode());\n\n        // Set the index\n        childPointer.setIndex(parentPointer.getIndex() + 1);\n\n        // Return the child pointer\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the property for the step\n    Property property = parentPointer.getProperty();\n    // Get the value for the property\n    Object value = property.getValue();\n    // Get the child property for the step\n    Property childProperty = step.getChildProperty();\n    // Get the child value for the child property\n    Object childValue = childProperty.getValue();\n    // Create the child pointer\n    NodePointer childPointer = new NodePointer(\n                                    childProperty, childValue, parentPointer);\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        if (parentPointer.getNode() instanceof ObjectNode) {\n            ObjectNode objectNode = (ObjectNode) parentPointer.getNode();\n            if (step.getKey() != null) {\n                childPointer = new PropertyOwnerPointer(\n                        objectNode.getProperty(step.getKey()), step.getKey());\n            }\n        } else if (parentPointer.getNode() instanceof ArrayNode) {\n            ArrayNode arrayNode = (ArrayNode) parentPointer.getNode();\n            if (step.getIndex() != null) {\n                childPointer = new PropertyOwnerPointer(\n                        arrayNode.get(step.getIndex()), step.getIndex());\n            }\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        // Get the parent node\n        Node parentNode = parentPointer.getNode();\n        // Get the property\n        Property property = parentNode.getProperty(step.getPropertyName());\n        // Get the child node\n        Node childNode = property.getNode();\n        // Create the child pointer\n        NodePointer childPointer = new NodePointer(childNode);\n        // Return the child pointer\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    // if the step is a property step\n    if (step.isPropertyStep()) {\n        // get the property step\n        PropertyStep propertyStep = step.asPropertyStep();\n        // get the property name\n        String propertyName = propertyStep.getPropertyName();\n        // get the property owner\n        PropertyOwner propertyOwner = parentPointer.getPropertyOwner();\n        // get the property\n        Property property = propertyOwner.getProperty(propertyName);\n        // create the child pointer\n        childPointer = new PropertyOwnerPointer(property);\n    }\n    // if the step is a collection step\n    else if (step.isCollectionStep()) {\n        // get the collection step\n        CollectionStep collectionStep = step.asCollectionStep();\n        // get the collection name\n        String collectionName = collectionStep.getCollectionName();\n        // get the collection owner\n        CollectionOwner collectionOwner = parentPointer.getCollectionOwner();\n        // get the collection\n        Collection collection = collectionOwner.getCollection(collectionName);\n        // create the child pointer\n        childPointer = new CollectionPointer(collection);\n    }\n    // if the step is a map step\n    else if (step.isMapStep()) {\n        // get the map step\n        MapStep mapStep = step.asMapStep();\n        // get the map name\n        String mapName = mapStep.getMapName();\n        // get the map owner\n        MapOwner mapOwner = parentPointer.getMapOwner();\n        // get the map\n        Map map = mapOwner.getMap(mapName);\n        // create the child pointer\n        childPointer = new MapPointer(map);\n    }\n    // if the step is a value step\n    else if (step.isValueStep()) {\n        // get the value step\n        ValueStep valueStep = step.asValueStep();\n        // get the value\n        Object value = valueStep.getValue();\n        // create the child pointer\n        childPointer = new ValuePointer(value);\n    }\n    // return the child pointer\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Create the child pointer for the given step\n    NodePointer childPointer = new NodePointer(parentPointer, step);\n    // Add the child pointer to the parent pointer\n    parentPointer.addChildPointer(childPointer);\n    // Return the child pointer\n    return childPointer;\n}"
    ],
    [
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return inf;\n}",
      "public double getInf()  {\n    if(isEmpty())\n        return Double.POSITIVE_INFINITY;\n    else if(low == null)\n        return Double.NEGATIVE_INFINITY;\n    else\n        return low;\n}",
      "public double getInf()  {\n    if (isEmpty()) \n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if (low == Double.NEGATIVE_INFINITY) \n    {\n        return low;\n    }\n    else \n    {\n        return Double.NEGATIVE_INFINITY;\n    }\n}",
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        return inf;\n    }\n}",
      "public double getInf()  {\n    if(this.isEmpty())\n        return Double.POSITIVE_INFINITY;\n    else if(this.lowest == null)\n        return Double.NEGATIVE_INFINITY;\n    else\n        return this.lowest.getKey();\n}",
      "public double getInf()  {\n    if(isEmpty())\n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else\n    {\n        return inf;\n    }\n}",
      "public double getInf()  {\n    if(isEmpty())\n        return Double.POSITIVE_INFINITY;\n    if(lowest == null)\n        return Double.NEGATIVE_INFINITY;\n    return lowest;\n}",
      "public double getInf()  {\n    if (isEmpty())\n        return Double.POSITIVE_INFINITY;\n    return low;\n}",
      "public double getInf()  {\n    if(this.isEmpty())\n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if(this.low == null)\n    {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else\n    {\n        return this.low;\n    }\n}",
      "public double getInf()  {\n    if (this.isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if (this.lowest.getKey() == Double.NEGATIVE_INFINITY) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else {\n        return this.lowest.getKey();\n    }\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new Strategy() \n}"
    ],
    [
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        nextObject = this.getNext();\n        if (nextObject == null) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        if (objects.hasNext()) \n        {\n            nextObject = objects.next();\n            return true;\n        }\n        else \n        {\n            return false;\n        }\n    }\n    else \n    {\n        if (objects.hasNext()) \n        {\n            nextObject = objects.next();\n            return true;\n        }\n        else \n        {\n            return false;\n        }\n    }\n}",
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        nextObject = firstObject;\n        return true;\n    }\n    nextObject = nextObject.getNext();\n    if (nextObject == null) \n    {\n        return false;\n    }\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        if (objects.hasNext()) \n        {\n            nextObject = objects.next();\n            return true;\n        }\n        else \n        {\n            return false;\n        }\n    }\n    else \n    {\n        return true;\n    }\n}",
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        nextObject = getNextObject();\n        return nextObject != null;\n    }\n    else \n    {\n        return true;\n    }\n}",
      "private boolean setNextObject()  {\n    // If there are no more objects then return false.\n    if (nextObject == null) \n    {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}",
      "private boolean setNextObject()  {\n    // If there are no more objects then return false.\n    if (nextObject == null) \n    {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}",
      "private boolean setNextObject()  {\n    //-----------------------------------------------------------------------\n    //  YOUR CODE HERE\n    //-----------------------------------------------------------------------\n    if (nextObject == null) {\n        nextObject = firstObject;\n        return true;\n    }\n    else if (nextObject.nextObject == null) {\n        return false;\n    }\n    else {\n        nextObject = nextObject.nextObject;\n        return true;\n    }\n}",
      "private boolean setNextObject()  {\n    // If the current object is not null, then there is another object\n    if (currentObject != null) \n    {\n        // Set the next object to the next object in the list\n        nextObject = currentObject.getNext();\n        return true;\n    } \n    else \n    {\n        // If the current object is null, then there are no more objects\n        nextObject = null;\n        return false;\n    }\n}",
      "private boolean setNextObject()  {\n    if (nextObject == null) \n    {\n        nextObject = new Object();\n        return true;\n    } \n    else \n    {\n        return false;\n    }\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    // TODO: implement this method\n    return null;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] x_repair = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < 0.0) {\n            x_repair[i] = 0.0;\n        } else if (x[i] > 1.0) {\n            x_repair[i] = 1.0;\n        } else {\n            x_repair[i] = x[i];\n        }\n    }\n    return x_repair;\n}",
      "private double[] repair(final double[] x)  {\n    double[] xRepaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        xRepaired[i] = Math.max(x[i], 0.0);\n        xRepaired[i] = Math.min(xRepaired[i], 1.0);\n    }\n    return xRepaired;\n}",
      "private double[] repair(final double[] x)  {\n    // TODO: implement this method\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    // TODO: Implement this method\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repairedX = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repairedX[i] = Math.min(Math.max(x[i], 0.0), 1.0);\n    }\n    return repairedX;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] xRepaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        xRepaired[i] = Math.max(x[i], 0);\n        xRepaired[i] = Math.min(xRepaired[i], 1);\n    }\n    return xRepaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.min(Math.max(x[i], 0), 1);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] repaired = x.clone();\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < 0) {\n            repaired[i] = 0;\n        } else if (x[i] > 1) {\n            repaired[i] = 1;\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    //repair the objective variables\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < 0) \n        {\n            x[i] = 0;\n        } \n        else if (x[i] > 1) \n        {\n            x[i] = 1;\n        }\n    }\n    return x;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    transformer.transform();\n    return transformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an enum\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < values.length; i++) {\n        long bitVector = values[i];\n        for (int j = 0; j < constants.length; j++) {\n            if (bitVector % 2 == 1) {\n                result.add(constants[j]);\n            }\n            bitVector = bitVector >> 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    //checks\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an Enum\");\n    }\n    //checks done\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E e : enumClass.getEnumConstants()) {\n        final long bitVector = 1L << e.ordinal();\n        for (final long value : values) {\n            if ((value & bitVector) != 0) {\n                result.add(e);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The Enum Class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The Class must be an Enum\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] enums = enumClass.getEnumConstants();\n    for (final long val : values) {\n        for (int i = 0; i < enums.length; i++) {\n            if (val == 0) {\n                break;\n            }\n            if ((val & 1) == 1) {\n                result.add(enums[i]);\n            }\n            val >>>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] enumConstants = enumClass.getEnumConstants();\n    for (final long value : values) {\n        final int bit = Long.numberOfTrailingZeros(value);\n        if (bit < enumConstants.length) {\n            result.add(enumConstants[bit]);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an enum\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (final long element : values) {\n        for (final E constant : constants) {\n            if (element == constant.ordinal()) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    // Validate parameters\n    if (enumClass == null) {\n        throw new NullPointerException(\"The EnumUtils.processBitVectors(Class<E>, long...) method requires a non-null enum class.\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The EnumUtils.processBitVectors(Class<E>, long...) method requires an enum class, \" + enumClass.getName() + \" is not an enum class.\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The EnumUtils.processBitVectors(Class<E>, long...) method requires a non-null array of longs.\");\n    }\n\n    // Create an array to hold the enum values\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n\n    // Iterate over the values, setting the appropriate bit\n    for (int i = 0; i < values.length; i++) {\n        final long bitVector = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if (((1L << j) & bitVector) != 0) {\n                result.add(EnumUtils.getEnum((Class<E>) enumClass, i * Long.SIZE + j));\n            }\n        }\n    }\n\n    // Return the enum set\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The Enum Class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The Class must be an Enum Class\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The long[] must not be null\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E e : enumClass.getEnumConstants()) {\n        final long bitVector = e.ordinal();\n        for (final long value : values) {\n            if ((value & bitVector) == bitVector) {\n                result.add(e);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an enum\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final int mod = values.length - 1;\n    for (int i = 0; i < values.length; i++) {\n        final long bits = values[i];\n        final int offset = i * Long.SIZE;\n        for (int j = 0; j < Long.SIZE; j++) {\n            final long bit = 1L << j;\n            if ((bits & bit) != 0) {\n                final int ordinal = offset + j;\n                final E e = enumClass.getEnumConstants()[ordinal];\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The Enum Class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The Class must be an Enum Class\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        int bit = 0;\n        while (value > 0) {\n            final long mask = 1L << bit++;\n            if ((value & mask) > 0) {\n                result.add(EnumUtils.getEnum((Class<E>) enumClass, bit - 1));\n            }\n            value &= ~mask;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The Enum Class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The Class must be an Enum Class\");\n    }\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E e : enumClass.getEnumConstants()) {\n        final long bitVector = 1L << e.ordinal();\n        for (final long value : values) {\n            if ((value & bitVector) != 0) {\n                result.add(e);\n                break;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = getMillis();\n    return newZone.getMillisKeepLocal(this, localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert the old instant to local millis in this zone\n    long localMillis = getMillis();\n    // Convert back to UTC millis in the new zone\n    return newZone.getMillisKeepLocal(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    return newZone.getMillisKeepLocal(this, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localMillis, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = newZone.convertLocalToUTC(localInstant, false, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = getMillis();\n    long newLocalMillis = newZone.getMillisKeepLocal(this, localMillis);\n    return newZone.getMillisKeepLocal(this, newLocalMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    return newZone.getMillisKeepLocal(this, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    long localMillis = getMillisKeepLocal(oldInstant);\n    return newZone.getMillisKeepLocal(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    return newZone.getMillisKeepLocal(this, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis, false);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // get the current date\n    Date currentDate = (Date) date.clone();\n\n    // get the current unit\n    DateTickUnit currentUnit = unit;\n\n    // get the current unit count\n    int currentUnitCount = currentUnit.getUnitCount();\n\n    // get the current unit index\n    int currentUnitIndex = currentUnit.getUnitIndex();\n\n    // get the current unit size\n    int currentUnitSize = currentUnit.getUnitSize();\n\n    // get the current unit type\n    int currentUnitType = currentUnit.getUnitType();\n\n    // get the current unit count\n    int currentUnitCount = currentUnit.getUnitCount();\n\n    // get the current unit index\n    int currentUnitIndex = currentUnit.getUnitIndex();\n\n    // get the current unit size\n    int currentUnitSize = currentUnit.getUnitSize();\n\n    // get the current unit type\n    int currentUnitType = currentUnit.getUnitType();\n\n    // get the current unit count\n    int currentUnitCount = currentUnit.getUnitCount();\n\n    // get the current unit index\n    int currentUnitIndex = currentUnit.getUnitIndex();\n\n    // get the current unit size\n    int currentUnitSize = currentUnit.getUnitSize();\n\n    // get the current unit type\n    int currentUnitType = currentUnit.getUnitType();\n\n    // get the current unit count\n    int currentUnitCount = currentUnit.getUnitCount();\n\n    // get the current unit index\n    int currentUnitIndex = currentUnit.getUnitIndex();\n\n    // get the current unit size\n    int currentUnitSize = currentUnit.getUnitSize();\n\n    // get the current unit type\n    int currentUnitType = currentUnit.getUnitType();\n\n    // get the current unit count\n    int currentUnitCount = currentUnit.getUnitCount();\n\n    // get the current unit index\n    int currentUnitIndex = currentUnit.getUnitIndex();\n\n    // get the current unit size\n    int currentUnitSize = currentUnit.getUnitSize();\n\n    // get the current unit type\n    int currentUnitType = currentUnit.getUnitType();\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date nextDate = null;\n    if (unit.getUnit() == DateTickUnit.DAY) \n    {\n        nextDate = new Date(date.getTime() + (unit.getSize() * 24 * 60 * 60 * 1000));\n    } \n    else if (unit.getUnit() == DateTickUnit.MONTH) \n    {\n        nextDate = new Date(date.getTime() + (unit.getSize() * 30 * 24 * 60 * 60 * 1000));\n    } \n    else if (unit.getUnit() == DateTickUnit.YEAR) \n    {\n        nextDate = new Date(date.getTime() + (unit.getSize() * 365 * 24 * 60 * 60 * 1000));\n    }\n    return nextDate;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = null;\n    if (unit.getUnit() == DateTickUnit.DAY) \n    {\n        result = new Date(date.getTime() + (24 * 60 * 60 * 1000));\n    } \n    else if (unit.getUnit() == DateTickUnit.MONTH) \n    {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, 1);\n        result = calendar.getTime();\n    } \n    else if (unit.getUnit() == DateTickUnit.YEAR) \n    {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, 1);\n        result = calendar.getTime();\n    }\n    return result;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // COMPLETE THIS METHOD\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // TODO: implement this method\n    return null;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // add the tick unit to the reference date\n    Date next = (Date) date.clone();\n    next.setTime(next.getTime() + unit.getSize());\n\n    // check if the result is a \"standard\" date\n    if (isStandardDate(next, unit)) {\n        return next;\n    }\n    else {\n        // find the next \"standard\" date\n        while (!isStandardDate(next, unit)) {\n            next.setTime(next.getTime() + unit.getSize());\n        }\n        return next;\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Date result = (Date) date.clone();\n    long unitMillis = unit.getSize() * unit.getCount();\n    long current = result.getTime();\n    long next = (current / unitMillis + 1) * unitMillis;\n    result.setTime(next);\n    return result;\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // get the resolver that this instance uses\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    // resolve the variable to a value\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    // remove the variable from the buffer\n    buf.delete(startPos, endPos + 1);\n    // append the variable's value\n    buf.insert(startPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Check if the variable resolver is null\n    if (getVariableResolver() == null) \n    {\n        return null;\n    }\n    // Call the variable resolver\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) \n    {\n        return null;\n    }\n    // Replace the variable with the value\n    buf.replace(startPos, endPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrBuilder variable = new StrBuilder();\n    variable.append(buf.substring(startPos, endPos));\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) \n    {\n        return null;\n    }\n    buf.replace(startPos, endPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // use the variable resolver to get the value\n    final String value = getVariableResolver().resolve(variableName);\n    if (value != null) {\n        // replace the variable with the value\n        buf.replace(startPos, endPos, value);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) \n    {\n        return null;\n    }\n    buf.replace(startPos, endPos + 1, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String value = getVariableResolver().resolve(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Validate the input.\n    if (variableName == null) {\n        throw new NullPointerException(\"Variable name must not be null\");\n    }\n    if (buf == null) {\n        throw new NullPointerException(\"StrBuilder must not be null\");\n    }\n    if (startPos < 0 || startPos > buf.length()) {\n        throw new IndexOutOfBoundsException(\"Invalid start position: \" + startPos);\n    }\n    if (endPos < 0 || endPos > buf.length()) {\n        throw new IndexOutOfBoundsException(\"Invalid end position: \" + endPos);\n    }\n    // Resolve the variable.\n    final String value = getVariableResolver().resolve(variableName);\n    // Perform the substitution.\n    if (value != null) {\n        buf.replace(startPos, endPos, value);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n    final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n    final StrMatcher valueDelimiterMatcher = getVariableValueDelimiterMatcher();\n    final StrBuilder variableBuf = buf.subSequence(startPos + prefixMatcher.length(), endPos - suffixMatcher.length());\n    final StrBuilder valueBuf = new StrBuilder();\n    int valueStartPos = 0;\n    int valueEndPos = variableBuf.length();\n    int valueDelimiterStartPos = valueBuf.indexOf(valueDelimiterMatcher);\n    if (valueDelimiterStartPos >= 0) \n    {\n        valueStartPos = valueDelimiterStartPos + valueDelimiterMatcher.length();\n        valueEndPos = valueBuf.length();\n    }\n    final StrMatcher valueDelimiterMatcher2 = getVariableValueDelimiterMatcher();\n    final StrMatcher suffixMatcher2 = getVariableSuffixMatcher();\n    final StrMatcher prefixMatcher2 = getVariablePrefixMatcher();\n    final StrBuilder variableBuf2 = buf.subSequence(startPos + prefixMatcher2.length(), endPos - suffixMatcher2.length());\n    final StrBuilder valueBuf2 = new StrBuilder();\n    int valueStartPos2 = 0;\n    int valueEndPos2 = variableBuf2.length();\n    int valueDelimiterStartPos2 = valueBuf2.indexOf(valueDelimiterMatcher2);\n    if (valueDelimiterStartPos2 >= 0) \n    {\n        valueStartPos2 = valueDelimiterStartPos2 + valueDelimiterMatcher2.length();\n        valueEndPos2 = valueBuf2.length();\n    }\n    final StrMatcher valueDelimiterMatcher3 = getVariableValueDelimiterMatcher();\n    final StrMatcher suffixMatcher3 = getVariableSuffixMatcher();\n    final StrMatcher prefixMatcher3 = getVariablePrefixMatcher();\n    final StrBuilder variableBuf3 = buf.subSequence(startPos + prefixMatcher3.length(), endPos - suffixMatcher3.length());\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (getVariableResolver() != null) \n    {\n        value = getVariableResolver().resolve(variableName);\n    }\n    if (value == null) \n    {\n        value = System.getProperty(variableName);\n        if (value == null) \n        {\n            value = System.getenv(variableName);\n        }\n    }\n    return value;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] sArr = str.toCharArray();\n    StringBuilder sBld = new StringBuilder();\n    sBld.append(sArr[0]);\n    for (int i = 1; i < sArr.length; i++) {\n        char c1 = sArr[i];\n        char c2 = sArr[i - 1];\n        if (c1 != c2) {\n            int ci = mapChar(c1);\n            if (ci != -1) {\n                sBld.append(ci);\n            }\n        }\n    }\n    return sBld.toString();\n}",
      "public String soundex(String str)  {\n    // TODO: Implement the Soundex algorithm\n    return \"\";\n}",
      "public String soundex(String str)  {\n    // TODO: Implement this method\n}",
      "public String soundex(String str)  {\n    //TODO: Implement the Soundex algorithm\n    return \"\";\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        throw new IllegalArgumentException(\"The String cannot be null\");\n    }\n    if (str.length() == 0) \n    {\n        return str;\n    }\n    char[] in = str.toUpperCase().toCharArray();\n    char[] out = new char[4];\n    out[0] = in[0];\n    int length = 1;\n    for (int i = 1; i < in.length; i++) \n    {\n        char c = in[i];\n        if (c != 'H' && c != 'W' && c != 'Y') \n        {\n            if (length < 4) \n            {\n                out[length] = c;\n            }\n            length++;\n        }\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    // TODO: Implement the Soundex algorithm\n    return null;\n}",
      "public String soundex(String str)  {\n    // TODO: Implement the Soundex algorithm\n    return null;\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    if (str.length() == 0) {\n        return \"\";\n    }\n    char[] sArr = str.toCharArray();\n    StringBuilder sBuf = new StringBuilder();\n    sBuf.append(sArr[0]);\n    for (int i = 1; i < sArr.length; i++) {\n        char c1 = sArr[i - 1];\n        char c2 = sArr[i];\n        int mapped1 = getMappedValue(c1);\n        int mapped2 = getMappedValue(c2);\n        if (mapped1 != -1 && mapped2 != -1) {\n            if (mapped1 != mapped2) {\n                sBuf.append(mapped2);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Character \" + c1 + \" is not mapped\");\n        }\n    }\n    return sBuf.toString();\n}",
      "public String soundex(String str)  {\n    // Implement this method\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    if (str.length() == 0) {\n        return str;\n    }\n    char[] sArr = str.toCharArray();\n    char[] result = new char[4];\n    result[0] = sArr[0];\n    int count = 1;\n    for (int i = 1; i < sArr.length; i++) {\n        char c1 = sArr[i];\n        if (c1 != 'A' && c1 != 'E' && c1 != 'I' && c1 != 'O' && c1 != 'U' && c1 != 'Y' && c1 != 'W' && c1 != 'H') {\n            char c2 = result[count - 1];\n            if (c2 == 'A' || c2 == 'E' || c2 == 'I' || c2 == 'O' || c2 == 'U' || c2 == 'Y' || c2 == 'W' || c2 == 'H') {\n                result[count] = c1;\n                count++;\n            } else if (c2 != c1) {\n                result[count] = c1;\n                count++;\n            }\n        }\n    }\n    while (count < 4) {\n        result[count] = '0';\n        count++;\n    }\n    return new String(result);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    JavaType jt = null;\n    if (clz.isPrimitive()) {\n        jt = _typeFactory.constructType(clz);\n    } else if (String.class == clz) {\n        jt = _typeFactory.constructType(String.class);\n    } else if (Number.class.isAssignableFrom(clz)) {\n        jt = _typeFactory.constructType(Number.class);\n    } else if (Boolean.class == clz) {\n        jt = _typeFactory.constructType(Boolean.class);\n    } else if (Character.class == clz) {\n        jt = _typeFactory.constructType(Character.class);\n    }\n    return jt;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringType.instance;\n    }\n    if (clz == Integer.class) {\n        return IntType.instance;\n    }\n    if (clz == Long.class) {\n        return LongType.instance;\n    }\n    if (clz == Double.class) {\n        return DoubleType.instance;\n    }\n    if (clz == Boolean.class) {\n        return BooleanType.instance;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return INT;\n        }\n        if (clz == Long.TYPE) {\n            return LONG;\n        }\n        if (clz == Double.TYPE) {\n            return DOUBLE;\n        }\n        if (clz == Boolean.TYPE) {\n            return BOOLEAN;\n        }\n        if (clz == String.class) {\n            return STRING;\n        }\n        if (clz == Byte.TYPE) {\n            return BYTE;\n        }\n        if (clz == Short.TYPE) {\n            return SHORT;\n        }\n        if (clz == Float.TYPE) {\n            return FLOAT;\n        }\n        if (clz == Character.TYPE) {\n            return CHAR;\n        }\n        if (clz == Void.TYPE) {\n            return VOID;\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return _typeFactory.constructType(Object.class);\n    }\n    if (clz == CLASS_STRING) {\n        return _typeFactory.constructType(String.class);\n    }\n    if (clz == CLASS_ITERABLE) {\n        return _typeFactory.constructType(Iterable.class);\n    }\n    if (clz == CLASS_MAP) {\n        return _typeFactory.constructType(Map.class);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    JavaType[] types = _wellKnownSimpleTypes;\n    for (int i = 0, end = types.length; i < end; ++i) {\n        JavaType type = types[i];\n        if (type.getRawClass() == clz) {\n            return type;\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    JavaType jt = null;\n    if (clz == String.class) {\n        jt = String.class;\n    } else if (clz == Integer.class) {\n        jt = Integer.class;\n    } else if (clz == Long.class) {\n        jt = Long.class;\n    } else if (clz == Double.class) {\n        jt = Double.class;\n    } else if (clz == Boolean.class) {\n        jt = Boolean.class;\n    }\n    return jt;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return _typeFactory.constructType(Object.class);\n    }\n    if (clz == CLASS_STRING) {\n        return _typeFactory.constructType(String.class);\n    }\n    if (clz == CLASS_ENUM) {\n        return _typeFactory.constructType(Enum.class);\n    }\n    if (clz == CLASS_CLASS) {\n        return _typeFactory.constructType(Class.class);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    JavaType[] types = _wellKnownSimpleTypes;\n    for (int i = 0, end = types.length; i < end; ++i) {\n        JavaType t = types[i];\n        if (t.getRawClass() == clz) {\n            return t;\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // first: well-known \"simple\" types:\n    if (clz.isPrimitive()) {\n        if (clz == Integer.TYPE) {\n            return IntType.instance;\n        }\n        if (clz == Long.TYPE) {\n            return LongType.instance;\n        }\n        if (clz == Double.TYPE) {\n            return DoubleType.instance;\n        }\n        if (clz == Boolean.TYPE) {\n            return BooleanType.instance;\n        }\n        if (clz == String.class) {\n            return StringType.instance;\n        }\n        if (clz == Object.class) {\n            return ObjectType.instance;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    // Find the first prototype member declaration in the node\n    // and return it if found.\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    } else {\n        return null;\n    }\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    }\n    else if (n instanceof ExpressionStatement) \n    {\n        ExpressionStatement es = (ExpressionStatement) n;\n        if (es.getExpression() instanceof PrototypeMemberDeclaration) \n        {\n            return (PrototypeMemberDeclaration) es.getExpression();\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof PrototypeMemberDeclaration) \n    {\n        return (PrototypeMemberDeclaration) n;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    //TODO: Complete this method\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            result.setSubMatrix(mat.getData(), mat.getRowDimension() * i, mat.getColumnDimension() * j);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    RealMatrix result = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat.getData(), i * rows, (i + 1) * rows - 1, j * cols, (j + 1) * cols - 1);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Your code here\n    return null;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix res = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            res.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return res;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n\n    // Fill the new matrix with the values of the input matrix\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            result.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // write your code here\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            result.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix res = MatrixUtils.createRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            res.setSubMatrix(mat.getData(), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n    return res;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node current = root;\n    Node previous = null;\n    while (current != null) {\n        if (comparator.compare(current.element, reference) <= 0) {\n            previous = current;\n            current = current.right;\n        } else {\n            current = current.left;\n        }\n    }\n    return previous;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = root;\n    while (current != null) \n    {\n        final int comparison = comparator.compare(reference, current.element);\n        if (comparison == 0) \n        {\n            return current;\n        }\n        else if (comparison < 0) \n        {\n            current = current.left;\n        }\n        else \n        {\n            current = current.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = root;\n    while (current != null) \n    {\n        if (comparator.compare(reference, current.element) > 0) \n        {\n            current = current.right;\n        } \n        else if (comparator.compare(reference, current.element) < 0) \n        {\n            current = current.left;\n        } \n        else \n        {\n            return current;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty()) {\n        return null;\n    }\n    Node node = root;\n    while (node != null) {\n        if (reference.compareTo(node.element) < 0) {\n            node = node.left;\n        } else if (reference.compareTo(node.element) > 0) {\n            node = node.right;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node node = root;\n    while (node != null) {\n        if (comparator.compare(reference, node.element) > 0) {\n            node = node.right;\n        } else {\n            node = node.left;\n        }\n    }\n    return node;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (isEmpty())\n        return null;\n    Node current = root;\n    while (current.getNext() != null)\n    {\n        if (reference.compareTo(current.getNext().getElement()) < 0)\n            current = current.getNext();\n        else\n            current = current.getNext().getPrevious();\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (root == null) \n    {\n        return null;\n    }\n    Node current = root;\n    while (current.getNext() != null) \n    {\n        if (comparator.compare(current.getNext().getElement(), reference) > 0) \n        {\n            current = current.getNext();\n        } \n        else \n        {\n            return current;\n        }\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (root == null) {\n        return null;\n    }\n    Node current = root;\n    while (current != null) {\n        if (current.element.compareTo(reference) <= 0) {\n            current = current.right;\n        } else {\n            current = current.left;\n        }\n    }\n    return current;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node current = root;\n    while (current != null) \n    {\n        final int comparison = comparator.compare(reference, current.element);\n        if (comparison == 0) \n        {\n            return current;\n        }\n        else if (comparison < 0) \n        {\n            current = current.left;\n        }\n        else \n        {\n            current = current.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node node = root;\n    while (node != null) {\n        final int comparison = comparator.compare(reference, node.element);\n        if (comparison < 0) {\n            node = node.left;\n        } else if (comparison > 0) {\n            node = node.right;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    long bytesRead = inf.getBytesWritten();\n    if (bytesInflated < bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < bytesRead) {\n        return bytesInflated;\n    }\n    long diff = bytesRead - bytesInflated;\n    if (diff < 0x100000000L) {\n        return bytesInflated;\n    }\n    return bytesInflated - 0x100000000L;\n}",
      "private long getBytesInflated()  {\n    long total = bytesRead;\n    long last = lastRead;\n    long inflated = inf.getBytesWritten();\n    if (inflated > total) {\n        inflated = total;\n    } else if (inflated < last) {\n        inflated = last;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long total = bytesRead;\n    long last = inf.getBytesRead();\n    if (last > total) {\n        return total;\n    }\n    return total - last;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long totalBytesRead = getBytesRead();\n    long totalBytesConsumed = getBytesWritten();\n    if (totalBytesRead - totalBytesConsumed > Integer.MAX_VALUE) {\n        totalBytesConsumed = totalBytesRead - Integer.MAX_VALUE;\n    }\n    return totalBytesConsumed;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > bytesRead) {\n        // if the number of bytes inflated is greater than the number\n        // of bytes read, then assume it is less than the number of\n        // bytes read plus 2^32\n        bytesInflated = bytesRead + (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = bytesRead;\n    long bytesRead = inf.getBytesRead();\n    if (bytesRead > bytesInflated) {\n        bytesInflated = bytesRead;\n    }\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = 0;\n    long bytesRead = getBytesRead();\n    if (bytesRead > 0) {\n        bytesInflated = bytesRead;\n        long bytesInflated0 = getBytesWritten();\n        if (bytesInflated0 > 0) {\n            bytesInflated = bytesInflated0;\n        }\n        if (bytesInflated > bytesRead) {\n            bytesInflated = bytesRead;\n        }\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object is not recognized as a collection, map, array, iterator or enumeration\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"The object is not recognized as a collection, map, array, iterator or enumeration.\");\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object \" + object.getClass().getName() + \" is not supported\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object is not recognized as a collection, map, array, iterator or enumeration.\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"The object type \" + object.getClass().getName() + \" is not supported, please provide an implementation for isEmpty()\");\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) {\n        return !((Iterator) object).hasNext();\n    }\n    if (object instanceof Enumeration) {\n        return !((Enumeration) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unknown object type: \" + object.getClass().getName());\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n        return false;\n    }\n    for (String part : name.split(\"\\\\.\")) {\n        if (!isValidIdentifier(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null) {\n    return false;\n  }\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This is not correct.\n    // We need to check that the name is a valid identifier,\n    // and that it does not contain any reserved words.\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    int index = name.indexOf('.');\n    if (index == -1) {\n      return isValidIdentifier(name);\n    } else {\n      return isValidIdentifier(name.substring(0, index))\n          && isValidQualifiedName(name.substring(index + 1));\n    }\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n  int start = 0;\n  if (name.charAt(0) == '.') {\n    start = 1;\n  }\n  for (int i = start; i < name.length(); i++) {\n    char c = name.charAt(i);\n    if (c == '.') {\n      if (i == start) {\n        return false;\n      }\n      start = i + 1;\n    } else if (!isValidQualifiedNamePart(c)) {\n      return false;\n    }\n  }\n  return start != name.length();\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.length() == 0) \n    {\n        return false;\n    }\n    char[] chars = name.toCharArray();\n    for (int i = 0; i < chars.length; i++) \n    {\n        char c = chars[i];\n        if (!isValidQualifiedNameChar(c)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"[a-zA-Z_$][a-zA-Z_$0-9]*\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    int lastDot = name.lastIndexOf('.');\n    if (lastDot == -1) {\n      return isValidSimpleName(name);\n    }\n    String baseName = name.substring(0, lastDot);\n    String propertyName = name.substring(lastDot + 1);\n    return isValidSimpleName(baseName) && isValidSimpleName(propertyName);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_$][a-zA-Z0-9_$]*$\");\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Compute the norm of the sub-diagonal elements\n    double norm = 0.0;\n    for (int i = il; i <= iu; i++) \n    {\n        norm += Math.abs(shift.getSubDiagonal(i));\n    }\n\n    // Initialize the householder vector\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i] = shift.getSubDiagonal(i) / norm;\n    }\n\n    // Compute the start index for the QR step\n    int startIndex = il;\n    if (Math.abs(hVec[il]) > Math.abs(hVec[il + 1])) \n    {\n        startIndex = il + 1;\n    }\n\n    return startIndex;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int start = 0;\n    double[] v = new double[hVec.length];\n    double[] hVecTemp = new double[hVec.length];\n    double[] hVecTemp2 = new double[hVec.length];\n    double[] hVecTemp3 = new double[hVec.length];\n    double[] hVecTemp4 = new double[hVec.length];\n    double[] hVecTemp5 = new double[hVec.length];\n    double[] hVecTemp6 = new double[hVec.length];\n    double[] hVecTemp7 = new double[hVec.length];\n    double[] hVecTemp8 = new double[hVec.length];\n    double[] hVecTemp9 = new double[hVec.length];\n    double[] hVecTemp10 = new double[hVec.length];\n    double[] hVecTemp11 = new double[hVec.length];\n    double[] hVecTemp12 = new double[hVec.length];\n    double[] hVecTemp13 = new double[hVec.length];\n    double[] hVecTemp14 = new double[hVec.length];\n    double[] hVecTemp15 = new double[hVec.length];\n    double[] hVecTemp16 = new double[hVec.length];\n    double[] hVecTemp17 = new double[hVec.length];\n    double[] hVecTemp18 = new double[hVec.length];\n    double[] hVecTemp19 = new double[hVec.length];\n    double[] hVecTemp20 = new double[hVec.length];\n    double[] hVecTemp21 = new double[hVec.length];\n    double[] hVecTemp22 = new double[hVec.length];\n    double[] hVecTemp23 = new double[hVec.length];\n    double[] hVecTemp24 = new double[hVec.length];\n    double[] hVecTemp25 = new double[hVec.length];\n    double[] hVecTemp26 = new double[hVec.length];\n    double[] hVecTemp27 = new double[hVec.length];\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors for the QR step\n    int startIndex = 0;\n    for (int i = il; i <= iu; i++) \n    {\n        double h = hVec[i];\n        if (h != 0.0) \n        {\n            startIndex = i;\n            break;\n        }\n    }\n\n    // Initialize the householder vectors for the QR step\n    for (int i = startIndex; i <= iu; i++) \n    {\n        double h = hVec[i];\n        if (h != 0.0) \n        {\n            double tau = 0.0;\n            if (i == startIndex) \n            {\n                tau = -h / (hVec[i] + shift.getShift());\n            } \n            else \n            {\n                tau = -h / hVec[i];\n            }\n            hVec[i] = 1.0 + tau;\n            hVec[i + 1] = tau;\n        }\n        else \n        {\n            hVec[i] = 0.0;\n            hVec[i + 1] = 0.0;\n        }\n    }\n\n    return startIndex;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Your code here\n    return 0;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIndex = iu;\n    if (il == iu) {\n        hVec[il] = 1;\n    } else {\n        double s = 0;\n        for (int i = il; i < iu; i++) {\n            s += Math.pow(shift.getEigenvalue(i) - shift.getEigenvalue(i + 1), 2);\n        }\n        s = Math.sqrt(s);\n        hVec[il] = 1;\n        hVec[il + 1] = shift.getEigenvalue(il) - shift.getEigenvalue(il + 1) - s;\n        for (int i = il + 2; i < iu; i++) {\n            hVec[i] = 0;\n        }\n        hVec[iu] = s;\n        startIndex = il;\n    }\n    return startIndex;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    int startIndex = 0;\n    if (il == 0) {\n        hVec[0] = 1;\n        startIndex = 1;\n    }\n    for (int i = startIndex; i < iu; i++) {\n        hVec[i] = shift.get(i);\n    }\n    return startIndex;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIndex = 0;\n    if (il == 0) {\n        startIndex = iu;\n        hVec[startIndex] = 1;\n    } else {\n        startIndex = il - 1;\n        hVec[startIndex] = -shift.getShift();\n    }\n    return startIndex;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors\n    final int n = hVec.length;\n    final double[] v = new double[n];\n    int start = il;\n    int end = iu;\n    int i = start;\n    while (i < end) {\n        final double scale = Math.abs(hVec[i]) + Math.abs(hVec[i + 1]);\n        v[i] = hVec[i] / scale;\n        v[i + 1] = hVec[i + 1] / scale;\n        hVec[i] = scale * v[i];\n        hVec[i + 1] = scale * v[i + 1];\n        i += 2;\n    }\n    return start;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int start = il;\n    double scale = 0;\n    double hh = 0;\n    for (int i = il; i <= iu; i++) \n    {\n        LAPACK.getInstance().dlaev2(shift.getRho(), shift.getSigma(), shift.getTau(), hh, hVec[i], hVec[i + 1]);\n        if (i > il) \n        {\n            hVec[i - 1] = scale * hVec[i - 1];\n        }\n        scale = Math.abs(hVec[i]);\n        hh = hh + hVec[i] * hVec[i];\n    }\n    return start;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            TextNode textNode = (TextNode) node;\n            textNodes.add(textNode);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<TextNode>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    return Collector.collect(new TextNodeCollector(this));\n}\n\nclass TextNodeCollector implements NodeVisitor",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    // Add your code here\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes()) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.isIncluded()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) \n    {\n        if (!segment.isIncluded() || segment.isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) \n    {\n        if (!segment.isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) \n    {\n        if (!segment.isIncluded() || segment.isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) \n    {\n        if (!segment.isIncluded() || segment.isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment s : segments) {\n        if (!s.isIncluded() || s.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment s : segments) \n    {\n        if (!s.isIncluded() || s.isException()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment : segments) {\n        if (!segment.isIncluded() || segment.isException()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    // TODO: Complete this function\n    return false;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must both be the same type\");\n    }\n    if (zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"The zero instance must not be null\");\n    }\n    if (start.isSupported(zeroInstance) == false || end.isSupported(zeroInstance) == false) \n    {\n        throw new IllegalArgumentException(\"The partial must be supported by the period\");\n    }\n    int startValue = start.get(zeroInstance);\n    int endValue = end.get(zeroInstance);\n    if (startValue < endValue) \n    {\n        return endValue - startValue;\n    }\n    else \n    {\n        return endValue - startValue + 1;\n    }\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod objects must not be null\");\n    }\n    int size = zeroInstance.size();\n    int[] starts = new int[size];\n    int[] ends = new int[size];\n    for (int i = 0; i < size; i++) {\n        starts[i] = start.get(i);\n        ends[i] = end.get(i);\n    }\n    return between(starts, ends);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    //-----------------------------------------------------------------------\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod objects must not be null\");\n    }\n    int size = zeroInstance.size();\n    if (start.size() != size || end.size() != size) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] starts = new int[size];\n    int[] ends = new int[size];\n    for (int i = 0; i < size; i++) {\n        starts[i] = start.getValue(i);\n        ends[i] = end.getValue(i);\n    }\n    return between(starts, ends, zeroInstance);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    //-----------------------------------------------------------------------\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false) {\n        throw new IllegalArgumentException(\"ReadablePartial must be LocalDate\");\n    }\n    LocalDate startDate = (LocalDate) start;\n    LocalDate endDate = (LocalDate) end;\n    if (startDate.isAfter(endDate)) {\n        throw new IllegalArgumentException(\"Start must be before end\");\n    }\n    int days = endDate.getDayOfYear() - startDate.getDayOfYear();\n    int startYear = startDate.getYear();\n    int endYear = endDate.getYear();\n    if (startYear != endYear) {\n        int leapDays = 0;\n        int startMonth = startDate.getMonthOfYear();\n        int endMonth = endDate.getMonthOfYear();\n        if (startMonth <= 2 && endMonth >= 2) {\n            leapDays = (startYear % 4 == 0 ? 1 : 0);\n        }\n        int yearDiff = endYear - startYear;\n        days += (yearDiff * 365) + (leapDays * yearDiff);\n    }\n    return days;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod objects must not be null\");\n    }\n    int size = zeroInstance.size();\n    if (start.size() != size || end.size() != size) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must contain the same fields\");\n    }\n    int[] starts = new int[size];\n    int[] ends = new int[size];\n    for (int i = 0; i < size; i++) {\n        starts[i] = start.getValue(i);\n        ends[i] = end.getValue(i);\n    }\n    int[] durations = zeroInstance.getValues();\n    int total = 0;\n    for (int i = 0; i < size; i++) {\n        int start = starts[i];\n        int end = ends[i];\n        int duration = durations[i];\n        if (start > end) {\n            total += ((start - end) / duration) + 1;\n        } else if (start < end) {\n            total += (end - start) / duration;\n        }\n    }\n    return total;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must both be the same type\");\n    }\n    if (zeroInstance instanceof LocalDate == false) \n    {\n        throw new IllegalArgumentException(\"ReadablePeriod object must be the same type\");\n    }\n    long startMillis = start.get(DateTimeFieldType.millisOfSecond());\n    long endMillis = end.get(DateTimeFieldType.millisOfSecond());\n    long difference = endMillis - startMillis;\n    int amount = (int) (difference / zeroInstance.get(DateTimeFieldType.millisOfSecond()));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        return LocalDate.between((LocalDate) start, (LocalDate) end);\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime) {\n        return LocalTime.between((LocalTime) start, (LocalTime) end);\n    }\n    if (start instanceof LocalDateTime && end instanceof LocalDateTime) {\n        return LocalDateTime.between((LocalDateTime) start, (LocalDateTime) end);\n    }\n    if (start instanceof ZonedDateTime && end instanceof ZonedDateTime) {\n        return ZonedDateTime.between((ZonedDateTime) start, (ZonedDateTime) end);\n    }\n    if (start instanceof OffsetTime && end instanceof OffsetTime) {\n        return OffsetTime.between((OffsetTime) start, (OffsetTime) end);\n    }\n    if (start instanceof OffsetDateTime && end instanceof OffsetDateTime) {\n        return OffsetDateTime.between((OffsetDateTime) start, (OffsetDateTime) end);\n    }\n    if (start instanceof YearMonth && end instanceof YearMonth) {\n        return YearMonth.between((YearMonth) start, (YearMonth) end);\n    }\n    if (start instanceof Year && end instanceof Year) {\n        return Year.between((Year) start, (Year) end);\n    }\n    if (start instanceof MonthDay && end instanceof MonthDay) {\n        return MonthDay.between((MonthDay) start, (MonthDay) end);\n    }\n    if (start instanceof Month && end instanceof Month) {\n        return Month.between((Month) start, (Month) end);\n    }\n    if (start instanceof DayOfWeek && end instanceof DayOfWeek) {\n        return DayOfWeek.between((DayOfWeek) start, (DayOfWeek) end);\n    }\n    if (start instanceof Instant && end instanceof Instant) {\n        return Instant.between((Instant) start, (Instant) end);\n    }\n    if (start instanceof Duration && end instanceof Duration) {\n        return Duration.between((Duration) start, (Duration) end);\n    }\n    if (start instanceof Period && end instanceof Period) {\n}\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate == false || end instanceof LocalDate == false) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be both LocalDate\");\n    }\n    LocalDate startDate = (LocalDate) start;\n    LocalDate endDate = (LocalDate) end;\n    return (int) ChronoUnit.DAYS.between(startDate, endDate);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            return LocalDate.between((LocalDate) start, (LocalDate) end);\n        } else if (start instanceof LocalTime && end instanceof LocalTime) {\n            return LocalTime.between((LocalTime) start, (LocalTime) end);\n        } else if (start instanceof LocalDateTime && end instanceof LocalDateTime) {\n            return LocalDateTime.between((LocalDateTime) start, (LocalDateTime) end);\n        } else if (start instanceof ZonedDateTime && end instanceof ZonedDateTime) {\n            return ZonedDateTime.between((ZonedDateTime) start, (ZonedDateTime) end);\n        } else if (start instanceof OffsetTime && end instanceof OffsetTime) {\n            return OffsetTime.between((OffsetTime) start, (OffsetTime) end);\n        } else if (start instanceof OffsetDateTime && end instanceof OffsetDateTime) {\n            return OffsetDateTime.between((OffsetDateTime) start, (OffsetDateTime) end);\n        } else if (start instanceof LocalDate && end instanceof LocalDateTime) {\n            return LocalDate.between((LocalDate) start, (LocalDateTime) end);\n        } else if (start instanceof LocalTime && end instanceof LocalDateTime) {\n            return LocalTime.between((LocalTime) start, (LocalDateTime) end);\n        } else if (start instanceof LocalDateTime && end instanceof LocalDate) {\n            return LocalDate.between((LocalDateTime) start, (LocalDate) end);\n        } else if (start instanceof LocalDateTime && end instanceof LocalTime) {\n            return LocalTime.between((LocalDateTime) start, (LocalTime) end);\n        } else if (start instanceof ZonedDateTime && end instanceof ZonedDateTime) {\n            return ZonedDateTime.between((ZonedDateTime) start, (ZonedDateTime) end);\n        } else if (start instanceof OffsetTime && end instanceof OffsetDateTime) {\n            return OffsetDateTime.between((OffsetTime) start, (OffsetDateTime) end);\n        } else if (start instanceof OffsetDateTime && end instanceof OffsetTime) {\n            return OffsetTime.between((OffsetDateTime) start, (OffsetTime) end);\n        } else if (start instanceof OffsetDateTime && end instanceof OffsetDateTime) {\n}\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        return LocalDate.between((LocalDate) start, (LocalDate) end);\n    }\n    if (start instanceof LocalTime && end instanceof LocalTime) {\n        return LocalTime.between((LocalTime) start, (LocalTime) end);\n    }\n    if (start instanceof LocalDateTime && end instanceof LocalDateTime) {\n        return LocalDateTime.between((LocalDateTime) start, (LocalDateTime) end);\n    }\n    if (start instanceof ZonedDateTime && end instanceof ZonedDateTime) {\n        return ZonedDateTime.between((ZonedDateTime) start, (ZonedDateTime) end);\n    }\n    if (start instanceof OffsetTime && end instanceof OffsetTime) {\n        return OffsetTime.between((OffsetTime) start, (OffsetTime) end);\n    }\n    if (start instanceof OffsetDateTime && end instanceof OffsetDateTime) {\n        return OffsetDateTime.between((OffsetDateTime) start, (OffsetDateTime) end);\n    }\n    if (start instanceof YearMonth && end instanceof YearMonth) {\n        return YearMonth.between((YearMonth) start, (YearMonth) end);\n    }\n    if (start instanceof Year && end instanceof Year) {\n        return Year.between((Year) start, (Year) end);\n    }\n    if (start instanceof Month && end instanceof Month) {\n        return Month.between((Month) start, (Month) end);\n    }\n    if (start instanceof MonthDay && end instanceof MonthDay) {\n        return MonthDay.between((MonthDay) start, (MonthDay) end);\n    }\n    if (start instanceof YearWeek && end instanceof YearWeek) {\n        return YearWeek.between((YearWeek) start, (YearWeek) end);\n    }\n    if (start instanceof DayOfWeek && end instanceof DayOfWeek) {\n        return DayOfWeek.between((DayOfWeek) start, (DayOfWeek) end);\n    }\n    if (start instanceof Duration && end instanceof Duration) {\n        return Duration.between((Duration) start, (Duration) end);\n    }\n    if (start instanceof Period && end instanceof Period) {\n}\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.legend == null)\n    {\n        return null;\n    }\n    else\n    {\n        return this.legend.get(index);\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index >= 0 && index < this.legendTitles.size()) \n    {\n        return this.legendTitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (index >= 0 && index < this.legendTitles.size()) \n    {\n        legend = this.legendTitles.get(index);\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index >= 0 && index < this.legendTitles.size()) \n    {\n        return this.legendTitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.legend == null)\n        return null;\n    else\n        return this.legend.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    return this.legend;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return new ZipArchiveEntryEnumeration(this);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    final Iterator<ZipArchiveEntry> it = entries.values().iterator();\n    return new Enumeration<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return entries.elements();\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        final Enumeration<ZipArchiveEntry> e = getEntries();\n        final List<ZipArchiveEntry> entries = new ArrayList<>();\n        while (e.hasMoreElements()) {\n            entries.add(e.nextElement());\n        }\n        Collections.sort(entries, new Comparator<ZipArchiveEntry>() {\n}\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        final Enumeration<ZipArchiveEntry> zipArchiveEntries = getEntries();\n        final List<ZipArchiveEntry> entries = new ArrayList<ZipArchiveEntry>();\n        while (zipArchiveEntries.hasMoreElements()) {\n            entries.add(zipArchiveEntries.nextElement());\n        }\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node annotation = new Node(Token.PARAM_TYPE_EXPRESSION_ANNOTATION);\n  annotation.addChildToBack(token);\n\n  JsDocToken nextToken = token.next();\n  if (nextToken.type == Token.ELLIPSIS) {\n    annotation.addChildToBack(nextToken);\n    nextToken = nextToken.next();\n  }\n\n  if (nextToken.type == Token.RBRACE) {\n    return annotation;\n  }\n\n  if (nextToken.type == Token.EQUALS) {\n    annotation.addChildToBack(nextToken);\n    nextToken = nextToken.next();\n  }\n\n  Node typeExpression = parseTopLevelTypeExpression(nextToken);\n  annotation.addChildToBack(typeExpression);\n\n  return annotation;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token.type != JsDocToken.Type.OPEN_CURLY) {\n        throw new JsDocParseException(\"Expected '{'\", token);\n    }\n\n    token = nextToken();\n\n    if (token.type == JsDocToken.Type.ELLIPSIS) {\n        // '...' TopLevelTypeExpression\n        token = nextToken();\n        Node typeExpression = parseTopLevelTypeExpression(token);\n        return new Node(Node.Type.PARAM_TYPE_EXPRESSION, typeExpression);\n    } else if (token.type == JsDocToken.Type.CLOSE_CURLY) {\n        // '{}'\n        return new Node(Node.Type.PARAM_TYPE_EXPRESSION, null);\n    } else {\n        // OptionalParameterType\n        Node parameterType = parseOptionalParameterType(token);\n        token = nextToken();\n        if (token.type != JsDocToken.Type.CLOSE_CURLY) {\n            throw new JsDocParseException(\"Expected '}'\", token);\n        }\n        return new Node(Node.Type.PARAM_TYPE_EXPRESSION, parameterType);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    // TODO: implement\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    Node node = new Node();\n    node.setType(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION);\n    node.setToken(token);\n    node.setValue(token.getValue());\n    node.setStart(token.getStart());\n    node.setEnd(token.getEnd());\n    node.setLine(token.getLine());\n    node.setColumn(token.getColumn());\n    return node;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token.type != JsDocTokenType.LBRACE) {\n        throw new IllegalStateException(\"Expected '{'\");\n    }\n\n    JsDocToken nextToken = token.next;\n    if (nextToken.type == JsDocTokenType.RBRACE) {\n        return new JsDocNode(JsDocNodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, token, nextToken);\n    }\n\n    if (nextToken.type == JsDocTokenType.ELLIPSIS) {\n        nextToken = nextToken.next;\n        if (nextToken.type != JsDocTokenType.RBRACE) {\n            throw new IllegalStateException(\"Expected '}'\");\n        }\n        return new JsDocNode(JsDocNodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, token, nextToken);\n    }\n\n    JsDocToken typeToken = parseTopLevelTypeExpression(nextToken);\n    nextToken = typeToken.next;\n    if (nextToken.type != JsDocTokenType.RBRACE) {\n        throw new IllegalStateException(\"Expected '}'\");\n    }\n    return new JsDocNode(JsDocNodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, token, nextToken);\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node node = new Node(token);\n  if (token.type == JsDocTokenType.LEFT_BRACE) {\n    token = token.next;\n    if (token.type == JsDocTokenType.RIGHT_BRACE) {\n      return node;\n    }\n    if (token.type == JsDocTokenType.ELLIPSIS) {\n      token = token.next;\n      node.addChild(parseTopLevelTypeExpression(token));\n      token = token.next;\n      if (token.type == JsDocTokenType.RIGHT_BRACE) {\n        return node;\n      }\n    }\n    node.addChild(parseTopLevelTypeExpression(token));\n    token = token.next;\n    if (token.type == JsDocTokenType.RIGHT_BRACE) {\n      return node;\n    }\n    if (token.type == JsDocTokenType.EQUALS) {\n      token = token.next;\n      node.addChild(parseTopLevelTypeExpression(token));\n      token = token.next;\n      if (token.type == JsDocTokenType.RIGHT_BRACE) {\n        return node;\n      }\n    }\n  }\n  return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token.type == JsDocTokenType.LBRACE) {\n      token = token.next;\n      if (token.type == JsDocTokenType.RBRACE) {\n        return null;\n      }\n      if (token.type == JsDocTokenType.DOT_DOT_DOT) {\n        token = token.next;\n        Node node = parseTopLevelTypeExpression(token);\n        if (node == null) {\n          return null;\n        }\n        return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n      }\n      Node node = parseTopLevelTypeExpression(token);\n      if (node == null) {\n        return null;\n      }\n      if (token.type == JsDocTokenType.EQUALS) {\n        token = token.next;\n        node = parseTopLevelTypeExpression(token);\n        if (node == null) {\n          return null;\n        }\n        return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n      }\n      return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n    }\n    return null;\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token.type == JsDocTokenType.OPEN_CURLY) {\n      token = nextToken();\n      if (token.type == JsDocTokenType.ELLIPSIS) {\n        token = nextToken();\n        Node node = parseTopLevelTypeExpression(token);\n        return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n      } else {\n        Node node = parseTopLevelTypeExpression(token);\n        return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n      }\n    } else {\n      Node node = parseTopLevelTypeExpression(token);\n      return new Node(NodeType.PARAM_TYPE_EXPRESSION_ANNOTATION, node);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramTypeExpression = new Node(token.getType(), token.getValue());\n  Node typeExpression = null;\n  Node optionalParameterType = null;\n  Node topLevelTypeExpression = null;\n\n  while (token.getType() != JsDocToken.Type.EOF) {\n    switch (token.getType()) {\n      case LBRACE:\n        if (optionalParameterType == null) {\n          optionalParameterType = parseOptionalParameterType(token);\n        } else {\n          topLevelTypeExpression = parseTopLevelTypeExpression(token);\n        }\n        break;\n      case RBRACE:\n        if (optionalParameterType != null) {\n          paramTypeExpression.addChildToBack(optionalParameterType);\n        }\n        if (topLevelTypeExpression != null) {\n          paramTypeExpression.addChildToBack(topLevelTypeExpression);\n        }\n        return paramTypeExpression;\n      default:\n        break;\n    }\n    token = token.getNext();\n  }\n  return paramTypeExpression;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token.type == JsDocTokenType.OPEN_BRACE) {\n        JsDocToken nextToken = token.next;\n        if (nextToken.type == JsDocTokenType.ELLIPSIS) {\n            return parseParamTypeExpressionAnnotation(nextToken.next);\n        }\n        else if (nextToken.type == JsDocTokenType.CLOSE_BRACE) {\n            return parseParamTypeExpressionAnnotation(nextToken.next);\n        }\n        else {\n            return parseParamTypeExpressionAnnotation(nextToken);\n        }\n    }\n    else if (token.type == JsDocTokenType.TOP_LEVEL_TYPE_EXPRESSION) {\n        return parseParamTypeExpressionAnnotation(token.next);\n    }\n    else if (token.type == JsDocTokenType.EQUALS) {\n        return parseParamTypeExpressionAnnotation(token.next);\n    }\n    else {\n        return null;\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String s = sw.getBuffer().toString();\n    final String[] lines = s.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>(lines.length);\n    for (final String line : lines) {\n        if (line.startsWith(\"&nbsp;&nbsp;&nbsp;&nbsp;at\")) {\n            list.add(line);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String s = sw.getBuffer().toString();\n    final String[] lines = s.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>();\n    String lastLine = null;\n    for (final String line : lines) {\n        if (line.startsWith(\"at \")) {\n            if (lastLine != null) {\n                list.add(lastLine);\n            }\n            lastLine = line;\n        } else {\n            lastLine = null;\n        }\n    }\n    if (lastLine != null) {\n        list.add(lastLine);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\r\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String[] lines = stackTrace.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>(lines.length + 2);\n\n    for (final String line : lines) {\n        if (line.startsWith(\"&nbsp;&nbsp;&nbsp;&nbsp;at\")) {\n            list.add(line);\n        }\n    }\n\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String s = sw.getBuffer().toString();\n    final String[] lines = s.split(\"\\\\r?\\\\n\");\n    final List<String> list = new ArrayList<String>();\n    String trace = \"\";\n    for (String line : lines) {\n        if (line.startsWith(\"at \")) {\n            if (trace.length() > 0) {\n                list.add(trace);\n            }\n            trace = line;\n        } else {\n            trace += \"\\n\" + line;\n        }\n    }\n    list.add(trace);\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String stackTrace = sw.getBuffer().toString();\n    final StringTokenizer frames = new StringTokenizer(stackTrace, \"\\n\");\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    // TODO: Implement this method\n}",
      "public boolean nextBoolean() throws IOException  {\n  JsonToken token = peek();\n  if (token == JsonToken.BOOLEAN) {\n    boolean result = reader.nextBoolean();\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  throw new IllegalStateException(\"Expected BOOLEAN but was \" + peek());\n}",
      "public boolean nextBoolean() throws IOException  {\n    expect(JsonToken.BOOLEAN);\n    return nextBoolean();\n}",
      "public boolean nextBoolean() throws IOException  {\n  JsonToken token = peek();\n  if (token == JsonToken.BOOLEAN) \n  {\n    consume();\n    return reader.nextBoolean();\n  }\n  throw new IllegalStateException(\"Expected BOOLEAN but was \" + token);\n}",
      "public boolean nextBoolean() throws IOException  {\n    JsonToken token = peek();\n    if (token == JsonToken.BOOLEAN) {\n        consume();\n        return jsonReader.isLenient() ? Boolean.parseBoolean(jsonReader.nextString()) : jsonReader.nextBoolean();\n    }\n    throw new IllegalStateException(\"Expected BOOLEAN but was \" + peek());\n}",
      "public boolean nextBoolean() throws IOException  {\n  JsonToken token = peek();\n  if (token == JsonToken.BOOLEAN) {\n    // Consume the token\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedBoolean;\n  } else if (token == JsonToken.STRING) {\n    // Consume the token\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Boolean.parseBoolean(peekedString);\n  }\n  throw new IllegalStateException(\"Expected BOOLEAN but was \" + peek());\n}",
      "public boolean nextBoolean() throws IOException  {\n  return nextBoolean();\n}",
      "public boolean nextBoolean() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.BOOLEAN) {\n        return nextBoolean();\n    } else if (peek == JsonToken.NULL) {\n        nextNull();\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected BOOLEAN but was \" + peek);\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  // Consume the next token\n  peek();\n\n  // Check if the next token is a boolean\n  if (token == JsonToken.BOOLEAN) \n  {\n    // Return the boolean value\n    return Boolean.parseBoolean(value);\n  } \n  else \n  {\n    // Throw an exception if the next token is not a boolean\n    throw new IllegalStateException(\"Expected BOOLEAN but was \" + token);\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    // TODO: Implement this method\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Iterate over the arguments of the method call.\n  for (Node arg : call.getChildNodes()) {\n    // If the argument has side effects, return true.\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  // Otherwise, return false.\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node firstArg = call.getFirstChild().getNext();\n    if (firstArg == null) \n    {\n        return false;\n    }\n    for (Node arg = firstArg; arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getChildNodes()) {\n        if (argMayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getFirstChild().getNext();\n  while (args != null) {\n    if (args.hasSideEffects()) {\n      return true;\n    }\n    args = args.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node argList = call.getFirstChild().getNext();\n    if (argList.getType() == Token.NAME) {\n        return true;\n    }\n    for (Node arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n        if (NodeUtil.mayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) \n    {\n        if (args.getType() == Token.NAME) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.CALL) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.NEW) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.GETPROP) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.GETELEM) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.INC) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.DEC) \n        {\n            return true;\n        } \n        else if (args.getType() == Token.STRING) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.NUMBER) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.NULL) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.THIS) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.TRUE) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.FALSE) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.REGEXP) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.ARRAYLIT) \n        {\n            return false;\n        } \n        else if (args.getType() == Token.OBJECTLIT) \n        {\n            return false;\n        } \n}\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the arguments of the call have side effects.\n    for (Node arg : call.getChildNodes()) \n    {\n        if (arg.hasSideEffects()) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // Check if the arguments have side effects.\n  for (Node arg : call.getChild(1).children()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) {\n        if (args.getType() == Token.CALL) {\n            if (argsMayHaveSideEffects((Node) args)) {\n                return true;\n            }\n        } else if (args.getType() == Token.NEW) {\n            return true;\n        } else if (NodeUtil.mayHaveSideEffects(args)) {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  // If the call has no arguments, it cannot have side effects.\n  if (call.getChildCount() == 0) {\n    return false;\n  }\n\n  // Check if any of the arguments have side effects.\n  for (Node arg : call.children()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n\n  // No arguments have side effects.\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if (p == null) {\n        final int n = pivot.length;\n        final T[] data = buildArray(field, n * n);\n        for (int i = 0; i < n; ++i) {\n            data[i * n + pivot[i]] = field.getOne();\n        }\n        p = MatrixUtils.createFieldMatrix(data);\n    }\n    return p;\n}",
      "public FieldMatrix<T> getP()  {\n        final int n = pivot.length;\n        final FieldMatrix<T> p = MatrixUtils.createFieldMatrix(field, n, n);\n        for (int i = 0; i < n; ++i) {\n            p.setEntry(i, pivot[i], field.getOne());\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n    return new Array2DRowFieldMatrix<T>(p, false);\n}",
      "public FieldMatrix<T> getP()  {\n        final int n = pivot.length;\n        final FieldMatrix<T> p = MatrixUtils.createFieldMatrix(field, n, n);\n        for (int i = 0; i < n; ++i) {\n            p.setEntry(i, pivot[i], field.getOne());\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n        final int n = pivot.length;\n        final FieldMatrix<T> p = MatrixUtils.createFieldMatrix(field, n, n);\n        for (int i = 0; i < n; ++i) {\n            p.setEntry(i, pivot[i], field.getOne());\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n        if (p == null) {\n            final int n = pivot.length;\n            p = createMatrix(n, n);\n            for (int i = 0; i < n; ++i) {\n                p.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n    return p;\n}",
      "public FieldMatrix<T> getP()  {\n        if (p == null) {\n            if (pivot == null) {\n                throw new IllegalStateException(\"decomposition not computed\");\n            }\n            p = createFieldMatrix(pivot.length, pivot.length);\n            for (int i = 0; i < pivot.length; ++i) {\n                p.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return p;\n    }",
      "public FieldMatrix<T> getP()  {\n        return new Array2DRowFieldMatrix<T>(p, false);\n    }",
      "public FieldMatrix<T> getP()  {\n        if (p == null) {\n            if (pivot == null) {\n                throw new IllegalStateException(\"Decomposition not computed\");\n            }\n            final int n = pivot.length;\n            p = MatrixUtils.createFieldMatrix(field, n, n);\n            for (int i = 0; i < n; ++i) {\n                p.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return p;\n    }"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    for (final ZipExtraField extraField : data) {\n        if (extraField instanceof ExtraFile) {\n            final byte[] localFileData = ((ExtraFile) extraField).getLocalFileDataData();\n            if (localFileData != null) {\n                bos.write(localFileData);\n            }\n        }\n    }\n    return bos.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<byte[]> dataList = new ArrayList<byte[]>();\n    for (final ZipExtraField field : data) \n    {\n        dataList.add(field.getLocalFileDataData());\n    }\n    return merge(dataList);\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    //TODO: Implement this method\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (final ZipExtraField field : data) {\n        final byte[] fieldData = field.getLocalFileDataData();\n        result = Arrays.copyOf(result, result.length + fieldData.length);\n        System.arraycopy(fieldData, 0, result, result.length - fieldData.length, fieldData.length);\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null) \n    {\n        return null;\n    }\n    int totalLength = 0;\n    for (final ZipExtraField element : data) \n    {\n        totalLength += element.getLocalFileDataLength();\n    }\n    final byte[] result = new byte[totalLength];\n    int offset = 0;\n    for (final ZipExtraField element : data) \n    {\n        final byte[] localFileData = element.getLocalFileDataData();\n        System.arraycopy(localFileData, 0, result, offset, localFileData.length);\n        offset += localFileData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField ze : data) {\n        if (ze == null) {\n            continue;\n        }\n        final byte[] b = ze.getLocalFileDataData();\n        if (b != null) {\n            baos.write(b);\n        }\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField extra : data) {\n        if (extra instanceof LocalFileDataExtraField) {\n            final LocalFileDataExtraField local = (LocalFileDataExtraField) extra;\n            final byte[] bytes = local.getLocalFileDataData();\n            baos.write(bytes);\n        }\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField extra : data) {\n        byte[] data = extra.getLocalFileDataData();\n        if (data != null) {\n            result = Arrays.copyOf(result, result.length + data.length);\n            System.arraycopy(data, 0, result, result.length - data.length, data.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    byte[] result = null;\n    if (data != null) {\n        int totalLength = 0;\n        for (final ZipExtraField element : data) {\n            if (element != null) {\n                totalLength += element.getLocalFileDataLength().getValue();\n            }\n        }\n        if (totalLength > 0) {\n            final byte[] localFileData = new byte[totalLength];\n            int pos = 0;\n            for (final ZipExtraField element : data) {\n                if (element != null) {\n                    final byte[] localFileDataElement = element.getLocalFileDataData();\n                    System.arraycopy(localFileDataElement, 0, localFileData, pos, localFileDataElement.length);\n                    pos += localFileDataElement.length;\n                }\n            }\n            result = localFileData;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    // Your code goes here\n    return null;\n}"
    ],
    [
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (high == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return high;\n}",
      "public double getSup()  {\n    if(isEmpty())\n    {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else if(highBound == Double.POSITIVE_INFINITY)\n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else\n    {\n        return highBound;\n    }\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (high == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return high;\n}",
      "public double getSup()  {\n    // TODO: implement this method\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (highBound == Double.POSITIVE_INFINITY) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return highBound;\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (high == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return high;\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return max;\n}",
      "public double getSup()  {\n    if (this.isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return this.getHigh();\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (hasHighBound()) {\n        return highBound;\n    }\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return high;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean escaped = false;\n    final StringBuilder sb = new StringBuilder();\n    while (ch != -1) {\n        if (escaped) {\n            sb.append((char) ch);\n            escaped = false;\n        } else {\n            if (ch == '\\\\') {\n                escaped = true;\n            } else if (ch == delimiter) {\n                token.type = Token.TOKEN;\n                token.value = sb.toString();\n                return token;\n            } else if (ch == '\\r' || ch == '\\n') {\n                token.type = Token.EORECORD;\n                token.value = sb.toString();\n                return token;\n            } else {\n                sb.append((char) ch);\n            }\n        }\n        ch = reader.read();\n    }\n    token.type = Token.EOF;\n    token.value = sb.toString();\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // read the next character\n    ch = read();\n    // loop until the end of the token\n    while (ch != -1 && ch != EORECORD && ch != EOF && ch != delimiter) {\n        // check if the character is escaped\n        if (ch == escapeChar) {\n            // read the next character\n            ch = read();\n            // check if the next character is a delimiter\n            if (ch == delimiter) {\n                // add the delimiter to the token\n                token.add(delimiter);\n            } else if (ch == escapeChar) {\n                // add the escape character to the token\n                token.add(escapeChar);\n            } else {\n                // add the character to the token\n                token.add(ch);\n            }\n        } else {\n            // add the character to the token\n            token.add(ch);\n        }\n        // read the next character\n        ch = read();\n    }\n    // return the token\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder buffer = token.buffer;\n    while (ch != EORECORD && ch != EOF && ch != DELIMITER) {\n        if (ch == ESCAPE) {\n            ch = read();\n            if (ch == EORECORD || ch == EOF) {\n                break;\n            }\n        }\n        buffer.append((char) ch);\n        ch = read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: implement\n    return null;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // initialize token\n    token.setStart(currentPosition);\n    token.setEnd(currentPosition);\n    token.setType(Token.TOKEN);\n\n    // parse simple token\n    while (ch != -1) {\n        if (ch == '\\r' || ch == '\\n') {\n            // end of line reached\n            token.setEnd(currentPosition);\n            token.setType(Token.EORECORD);\n            return token;\n        } else if (ch == '\\t' || ch == ' ') {\n            // end of token reached\n            token.setEnd(currentPosition);\n            token.setType(Token.TOKEN);\n            return token;\n        } else if (ch == '\\'') {\n            // end of token reached\n            token.setEnd(currentPosition);\n            token.setType(Token.TOKEN);\n            return token;\n        } else if (ch == '\\\\') {\n            // escaped delimiter\n            ch = reader.read();\n            if (ch == -1) {\n                // end of stream reached\n                token.setEnd(currentPosition);\n                token.setType(Token.EOF);\n                return token;\n            } else if (ch == '\\r' || ch == '\\n') {\n                // end of line reached\n                token.setEnd(currentPosition);\n                token.setType(Token.EORECORD);\n                return token;\n            } else if (ch == '\\t' || ch == ' ') {\n                // end of token reached\n                token.setEnd(currentPosition);\n                token.setType(Token.TOKEN);\n                return token;\n            } else if (ch == '\\'') {\n                // end of token reached\n                token.setEnd(currentPosition);\n                token.setType(Token.TOKEN);\n                return token;\n            }\n        }\n\n        // update position\n        currentPosition++;\n\n        // read next character\n        ch = reader.read();\n    }\n\n    // end of stream reached\n    token.setEnd(currentPosition);\n    token.setType(Token.EOF);\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // The current token is empty.\n    // If the current character is a delimiter, then the token is finished.\n    // Otherwise, add the character to the token.\n    if (token.isEmpty()) {\n        if (isDelimiter(ch)) {\n            token.setType(Token.TOKEN_TYPE.DELIMITER);\n            token.setValue(String.valueOf((char) ch));\n        } else {\n            token.setType(Token.TOKEN_TYPE.SIMPLE_TOKEN);\n            token.setValue(String.valueOf((char) ch));\n        }\n    } else {\n        // The current token is not empty.\n        // If the current character is a delimiter, then the token is finished.\n        // Otherwise, add the character to the token.\n        if (isDelimiter(ch)) {\n            token.setType(Token.TOKEN_TYPE.DELIMITER);\n            token.setValue(String.valueOf((char) ch));\n        } else {\n            token.setType(Token.TOKEN_TYPE.SIMPLE_TOKEN);\n            token.setValue(token.getValue() + String.valueOf((char) ch));\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        switch (ch) \n        {\n            case -1:\n                token.type = Token.Type.EOF;\n                return token;\n            case '\\n':\n                token.type = Token.Type.EORECORD;\n                return token;\n            case delimiter:\n                token.type = Token.Type.TOKEN;\n                return token;\n            case '\\\\':\n                ch = reader.read();\n                if (ch == -1) \n                {\n                    token.type = Token.Type.EOF;\n                    return token;\n                }\n                if (ch == '\\n') \n                {\n                    token.type = Token.Type.EORECORD;\n                    return token;\n                }\n                if (ch == delimiter) \n                {\n                    token.type = Token.Type.TOKEN;\n                    return token;\n                }\n                token.append((char) ch);\n                break;\n            default:\n                token.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (ch != -1 && ch != delimiter && ch != '\\n' && ch != '\\r') {\n        if (ch == '\\\\') {\n            ch = read();\n            if (ch == -1) {\n                throw new IOException(\"EOF reached after escape character\");\n            }\n            if (ch == '\\n' || ch == '\\r') {\n                token.append((char) ch);\n            } else {\n                token.append('\\\\');\n                token.append((char) ch);\n            }\n        } else {\n            token.append((char) ch);\n        }\n        ch = read();\n    }\n    if (ch == '\\n' || ch == '\\r') {\n        token.setType(Token.EORECORD);\n    } else if (ch == delimiter) {\n        token.setType(Token.TOKEN);\n    } else if (ch == -1) {\n        token.setType(Token.EOF);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // token.setType(Token.TOKEN);\n    while (ch != -1 && ch != this.delimiter && ch != this.eol) \n    {\n        if (ch == this.escape) \n        {\n            ch = this.read();\n            if (ch == -1) \n            {\n                token.setType(Token.EOF);\n                return token;\n            } \n            else if (ch == this.eol) \n            {\n                token.setType(Token.EORECORD);\n                return token;\n            } \n            else if (ch == this.escape) \n            {\n                token.append(this.escape);\n            } \n            else \n            {\n                token.append(ch);\n            }\n        } \n        else \n        {\n            token.append(ch);\n        }\n        ch = this.read();\n    }\n    if (ch == this.delimiter) \n    {\n        token.setType(Token.TOKEN);\n    } \n    else if (ch == this.eol) \n    {\n        token.setType(Token.EORECORD);\n    } \n    else if (ch == -1) \n    {\n        token.setType(Token.EOF);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // TODO: complete this method\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= size) {\n            throw new OutOfRangeException(index, 0, size);\n        }\n        int[] counts = new int[n];\n        for (int i = 0; i < n; i++) {\n            counts[i] = index % counts[i];\n            index /= counts[i];\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n    int[] counts = new int[getDimension()];\n    for (int i = 0; i < counts.length; i++) {\n        counts[i] = index % getSize(i);\n        index /= getSize(i);\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= getSize()) {\n            throw new OutOfRangeException(\"Index out of range\");\n        }\n        int[] counts = new int[getDimension()];\n        int div = 1;\n        for (int i = getDimension() - 1; i >= 0; i--) {\n            counts[i] = index / div;\n            index %= div;\n            div *= getSize(i);\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(\"Index out of range: \" + index);\n    }\n    int[] counts = new int[getDimensions()];\n    for (int i = 0; i < counts.length; i++) {\n        counts[i] = index % getSize(i);\n        index /= getSize(i);\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[getDimensions()];\n    for (int i = 0; i < counts.length; i++) {\n        counts[i] = index % getSize(i);\n        index /= getSize(i);\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(\"Index out of range\");\n    }\n    int[] counts = new int[getDimension()];\n    int quotient = index;\n    for (int i = getDimension() - 1; i >= 0; i--) {\n        counts[i] = quotient % getSize(i);\n        quotient /= getSize(i);\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= size) {\n        throw new OutOfRangeException(\"Index \" + index + \" is out of range [0, \" + size + \")\");\n    }\n    int[] counts = new int[2];\n    counts[0] = index / 10;\n    counts[1] = index % 10;\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= size) {\n        throw new OutOfRangeException(\"index out of range\");\n    }\n    int[] counts = new int[n];\n    for (int i = 0; i < n; i++) {\n        counts[i] = index % (i + 1);\n        index /= i + 1;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n\n    int[] counts = new int[getDimensions()];\n    for (int i = 0; i < getDimensions(); i++) {\n        counts[i] = index % getSize(i);\n        index /= getSize(i);\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[getDimensions()];\n    for (int i = 0; i < counts.length; i++) {\n        counts[i] = index % getSize(i);\n        index /= getSize(i);\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last.next != null) {\n        last = last.next;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last.next != null) {\n        last = last.next;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    if (this.segments.isEmpty()) {\n        throw new IllegalStateException(\"JSON Pointer is empty\");\n    }\n    int last = this.segments.size() - 1;\n    JsonPointer pointer = new JsonPointer(this.segments.subList(0, last));\n    return pointer;\n}",
      "public JsonPointer last()  {\n    return new JsonPointer(this.segments.subList(this.segments.size() - 1, this.segments.size()));\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p.next != null) {\n        p = p.next;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer result = this;\n    while (result.next != null) \n    {\n        result = result.next;\n    }\n    return result;\n}",
      "public JsonPointer last()  {\n    if (this.path.isEmpty()) \n    {\n        return this;\n    }\n    else \n    {\n        JsonPointer last = this;\n        for (String segment : this.path) \n        {\n            last = last.append(segment);\n        }\n        return last;\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p.next != null) {\n        p = p.next;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    if (segments.isEmpty()) {\n        return this;\n    }\n    return new JsonPointer(segments.subList(0, segments.size() - 1));\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p.next != null) \n    {\n        p = p.next;\n    }\n    return p;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read = data.read(buffer, 0, 8192);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, 8192);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read = data.read(buffer, 0, 8192);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, 8192);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Create buffer to read data\n    byte[] buffer = new byte[8192];\n    int read;\n\n    // Read data until EOF\n    while ((read = data.read(buffer)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n\n    // Return digest\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer, 0, 8192)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Complete this function\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Complete this function\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Create buffer\n    final byte[] buffer = new byte[8192];\n    int read;\n    // Read data until EOF\n    while ((read = data.read(buffer)) > -1) {\n        // Update the digest\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[8192];\n    int read;\n    while ((read = data.read(buffer, 0, 8192)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Complete this function\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    // Create a buffer to read the data in chunks\n    byte[] buffer = new byte[8192];\n    int nread;\n\n    // Read all the data\n    while ((nread = data.read(buffer)) != -1) {\n        // Update the digest with the data read\n        digest.update(buffer, 0, nread);\n    }\n\n    // Return the digest\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  throws CloneFailedException \n{\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because clone() is not generic\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because clone() is not generic\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + obj, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return (T) clone.invoke(obj);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Clone failed\", ex);\n        }\n    }\n    throw new CloneFailedException(\"Clone not supported\");\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        Class<?> cls = obj.getClass();\n        try \n        {\n            @SuppressWarnings(\"unchecked\")\n            T clone = (T) cls.newInstance();\n            return clone;\n        } \n        catch (InstantiationException ex) \n        {\n            throw new CloneFailedException(\"Clone not supported. \" + ex);\n        } \n        catch (IllegalAccessException ex) \n        {\n            throw new CloneFailedException(\"Clone not supported. \" + ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n            final T clone = (T) cls.newInstance();\n            return clone;\n        } catch (final InstantiationException ex) {\n            throw new CloneFailedException(\"Clone not supported. InstantiationException.\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not supported. IllegalAccessException.\", ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // clone() is covariant\n            T clone = (T) cls.getDeclaredMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T) cls.newInstance();\n            return result;\n        } catch (InstantiationException ex) {\n            throw new CloneFailedException(\"Clone not supported. \" + ex);\n        } catch (IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not supported. \" + ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        final Class<?> cls = obj.getClass();\n        try {\n            final Method clone = cls.getMethod(\"clone\");\n            return (T) clone.invoke(obj);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not supported\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Clone failed\", ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException \n{\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because clone() is not generic\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(\"Clone not supported: \" + ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because clone() is not generic\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        for (Symbol param : sym.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        // get the function's parameters\n        Symbol params = sym.getProperty(\"params\");\n        // if we found some parameters\n        if (params != null) {\n            // loop through each parameter\n            for (Symbol param : params.getAllProperties()) {\n                // if the parameter's name matches the given name\n                if (param.getName().equals(paramName)) {\n                    // return the parameter\n                    return param;\n                }\n            }\n        }\n    }\n    // if we didn't find any parameters\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getKind() == ElementKind.METHOD) {\n    for (Symbol param : sym.getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param;\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType() != Symbol.Type.FUNCTION) {\n        return null;\n    }\n\n    SymbolTable symTable = sym.getFunctionSymbolTable();\n    if (symTable == null) {\n        return null;\n    }\n\n    Symbol param = symTable.getSymbol(paramName);\n    if (param == null) {\n        return null;\n    }\n\n    return param;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        SymbolTable symTable = sym.getSymbolTable();\n        SymbolTable.Scope scope = symTable.getScope(sym);\n        Symbol param = scope.getSymbol(paramName);\n        if (param != null) {\n            return param;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getType() == Symbol.Type.FUNCTION) {\n    SymbolTable symTable = sym.getSymbolTable();\n    Symbol param = symTable.getSymbol(paramName);\n    if (param != null) {\n      return param;\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // TODO: Fill this in.\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // TODO: Implement this function\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) {\n        for (Symbol param : sym.getParameters()) {\n            if (param.getName().equals(paramName)) {\n                return param;\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // check for sufficient data\n    if (matrix.getColumnDimension() < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_MATRIX_NOT_ENOUGH_DATA);\n    }\n\n    // compute covariance matrix\n    RealMatrix covariance = matrix.transpose().multiply(matrix);\n\n    // correct for bias\n    if (biasCorrected) {\n        covariance.scalarMultiply(1 / (matrix.getRowDimension() - 1));\n    }\n\n    return covariance;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX);\n        }\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / (matrix.getRowDimension() - 1)));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / matrix.getRowDimension()));\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.TOO_SMALL, matrix.getColumnDimension(), 2);\n        }\n        if (matrix.getRowDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.TOO_SMALL, matrix.getRowDimension(), 2);\n        }\n        final int n = matrix.getColumnDimension();\n        final RealMatrix covariance = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        if (biasCorrected) {\n            covariance.scalarMultiply(n/(n-1.0));\n        }\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getColumnDimension();\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX);\n    }\n    RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n    if (biasCorrected) {\n        covarianceMatrix.scalarMultiply(n/(n-1.0));\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check that the matrix has sufficient data\n        if (matrix.getColumnDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX,\n                                                   matrix.getColumnDimension(), 2);\n        }\n\n        // Compute the covariance matrix\n        RealMatrix covariance = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n\n        // Correct for bias if necessary\n        if (biasCorrected) {\n            covariance = covariance.scalarMultiply((1.0 / (matrix.getRowDimension() - 1)));\n        } else {\n            covariance = covariance.scalarMultiply((1.0 / matrix.getRowDimension()));\n        }\n\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 1)\n        {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX);\n        }\n        else if (matrix.getColumnDimension() == 1)\n        {\n            return matrix.scalarMultiply(0.0);\n        }\n        else\n        {\n            RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n            if (biasCorrected)\n            {\n                covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / (matrix.getRowDimension() - 1)));\n            }\n            else\n            {\n                covarianceMatrix = covarianceMatrix.scalarMultiply((1.0 / matrix.getRowDimension()));\n            }\n            return covarianceMatrix;\n        }\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check input\n        if (matrix.getColumnDimension() < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_COLUMNS,\n                                                   matrix.getColumnDimension(), 1);\n        }\n        if (matrix.getRowDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_ROWS,\n                                                   matrix.getRowDimension(), 2);\n        }\n\n        // Compute covariance matrix\n        RealMatrix covariance = matrix.transpose().multiply(matrix);\n        covariance = covariance.scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n\n        // Bias-corrected covariance matrix\n        if (biasCorrected) {\n            RealMatrix factor = matrix.getSubMatrix(1, matrix.getRowDimension() - 1,\n                                                    0, matrix.getColumnDimension() - 1);\n            factor = factor.transpose().multiply(factor);\n            factor = factor.scalarMultiply(1.0 / (matrix.getRowDimension() - 2));\n            covariance = covariance.subtract(factor);\n        }\n\n        return covariance;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Get the number of rows and columns in the input matrix\n        int nRows = matrix.getRowDimension();\n        int nCols = matrix.getColumnDimension();\n\n        // Check that the input matrix has sufficient data\n        if (nRows < 2 || nCols < 1)\n        {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX, nRows, nCols);\n        }\n\n        // Create a covariance matrix with the same dimensions as the input matrix\n        RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(nCols, nCols);\n\n        // Compute the covariance matrix\n        for (int i = 0; i < nCols; i++)\n        {\n            for (int j = i; j < nCols; j++)\n            {\n                double covariance = 0;\n\n                // Compute the covariance between the i-th and j-th columns\n                for (int k = 0; k < nRows; k++)\n                {\n                    covariance += (matrix.getEntry(k, i) - matrix.getColumnMean(i)) * (matrix.getEntry(k, j) - matrix.getColumnMean(j));\n                }\n\n                // Store the covariance in the covariance matrix\n                covarianceMatrix.setEntry(i, j, covariance);\n\n                // If the covariance matrix is not symmetric, compute the covariance between the j-th and i-th columns\n                if (i != j)\n                {\n                    covarianceMatrix.setEntry(j, i, covariance);\n                }\n            }\n        }\n\n        // If the covariance matrix is bias-corrected, divide the covariance matrix by the number of rows minus one\n        if (biasCorrected)\n        {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1 / (nRows - 1));\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getColumnDimension();\n    int m = matrix.getRowDimension();\n    if (m < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX, m, 2);\n    }\n    RealMatrix covarianceMatrix = matrix.copy();\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            double covariance = 0;\n            for (int k = 0; k < m; k++) {\n                covariance += (matrix.getEntry(k, i) - covarianceMatrix.getEntry(i, i)) *\n                              (matrix.getEntry(k, j) - covarianceMatrix.getEntry(j, j));\n            }\n            if (biasCorrected) {\n                covariance *= m / (m - 1.0);\n            }\n            covarianceMatrix.setEntry(i, j, covariance);\n            covarianceMatrix.setEntry(j, i, covariance);\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 2)\n        {\n            throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_MATRIX_NOT_ENOUGH_DATA);\n        }\n        RealMatrix covariance = matrix.subtract(matrix.getColumnMean()).transpose().multiply(matrix.subtract(matrix.getColumnMean()));\n        if (biasCorrected)\n        {\n            covariance.scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n        }\n        else\n        {\n            covariance.scalarMultiply(1.0 / matrix.getRowDimension());\n        }\n        return covariance;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63)\n        throw new IllegalArgumentException(\"Invalid number of bits to read\");\n    long result = 0;\n    int offset = 0;\n    while (offset < count) {\n        int bits = read();\n        if (bits < 0)\n            return -1;\n        result |= (long) bits << offset;\n        offset += 8;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    long result = 0;\n    int bitsRead = 0;\n    while (bitsRead < count) \n    {\n        final int bitsLeft = count - bitsRead;\n        final int bitsToRead = Math.min(bitsLeft, 32);\n        final int bits = readInt();\n        if (bits == -1) \n        {\n            return -1;\n        }\n        result = result << bitsToRead | bits & (1 << bitsToRead) - 1;\n        bitsRead += bitsToRead;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63)\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    long result = 0;\n    int offset = 0;\n    while (offset < count)\n    {\n        int b = read();\n        if (b == -1)\n            return -1;\n        result |= (b & 0xFFL) << offset;\n        offset += 8;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    int currentByte = read();\n    if (currentByte == -1) {\n        return -1;\n    }\n    long result = currentByte & 0xff;\n    for (int i = 1; i < count / 8; i++) {\n        currentByte = read();\n        if (currentByte == -1) {\n            return -1;\n        }\n        result = (result << 8) | (currentByte & 0xff);\n    }\n    if (count % 8 != 0) {\n        currentByte = read();\n        if (currentByte == -1) {\n            return -1;\n        }\n        result = (result << (count % 8)) | (currentByte >> (8 - (count % 8)));\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IllegalArgumentException(\"Invalid count: \" + count);\n    }\n    if (count == 63) {\n        return -1;\n    }\n    long result = 0;\n    int shift = 0;\n    while (count > 0) {\n        final int b = read();\n        if (b == -1) {\n            return -1;\n        }\n        result |= (b & 0xFFL) << shift;\n        shift += 8;\n        count -= 8;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) {\n        throw new IllegalArgumentException(\"Invalid number of bits to read: \" + count);\n    }\n    int bitsRead = 0;\n    long result = 0;\n    while (bitsRead < count) {\n        final int bitsLeft = count - bitsRead;\n        final int bitsToRead = Math.min(bitsLeft, 8);\n        final int b = read();\n        if (b == -1) {\n            return -1;\n        }\n        result <<= bitsToRead;\n        result |= (b & ((1 << bitsToRead) - 1));\n        bitsRead += bitsToRead;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    // Implement the function\n}",
      "public long readBits(final int count) throws IOException  {\n    //TODO: implement this method\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be a positive number not bigger than 63\");\n    }\n    long result = 0;\n    int read = 0;\n    while (read < count) {\n        final int next = readBits(6);\n        if (next == -1) {\n            return -1;\n        }\n        result = (result << 6) | next;\n        read += 6;\n    }\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than 63\");\n    }\n    long result = 0;\n    int shift = 0;\n    while (count > 0) {\n        int read = read();\n        if (read == -1) {\n            return -1;\n        }\n        result |= (long) read << shift;\n        shift += 8;\n        count -= 8;\n    }\n    return result;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(v.getDimension(), this.getColumnDimension());\n    for (int i = 0; i < v.getDimension(); i++) {\n        for (int j = 0; j < this.getColumnDimension(); j++) {\n            result.setEntry(i, j, this.getEntry(i, j).multiply(v.getEntry(i)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(v.getDimension(), this.getColumnDimension());\n    for (int i = 0; i < v.getDimension(); i++) {\n        for (int j = 0; j < this.getColumnDimension(); j++) {\n            result.setEntry(i, j, v.getEntry(i).multiply(this.getEntry(i, j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    if (v.getDimension() != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"Dimensions must be equal\");\n    }\n    FieldMatrix<T> result = createMatrix(this.getRowDimension(), v.getDimension());\n    for (int i = 0; i < this.getRowDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, this.getEntry(i, j).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int n = this.getColumnDimension();\n    int m = v.getDimension();\n    FieldMatrix<T> result = this.getField().getMatrixFactory().createFieldMatrix(n, m);\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            result.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int n = v.getDimension();\n    int m = this.getColumnDimension();\n    FieldMatrix<T> res = MatrixUtils.createFieldMatrix(n, m, this.getField());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            res.setEntry(i, j, this.getEntry(i, j).multiply(v.getEntry(i)));\n        }\n    }\n    return res;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    // compute the outer product\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(this.getRowDimension(), v.getDimension());\n    for (int i = 0; i < this.getRowDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(v.getDimension(), this.getColumnDimension());\n    for (int i = 0; i < v.getDimension(); i++) {\n        for (int j = 0; j < this.getColumnDimension(); j++) {\n            result.setEntry(i, j, v.getEntry(i).multiply(this.getEntry(i, j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    FieldMatrix<T> result = MatrixUtils.createFieldMatrix(v.getDimension(), this.getColumnDimension());\n    for (int i = 0; i < v.getDimension(); i++) {\n        for (int j = 0; j < this.getColumnDimension(); j++) {\n            result.setEntry(i, j, this.getEntry(i, j).multiply(v.getEntry(i)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int n = this.getColumnDimension();\n    int m = v.getDimension();\n    FieldMatrix<T> result = MatrixUtils.createFieldMatrix(n, m, this.getField());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        // Create a matrix with the same dimensions as the instance\n        FieldMatrix<T> result = MatrixUtils.createFieldMatrix(getRowDimension(), v.getDimension(), getField());\n\n        // Fill the matrix with the outer product\n        for (int i = 0; i < getRowDimension(); i++) {\n            for (int j = 0; j < v.getDimension(); j++) {\n                result.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n            }\n        }\n\n        return result;\n    }"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    if (target instanceof Label) \n    {\n        return label.equals(((Label) target).getLabel());\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target == null) {\n        return false;\n    }\n    if (target instanceof LabeledStatement) {\n        LabeledStatement ls = (LabeledStatement) target;\n        return label.equals(ls.getLabel());\n    }\n    return matchLabel(target.getParent(), label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    return target.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  return target.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    if (target.getLabel() == null) \n    {\n        return false;\n    }\n    return target.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof JumpStmt) {\n        return label.equals(((JumpStmt) target).getLabel());\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    if (target.getLabel() == null) \n    {\n        return false;\n    }\n    return target.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target instanceof Label) {\n        return label.equals(((Label) target).getLabel());\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n\n  if (target instanceof Label) {\n    return label.equals(((Label) target).getLabel());\n  }\n\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target instanceof Label) {\n    return label.equals(((Label) target).getLabel());\n  }\n  return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    // COMPLETE THIS METHOD\n}",
      "public String getURL(int series, int item)  {\n    // TODO: implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    if (series >= 0 && series < this.series.size() && item >= 0 && item < this.series.get(series).getItemCount()) \n    {\n        url = this.series.get(series).getURL(item);\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: implement this method\n}",
      "public String getURL(int series, int item)  {\n    // TODO: implement this method\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    if (series == 0) \n    {\n        if (item == 0) \n        {\n            url = \"http://www.example.com/series0/item0.html\";\n        }\n        else if (item == 1) \n        {\n            url = \"http://www.example.com/series0/item1.html\";\n        }\n        else if (item == 2) \n        {\n            url = \"http://www.example.com/series0/item2.html\";\n        }\n    }\n    else if (series == 1) \n    {\n        if (item == 0) \n        {\n            url = \"http://www.example.com/series1/item0.html\";\n        }\n        else if (item == 1) \n        {\n            url = \"http://www.example.com/series1/item1.html\";\n        }\n        else if (item == 2) \n        {\n            url = \"http://www.example.com/series1/item2.html\";\n        }\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    if (series >= 0 && series < this.series.length) \n    {\n        Series s = this.series[series];\n        if (item >= 0 && item < s.items.length) \n        {\n            url = s.items[item].url;\n        }\n    }\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    // TODO: implement this method\n}",
      "public String getURL(int series, int item)  {\n    String url = null;\n    // TODO: implement this method\n    return url;\n}",
      "public String getURL(int series, int item)  {\n    // TODO add your code here\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        System.out.println(\"Invalid index: \" + str);\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        System.out.println(\"Invalid index: \" + str);\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        return -1;\n    }\n    int index = 0;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        // Ignore\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    if (str.startsWith(\"[\")) {\n        index = Integer.parseInt(str.substring(1, str.length() - 1));\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n        index = Integer.parseInt(str.substring(1, str.length() - 1));\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = -1;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        // Do nothing\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.equals(\"\"))\n        return -1;\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    if (str.startsWith(\"[\")) {\n        index = Integer.parseInt(str.substring(1, str.length() - 1));\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    try \n    {\n        index = Integer.parseInt(str);\n    } \n    catch (NumberFormatException e) \n    {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    return index;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 1) {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 0) {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 1)\n    {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size())\n    {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++)\n    {\n        sample[i] = c.toArray()[i];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k < 1)\n        throw new NotStrictlyPositiveException(k);\n    if (k > c.size())\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    Object[] sample = new Object[k];\n    int i = 0;\n    while (i < k) {\n        int j = i + 1;\n        while (j < k) {\n            if (nextBoolean()) {\n                sample[i] = sample[j];\n                sample[j] = c.iterator().next();\n            }\n            j++;\n        }\n        sample[i] = c.iterator().next();\n        i++;\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n\n    if (k < 1) {\n        throw new NotStrictlyPositiveException(k);\n    }\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(k, c.size(), true);\n    }\n\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    return new CallNode(srcref,\n                        new FuncNode(srcref,\n                                     new NameNode(srcref, methodName),\n                                     new ArgumentListNode(srcref, argumentNode)),\n                        null);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = new Node(Token.CALL, srcref);\n        callNode.addChildToBack(new Node(Token.NAME, srcref, methodName));\n        callNode.addChildToBack(argumentNode);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Get the method name.\n    String methodName = methodName.toString();\n\n    // Get the method argument.\n    Node argumentNode = argumentNode.getFirstChild();\n\n    // Get the source reference.\n    Node srcref = srcref.getFirstChild();\n\n    // Create a new method call node.\n    Node methodCallNode = new Node(Token.CALL, srcref);\n\n    // Set the method name.\n    methodCallNode.putProp(Node.NAME_PROP, methodName);\n\n    // Set the method argument.\n    methodCallNode.addChildToBack(argumentNode);\n\n    // Return the method call node.\n    return methodCallNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node methodNode = buildMethodCall(methodName, srcref);\n        Node callNode = buildCallNode(methodNode, argumentNode, srcref);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node methodNode = buildMethodNode(methodName, srcref);\n        return buildCallNode(methodNode, argumentNode, srcref);\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(this, srcref);\n    callNode.setName(methodName);\n    callNode.add(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node methodNode = new DotNode(srcref,\n                                      new DotNode(srcref,\n                                                  new SelfNode(srcref),\n                                                  methodName),\n                                      \"call\");\n        return new FCallNode(srcref, methodNode, argumentNode, null);\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Build a call node\n    CallNode callNode = new CallNode(srcref,\n                                     new IdentifierNode(srcref, methodName),\n                                     new NodeList<>(srcref),\n                                     null);\n\n    // Add the argument to the call node\n    callNode.addArgument(argumentNode);\n\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Token.CALL, srcref);\n    callNode.addChildToBack(new Node(Token.NAME, methodName, srcref));\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node methodCall = new Node(new SourceSection(getSource(), srcref.getStartLine(), srcref.getStartColumn(), srcref.getEndLine(), srcref.getEndColumn()),\n                               methodName, argumentNode);\n    methodCall.setSourceSection(srcref);\n    return methodCall;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    RealMatrix QT = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            QT.setEntry(i, j, QR.getEntry(i, j));\n        }\n    }\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    RealMatrix QT = new Array2DRowRealMatrix(this.Q.getRowDimension(), this.Q.getColumnDimension());\n    for (int i = 0; i < this.Q.getRowDimension(); i++) {\n        for (int j = 0; j < this.Q.getColumnDimension(); j++) {\n            QT.setEntry(i, j, this.Q.getEntry(j, i));\n        }\n    }\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    RealMatrix QT = new Array2DRowRealMatrix(Q.getRowDimension(), Q.getColumnDimension());\n    for (int i = 0; i < Q.getRowDimension(); i++) \n    {\n        for (int j = 0; j < Q.getColumnDimension(); j++) \n        {\n            QT.setEntry(i, j, Q.getEntry(j, i));\n        }\n    }\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    RealMatrix QT = new Array2DRowRealMatrix(Q.getRowDimension(), Q.getColumnDimension());\n    for (int i = 0; i < Q.getRowDimension(); i++) {\n        for (int j = 0; j < Q.getColumnDimension(); j++) {\n            QT.setEntry(i, j, Q.getEntry(j, i));\n        }\n    }\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    return QT;\n}",
      "public RealMatrix getQT()  {\n    return this.QT;\n}",
      "public RealMatrix getQT()  {\n    return this.QT;\n}",
      "public RealMatrix getQT()  {\n    return QT;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Comparable getGroup(Comparable key)  {\n    // TODO: implement this method\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = this.groupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = this.groupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    // TODO: Implement this method\n}",
      "public Comparable getGroup(Comparable key)  {\n    // TODO: implement this method\n    return null;\n}",
      "public Comparable getGroup(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n}",
      "public Comparable getGroup(Comparable key)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = null;\n    if (this.keyToGroupMap.containsKey(key)) \n    {\n        group = this.keyToGroupMap.get(key);\n    } \n    else \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = null;\n    if (key != null) \n    {\n        group = this.groupMap.get(key);\n        if (group == null) \n        {\n            group = this.defaultGroup;\n        }\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, old.length);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length;\n        while (newCapacity < capacity) {\n            newCapacity *= 2;\n        }\n        final char[] old = buffer;\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        int newCapacity = buffer.length;\n        while (newCapacity < capacity) \n        {\n            newCapacity = newCapacity << 1;\n        }\n        final char[] newBuffer = new char[newCapacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        int newSize = buffer.length;\n        while (newSize < capacity) \n        {\n            newSize = newSize << 1;\n        }\n        resize(newSize);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buf.length) {\n        final char[] newBuf = new char[capacity];\n        System.arraycopy(buf, 0, newBuf, 0, buf.length);\n        buf = newBuf;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        int newCapacity = buffer.length;\n        while (newCapacity < capacity) {\n            newCapacity <<= 1;\n        }\n        final char[] old = buffer;\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        int newSize = buffer.length;\n        while (newSize < capacity) \n        {\n            newSize *= 2;\n        }\n        resize(newSize);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    for (int series = 0; series < dataset.getSeriesCount(); series++) \n    {\n        double min = 0.0;\n        double max = 0.0;\n        for (int item = 0; item < dataset.getItemCount(series); item++) \n        {\n            double value = dataset.getValue(series, item).doubleValue();\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n        }\n        if (result == null) \n        {\n            result = new Range(min, max);\n        } \n        else \n        {\n            result = result.addRange(min, max);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item);\n            runningTotal += value;\n            if (runningTotal < minimum) \n            {\n                minimum = runningTotal;\n            }\n            if (runningTotal > maximum) \n            {\n                maximum = runningTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    for (int s = 0; s < dataset.getColumnCount(); s++) \n    {\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        for (int r = 0; r < dataset.getRowCount(); r++) \n        {\n            double runningTotal = 0.0;\n            for (int c = 0; c <= r; c++) \n            {\n                double v = dataset.getValue(r, c);\n                runningTotal += v;\n            }\n            min = Math.min(min, runningTotal);\n            max = Math.max(max, runningTotal);\n        }\n        Range r = new Range(min, max);\n        if (result == null) \n        {\n            result = r;\n        } \n        else \n        {\n            result = result.union(r);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item);\n            runningTotal += value;\n            double total = runningTotal;\n            if (result == null) {\n                result = new Range(total, total);\n            }\n            else {\n                if (total < result.getLowerBound()) {\n                    result.expandRange(total);\n                }\n                else if (total > result.getUpperBound()) {\n                    result.expandRange(total);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = 0.0;\n    double maximum = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item);\n            double runningTotal = value;\n            if (item > 0) \n            {\n                runningTotal += dataset.getValue(series, item - 1);\n            }\n            if (runningTotal < minimum) \n            {\n                minimum = runningTotal;\n            }\n            if (runningTotal > maximum) \n            {\n                maximum = runningTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) \n        {\n            double current = dataset.getValue(series, item);\n            runningTotal += current;\n            double currentValue = runningTotal;\n            if (result == null) \n            {\n                result = new Range(currentValue, currentValue);\n            } \n            else \n            {\n                result.ensureCovers(currentValue);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments...\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range of the values in the dataset...\n    Range range = new Range(0.0, 0.0);\n    for (int series = 0; series < dataset.getSeriesCount(); series++) \n    {\n        for (int item = 0; item < dataset.getItemCount(series); item++) \n        {\n            double value = dataset.getValue(series, item);\n            if (value < range.getLowerBound()) \n            {\n                range.expand(value);\n            }\n            else if (value > range.getUpperBound()) \n            {\n                range.expand(value);\n            }\n        }\n    }\n    return range;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // initialise the range\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n\n    // iterate through the categories and series...\n    for (int c = 0; c < dataset.getColumnCount(); c++) {\n        for (int r = 0; r < dataset.getRowCount(); r++) {\n            double runningTotal = 0.0;\n            for (int s = 0; s <= r; s++) {\n                double v = dataset.getValue(r, c);\n                runningTotal += v;\n            }\n            if (runningTotal < minimum) {\n                minimum = runningTotal;\n            }\n            if (runningTotal > maximum) {\n                maximum = runningTotal;\n            }\n        }\n    }\n\n    // return the range\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    for (int series = 0; series < dataset.getSeriesCount(); series++) \n    {\n        for (int item = 0; item < dataset.getItemCount(series); item++) \n        {\n            double value = dataset.getValue(series, item);\n            if (result == null) \n            {\n                result = new Range(value, value);\n            }\n            else \n            {\n                result = result.getUpdatedRange(value, value);\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < dataset.getColumnCount(); i++) \n    {\n        double runningTotal = 0;\n        for (int j = 0; j < dataset.getRowCount(); j++) \n        {\n            double value = dataset.getValue(j, i);\n            runningTotal += value;\n            if (runningTotal < minimum) \n            {\n                minimum = runningTotal;\n            }\n            if (runningTotal > maximum) \n            {\n                maximum = runningTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return forOffsetHoursMinutes(hoursOffset, minutesOffset, 0);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        // check for valid range\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n        }\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n        }\n        if (hoursOffset < 0 && minutesOffset > 0) {\n            throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n        }\n        // build the offset\n        int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        // create the object\n        return new FixedDateTimeZone(\"\", offset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return new DateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return forOffsetHoursMinutes(hoursOffset, minutesOffset, 0);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    return forOffsetHoursMinutes(hoursOffset, minutesOffset, 0);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return forOffsetHoursMinutes(hoursOffset, minutesOffset, 0);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(null, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    return new DateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n    return forOffsetMillis(hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Validate the input\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour offset is negative\");\n    }\n\n    // Calculate the total offset in milliseconds\n    int totalOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n\n    // Check for overflow\n    if (totalOffset > 23 * 60 * 60 * 1000 || totalOffset < -23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Total offset must be in the range -23:59:59.000 to +23:59:59.000\");\n    }\n\n    // Return the zone\n    return new DateTimeZone(\"GMT\" + (hoursOffset < 0 ? \"\" : \"+\") + hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset, totalOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    char[] queue = this.queue.toCharArray();\n    int i = 0;\n    while (i < queue.length) {\n        char c = queue[i];\n        if (c == open) {\n            sb.append(c);\n            i++;\n            while (i < queue.length) {\n                c = queue[i];\n                if (c == close) {\n                    sb.append(c);\n                    break;\n                } else if (c == '\\\\') {\n                    sb.append(c);\n                    i++;\n                    if (i < queue.length) {\n                        sb.append(queue[i]);\n                    }\n                } else if (c == '\\'' || c == '\"') {\n                    sb.append(c);\n                    i++;\n                    while (i < queue.length) {\n                        c = queue[i];\n                        if (c == '\\\\') {\n                            sb.append(c);\n                            i++;\n                            if (i < queue.length) {\n                                sb.append(queue[i]);\n                            }\n                        } else if (c == '\\'' || c == '\"') {\n                            sb.append(c);\n                            break;\n                        } else {\n                            sb.append(c);\n                        }\n                        i++;\n                    }\n                } else {\n                    sb.append(c);\n                }\n                i++;\n            }\n        } else {\n            i++;\n        }\n    }\n    this.queue = sb.toString();\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    // TODO: Your code here\n}",
      "public String chompBalanced(char open, char close)  {\n    String result = \"\";\n    int count = 0;\n    while (this.length() > 0) \n    {\n        char c = this.charAt(0);\n        if (c == open) \n        {\n            count++;\n        } \n        else if (c == close) \n        {\n            count--;\n        }\n        if (count == 0) \n        {\n            break;\n        }\n        result += c;\n        this.remove(0, 1);\n    }\n    return result;\n}",
      "public String chompBalanced(char open, char close)  {\n    String s = \"\";\n    int depth = 0;\n    while (this.hasNext()) \n    {\n        String next = this.next();\n        if (next.length() > 0) \n        {\n            char c = next.charAt(0);\n            if (c == open) \n            {\n                depth++;\n            } \n            else if (c == close) \n            {\n                depth--;\n                if (depth < 0) \n                {\n                    throw new IllegalStateException(\"Found closer '\" + close + \"' when none was expected\");\n                }\n            }\n            if (depth > 0) \n            {\n                s += next;\n            } \n            else \n            {\n                this.push(next);\n                break;\n            }\n        }\n    }\n    if (depth > 0) \n    {\n        throw new IllegalStateException(\"Found no closer '\" + close + \"' when one was expected\");\n    }\n    return s;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuffer sb = new StringBuffer();\n    int depth = 0;\n    char c;\n    while (this.hasNext()) {\n        c = this.next();\n        if (c == '\\\\') {\n            sb.append(this.next());\n        } else if (c == open) {\n            depth++;\n            sb.append(c);\n        } else if (c == close) {\n            depth--;\n            sb.append(c);\n            if (depth < 0) {\n                break;\n            }\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    char c;\n    while (!queue.isEmpty()) {\n        c = queue.remove();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n        }\n        if (depth > 0) {\n            sb.append(c);\n        } else {\n            queue.addFirst(c);\n            break;\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int stack = 0;\n    StringBuffer sb = new StringBuffer();\n    while (true) {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Unbalanced \" + open + \" and \" + close);\n        }\n        char c = peek();\n        if (c == open) {\n            stack++;\n        } else if (c == close) {\n            stack--;\n            if (stack < 0) {\n                throw new IllegalStateException(\"Unbalanced \" + open + \" and \" + close);\n            }\n        }\n        if (stack == 0) {\n            break;\n        }\n        sb.append(c);\n        pop();\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int level = 0;\n    StringBuilder sb = new StringBuilder();\n    while (true) {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Unbalanced expression\");\n        }\n        char c = poll();\n        if (c == open) {\n            level++;\n            sb.append(c);\n        } else if (c == close) {\n            level--;\n            sb.append(c);\n            if (level == 0) {\n                break;\n            }\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    String s = \"\";\n    int count = 0;\n    boolean quoted = false;\n    while (this.hasNext()) \n    {\n        char c = this.next();\n        if (c == '\\\\') \n        {\n            s += this.next();\n        } \n        else if (c == '\\'' || c == '\"') \n        {\n            quoted = !quoted;\n            s += c;\n        } \n        else if (!quoted && c == open) \n        {\n            count++;\n            s += c;\n        } \n        else if (!quoted && c == close) \n        {\n            count--;\n            s += c;\n            if (count < 0) \n            {\n                break;\n            }\n        } \n        else \n        {\n            s += c;\n        }\n    }\n    return s;\n}",
      "public String chompBalanced(char open, char close)  {\n    int level = 0;\n    StringBuilder sb = new StringBuilder();\n    while (this.hasNext()) {\n        char c = this.next();\n        if (c == open) {\n            level++;\n        } else if (c == close) {\n            level--;\n            if (level == 0) {\n                return sb.toString();\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = getXtX();\n        RealMatrix XtXinv = new LUDecomposition(XtX).getSolver().getInverse();\n        return XtXinv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create the X matrix\n        RealMatrix X = this.getX();\n\n        // Create the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(X);\n\n        // Get the R matrix\n        RealMatrix R = qr.getR();\n\n        // Get the top p rows of R\n        RealMatrix Rp = R.getSubMatrix(0, this.getBeta().getColumnDimension() - 1, 0, R.getColumnDimension() - 1);\n\n        // Calculate the inverse of Rp\n        RealMatrix RpInv = new LUDecomposition(Rp).getSolver().getInverse();\n\n        // Calculate the variance-covariance matrix\n        RealMatrix varBeta = RpInv.multiply(RpInv.transpose());\n\n        return varBeta;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix X = this.getX();\n        RealMatrix XtX = X.transpose().multiply(X);\n        QRDecomposition qr = new QRDecomposition(XtX);\n        RealMatrix R = qr.getR();\n        RealMatrix RtR = R.transpose().multiply(R);\n        RealMatrix RtRinv = new LUDecomposition(RtR).getSolver().getInverse();\n        RealMatrix betaVariance = RtRinv.multiply(XtX.transpose().multiply(RtRinv));\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTranspose = this.data.getXTranspose();\n        RealMatrix xTransposeX = xTranspose.multiply(this.data.getX());\n        RealMatrix inverseXTransposeX = new LUDecomposition(xTransposeX).getSolver().getInverse();\n        return inverseXTransposeX;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix X = getX();\n        RealMatrix XtX = X.transpose().multiply(X);\n        QRDecomposition qr = new QRDecomposition(XtX);\n        RealMatrix R = qr.getR();\n        int p = getBeta().getRowDimension();\n        RealMatrix RtR = R.getSubMatrix(0, p - 1, 0, p - 1).transpose().multiply(R.getSubMatrix(0, p - 1, 0, p - 1));\n        RealMatrix RtR_inv = new LUDecomposition(RtR).getSolver().getInverse();\n        return RtR_inv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Check that data has been loaded\n        if (this.data == null) \n        {\n            throw new NullPointerException(\"Data must be loaded before \"\n                    + \"calculating beta variance.\");\n        }\n\n        // Get the number of observations\n        int n = this.data.getRowDimension();\n\n        // Get the number of parameters\n        int p = this.beta.getColumnDimension();\n\n        // Create the matrix to hold the beta variance\n        RealMatrix betaVariance = MatrixUtils.createRealMatrix(p, p);\n\n        // Get the X matrix\n        RealMatrix X = this.data.getSubMatrix(0, n - 1, 0, p - 1);\n\n        // Get the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(X);\n\n        // Get the R matrix\n        RealMatrix R = qr.getR();\n\n        // Get the Q matrix\n        RealMatrix Q = qr.getQ();\n\n        // Get the inverse of R\n        RealMatrix RInverse = MatrixUtils.inverse(R);\n\n        // Calculate the beta variance\n        RealMatrix temp = Q.transpose().multiply(RInverse);\n        betaVariance = temp.multiply(Q);\n\n        // Return the beta variance\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix betaVariance = null;\n        RealMatrix xTranspose = this.x.transpose();\n        RealMatrix xTransposeX = xTranspose.multiply(this.x);\n        RealMatrix xTransposeXInverse = new LUDecomposition(xTransposeX).getSolver().getInverse();\n        int p = this.beta.getColumnDimension();\n        RealMatrix r = xTransposeXInverse.getSubMatrix(0, p - 1, 0, p - 1);\n        RealMatrix rTranspose = r.transpose();\n        RealMatrix rTransposeR = rTranspose.multiply(r);\n        betaVariance = new LUDecomposition(rTransposeR).getSolver().getInverse();\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Check that data has been loaded\n        if (this.data == null) {\n            throw new NullPointerException(\"Data has not been loaded\");\n        }\n\n        // Get the number of beta values\n        int nBeta = this.beta.getColumnDimension();\n\n        // Get the number of observations\n        int nObs = this.data.getRowDimension();\n\n        // Get the design matrix\n        RealMatrix X = this.data.getSubMatrix(0, nObs - 1, 0, nBeta - 1);\n\n        // Get the transpose of the design matrix\n        RealMatrix XT = X.transpose();\n\n        // Get the product of the transpose of the design matrix and the design matrix\n        RealMatrix XTX = XT.multiply(X);\n\n        // Get the inverse of the product of the transpose of the design matrix and the design matrix\n        RealMatrix XTXinv = XTX.inverse();\n\n        // Get the QR decomposition of the inverse of the product of the transpose of the design matrix and the design matrix\n        QRDecomposition qr = new QRDecomposition(XTXinv);\n\n        // Get the R matrix from the QR decomposition\n        RealMatrix R = qr.getR();\n\n        // Get the top p rows of the R matrix\n        RealMatrix Rp = R.getSubMatrix(0, nBeta - 1, 0, nBeta - 1);\n\n        // Get the inverse of the top p rows of the R matrix\n        RealMatrix Rpinv = Rp.inverse();\n\n        // Get the variance-covariance matrix\n        RealMatrix varBeta = Rpinv.multiply(XTXinv);\n\n        // Return the variance-covariance matrix\n        return varBeta;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTransposeX = this.xTranspose.multiply(this.x);\n        RealMatrix betaVariance = xTransposeX.inverse();\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix betaVariance = null;\n        RealMatrix xTx = getXtX();\n        RealMatrix qr = new QRDecomposition(xTx).getQR();\n        RealMatrix r = qr.getSubMatrix(0, qr.getRowDimension() - 1, 0, getBeta().getRowDimension() - 1);\n        RealMatrix rT = r.transpose();\n        RealMatrix rTR = rT.multiply(r);\n        RealMatrix rTRInv = new LUDecomposition(rTR).getSolver().getInverse();\n        betaVariance = rTRInv.multiply(rT);\n        return betaVariance;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    // This method is kept separate from the formatting classes to speed and\n    // simplify startup and classloading.\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    else \n    {\n        String sign = (offset < 0) ? \"-\" : \"+\";\n        offset = Math.abs(offset);\n        int hours = offset / (60 * 60 * 1000);\n        int minutes = (offset - (hours * 60 * 60 * 1000)) / (60 * 1000);\n        return sign + String.format(\"%02d\", hours) + String.format(\"%02d\", minutes);\n    }\n}",
      "private static String printOffset(int offset)  {\n    // create a formatter that outputs the offset in the format +/-HH:mm\n    DateTimeFormatter f = new DateTimeFormatterBuilder()\n        .appendLiteral(offset < 0 ? '-' : '+')\n        .appendValue(HOUR_OF_DAY, 2)\n        .appendLiteral(':')\n        .appendValue(MINUTE_OF_HOUR, 2)\n        .toFormatter();\n    // format the offset\n    return f.print(offset);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    String sign = (offset < 0) ? \"-\" : \"+\";\n    offset = Math.abs(offset);\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    return sign + String.format(\"%02d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        offset = -offset;\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    buf.append(String.format(\"%02d\", hours));\n    buf.append(String.format(\"%02d\", minutes));\n    buf.append(String.format(\"%02d\", seconds));\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    // create a formatter with the correct offset\n    DateTimeFormatter f = DateTimeFormatter.ofPattern(\"Z\").withZone(ZoneOffset.ofTotalSeconds(offset / 1000));\n    // print the offset\n    return f.format(LocalDateTime.now());\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    String sign = (offset < 0) ? \"-\" : \"+\";\n    offset = Math.abs(offset);\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset - (hours * 60 * 60 * 1000)) / (60 * 1000);\n    String zeros = \"0000\";\n    String hoursStr = Integer.toString(hours);\n    String minutesStr = Integer.toString(minutes);\n    return sign + zeros.substring(0, 4 - hoursStr.length()) + hoursStr + \":\" + zeros.substring(0, 2 - minutesStr.length()) + minutesStr;\n}",
      "private static String printOffset(int offset)  {\n    // Use StringBuilder for better multicharacter output performance\n    StringBuilder buf = new StringBuilder(9);\n    int hours = Math.abs((offset / 3600000));\n    int minutes = Math.abs((offset % 3600000) / 60000);\n    int seconds = Math.abs((offset % 60000) / 1000);\n    buf.append(offset < 0 ? \"-\" : \"+\");\n    if (hours < 10) {\n        buf.append(\"0\");\n    }\n    buf.append(hours);\n    buf.append(\":\");\n    if (minutes < 10) {\n        buf.append(\"0\");\n    }\n    buf.append(minutes);\n    if (seconds > 0) {\n        buf.append(\":\");\n        if (seconds < 10) {\n            buf.append(\"0\");\n        }\n        buf.append(seconds);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) \n    {\n        buf.append('-');\n        offset = -offset;\n    } \n    else \n    {\n        buf.append('+');\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    int millis = offset % 1000;\n    if (hours < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    buf.append(':');\n    if (seconds < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(seconds);\n    if (millis > 0) \n    {\n        buf.append('.');\n        if (millis < 100) \n        {\n            buf.append('0');\n        }\n        if (millis < 10) \n        {\n            buf.append('0');\n        }\n        buf.append(millis);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        buf.append(\"-\");\n        offset = -offset;\n    } else {\n        buf.append(\"+\");\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    int millis = offset % 1000;\n    buf.append(String.format(\"%02d\", hours));\n    buf.append(String.format(\"%02d\", minutes));\n    buf.append(String.format(\"%02d\", seconds));\n    buf.append(String.format(\"%03d\", millis));\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    int hours = Math.abs((offset / 1000) / 3600);\n    int minutes = Math.abs((offset / 1000) % 3600) / 60;\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    return buf.toString();\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    int low = 0;\n    int high = this.keys.length - 1;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int c = key.compareTo(this.keys[mid]);\n\n        if (c < 0) {\n            high = mid - 1;\n        }\n        else if (c > 0) {\n            low = mid + 1;\n        }\n        else if (c == 0) {\n            return mid;\n        }\n    }\n\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int low = 0;\n    int high = this.keys.length - 1;\n    while (low <= high) \n    {\n        int mid = (low + high) / 2;\n        int c = key.compareTo(this.keys[mid]);\n        if (c < 0) \n        {\n            high = mid - 1;\n        } \n        else if (c > 0) \n        {\n            low = mid + 1;\n        } \n        else \n        {\n            return mid;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = Arrays.binarySearch(this.keys, key);\n    if (index < 0) {\n        index = -1;\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    for (int i = 0; i < this.keys.length; i++) {\n        if (this.keys[i].compareTo(key) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = Collections.binarySearch(this.keys, key);\n    if (index < 0) {\n        index = -index - 1;\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    for (int i = 0; i < this.keys.length; i++) {\n        if (this.keys[i].compareTo(key) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    for (int i = 0; i < this.keys.length; i++) {\n        if (this.keys[i].compareTo(key) == 0) {\n            return i;\n        }\n    }\n\n    return -1;\n\n}",
      "public int getIndex(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (FlowScope flowScope = this;\n      flowScope != null;\n      flowScope = flowScope.parent) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : flowScope.slots.entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (slot.hasChanged()) {\n        result.put(name, slot);\n      }\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n    for (FlowScope scope : flowScopes) {\n      for (StaticSlot<JSType> slot : scope.getSlots()) {\n        allSlots.put(slot.getName(), slot);\n      }\n    }\n    return allSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (FlowScope scope : flowScopeStack) {\n    slots.putAll(scope.slots);\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Scope s = this; s != null; s = s.getParentScope()) {\n        if (s instanceof FlowScope) {\n            slots.putAll(((FlowScope) s).slots);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (FlowScope scope = this; scope != null; scope = scope.parent) {\n    for (StaticSlot<JSType> slot : scope.slots) {\n      allSlots.put(slot.getName(), slot);\n    }\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n  for (FlowScope flowScope : flowScopeStack) {\n    allSlots.putAll(flowScope.slots);\n  }\n  return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (FlowScope scope : flowScopeStack) {\n    for (Map.Entry<String, StaticSlot<JSType>> entry : scope.getSlotMap().entrySet()) {\n      String name = entry.getKey();\n      StaticSlot<JSType> slot = entry.getValue();\n      if (slot.isReassigned()) {\n        result.put(name, slot);\n      }\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> allSlots = new HashMap<>();\n    for (FlowScope scope = this; scope != null; scope = scope.parent) {\n      for (Map.Entry<String, StaticSlot<JSType>> entry : scope.slots.entrySet()) {\n        String name = entry.getKey();\n        StaticSlot<JSType> slot = entry.getValue();\n        if (slot.getType() != null) {\n          allSlots.put(name, slot);\n        }\n      }\n    }\n    return allSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (FlowScope scope = this; scope != null; scope = scope.parent) {\n    result.putAll(scope.slots);\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new LinkedHashMap<>();\n    for (FlowScope scope = this; scope != null; scope = scope.parent) {\n      scope.slots.forEach((k, v) -> {\n        if (v.hasChanged()) {\n          slots.put(k, v);\n        }\n      });\n    }\n    return slots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        if (columnData.length == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final int nRows = columnData.length;\n        final int nCols = 1;\n        final double[][] data = new double[nRows][nCols];\n        for (int i = 0; i < nRows; ++i) {\n            data[i][0] = columnData[i];\n        }\n        return new Array2DRowRealMatrix(data, false);\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    return new Array2DRowRealMatrix(columnData, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        if (columnData.length == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n        }\n        final int nRows = columnData.length;\n        final int nCols = 1;\n        final double[][] data = new double[nRows][nCols];\n        for (int i = 0; i < nRows; ++i) {\n            data[i][0] = columnData[i];\n        }\n        return new Array2DRowRealMatrix(data, false);\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_POINT);\n    }\n\n    final int nRows = columnData.length;\n    final int nCols = 1;\n    final double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; ++i) {\n        data[i][0] = columnData[i];\n    }\n    return new Array2DRowRealMatrix(data, false);\n}"
    ],
    [
      "public static double atanh(double a)  {\n    return Math.log(a + Math.sqrt(a*a - 1))/Math.sqrt(a*a - 1);\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return Math.log((1 + a) / (1 - a)) / 2;\n}",
      "public static double atanh(double a)  {\n    return Math.log(1 + a) - Math.log(1 - a);\n}",
      "public static double atanh(double a)  {\n    return 0.5 * Math.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    return Math.log(1 + a) - Math.log(1 - a);\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_IS_INFINITE);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_IS_ZERO);\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_SUM);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * normalizedSum / sum;\n        } else {\n            out[i] = values[i];\n        }\n    }\n\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        sum += values[i];\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM, sum);\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_NORMALIZED_SUM,\n                                               normalizedSum);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_EQUAL_TO_ZERO, sum);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM);\n    }\n\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        sum += values[i];\n    }\n\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM_NORMALIZATION);\n    }\n\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_IN_SUM,\n                                               normalizedSum);\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM,\n                                          sum);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM,\n                                          sum);\n    }\n\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n      if (Double.isInfinite(normalizedSum)) {\n         throw new MathIllegalArgumentException(new LocalizedFormats(\"NORMALIZED_SUM_INFINITE\"),\n                                                normalizedSum);\n      }\n      if (Double.isNaN(normalizedSum)) {\n         throw new MathIllegalArgumentException(new LocalizedFormats(\"NORMALIZED_SUM_NAN\"),\n                                                normalizedSum);\n      }\n      double sum = 0;\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            sum += values[i];\n         }\n      }\n      if (Double.isInfinite(sum)) {\n         throw new MathArithmeticException(new LocalizedFormats(\"SUM_IS_INFINITE\"),\n                                            sum);\n      }\n      if (sum == 0) {\n         throw new MathArithmeticException(new LocalizedFormats(\"SUM_IS_ZERO\"),\n                                            sum);\n      }\n      double[] out = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            out[i] = values[i] * normalizedSum / sum;\n         }\n      }\n      return out;\n   }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n    }\n\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_SUM);\n    }\n\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n      if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n          throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_NOT_ALLOWED);\n      }\n      double sum = 0;\n      for (int i = 0; i < values.length; i++) {\n          if (!Double.isNaN(values[i])) {\n              sum += values[i];\n          }\n      }\n      if (sum == 0) {\n          throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_IS_ZERO);\n      }\n      double[] out = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n          if (!Double.isNaN(values[i])) {\n              out[i] = values[i] * normalizedSum / sum;\n          }\n      }\n      return out;\n  }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n      if (Double.isInfinite(normalizedSum)) {\n          throw new MathIllegalArgumentException(new LocalizedFormats(\"NORMALIZED_SUM_IS_INFINITE\"),\n                                                 normalizedSum);\n      }\n      if (Double.isNaN(normalizedSum)) {\n          throw new MathIllegalArgumentException(new LocalizedFormats(\"NORMALIZED_SUM_IS_NAN\"),\n                                                 normalizedSum);\n      }\n      double sum = 0;\n      for (int i = 0; i < values.length; i++) {\n          if (!Double.isNaN(values[i])) {\n              sum += values[i];\n          }\n      }\n      if (sum == 0) {\n          throw new MathArithmeticException(new LocalizedFormats(\"SUM_OF_INPUT_ELEMENTS_IS_ZERO\"),\n                                            sum);\n      }\n      double[] out = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n          if (!Double.isNaN(values[i])) {\n              out[i] = values[i] * normalizedSum / sum;\n          }\n      }\n      return out;\n  }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n      double sum = 0;\n      for (double v : values) {\n         if (!Double.isNaN(v)) {\n            sum += v;\n         }\n      }\n\n      if (Double.isInfinite(sum)) {\n         throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n      }\n\n      if (sum == 0) {\n         throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n      }\n\n      if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n         throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_TARGET_SUM);\n      }\n\n      double[] normalized = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n         if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n         }\n      }\n\n      return normalized;\n   }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                continue;\n            }\n            sum += values[i];\n        }\n\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.NAN_ELEMENTS_IN_ARRAY);\n        }\n\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_VALUE_FOR_SUM, normalizedSum);\n        }\n\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalized[i] = values[i];\n            } else {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return normalized;\n    }"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    boolean capitalizeNext = true;\n    int cp;\n    for (int inOffset = 0; inOffset < strLen;) {\n        cp = str.codePointAt(inOffset);\n        if (isDelimiter(cp, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext || outOffset == 0) {\n            newCodePoints[outOffset++] = Character.toTitleCase(cp);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[outOffset++] = cp;\n        }\n        inOffset += Character.charCount(cp);\n    }\n    if (outOffset != 0) {\n        return new String(newCodePoints, 0, outOffset);\n    }\n    return str;\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer[i] = ch;\n            capitalizeNext = true;\n        } else if (capitalizeNext || i == 0 && !isDelimiter(ch, delimiters)) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] newCodePoints = new int[strLen];\n    int outOffset = 0;\n    boolean capitalizeNext = true;\n    for (int offset = 0, codePoint = 0; offset < strLen;) {\n        offset += Character.toChars(codePoint, newCodePoints, offset);\n        codePoint = str.codePointAt(offset);\n        if (Character.isWhitespace(codePoint) || isDelimiter(codePoint, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            newCodePoints[outOffset++] = Character.toTitleCase(codePoint);\n            capitalizeNext = false;\n        } else {\n            newCodePoints[outOffset++] = codePoint;\n        }\n    }\n    if (outOffset != newCodePoints.length) {\n        final int[] newCodePoints2 = new int[outOffset];\n        System.arraycopy(newCodePoints, 0, newCodePoints2, 0, outOffset);\n        newCodePoints = newCodePoints2;\n    }\n    return new String(newCodePoints, 0, outOffset);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] positions = new int[strLen];\n    int count = 0;\n\n    // find first characters after delimiters\n    for (int i = 0; i < strLen; i++) {\n        if (isDelimiter(str.charAt(i), delimiters)) {\n            continue;\n        }\n        positions[count++] = i;\n    }\n\n    // no content to capitalize\n    if (count == 0) {\n        return str;\n    }\n\n    // capitalize first characters after delimiters\n    final char[] buf = str.toCharArray();\n    for (int i = 0; i < count; i++) {\n        buf[positions[i]] = Character.toTitleCase(buf[positions[i]]);\n    }\n    return new String(buf);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder builder = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            builder.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            builder.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            builder.append(ch);\n        }\n    }\n    return builder.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str == null || str.length() == 0 || delimLen == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int[] positions = new int[strLen];\n    int count = 0;\n\n    // find first characters after delimiters\n    for (int i = 0; i < strLen; i++) {\n        if (isDelimiter(str.charAt(i), delimiters)) {\n            continue;\n        }\n        positions[count++] = i;\n    }\n\n    // no content to capitalize\n    if (count == 0) {\n        return str;\n    }\n\n    // capitalize first characters after delimiters\n    final char[] buf = str.toCharArray();\n    for (int i = 0; i < count; i++) {\n        buf[positions[i]] = Character.toTitleCase(buf[positions[i]]);\n    }\n    return new String(buf);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    if (delimLen == 0) {\n        return capitalize(str);\n    }\n    final int strLen = str.length();\n    final int[] positions = new int[strLen];\n    int count = 0;\n    boolean containsDelimiter = false;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                containsDelimiter = true;\n                positions[count++] = i;\n                break;\n            }\n        }\n    }\n    if (!containsDelimiter) {\n        return capitalize(str);\n    }\n    final char[] out = new char[strLen];\n    for (int i = 0, j = 0; i < count; ) {\n        out[positions[i++]] = Character.toTitleCase(str.charAt(j++));\n    }\n    for (int i = positions[count - 1] + 1; i < strLen; i++) {\n        out[i] = str.charAt(i);\n    }\n    return new String(out);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder builder = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            builder.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            builder.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            builder.append(ch);\n        }\n    }\n    return builder.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    final int[] delimiterBuffer = new int[delimLen];\n    int delimPos = 0;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        for (int j = 0; j < delimLen; j++) {\n            if (ch == delimiters[j]) {\n                delimiterBuffer[delimPos] = i;\n                delimPos++;\n                break;\n            }\n        }\n    }\n    int capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return capitalize(str);\n    }\n    final int delimLen = delimiters.length;\n    final int strLen = str.length();\n    final StringBuilder buffer = new StringBuilder(strLen);\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            buffer.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        } else {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    //TODO: Complete the code\n    return null;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    // TODO: Complete this method\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    return parseMutableDateTime(text, Locale.getDefault(Locale.Category.FORMAT));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    // Implement this method\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeFormatter formatter = new DateTimeFormatterBuilder().append(this).toFormatter();\n    return formatter.parseMutableDateTime(text);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    return parseMutableDateTime(text, new ParsePosition(0));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime mdt = new MutableDateTime();\n    DateTimeFormatter fmt = new DateTimeFormatterBuilder()\n            .append(null, new DateTimeParser[] {\n                    new DateTimeFormatterBuilder()\n                            .appendTimeZoneOffset(\"Z\", true, 2, 4)\n                            .toParser(),\n                    new DateTimeFormatterBuilder()\n                            .appendTimeZoneShortName(null)\n                            .toParser(),\n                    new DateTimeFormatterBuilder()\n                            .appendTimeZoneLongName(null)\n                            .toParser()\n            })\n            .toFormatter()\n            .withChronology(Chronology.getInstance(DateTimeZone.getDefault()))\n            .withOffsetParsed();\n    mdt.setMillis(fmt.parseMillis(text));\n    return mdt;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    //Implement the code here\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    // implement here\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    // TODO: Implement this method\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix Omega = getOmega();\n        RealVector y = getY();\n        RealMatrix Xt = X.transpose();\n        RealMatrix OmegaInv = Omega.inverse();\n        RealMatrix XtOmegaInvX = Xt.multiply(OmegaInv).multiply(X);\n        RealMatrix XtOmegaInv = Xt.multiply(OmegaInv);\n        RealVector b = XtOmegaInvX.solve(XtOmegaInv.operate(y));\n        return b;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = this.getX();\n        RealMatrix Omega = this.getOmega();\n        RealVector y = this.getY();\n        RealMatrix XT = X.transpose();\n        RealMatrix OmegaInverse = Omega.inverse();\n        RealMatrix XTOmegaInverse = XT.multiply(OmegaInverse);\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.multiply(X);\n        RealMatrix betaMatrix = XTOmegaInverseX.inverse();\n        RealMatrix XTOmegaInverseY = XTOmegaInverse.multiply(y);\n        RealVector beta = betaMatrix.operate(XTOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = this.getX();\n        RealMatrix Omega = this.getOmega();\n        RealVector y = this.getY();\n        RealMatrix Xt = X.transpose();\n        RealMatrix XtOmega = Xt.multiply(Omega.inverse());\n        RealMatrix XtOmegaX = XtOmega.multiply(X);\n        RealMatrix XtOmegaXInv = XtOmegaX.inverse();\n        RealMatrix XtOmegaXInvXt = XtOmegaXInv.multiply(Xt);\n        RealVector b = XtOmegaXInvXt.operate(y);\n        return b;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XtOmegaInverseX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix XtOmegaInverse = X.transpose().multiply(OmegaInverse);\n        RealVector beta = XtOmegaInverseX.solve(XtOmegaInverse.operate(y));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Omega = this.getOmega();\n        RealMatrix X = this.getX();\n        RealVector y = this.getY();\n        RealMatrix XtOmegaInvX = X.transpose().multiply(Omega.inverse()).multiply(X);\n        RealMatrix XtOmegaInvXInv = XtOmegaInvX.inverse();\n        RealMatrix XtOmegaInv = X.transpose().multiply(Omega.inverse());\n        RealVector b = XtOmegaInvXInv.multiply(XtOmegaInv).multiply(y);\n        return b;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Xt = this.X.transpose();\n        RealMatrix OmegaInv = this.Omega.inverse();\n        RealMatrix XtOmegaInvX = Xt.multiply(OmegaInv).multiply(this.X);\n        RealMatrix XtOmegaInv = Xt.multiply(OmegaInv);\n        RealVector b = XtOmegaInvX.solve(XtOmegaInv.operate(this.y));\n        return b;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix Omega = getOmega();\n        RealVector y = getY();\n        RealMatrix Xt = X.transpose();\n        RealMatrix XtOmegaInv = Xt.multiply(Omega.inverse());\n        RealMatrix XtOmegaInvX = XtOmegaInv.multiply(X);\n        RealMatrix XtOmegaInvXInv = XtOmegaInvX.inverse();\n        RealMatrix XtOmegaInvy = XtOmegaInv.multiply(y);\n        RealVector beta = XtOmegaInvXInv.multiply(XtOmegaInvy);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix Omega = getOmega();\n        RealVector y = getY();\n        RealMatrix XtOmega = X.transpose().multiply(Omega.inverse());\n        RealMatrix XtOmegaX = XtOmega.multiply(X);\n        RealMatrix XtOmegaXInv = XtOmegaX.inverse();\n        RealMatrix XtOmegaXInvXtOmega = XtOmegaXInv.multiply(XtOmega);\n        RealVector beta = XtOmegaXInvXtOmega.operate(y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInverse = new LUDecomposition(Omega).getSolver().getInverse();\n        RealMatrix XTranspose = X.transpose();\n        RealMatrix XOmegaInverse = XTranspose.multiply(OmegaInverse);\n        RealMatrix XOmegaInverseX = XOmegaInverse.multiply(X);\n        RealMatrix XOmegaInverseXInverse = new LUDecomposition(XOmegaInverseX).getSolver().getInverse();\n        RealMatrix XOmegaInverseY = XOmegaInverse.multiply(y);\n        RealVector beta = XOmegaInverseXInverse.multiply(XOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Omega = this.getOmega();\n        RealMatrix X = this.getX();\n        RealVector y = this.getY();\n        RealMatrix Xt = X.transpose();\n        RealMatrix XtOmegaInv = Xt.multiply(Omega.inverse());\n        RealMatrix XtOmegaInvX = XtOmegaInv.multiply(X);\n        RealMatrix XtOmegaInvXInv = XtOmegaInvX.inverse();\n        RealMatrix XtOmegaInvXInvXt = XtOmegaInvXInv.multiply(Xt);\n        RealVector b = XtOmegaInvXInvXt.operate(y);\n        return b;\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    if (id == null)\n        throw new IllegalArgumentException(\"String id must not be null.\");\n    if (id.length() == 0)\n        throw new IllegalArgumentException(\"String id must not be empty.\");\n    if (id.indexOf(',') > 0)\n        throw new IllegalArgumentException(\"String id must not contain ',': \" + id);\n    Elements els = this.getElementsByAttributeValue(\"id\", id);\n    return els.size() > 0 ? els.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n    if (id.equals(id()))\n        return this;\n    for (Element child : children()) {\n        Element found = child.getElementById(id);\n        if (found != null)\n            return found;\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(this.id)) \n    {\n        return this;\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(id()))\n        return this;\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(id()))\n        return this;\n    else\n    {\n        Elements els = this.getElementsByAttribute(\"id\", id);\n        if (els.size() > 0)\n            return els.get(0);\n        else\n            return null;\n    }\n}",
      "public Element getElementById(String id)  {\n    //Check if id is null\n    if(id == null)\n    {\n        return null;\n    }\n    //Check if this element has the id\n    if(this.id != null && this.id.equals(id))\n    {\n        return this;\n    }\n    //Check if this element has children\n    if(this.childNodes != null)\n    {\n        //Loop through children\n        for(int i = 0; i < this.childNodes.size(); i++)\n        {\n            //Check if child has the id\n            if(this.childNodes.get(i).id != null && this.childNodes.get(i).id.equals(id))\n            {\n                return this.childNodes.get(i);\n            }\n            //Check if child has children\n            if(this.childNodes.get(i).childNodes != null)\n            {\n                //Loop through grandchildren\n                for(int j = 0; j < this.childNodes.get(i).childNodes.size(); j++)\n                {\n                    //Check if grandchild has the id\n                    if(this.childNodes.get(i).childNodes.get(j).id != null && this.childNodes.get(i).childNodes.get(j).id.equals(id))\n                    {\n                        return this.childNodes.get(i).childNodes.get(j);\n                    }\n                }\n            }\n        }\n    }\n    //If no element with the id was found\n    return null;\n}",
      "public Element getElementById(String id)  {\n    // check if id is null\n    if(id == null)\n    {\n        return null;\n    }\n\n    // check if id is empty\n    if(id.isEmpty())\n    {\n        return null;\n    }\n\n    // check if this element has id\n    if(this.id != null && this.id.equals(id))\n    {\n        return this;\n    }\n\n    // check if this element has children\n    if(this.children != null && this.children.size() > 0)\n    {\n        // loop through children\n        for(Element child : this.children)\n        {\n            // check if child has id\n            if(child.id != null && child.id.equals(id))\n            {\n                return child;\n            }\n\n            // check if child has children\n            if(child.children != null && child.children.size() > 0)\n            {\n                // recursively call getElementById on child\n                Element element = child.getElementById(id);\n\n                // check if element is not null\n                if(element != null)\n                {\n                    return element;\n                }\n            }\n        }\n    }\n\n    // no element found\n    return null;\n}",
      "public Element getElementById(String id)  {\n    //find the first matching element by ID, starting with this element\n    Elements els = this.select(\"[id=\" + id + \"]\");\n    if (els.size() > 0)\n    {\n        return els.get(0);\n    }\n    else\n    {\n        return null;\n    }\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(this.id)) \n    {\n        return this;\n    }\n    else \n    {\n        for (Element child : this.children) \n        {\n            Element found = child.getElementById(id);\n            if (found != null) \n            {\n                return found;\n            }\n        }\n        return null;\n    }\n}",
      "public Element getElementById(String id)  {\n    if (id.equals(id())) \n    {\n        return this;\n    }\n    else \n    {\n        for (Element el : children()) \n        {\n            Element found = el.getElementById(id);\n            if (found != null) \n            {\n                return found;\n            }\n        }\n        return null;\n    }\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String formattedPattern = pattern;\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            formattedPattern = formattedPattern.replaceFirst(CUSTOM_PATTERN_REGEX, customPattern);\n        }\n    }\n    return formattedPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String fullPattern = pattern;\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            fullPattern = fullPattern.replaceFirst(\"\\\\{0\\\\}\", customPattern);\n        }\n    }\n    return fullPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int i = 0;\n    while (i < pattern.length()) {\n        char c = pattern.charAt(i);\n        if (c == '\\'') {\n            result.append(c);\n            i++;\n            while (i < pattern.length() && pattern.charAt(i) != '\\'') {\n                result.append(pattern.charAt(i));\n                i++;\n            }\n            if (i < pattern.length()) {\n                result.append(c);\n            }\n        } else if (c == '[') {\n            i++;\n            int j = i;\n            while (i < pattern.length() && pattern.charAt(i) != ']') {\n                i++;\n            }\n            if (i < pattern.length()) {\n                String format = pattern.substring(j, i);\n                if (customPatterns.contains(format)) {\n                    result.append('[');\n                    result.append(format);\n                    result.append(']');\n                } else {\n                    result.append(format);\n                }\n                i++;\n            }\n        } else {\n            result.append(c);\n            i++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String formattedPattern = pattern;\n    for (String customPattern : customPatterns) \n    {\n        formattedPattern = formattedPattern.replaceFirst(\"\\\\{0\\\\}\", customPattern);\n    }\n    return formattedPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String result = pattern;\n    if (customPatterns != null) {\n        for (final String customPattern : customPatterns) {\n            result = result.replaceFirst(\"\\\\{([^}]+)\\\\}\", customPattern);\n        }\n    }\n    return result;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final String[] formatStrings = {\n}\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String result = pattern;\n    if (customPatterns != null) {\n        for (final String customPattern : customPatterns) {\n            result = result.replaceFirst(\"\\\\{([^\\\\}]+)\\\\}\", customPattern);\n        }\n    }\n    return result;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String result = pattern;\n    if (customPatterns != null) \n    {\n        for (final String customPattern : customPatterns) \n        {\n            final String format = customPattern.substring(1, customPattern.length() - 1);\n            result = result.replace(customPattern, format);\n        }\n    }\n    return result;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String fullPattern = pattern;\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            fullPattern = fullPattern.replaceFirst(\"\\\\{.+?\\\\}\", customPattern);\n        }\n    }\n    return fullPattern;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    String result = pattern;\n    for (String customPattern : customPatterns) \n    {\n        if (result.contains(customPattern)) \n        {\n            result = result.replace(customPattern, \"'\" + customPattern + \"'\");\n        }\n    }\n    return result;\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        InstantConverter removed = null;\n        if (converter != null) \n        {\n            removed = instantConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter removed = null;\n    synchronized (converters) {\n        if (converters.contains(converter)) {\n            removed = converters.remove(converters.indexOf(converter));\n        }\n    }\n    return removed;\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        InstantConverter removed = null;\n        if (converter != null) {\n            removed = instantConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter removed = null;\n        for (int i = 0; i < converters.size(); i++) {\n            InstantConverter c = converters.get(i);\n            if (c.equals(converter)) {\n                removed = c;\n                converters.remove(i);\n                break;\n            }\n        }\n        return removed;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter removed = null;\n        if (converters.contains(converter)) {\n            removed = converters.remove(converter);\n        }\n        return removed;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter removed = null;\n    if (converters.contains(converter)) {\n        removed = converters.remove(converter);\n    }\n    return removed;\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter replaced = null;\n    synchronized (instantConverters) {\n        replaced = instantConverters.remove(converter);\n    }\n    return replaced;\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converter.getClass().equals(InstantConverter.class)) {\n            return null;\n        }\n        InstantConverter replaced = null;\n        for (int i = 0; i < iInstantConverters.size(); i++) {\n            InstantConverter ic = iInstantConverters.get(i);\n            if (ic.equals(converter)) {\n                replaced = ic;\n                iInstantConverters.remove(i);\n                break;\n            }\n        }\n        return replaced;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        InstantConverter removed = null;\n        if (converter != null) {\n            removed = instantConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converters.contains(converter)) {\n            converters.remove(converter);\n            return converter;\n        }\n        return null;\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      if (fromArgs.length == toArgs.length) {\n        for (int i = 0; i < fromArgs.length; i++) {\n          if (fromArgs[i] instanceof TypeVariable) {\n            String name = ((TypeVariable) fromArgs[i]).getName();\n            Type toArg = typeVarMap.get(name);\n            if (toArg == null) {\n              return false;\n            }\n            if (!toArgs[i].equals(toArg)) {\n              return false;\n            }\n          } else if (!fromArgs[i].equals(toArgs[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      if (fromArgs.length == toArgs.length) {\n        for (int i = 0; i < fromArgs.length; i++) {\n          Type fromArg = fromArgs[i];\n          Type toArg = toArgs[i];\n          if (fromArg instanceof TypeVariable) {\n            TypeVariable fromVar = (TypeVariable) fromArg;\n            if (typeVarMap.containsKey(fromVar.getName())) {\n              fromArg = typeVarMap.get(fromVar.getName());\n            }\n          }\n          if (toArg instanceof TypeVariable) {\n            TypeVariable toVar = (TypeVariable) toArg;\n            if (typeVarMap.containsKey(toVar.getName())) {\n              toArg = typeVarMap.get(toVar.getName());\n            }\n          }\n          if (!fromArg.equals(toArg)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType().equals(to.getRawType())) {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length == toArgs.length) {\n      for (int i = 0; i < fromArgs.length; i++) {\n        Type fromArg = fromArgs[i];\n        Type toArg = toArgs[i];\n        if (fromArg instanceof TypeVariable) {\n          if (toArg instanceof TypeVariable) {\n            // TypeVariable<D> is not assignable to TypeVariable<D>\n            // because the latter is more specific.\n            return false;\n          } else {\n            // TypeVariable<D> is assignable to T\n            // if T is a type variable and T is assignable to U\n            // and TypeVariable<D> is assignable to U\n            String typeVarName = ((TypeVariable) fromArg).getName();\n            Type typeVar = typeVarMap.get(typeVarName);\n            if (typeVar == null) {\n              typeVarMap.put(typeVarName, toArg);\n            } else if (!typeEquals(typeVar, toArg, typeVarMap)) {\n              return false;\n            }\n          }\n        } else if (fromArg instanceof ParameterizedType) {\n          if (toArg instanceof ParameterizedType) {\n            // P<A1, ..., An> is assignable to P<B1, ..., Bn>\n            // if Ai is assignable to Bi for all i\n            return typeEquals((ParameterizedType) fromArg,\n                (ParameterizedType) toArg, typeVarMap);\n          } else {\n            // P<A1, ..., An> is not assignable to B\n            return false;\n          }\n        } else if (fromArg instanceof WildcardType) {\n          if (toArg instanceof WildcardType) {\n            // ? is assignable to ?\n            // ? extends A is assignable to ? extends B\n            // if A is assignable to B\n            // ? super A is assignable to ? super B\n            // if B is assignable to A\n}\n}\n}\n}\n}\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // If the two types are not parameterized, they are equal.\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    // If the two types are parameterized, check that they have the same\n    // number of type parameters.\n    if (from.getActualTypeArguments().length != \n        to.getActualTypeArguments().length) {\n      return false;\n    }\n    // If the two types are parameterized, check that they have the same\n    // number of type parameters.\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromType = from.getActualTypeArguments()[i];\n      Type toType = to.getActualTypeArguments()[i];\n      // If the type is a type variable, check that it is equal to the\n      // corresponding type variable in the other type.\n      if (fromType instanceof TypeVariable) {\n        String typeVarName = ((TypeVariable) fromType).getName();\n        if (typeVarMap.containsKey(typeVarName)) {\n          if (!typeVarMap.get(typeVarName).equals(toType)) {\n            return false;\n          }\n        } else {\n          typeVarMap.put(typeVarName, toType);\n        }\n      } else if (fromType instanceof ParameterizedType) {\n        // If the type is a parameterized type, check that it is equal to the\n        // corresponding parameterized type in the other type.\n        if (!typeEquals((ParameterizedType) fromType,\n            (ParameterizedType) toType, typeVarMap)) {\n          return false;\n        }\n      } else {\n        // If the type is a raw type, check that it is equal to the\n        // corresponding raw type in the other type.\n        if (!fromType.equals(toType)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.equals(to)) {\n    return true;\n  }\n\n  if (from.getRawType() != to.getRawType()) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    if (fromArg instanceof TypeVariable) {\n      String typeVarName = ((TypeVariable) fromArg).getName();\n      if (typeVarMap.containsKey(typeVarName)) {\n        toArg = typeVarMap.get(typeVarName);\n      }\n    }\n    if (!typeEquals(fromArg, toArg, typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // TODO: Implement this method\n    return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable) {\n        String name = ((TypeVariable) fromArg).getName();\n        if (typeVarMap.containsKey(name)) {\n          toArg = typeVarMap.get(name);\n        }\n      }\n      if (!typeEquals(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      if (fromArgs.length == toArgs.length) {\n        for (int i = 0; i < fromArgs.length; i++) {\n          if (fromArgs[i] instanceof TypeVariable) {\n            String typeVarName = ((TypeVariable) fromArgs[i]).getName();\n            Type typeVarValue = typeVarMap.get(typeVarName);\n            if (typeVarValue == null) {\n              typeVarMap.put(typeVarName, toArgs[i]);\n            } else if (!typeVarValue.equals(toArgs[i])) {\n              return false;\n            }\n          } else if (!fromArgs[i].equals(toArgs[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable) {\n        TypeVariable fromVar = (TypeVariable) fromArg;\n        if (typeVarMap.containsKey(fromVar.getName())) {\n          fromArg = typeVarMap.get(fromVar.getName());\n        }\n      }\n      if (toArg instanceof TypeVariable) {\n        TypeVariable toVar = (TypeVariable) toArg;\n        if (typeVarMap.containsKey(toVar.getName())) {\n          toArg = typeVarMap.get(toVar.getName());\n        }\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) \n    {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      if (fromArgs.length == toArgs.length) \n      {\n        for (int i = 0; i < fromArgs.length; i++) \n        {\n          Type fromArg = fromArgs[i];\n          Type toArg = toArgs[i];\n          if (fromArg instanceof TypeVariable) \n          {\n            TypeVariable fromVar = (TypeVariable) fromArg;\n            TypeVariable toVar = (TypeVariable) toArg;\n            if (!fromVar.getName().equals(toVar.getName())) \n            {\n              return false;\n            }\n            if (typeVarMap.containsKey(fromVar.getName())) \n            {\n              Type type = typeVarMap.get(fromVar.getName());\n              if (!type.equals(toVar)) \n              {\n                return false;\n              }\n            } else \n            {\n              typeVarMap.put(fromVar.getName(), toVar);\n            }\n          } else if (!fromArg.equals(toArg)) \n          {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter replaced = null;\n        for (int i = 0; i < iPeriodConverters.size(); i++) {\n            PeriodConverter current = iPeriodConverters.get(i);\n            if (current.getClass().equals(converter.getClass())) {\n                replaced = current;\n                iPeriodConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            iPeriodConverters.add(converter);\n        }\n        return replaced;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter old = null;\n    for (int i = 0; i < iPeriodConverters.length; i++) {\n        if (iPeriodConverters[i].equals(converter)) {\n            old = iPeriodConverters[i];\n            iPeriodConverters[i] = converter;\n            break;\n        }\n    }\n    return old;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter replaced = null;\n        for (int i = 0; i < iPeriodConverters.length; i++) {\n            if (iPeriodConverters[i].equals(converter)) {\n                replaced = iPeriodConverters[i];\n                iPeriodConverters[i] = converter;\n                break;\n            }\n        }\n        return replaced;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter replaced = null;\n        for (int i = 0; i < iConverters.length; i++) {\n            if (iConverters[i].equals(converter)) {\n                replaced = iConverters[i];\n                iConverters[i] = converter;\n                break;\n            }\n        }\n        return replaced;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter old = null;\n    for (int i = 0; i < iPeriodConverters.size(); i++) {\n        PeriodConverter test = iPeriodConverters.get(i);\n        if (test.equals(converter)) {\n            old = test;\n            break;\n        }\n    }\n    if (old == null) {\n        iPeriodConverters.add(converter);\n    } else {\n        iPeriodConverters.set(iPeriodConverters.indexOf(old), converter);\n    }\n    return old;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter replaced = null;\n        for (int i = 0; i < iPeriodConverters.size(); i++) {\n            PeriodConverter existing = iPeriodConverters.get(i);\n            if (existing.getClass().equals(converter.getClass())) {\n                replaced = existing;\n                iPeriodConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            iPeriodConverters.add(converter);\n        }\n        return replaced;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter replaced = null;\n    for (int i = 0; i < iConverters.length; i++) {\n        if (iConverters[i].getSupportedType() == converter.getSupportedType()) {\n            replaced = iConverters[i];\n            iConverters[i] = converter;\n            break;\n        }\n    }\n    return replaced;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter replaced = null;\n    for (int i = 0; i < iConverters.length; i++) {\n        if (iConverters[i].equals(converter)) {\n            replaced = iConverters[i];\n            iConverters[i] = converter;\n            break;\n        }\n    }\n    return replaced;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter replaced = null;\n        for (int i = 0; i < iConverters.size(); i++) {\n            PeriodConverter current = iConverters.get(i);\n            if (current.equals(converter)) {\n                replaced = current;\n                iConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            iConverters.add(converter);\n        }\n        return replaced;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter replaced = null;\n    for (int i = 0; i < iConverters.size(); i++) {\n        PeriodConverter conv = iConverters.get(i);\n        if (conv.equals(converter)) {\n            replaced = conv;\n            iConverters.set(i, converter);\n            break;\n        }\n    }\n    if (replaced == null) {\n        iConverters.add(converter);\n    }\n    return replaced;\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return (Iterator<E>) iterator;\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        Iterator<E> tmp = (Iterator<E>) iterator;\n        return tmp;\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return (Iterator<E>) iterator;\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<E> tmp = (Iterator<E>) iterator;\n        return tmp;\n    }\n    return new Iterator<E>() \n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<E> tmp = (Iterator<E>) iterator;\n        return tmp;\n    }\n    return new Iterator<E>() \n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterator<E>() \n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return (Iterator<E>) iterator;\n    }\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterator<E>() \n    {\n}\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) \n    {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<E> tmp = (Iterator<E>) iterator;\n        return tmp;\n    }\n    return new Iterator<E>() \n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<E> tmp = (Iterator<E>) iterator;\n        return tmp;\n    }\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    int partition = node.getPartition();\n    for (N neighbor : node.getNeighbors()) \n    {\n        if (neighbor.getPartition() == partition) \n        {\n            if (superNode == null) \n            {\n                superNode = neighbor;\n            } \n            else \n            {\n                if (superNode.getPartition() == neighbor.getPartition()) \n                {\n                    superNode = neighbor;\n                }\n            }\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    int partition = node.getPartition();\n    for (N n : nodes) \n    {\n        if (n.getPartition() == partition) \n        {\n            superNode = n;\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  // Implement this method\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  // Check if the node is already the super node\n  if (node.getColor() == Color.BLACK) \n  {\n    return node;\n  }\n  // Check if the node is a leaf\n  if (node.getLeft() == null && node.getRight() == null) \n  {\n    return node;\n  }\n  // Check if the node has a left child\n  if (node.getLeft() != null) \n  {\n    return getPartitionSuperNode(node.getLeft());\n  }\n  // Check if the node has a right child\n  if (node.getRight() != null) \n  {\n    return getPartitionSuperNode(node.getRight());\n  }\n  // If the node is not a leaf and does not have a child, then it is a super node\n  return node;\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (node == null) {\n    return null;\n  }\n\n  N current = node;\n  while (current.getColor() == Color.WHITE) {\n    current = current.getParent();\n  }\n\n  return current;\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (node == null) \n    {\n        return null;\n    }\n    int partition = getColor(node);\n    if (partition == -1) \n    {\n        return null;\n    }\n    N superNode = null;\n    for (N neighbor : getNeighbors(node)) \n    {\n        int neighborPartition = getColor(neighbor);\n        if (neighborPartition == partition) \n        {\n            superNode = getPartitionSuperNode(neighbor);\n            break;\n        }\n    }\n    if (superNode == null) \n    {\n        superNode = node;\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // TODO: Complete this method\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // find the partition of the node\n    int partition = getPartition(node);\n    // find the node that represents the partition\n    N superNode = getPartitionSuperNode(partition);\n    // if the super node is not found, then the node itself is the super node\n    if (superNode == null)\n    {\n        superNode = node;\n    }\n    return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getSecond())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getSecond())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getSecond())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getDouble())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getDoubleValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getSecond())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getSecond())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getSecond())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        double x = points[i];\n        double w = weights[i];\n        sum += f.value(x) * w;\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        double x = points[i];\n        double w = weights[i];\n        sum += f.value(x) * w;\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        double x = points[i];\n        double w = weights[i];\n        sum += w * f.value(x);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += f.value(points[i]) * weights[i];\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        double x = points[i];\n        double w = weights[i];\n        sum += f.value(x) * w;\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += f.value(points[i]) * weights[i];\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    else \n    {\n        for (Object key : map1.keySet()) \n        {\n            if (!map2.containsKey(key)) \n            {\n                return false;\n            }\n            else \n            {\n                Paint p1 = (Paint) map1.get(key);\n                Paint p2 = (Paint) map2.get(key);\n                if (!p1.equals(p2)) \n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        if (!map1.get(key).equals(map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    for (Object key : map1.keySet()) {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    for (Object key : map1.keySet()) {\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    for (Object key : map1.keySet()) {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    else \n    {\n        Iterator it = map1.entrySet().iterator();\n        while (it.hasNext()) \n        {\n            Map.Entry e = (Map.Entry) it.next();\n            Comparable key = (Comparable) e.getKey();\n            Paint p1 = (Paint) e.getValue();\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO: Replace this with your code\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Replace the expression with a short encoded string expression.\n  String shortExpr = encodeExpression(expr);\n  if (shortExpr != null) {\n    Node replacement = Node.newString(t.getSourceName(), shortExpr);\n    replacement.copyInformationFrom(expr);\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isName() || expr.isNumber() || expr.isString()) {\n        return expr;\n    }\n    Node replacement = expr;\n    if (expr.isGetProp() && expr.getLastChild().getString().equals(\"toString\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"valueOf\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"toLowerCase\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"toUpperCase\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"charAt\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"charCodeAt\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"substr\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"substring\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"slice\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"indexOf\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"lastIndexOf\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"includes\")) {\n        replacement = expr.getFirstChild();\n    } else if (expr.isGetProp() && expr.getLastChild().getString().equals(\"startsWith\")) {\n}\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isName() || expr.isNumber() || expr.isString()) {\n    // We can't replace a name, number, or string.\n    return expr;\n  }\n\n  if (expr.isGetProp()) {\n    // Replace a.b with a.b.\n    Node replacement = NodeUtil.newGetProp(expr.getFirstChild(), expr.getLastChild().getString());\n    replacement.setJSType(expr.getJSType());\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n\n  if (expr.isCall()) {\n    // Replace a() with a().\n    Node replacement = NodeUtil.newCall(expr.getFirstChild());\n    replacement.setJSType(expr.getJSType());\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n\n  if (expr.isArrayLit()) {\n    // Replace [a, b] with [a, b].\n    Node replacement = NodeUtil.newArrayLiteral();\n    for (Node child = expr.getFirstChild(); child != null; child = child.getNext()) {\n      replacement.addChildToBack(child.detach());\n    }\n    replacement.setJSType(expr.getJSType());\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n\n  if (expr.isObjectLit()) {\n    // Replace {a: b} with {a: b}.\n    Node replacement = NodeUtil.newObjectLiteral();\n    for (Node child = expr.getFirstChild(); child != null; child = child.getNext()) {\n      replacement.addChildToBack(child.detach());\n    }\n    replacement.setJSType(expr.getJSType());\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n\n  if (expr.isThis()) {\n    // Replace this with this.\n    Node replacement = NodeUtil.newThis(expr.getSourceFileName());\n    replacement.setJSType(expr.getJSType());\n    parent.replaceChild(expr, replacement);\n    return replacement;\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        // Replace the expression with a short string.\n        Node replacement = NodeUtil.newString(t.getSourceName(), \"\");\n        replacement.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Replace the expression with a short encoded string expression\n    String shortExpression = shortenExpression(expr);\n    if (shortExpression != null) {\n        Node replacement = NodeUtil.newString(t.getSourceName(), shortExpression);\n        replacement.copyInformationFrom(expr);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isName() || expr.isNumber() || expr.isString()) {\n    // If the expression is a name, number, or string, replace it with a\n    // shortened version.\n    String shortName = getShortName(expr.getString());\n    if (shortName != null) {\n      Node replacement = Node.newString(Token.NAME, shortName);\n      replacement.copyInformationFrom(expr);\n      parent.replaceChild(expr, replacement);\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // TODO: Replace this code with a short expression\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // Replace the expression with a short encoded string expression\n  String shortExpression = encodeExpression(expr);\n  Node replacement = NodeUtil.newString(t.getSourceName(), shortExpression);\n\n  // Replace the expression in the parent node\n  parent.replaceChild(expr, replacement);\n\n  // Return the replacement node\n  return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n        // Replace the string expression with a short encoded string expression\n        // (e.g. \"abc\" -> \"a|b|c\")\n        String shortExpr = encodeString(expr.getString());\n        Node replacement = NodeUtil.newString(t.getSourceName(), shortExpr);\n        replacement.copyInformationFrom(expr);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    }\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n    double[] copy = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, copy, 0, coefficients.length);\n    return copy;\n}",
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n    double[] coefficients = new double[this.coefficients.length];\n    System.arraycopy(this.coefficients, 0, coefficients, 0, this.coefficients.length);\n    return coefficients;\n}",
      "public double[] getCoefficients()  {\n    return Arrays.copyOf(coefficients, coefficients.length);\n}",
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}",
      "public double[] getCoefficients()  {\n    return coefficients.clone();\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    Node jsDoc = NodeUtil.getBestJSDocInfo(node);\n    if (jsDoc == null) {\n        return false;\n    }\n    String desc = jsDoc.getDesc();\n    if (desc == null) {\n        return false;\n    }\n    builder.setDescription(desc);\n    return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  // If the node has JSDoc info, use it to populate the message builder's\n  // meta data.\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    // If there is a @desc annotation, use it to set the message's description.\n    String desc = info.getDescription();\n    if (desc != null) {\n      builder.setDescription(desc);\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  // Get the JSDocInfo object for the node\n  JSDocInfo info = node.getJSDocInfo();\n\n  // If the node has JSDoc info\n  if (info != null) {\n    // Get the description of the message\n    String description = info.getDescription();\n\n    // If the description is not null\n    if (description != null) {\n      // Set the description of the message in the builder\n      builder.setDescription(description);\n\n      // Return true\n      return true;\n    }\n  }\n\n  // Return false\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    Node jsDoc = NodeUtil.getBestJSDocInfo(node);\n    if (jsDoc == null) {\n        return false;\n    }\n    String desc = jsDoc.getDescription();\n    if (desc == null) {\n        return false;\n    }\n    builder.setDescription(desc);\n    return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(node);\n  if (jsdoc != null) {\n    builder.setDescription(jsdoc.getBlockDescription());\n    builder.setDeprecated(jsdoc.isDeprecated());\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    Node jsDocNode = NodeUtil.getBestJSDocInfoNode(node);\n    if (jsDocNode == null) {\n        return false;\n    }\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc == null) {\n        return false;\n    }\n    String desc = jsDoc.getDescription();\n    if (desc == null) {\n        return false;\n    }\n    builder.setDescription(desc);\n    return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info == null) {\n        return false;\n    }\n    String desc = info.getDescription();\n    if (desc == null) {\n        return false;\n    }\n    builder.setDescription(desc);\n    return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc != null) \n    {\n        builder.setDescription(jsDoc.getBlockDescription());\n        return true;\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n        String desc = info.getDescription();\n        if (desc != null) {\n            builder.setDescription(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(node);\n  if (jsDoc == null) {\n    return false;\n  }\n\n  String desc = jsDoc.getDescription();\n  if (desc == null) {\n    return false;\n  }\n\n  builder.setDescription(desc);\n  return true;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.get(i);\n            final int closestClusterIndex = getClosestClusterIndex(clusters, point);\n            assignments[i] = closestClusterIndex;\n            clusters.get(closestClusterIndex).addPoint(point);\n            numAssigned++;\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int numAssigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int closestCluster = findClosestCluster(clusters, point);\n        assignments[i] = closestCluster;\n        numAssigned += closestCluster;\n    }\n    return numAssigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int numAssigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int closestCluster = findClosestCluster(clusters, point);\n        assignments[i] = closestCluster;\n        clusters.get(closestCluster).addPoint(point);\n        numAssigned++;\n    }\n    return numAssigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int oldAssignments = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = points.get(i);\n            double minDistance = Double.POSITIVE_INFINITY;\n            int clusterIndex = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                CentroidCluster<T> cluster = clusters.get(j);\n                double distance = cluster.distanceToCentroid(point);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    clusterIndex = j;\n                }\n            }\n            assignments[i] = clusterIndex;\n            if (assignments[i] != oldAssignments[i]) {\n                oldAssignments++;\n            }\n        }\n        return oldAssignments;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int numAssigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int closestClusterIndex = findClosestCluster(clusters, point);\n        final int currentAssignment = assignments[i];\n        if (currentAssignment != closestClusterIndex) {\n            numAssigned++;\n        }\n        assignments[i] = closestClusterIndex;\n    }\n    return numAssigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int numAssigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int assignment = assignments[i];\n        final CentroidCluster<T> cluster = clusters.get(assignment);\n        cluster.addPoint(point);\n        numAssigned += (assignment == assignments[i] ? 1 : 0);\n    }\n    return numAssigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int previousAssignments = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.get(i);\n            final int clusterIndex = getClosestClusterIndex(clusters, point);\n            assignments[i] = clusterIndex;\n            if (assignments[i] != previousAssignments) {\n                previousAssignments = assignments[i];\n            }\n        }\n        return previousAssignments;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int numAssigned = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.get(i);\n            final int clusterIndex = getClosestClusterIndex(clusters, point);\n            assignments[i] = clusterIndex;\n            clusters.get(clusterIndex).addPoint(point);\n            numAssigned++;\n        }\n        return numAssigned;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int index = findClosestCluster(clusters, point);\n        final CentroidCluster<T> cluster = clusters.get(index);\n        cluster.addPoint(point);\n        assignments[i] = index;\n        assigned++;\n    }\n    return assigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int previousAssignments = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.get(i);\n        final int closestClusterIndex = findClosestClusterIndex(clusters, point);\n        assignments[i] = closestClusterIndex;\n        clusters.get(closestClusterIndex).addPoint(point);\n    }\n    return previousAssignments;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    // Check that arrays are the same length\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n\n    // Check that arrays are at least length 2\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n\n    // Compute mean values\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n\n    // Compute sum of squares differences\n    double sumOfSquaresX = 0;\n    double sumOfSquaresY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumOfSquaresX += (xArray[i] - xMean) * (xArray[i] - xMean);\n        sumOfSquaresY += (yArray[i] - yMean) * (yArray[i] - yMean);\n    }\n\n    // Compute covariance\n    double covariance = (sumOfSquaresX * sumOfSquaresY) / (xArray.length - 1);\n\n    // If bias-corrected, compute the bias-corrected covariance\n    if (biasCorrected) {\n        covariance = covariance * (xArray.length - 1) / xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    // Check that the arrays are the same length\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n\n    // Check that there is sufficient data\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n\n    // Compute the mean\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n\n    // Compute the covariance\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n\n    // Correct for bias\n    if (biasCorrected) {\n        covariance /= (xArray.length - 1);\n    } else {\n        covariance /= xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double xSum = 0;\n    double ySum = 0;\n    double xySum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        xSum += xArray[i];\n        ySum += yArray[i];\n        xySum += xArray[i] * yArray[i];\n    }\n    double xMean = xSum / xArray.length;\n    double yMean = ySum / yArray.length;\n    double covariance = xySum / (xArray.length - (biasCorrected ? 1 : 0)) - xMean * yMean;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    // Validate input\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    // Compute covariance\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - mean(xArray)) * (yArray[i] - mean(yArray));\n    }\n    covariance /= xArray.length - (biasCorrected ? 1 : 0);\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        double covariance = 0;\n        double meanX = 0;\n        double meanY = 0;\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumXY = 0;\n        double sumX2 = 0;\n        double sumY2 = 0;\n        double n = 0;\n        double x = 0;\n        double y = 0;\n        double x2 = 0;\n        double y2 = 0;\n        double xy = 0;\n\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                    xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                    xArray.length, 2);\n        }\n\n        for (int i = 0; i < xArray.length; i++) {\n            x = xArray[i];\n            y = yArray[i];\n            x2 = x * x;\n            y2 = y * y;\n            xy = x * y;\n            sum += 1;\n            sumX += x;\n            sumY += y;\n            sumXY += xy;\n            sumX2 += x2;\n            sumY2 += y2;\n        }\n        n = sum;\n        meanX = sumX / n;\n        meanY = sumY / n;\n        covariance = (sumXY - sumX * meanY - sumY * meanX + sum * meanX * meanY) / (n - 1);\n\n        if (biasCorrected) {\n            covariance *= n / (n - 1);\n        }\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double xmean = mean(xArray);\n    double ymean = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xmean) * (yArray[i] - ymean);\n    }\n    if (biasCorrected) {\n        sum -= (xArray.length - 1) * (xmean * ymean);\n    }\n    return sum / (xArray.length - 1);\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    double covariance = 0;\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        covariance /= xArray.length - 1;\n    } else {\n        covariance /= xArray.length;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    double covariance = 0;\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        covariance /= xArray.length - 1;\n    } else {\n        covariance /= xArray.length;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n\n    // Check that arrays are of same length\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n\n    // Check that arrays have at least 2 entries\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n\n    // Compute the mean of both arrays\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n\n    // Compute the covariance\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n\n    // Bias-corrected covariance\n    if (biasCorrected) {\n        covariance *= (xArray.length - 1) / xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length, 2);\n    }\n    double sumOfProducts = 0;\n    double sumOfX = 0;\n    double sumOfY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumOfProducts += xArray[i] * yArray[i];\n        sumOfX += xArray[i];\n        sumOfY += yArray[i];\n    }\n    double meanOfX = sumOfX / xArray.length;\n    double meanOfY = sumOfY / xArray.length;\n    double covariance = sumOfProducts / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance -= meanOfX * meanOfY;\n    }\n    return covariance;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"value must be non-negative\");\n    }\n    if (value == 0) {\n        return;\n    }\n    long remaining = value;\n    while (remaining > 0) {\n        final int toRead = (int) Math.min(remaining, BUFFER_SIZE);\n        final int read = read(buffer, 0, toRead);\n        if (read < 0) {\n            throw new EOFException();\n        }\n        remaining -= read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) \n    {\n        int read = in.read(SKIP_BUFFER, 0, (int) Math.min(SKIP_BUFFER.length, remaining));\n        if (read <= 0) \n        {\n            throw new IOException(\"Unable to skip \" + value + \" bytes, \" + remaining + \" bytes remaining\");\n        }\n        remaining -= read;\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final int toRead = (int) Math.min(remaining, SKIP_BUFFER_SIZE);\n        final int n = read(skipBuffer, 0, toRead);\n        if (n < 0) {\n            break;\n        }\n        remaining -= n;\n    }\n    if (remaining > 0) {\n        throw new IOException(\"Could not skip \" + value + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) \n    {\n        throw new IllegalArgumentException(\"value must be >= 0\");\n    }\n\n    if (value == 0) \n    {\n        return;\n    }\n\n    final byte[] skipBuf = new byte[SKIP_BUFFER_SIZE];\n    long remaining = value;\n\n    while (remaining > 0) \n    {\n        final int toRead = (int) Math.min(SKIP_BUFFER_SIZE, remaining);\n        final int numRead = read(skipBuf, 0, toRead);\n\n        if (numRead == -1) \n        {\n            break;\n        }\n\n        remaining -= numRead;\n    }\n\n    if (remaining > 0) \n    {\n        throw new IOException(\"Unable to skip \" + remaining + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) \n    {\n        return;\n    }\n    final long skipped = IOUtils.skipFully(this.archiveStream, value);\n    this.bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long skipped = this.stream.skip(value);\n    this.bytesRead += skipped;\n    if (skipped != value) {\n        throw new IOException(\"Could not skip enough bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    bytesRead += skipped;\n    if (skipped != value) {\n        throw new IOException(\"Unable to skip requested \" + value + \" bytes, \" +\n                              \"only skipped \" + skipped + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    long remaining = value;\n    while (remaining > 0) {\n        int read = in.read(skipBuf, 0, (int) Math.min(skipBuf.length, remaining));\n        if (read < 0) {\n            break;\n        }\n        remaining -= read;\n    }\n    if (remaining > 0) {\n        throw new IOException(\"Unable to skip \" + remaining + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"value must be >= 0\");\n    }\n    long remaining = value;\n    while (remaining > 0) {\n        final int toRead = (int) Math.min(remaining, SIXTEEN_K);\n        final byte[] b = new byte[toRead];\n        final int read = readFully(b);\n        if (read < toRead) {\n            throw new EOFException(\"Premature EOF: \" + remaining + \" bytes remaining\");\n        }\n        remaining -= read;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"value must be >= 0\");\n    }\n\n    long remaining = value;\n    while (remaining > 0) {\n        final int toRead = (int) Math.min(remaining, SIXTEEN_KB);\n        final byte[] b = new byte[toRead];\n        final int read = read(b);\n        if (read == -1) {\n            throw new EOFException(\"Unexpected EOF reached after \" +\n                    value + \" bytes read\");\n        }\n        remaining -= read;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) {\n        field.setAccessible(true);\n    }\n    try {\n        return field.get(target);\n    } finally {\n        if (!accessible) {\n            field.setAccessible(false);\n        }\n    }\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) \n    {\n        field.setAccessible(true);\n    }\n    try \n    {\n        return field.get(target);\n    } \n    finally \n    {\n        if (!accessible) \n        {\n            field.setAccessible(false);\n        }\n    }\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) \n    {\n        field.setAccessible(true);\n    }\n    try \n    {\n        return field.get(target);\n    } \n    finally \n    {\n        if (!accessible) \n        {\n            field.setAccessible(false);\n        }\n    }\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"fieldName must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"fieldName must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) \n    {\n        field.setAccessible(true);\n    }\n    try \n    {\n        return field.get(target);\n    } \n    finally \n    {\n        if (!accessible) \n        {\n            field.setAccessible(false);\n        }\n    }\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"field name must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) {\n        field.setAccessible(true);\n    }\n    try {\n        return field.get(target);\n    } finally {\n        if (!accessible) {\n            field.setAccessible(false);\n        }\n    }\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    Class<?> cls = target.getClass();\n    if (cls == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (cls.isArray()) {\n        return Array.get(target, 0);\n    }\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    Validate.isTrue(target != null, \"target object must not be null\");\n    Validate.isTrue(fieldName != null, \"field name must not be null\");\n    Class<?> cls = target.getClass();\n    Field field = getDeclaredField(cls, fieldName, forceAccess);\n    Validate.isTrue(field != null, \"Cannot locate declared field %s.%s\", cls.getName(), fieldName);\n    boolean wasAccessible = field.isAccessible();\n    if (!wasAccessible) {\n        field.setAccessible(true);\n    }\n    Object result = field.get(target);\n    field.setAccessible(wasAccessible);\n    return result;\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Field field = getDeclaredField(target, fieldName, forceAccess);\n    final boolean accessible = field.isAccessible();\n    if (!accessible) \n    {\n        field.setAccessible(true);\n    }\n    try \n    {\n        return field.get(target);\n    } \n    finally \n    {\n        if (!accessible) \n        {\n            field.setAccessible(false);\n        }\n    }\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        fingerprint = (fingerprint << 5) + fingerprint + part.hashCode();\n    }\n    return Long.toString(fingerprint, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        for (int i = 0; i < part.length(); i++) \n        {\n            fingerprint = (fingerprint << 5) + fingerprint + part.charAt(i);\n        }\n    }\n    return Long.toString(fingerprint, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement the fingerprinting algorithm here\n    // ...\n    // ...\n    // ...\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Compute the fingerprint\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) {\n        fingerprint = fingerprint * 31 + part.hashCode();\n    }\n\n    // Convert the fingerprint to a string\n    String fingerprintString = Long.toString(fingerprint, 36);\n\n    // Truncate the string to the first 8 characters\n    return fingerprintString.substring(0, 8);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Generate a fingerprint of the content parts of the message.\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        fingerprint = (fingerprint << 1) ^ part.hashCode();\n    }\n    // Generate a compact uppercase alphanumeric text representation of the fingerprint.\n    StringBuilder fingerprintText = new StringBuilder();\n    for (int i = 0; i < 12; i++) \n    {\n        fingerprintText.append(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                .charAt((int) (fingerprint & 0x3F)));\n        fingerprint >>>= 6;\n    }\n    return fingerprintText.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Generate a fingerprint from the message parts\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) {\n        fingerprint = fingerprint * 31 + part.hashCode();\n    }\n    // TODO: Generate a compact uppercase alphanumeric text representation of the fingerprint\n    String fingerprintString = Long.toString(fingerprint, 36);\n    return fingerprintString.toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        fingerprint = (fingerprint * 31) + part.hashCode();\n    }\n    return Long.toString(fingerprint, 36);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Create a 64-bit fingerprint of the content parts of a message\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) {\n        fingerprint = fingerprint * 31 + part.hashCode();\n    }\n\n    // Generate a compact uppercase alphanumeric text representation\n    // of the fingerprint\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < 12; i++) {\n        result.append(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                .charAt((int) (fingerprint >> (63 - 5 * i)) & 31));\n    }\n    return result.toString();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // TODO: Implement this method\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd >= maxDistanceFromEnd) {\n        raf.seek(raf.length() - distanceFromEnd);\n        distanceFromEnd -= sig.length;\n        if (raf.read(sig) == sig.length) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // Implement this method\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // Implement this method\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        throw new IllegalArgumentException(\"minDistanceFromEnd must be less than or equal to maxDistanceFromEnd\");\n    }\n    if (minDistanceFromEnd < 0) {\n        throw new IllegalArgumentException(\"minDistanceFromEnd must be greater than or equal to 0\");\n    }\n    if (maxDistanceFromEnd < 0) {\n        throw new IllegalArgumentException(\"maxDistanceFromEnd must be greater than or equal to 0\");\n    }\n    if (sig == null) {\n        throw new IllegalArgumentException(\"sig must not be null\");\n    }\n    if (sig.length == 0) {\n        throw new IllegalArgumentException(\"sig must not be empty\");\n    }\n\n    final long maxDistance = Math.min(maxDistanceFromEnd, length() - sig.length);\n    long pos = Math.max(0, length() - minDistanceFromEnd);\n    while (pos <= maxDistance) {\n        file.seek(pos);\n        boolean found = true;\n        for (int i = 0; i < sig.length; i++) {\n            if (file.readByte() != sig[i]) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // Complete this method\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = minDistanceFromEnd;\n    while (distance <= maxDistanceFromEnd) \n    {\n        long pos = raf.length() - distance;\n        raf.seek(pos);\n        byte[] b = new byte[sig.length];\n        raf.read(b);\n        if (Arrays.equals(b, sig)) \n        {\n            return true;\n        }\n        distance += 1;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    // Write your code here\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        raf.seek(raf.length() - distanceFromEnd);\n        if (raf.read(sig) == sig.length) {\n            return true;\n        }\n        distanceFromEnd++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    if (maxDistanceFromEnd < minDistanceFromEnd) {\n        throw new IllegalArgumentException(\"maxDistanceFromEnd must be greater than minDistanceFromEnd\");\n    }\n\n    final long maxOffset = maxDistanceFromEnd;\n    final long minOffset = Math.max(0, minDistanceFromEnd);\n\n    long offset = maxOffset;\n\n    while (offset >= minOffset) {\n        raf.seek(offset);\n\n        if (raf.read(sig) == sig.length) {\n            return true;\n        }\n\n        offset--;\n    }\n\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.TOP;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.TOP;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index == 0) \n    {\n        result = RectangleEdge.LEFT;\n    } \n    else if (index == 1) \n    {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index == 0) \n    {\n        result = RectangleEdge.LEFT;\n    } \n    else if (index == 1) \n    {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    return RectangleEdge.BOTTOM;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index == 0) \n    {\n        result = RectangleEdge.LEFT;\n    } \n    else if (index == 1) \n    {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        return partialConverters.remove(converter);\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter replaced = null;\n        synchronized (this) {\n            replaced = partialConverters.remove(converter);\n        }\n        return replaced;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter removed = null;\n        synchronized (partialConverters) {\n            removed = partialConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter removed = null;\n        if (partialConverters.contains(converter)) {\n            removed = partialConverters.remove(converter);\n        }\n        return removed;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter removed = null;\n        if (converters != null) {\n            removed = converters.remove(converter);\n        }\n        return removed;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter removed = null;\n        for (PartialConverter c : partialConverters) {\n            if (c.equals(converter)) {\n                removed = c;\n                partialConverters.remove(c);\n                break;\n            }\n        }\n        return removed;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converters.remove(converter)) {\n            return converter;\n        }\n        return null;\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        return partialConverters.remove(converter);\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    if (partialConverters == null) {\n        return null;\n    }\n    return partialConverters.remove(converter);\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter removed = null;\n        synchronized (partialConverters) {\n            removed = partialConverters.remove(converter);\n        }\n        return removed;\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(data);\n}",
      "public InputStream getDataStream()  {\n    return dataStream;\n}",
      "public InputStream getDataStream()  {\n    return dataStream;\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(data);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(this.buffer);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(data);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(data);\n}",
      "public InputStream getDataStream()  {\n    return this.dataStream;\n}",
      "public InputStream getDataStream()  {\n}",
      "public InputStream getDataStream()  {\n    return new SequenceInputStream(new ByteArrayInputStream(this.buffer), this.stream);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // check if the section is in the dataset\n    if (section < getSectionCount()) \n    {\n        key = getSection(section).getKey();\n    }\n    // if not, generate a key\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < getSectionCount()) {\n        key = getSection(section).getKey();\n    }\n    if (key == null) {\n        key = createSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < this.sections.size())  {\n        key = this.sections.get(section).getKey();\n    }\n    if (key == null)  {\n        key = \"section\" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = (Comparable) this.sections.get(section);\n    if (key == null) {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.sections.size())  {\n        key = (Comparable) this.sections.get(section);\n    }\n    if (key == null)  {\n        key = createSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.sections.size()) \n    {\n        key = (Comparable) this.sections.get(section);\n    }\n    else \n    {\n        key = createSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < getSectionCount()) {\n        key = getSection(section).getKey();\n    }\n    if (key == null) {\n        key = createSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < getSectionCount()) \n    {\n        key = getSection(section).getKey();\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = (Comparable) this.sections.get(section);\n    if (key == null) \n    {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.sections.size()) \n    {\n        key = this.sections.get(section);\n    }\n    else \n    {\n        key = createSectionKey(section);\n        this.sections.add(key);\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(this.value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(this.value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(this.value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(value);\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return ignoreCase ? regionMatches(true, str, 0, prefix, 0, prefix.length()) :\n        str.toString().startsWith(prefix.toString());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(strChar) != Character.toLowerCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if (strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    if (ignoreCase) \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    } \n    else \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            if (str.charAt(i) != prefix.charAt(i)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    if (ignoreCase) {\n        for (int i = 0; i < prefix.length(); i++) {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefix.length(); i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    if (ignoreCase) {\n        for (int i = 0; i < prefix.length(); i++) {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefix.length(); i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    if (ignoreCase) \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            final char strChar = Character.toLowerCase(str.charAt(i));\n            final char prefixChar = Character.toLowerCase(prefix.charAt(i));\n            if (strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    } \n    else \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            if (str.charAt(i) != prefix.charAt(i)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    // TODO: Implement this method\n    return false;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (ignoreCase) \n        {\n            if (Character.toLowerCase(strChar) != Character.toLowerCase(prefixChar)) \n            {\n                return false;\n            }\n        } \n        else \n        {\n            if (strChar != prefixChar) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return (str == null && prefix == null);\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    // TODO: implement this method\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    String string = null;\n    switch (peek()) {\n        case NUMBER:\n            string = nextNumber();\n            break;\n        case STRING:\n            string = nextString();\n            break;\n        default:\n            throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    return string;\n}",
      "public String nextString() throws IOException  {\n  String result;\n  JsonToken token = peek();\n  switch (token) {\n    case STRING:\n      result = nextStringInternal();\n      break;\n    case NUMBER:\n      result = nextNumber().toString();\n      break;\n    default:\n      throw new IllegalStateException(\"Expected \" + tokenName(STRING) + \" but was \" + tokenName(token));\n  }\n  return result;\n}",
      "public String nextString() throws IOException  {\n    String string = nextStringInternal();\n    if (string == null) {\n        throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n    return string;\n}",
      "public String nextString() throws IOException  {\n    String result;\n    switch (peek()) {\n    case STRING:\n        result = nextStringInternal();\n        break;\n    case NUMBER:\n        result = nextNumber();\n        break;\n    default:\n        throw new IllegalStateException(\"Expected \" + STRING + \" but was \" + peek());\n    }\n    return result;\n}",
      "public String nextString() throws IOException  {\n    JsonToken token = peek();\n    switch (token) {\n      case STRING:\n        return nextStringInternal();\n      case NUMBER:\n        JsonReaderInternalAccess.INSTANCE.promoteNameToValue(this);\n        token = peek();\n        if (token == JsonToken.STRING) {\n          return nextStringInternal();\n        }\n        // fall out\n      default:\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n  }",
      "public String nextString() throws IOException  {\n    // check if the next token is a string\n    if (peek() != JsonToken.STRING) \n    {\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n\n    // consume the next token\n    String value = nextStringInternal();\n\n    // return the string value\n    return value;\n}",
      "public String nextString() throws IOException  {\n    // Check if the next token is a string.\n    if (nextToken == JsonToken.STRING) {\n      // Return the string value of the next token.\n      return nextString();\n    } else if (nextToken == JsonToken.NUMBER) {\n      // Return the string form of the next token.\n      return nextNumber().toString();\n    } else {\n      // Throw an exception if the next token is not a string.\n      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + nextToken);\n    }\n  }",
      "public String nextString() throws IOException  {\n    String result = nextStringInternal();\n    if (result == null) {\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + peek());\n    }\n    return result;\n}",
      "public String nextString() throws IOException  {\n    // TODO: Implement this method\n}",
      "public String nextString() throws IOException  {\n    String result;\n    JsonToken token = peek();\n    if (token == JsonToken.STRING) \n    {\n        result = nextStringInternal();\n    } \n    else if (token == JsonToken.NUMBER) \n    {\n        result = nextNumber().toString();\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (nameIdMap.containsKey(symbolName)) \n    {\n        return nameIdMap.get(symbolName);\n    }\n    int newId = nameIdMap.size();\n    nameIdMap.put(symbolName, newId);\n    return newId;\n}",
      "private int getNameId(String symbolName)  {\n    //TODO: implement this method\n    return 0;\n}",
      "private int getNameId(String symbolName)  {\n    // Check if the symbol name is already in the pool\n    if (namePool.containsKey(symbolName)) \n    {\n        return namePool.get(symbolName);\n    } \n    else \n    {\n        // Add the symbol name to the pool\n        namePool.put(symbolName, namePool.size());\n        return namePool.get(symbolName);\n    }\n}",
      "private int getNameId(String symbolName)  {\n    // TODO: Implement this method\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName == null) {\n    return -1;\n  }\n  Integer id = symbolNameToId.get(symbolName);\n  if (id == null) {\n    id = symbolNameToId.size();\n    symbolNameToId.put(symbolName, id);\n  }\n  return id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n        return 0;\n    }\n    int id = symbolName.hashCode();\n    if (id < 0) {\n        id = -id;\n    }\n    return id;\n}",
      "private int getNameId(String symbolName)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "private int getNameId(String symbolName)  {\n  if (nameIdMap.containsKey(symbolName)) \n  {\n    return nameIdMap.get(symbolName);\n  } \n  else \n  {\n    int id = nameIdMap.size();\n    nameIdMap.put(symbolName, id);\n    return id;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName == null) {\n        return -1;\n    }\n    int nameId = symbolNameToId.get(symbolName);\n    if (nameId == -1) {\n        nameId = symbolNameToId.size();\n        symbolNameToId.put(symbolName, nameId);\n    }\n    return nameId;\n}",
      "private int getNameId(String symbolName)  {\n    if (nameIdMap.containsKey(symbolName)) {\n        return nameIdMap.get(symbolName);\n    }\n    int nameId = nameIdMap.size();\n    nameIdMap.put(symbolName, nameId);\n    return nameId;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    JsonToken token = peek();\n    if (token == JsonToken.NUMBER) {\n      return nextNumber().doubleValue();\n    } else if (token == JsonToken.STRING) {\n      return Double.parseDouble(nextString());\n    }\n    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + peek());\n  }",
      "public double nextDouble() throws IOException  {\n    JsonToken token = peek();\n    switch (token) \n    {\n    case NUMBER:\n        return nextNumber().doubleValue();\n    case STRING:\n        String string = nextString();\n        double value = Double.parseDouble(string);\n        if (Double.isFinite(value)) \n        {\n            return value;\n        }\n        else \n        {\n            throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n        }\n    default:\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n}",
      "public double nextDouble() throws IOException  {\n  JsonToken peek = peek();\n  if (peek == JsonToken.NUMBER) {\n    return nextNumber();\n  } else if (peek == JsonToken.STRING) {\n    return Double.parseDouble(nextString());\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n}",
      "public double nextDouble() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.NUMBER) {\n      return nextDouble();\n    } else if (peek == JsonToken.STRING) {\n      return Double.parseDouble(nextString());\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n  }",
      "public double nextDouble() throws IOException  {\n    JsonToken token = peek();\n    if (token == JsonToken.NUMBER) \n    {\n        return nextDouble();\n    } \n    else if (token == JsonToken.STRING) \n    {\n        return Double.parseDouble(nextString());\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.NUMBER) \n    {\n        return nextDouble();\n    } \n    else if (peek == JsonToken.STRING) \n    {\n        String str = nextString();\n        try \n        {\n            return Double.parseDouble(str);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Expecting a double but was \" + str, e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expecting double but was \" + peek);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    JsonToken token = peek();\n    if (token == JsonToken.NUMBER) {\n      return nextDouble();\n    } else if (token == JsonToken.STRING) {\n      return Double.parseDouble(nextString());\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + token);\n  }",
      "public double nextDouble() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.NUMBER) {\n      return nextDouble();\n    } else if (peek == JsonToken.STRING) {\n      String strVal = nextString();\n      try {\n        return Double.parseDouble(strVal);\n      } catch (NumberFormatException e) {\n        throw new JsonSyntaxException(\"Expecting number, got: \" + strVal, e);\n      }\n    }\n    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + peek);\n  }",
      "public double nextDouble() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.NUMBER) {\n        return nextDouble();\n    } else if (peek == JsonToken.STRING) {\n        String strVal = nextString();\n        double result = Double.parseDouble(strVal);\n        if (result >= -Double.MAX_VALUE && result <= Double.MAX_VALUE) {\n            return result;\n        }\n        throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    } else {\n        throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + peek + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    JsonToken peek = peek();\n    if (peek == JsonToken.NUMBER) {\n        return nextDouble();\n    } else if (peek == JsonToken.STRING) {\n        return Double.parseDouble(nextString());\n    }\n    throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + peek + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) \n    {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) \n    {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort headerId = ZipShort.get(headerId.getValue() & 0xffff);\n    final String className = getExtraFieldClassName(headerId);\n    if (className == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    try {\n        return (ZipExtraField) ZipExtraField.class.getClassLoader().loadClass(className).newInstance();\n    } catch (final ClassNotFoundException cnfe) {\n        throw new InstantiationException(cnfe.getMessage());\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    try {\n        ze = (ZipExtraField)\n            ZipShort.class.getClassLoader().loadClass(\n                    \"org.apache.commons.compress.archivers.zip.\" +\n                    \"Zip\" + headerId.getValue() + \"ExtraField\").newInstance();\n    } catch (ClassNotFoundException cnfe) {\n        ze = new UnrecognizedExtraField();\n    }\n    ze.setHeaderId(headerId);\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n    final ZipShort headerId = new ZipShort(headerId.getValue());\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, true);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        ZipExtraField extraField = null;\n        final Class<? extends ZipExtraField> clazz =\n            extraFieldMap.get(headerId);\n        if (clazz != null) {\n            extraField = clazz.newInstance();\n        } else {\n            extraField = new UnrecognizedExtraField();\n        }\n        extraField.setHeaderId(headerId);\n        return extraField;\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort headerId = ZipShort.get(headerId.getValue() & 0xffff);\n    final String className = ZIP_EXTRA_FIELD_MAP.get(headerId);\n    if (className != null) {\n        return (ZipExtraField) Class.forName(className).newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final ZipShort headerId = ZipShort.get(headerId.getValue() & 0xffff);\n    final ZipExtraField extraField = EXTRA_FIELD_FACTORY.createExtraField(headerId);\n    if (extraField == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final String className = \"org.apache.commons.compress.archivers.zip.ZipExtraField\";\n    final String methodName = \"createExtraField\";\n    final Class<?>[] parameterTypes = {ZipShort.class};\n    final Object[] parameters = {headerId};\n    return (ZipExtraField) invokeStaticMethod(className, methodName, parameterTypes, parameters);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    return createExtraField(headerId, false);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final String className = HEADER_TO_CLASS.get(headerId);\n    if (className != null) {\n        return (ZipExtraField) Class.forName(className).newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (str == null || str.length() == 0 || set == null || set.length == 0) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || str.length() == 0) {\n        return 0;\n    }\n    if (set == null || set.length == 0) {\n        return str.length();\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || set == null) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (CharSet.getInstance(set).contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || set == null) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        for (String seq : set) {\n            if (CharSet.getInstance(seq).contains(c)) {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || str.isEmpty() || set == null || set.length == 0) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || set == null) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || set == null) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        for (int j = 0; j < set.length; j++) {\n            if (CharSet.getInstance(set[j]).contains(ch)) {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || str.isEmpty() || set == null || set.length == 0) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || set == null) {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (CharSet.getInstance(set).contains(str.charAt(i))) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || str.isEmpty() || set == null || set.length == 0) \n    {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        for (int j = 0; j < set.length; j++) \n        {\n            if (CharSet.getInstance(set[j]).contains(ch)) \n            {\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Object key : map.keySet()) \n    {\n        Object value = map.get(key);\n        if (value instanceof Cloneable) \n        {\n            clone.put(key, ((Cloneable) value).clone());\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Object key : map.keySet()) \n    {\n        clone.put(key, ((Marker) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    return (Map) map.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    return (Map) map.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    return (Map) map.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    return (Map) map.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    return (Map) map.clone();\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (int i = 0; i < data.length; i++) {\n        byte[] b = data[i].getCentralDirectoryData();\n        if (b != null) {\n            result = Arrays.copyOf(result, result.length + b.length);\n            System.arraycopy(b, 0, result, result.length - b.length, b.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField element : data) \n    {\n        element.writeCentralDirectoryData(baos);\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return new byte[0];\n    }\n    final List<byte[]> dataList = new ArrayList<byte[]>();\n    for (final ZipExtraField element : data) {\n        dataList.add(element.getCentralDirectoryData());\n    }\n    return ZipExtraField.mergeLocalFileDataData(dataList);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    final List<byte[]> list = new ArrayList<>();\n    for (final ZipExtraField element : data) {\n        final byte[] local = element.getCentralDirectoryData();\n        if (local != null) {\n            list.add(local);\n        }\n    }\n    return ZipExtraField.mergeLocalFileDataData(list);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final List<byte[]> allData = new ArrayList<>();\n    for (final ZipExtraField element : data) {\n        final byte[] fieldData = element.getCentralDirectoryData();\n        if (fieldData != null) {\n            allData.add(fieldData);\n        }\n    }\n    return mergeData(allData);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField ze : data) \n    {\n        final byte[] b = ze.getCentralDirectoryData();\n        if (b != null) \n        {\n            baos.write(b);\n        }\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    byte[] result = new byte[0];\n    for (ZipExtraField field : data) {\n        result = Arrays.copyOf(result, result.length + field.getCentralDirectoryLength().getValue());\n        field.writeCentralDirectoryData(result, result.length - field.getCentralDirectoryLength().getValue());\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final List<byte[]> list = new ArrayList<>();\n    for (final ZipExtraField field : data) \n    {\n        final byte[] local = field.getCentralDirectoryData();\n        if (local != null) \n        {\n            list.add(local);\n        }\n    }\n    return ZipExtraField.mergeLocalFileDataData(list);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return null;\n    }\n    byte[] result = null;\n    for (final ZipExtraField element : data) {\n        final byte[] b = element.getCentralDirectoryData();\n        if (b.length > 0) {\n            if (result == null) {\n                result = b;\n            } else {\n                result = Arrays.copyOf(result, result.length + b.length);\n                System.arraycopy(b, 0, result, result.length - b.length, b.length);\n            }\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    if (data == null) {\n        return new byte[0];\n    }\n    final List<byte[]> result = new ArrayList<byte[]>();\n    for (final ZipExtraField ze : data) {\n        if (ze != null) {\n            final byte[] b = ze.getCentralDirectoryData();\n            if (b != null) {\n                result.add(b);\n            }\n        }\n    }\n    return ZipExtraField.mergeLocalFileDataData(result, false);\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (E element : coll) {\n            if (add(index, element)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E element : coll) {\n            if (add(index, element)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll.isEmpty()) {\n            return false;\n        }\n        final int size = coll.size();\n        if (size == 1) {\n            add(index, coll.iterator().next());\n            return true;\n        }\n        final Object[] a = coll.toArray();\n        if (a.length != size) {\n            throw new ConcurrentModificationException();\n        }\n        final int start = this.size();\n        for (int i = 0; i < size; i++) {\n            add(index + i, (E) a[i]);\n        }\n        return start != this.size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E element : coll) \n        {\n            if (add(index, element)) \n            {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (add(e)) {\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E element : coll) {\n            if (add(index, element)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean result = false;\n        for (final E e : coll) {\n            if (add(index, e)) {\n                result = true;\n            }\n        }\n        return result;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll.isEmpty()) {\n            return false;\n        }\n        final Iterator<? extends E> it = coll.iterator();\n        while (it.hasNext()) {\n            add(index, it.next());\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (add(index, element)) {\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n        // The List interface makes the assumption that the elements are always\n        // inserted. This may not happen with this implementation.\n        //\n        // (Violation)\n}"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    int maxEval = 1000;\n    double min = 0;\n    double max = 1;\n    double startValue = 0.5;\n    UnivariateObjectiveFunction objFunc = new UnivariateObjectiveFunction(f);\n    BrentOptimizer optimizer = new BrentOptimizer(1e-15, 1e-30);\n    optimizer.setMaximalAllowedEvaluations(maxEval);\n    optimizer.setRelativeAccuracy(1e-15);\n    optimizer.setAbsoluteAccuracy(1e-30);\n    UnivariatePointValuePair result = optimizer.optimize(new MaxEval(maxEval),\n                                                         new UnivariateObjectiveFunction(objFunc),\n                                                         GoalType.MINIMIZE,\n                                                         new SearchInterval(min, max),\n                                                         new InitialGuess(startValue));\n    return result.getValue();\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    // Check if the maximal number of evaluations is exceeded.\n    if (evaluations >= maxEvaluations) {\n        throw new TooManyEvaluationsException(maxEvaluations);\n    }\n    // Evaluate the function.\n    double y = f.value(x);\n    // Update the number of evaluations.\n    evaluations++;\n    // Return the function value.\n    return y;\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRightHandSide() > 0) {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRightHandSide() > 0) \n        {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRightHandSide() > 0) \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getRightHandSide() > 0) {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) \n    {\n        if (originalConstraint.getRightHandSide() > 0) \n        {\n            normalizedConstraints.add(originalConstraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRightHandSide() > 0) \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRightHandSide() > 0) \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) {\n        if (originalConstraint.getRhs() > 0) {\n            normalizedConstraints.add(originalConstraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRightHandSide() > 0) \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint originalConstraint : originalConstraints) \n    {\n        if (originalConstraint.getRightHandSide() > 0) \n        {\n            newConstraints.add(originalConstraint);\n        }\n    }\n    return newConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.equals(bin)) \n    {\n        return true;\n    }\n    return (this.getLowerBound() <= bin.getUpperBound() && this.getUpperBound() >= bin.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.getLowerBound() <= bin.getUpperBound()\n            && this.getUpperBound() >= bin.getLowerBound();\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    // COMPLETE THIS METHOD\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    // TODO: implement this method\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.getLowerBound() <= bin.getUpperBound() && bin.getLowerBound() <= this.getUpperBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.getLowerBound() <= bin.getUpperBound() &&\n            this.getUpperBound() >= bin.getLowerBound();\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.equals(bin)) {\n        return true;\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.upperBound) {\n        return true;\n    }\n    if (this.lowerBound == bin.upperBound && this.upperBound == bin.upperBound) {\n        return true;\n    }\n    if (this.lowerBound == bin.lowerBound && this.upperBound == bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.overlapsWith(bin.getLowerBound(), bin.getUpperBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.getLowerBound() <= bin.getUpperBound()\n            && this.getUpperBound() >= bin.getLowerBound());\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    return new DateTimeFormatterBuilder()\n        .append(DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"))\n        .toFormatter()\n        .withZone(DateTimeZone.getDefault())\n        .parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    // code here\n}",
      "public long parseMillis(String text)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    return LocalDateTime.parse(text).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();\n}",
      "public long parseMillis(String text)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    return DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").parseMillis(text);\n}",
      "public long parseMillis(String text)  {\n    return LocalDateTime.parse(text).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    // Find the condition node, which is the leftmost child of the root.\n    Node condition = n.getFirstChild();\n    // Find the positive and negative sides of the condition.\n    Node positive = condition.getNext();\n    Node negative = positive.getNext();\n    // Create a new MinimizedCondition object to represent this tree.\n    MinimizedCondition mc = new MinimizedCondition(n, condition, positive, negative);\n    // Return the MinimizedCondition object.\n    return mc;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  // The condition node is always a child of a CONDITIONAL_AND or CONDITIONAL_OR node.\n  Node parent = n.getParent();\n  int parentType = parent.getType();\n  if (parentType != Token.CONDITIONAL_AND && parentType != Token.CONDITIONAL_OR) {\n    throw new IllegalArgumentException(\"The given node is not a condition\");\n  }\n\n  // Find the other side of the condition.\n  Node otherSide = n;\n  while (otherSide.getNext() != null && otherSide.getNext().getType() == Token.COMMA) {\n    otherSide = otherSide.getNext();\n  }\n  otherSide = otherSide.getNext();\n\n  // Create a placeholder node to replace the condition node.\n  Node placeholder = new Node(Token.SCRIPT, \"\");\n  placeholder.setLength(Integer.MAX_VALUE);\n  placeholder.setParent(parent);\n  placeholder.setNext(otherSide);\n  placeholder.setPrevious(n.getPrevious());\n  n.getPrevious().setNext(placeholder);\n  otherSide.setPrevious(placeholder);\n  n.setParent(null);\n  n.setNext(null);\n  n.setPrevious(null);\n\n  // Create the MinimizedCondition object.\n  MinimizedCondition mc = new MinimizedCondition(n, placeholder);\n  mc.setParent(parent);\n  return mc;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = new Node(Token.SCRIPT, n.getSource());\n    placeholder.setLength(Integer.MAX_VALUE);\n    n.swapWith(placeholder);\n    return new MinimizedCondition(n, placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MinimizedCondition mc = new MinimizedCondition(n);\n    mc.setNegative(new Token(Token.SCRIPT, \"\"));\n    return mc;\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(n, new Token(Token.SCRIPT, \"\"), 0);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    // Create a new MinimizedCondition object for the given node.\n    MinimizedCondition mc = new MinimizedCondition(n);\n\n    // Set the negative side to a script node with a large length.\n    mc.negative = new Node(Token.SCRIPT, \"\");\n    mc.negative.setLength(Integer.MAX_VALUE);\n\n    // Return the MinimizedCondition object.\n    return mc;\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(n, new Token.SCRIPT(n.getStart(), n.getEnd()));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(n, new Token.SCRIPT(n.getBegin(), n.getEnd(), 1000000));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MinimizedCondition mc = new MinimizedCondition(n);\n    mc.setNegative(new Token(Token.SCRIPT, \"unoptimized\", 1000000000));\n    return mc;\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  MinimizedCondition mc = new MinimizedCondition(n);\n  mc.negative = new Token(Token.SCRIPT, \"unreasonably long\");\n  return mc;\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        enumSet.add(value);\n    }\n    return processBitVectors(enumSet);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an Enum\");\n    }\n    final E[] constants = enumClass.getEnumConstants();\n    final int enumSize = constants.length;\n    final int[] enumBits = new int[enumSize];\n    for (int i = 0; i < enumSize; i++) {\n        enumBits[i] = 1 << i;\n    }\n    final List<Long> bitVectors = new ArrayList<>();\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The Enum values must not be null\");\n        }\n        long bitVector = 0;\n        for (final E constant : constants) {\n            if (value == constant) {\n                bitVector |= enumBits[constant.ordinal()];\n            }\n        }\n        bitVectors.add(bitVector);\n    }\n    final long[] result = new long[bitVectors.size()];\n    for (int i = 0; i < bitVectors.size(); i++) {\n        result[i] = bitVectors.get(i);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    // TODO: Complete this method\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class must be an enum\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final E[] constants = enumClass.getEnumConstants();\n    final long[] bitVectors = new long[constants.length / Long.SIZE + 1];\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        final int index = value.ordinal();\n        final int arrayIndex = index / Long.SIZE;\n        final int bitIndex = index % Long.SIZE;\n        bitVectors[arrayIndex] |= 1L << bitIndex;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final Enum<?>[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(enumClass + \" does not represent an enum type\");\n    }\n    final long[] bitVectors = new long[enumConstants.length / 64 + 1];\n    int bitVectorIndex = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        final int index = value.ordinal();\n        if (index < 0 || index >= bitVectors.length * 64) {\n            throw new IllegalArgumentException(\"Enumeration \" + enumClass.getName() + \" does not contain value \" + value);\n        }\n        bitVectors[bitVectorIndex] |= 1L << index;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The Iterable of values must not contain null\");\n        }\n        enumSet.add(value);\n    }\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int arraySize = (enumSize + 63) / 64;\n    final long[] result = new long[arraySize];\n    int i = 0;\n    for (final E value : enumSet) {\n        final int ordinal = value.ordinal();\n        if (ordinal >= enumSize) {\n            throw new IllegalArgumentException(\"An Enum value was not in the specified Enum\");\n        }\n        result[i] |= 1L << ordinal;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumUtils.BitField<E> bitField = EnumUtils.BitField.from(enumClass);\n    final long[] bitVectors = new long[bitField.getVectorLength()];\n    for (final E value : values) {\n        bitField.set(bitVectors, value);\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    // Validate parameters\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    // Ensure that the class is an enum\n    if (enumClass.isEnum() == false) {\n        throw new IllegalArgumentException(\"The class must be an Enum\");\n    }\n    // Ensure that all values are valid\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n    }\n    // Create the array\n    final long[] bitVectors = new long[((enumClass.getEnumConstants().length - 1) / Long.SIZE) + 1];\n    // Set the bits\n    for (final E value : values) {\n        final int index = value.ordinal();\n        final int bit = 1 << index;\n        final int longIndex = index / Long.SIZE;\n        final long mask = bitVectors[longIndex];\n        bitVectors[longIndex] = mask | bit;\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The class must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final E[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null) {\n        throw new IllegalArgumentException(\"The class is not an enum\");\n    }\n    final int size = enumConstants.length;\n    final int longSize = (size + Long.SIZE - 1) / Long.SIZE;\n    final long[] result = new long[longSize];\n    int index = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        final int valueIndex = value.ordinal();\n        if (valueIndex < 0 || valueIndex >= size) {\n            throw new IllegalArgumentException(\"The value \" + value + \" does not belong to the enum \" + enumClass);\n        }\n        result[index] |= 1L << valueIndex;\n        index++;\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    final int enumSize = enumClass.getEnumConstants().length;\n    final int longSize = (enumSize + 63) / 64;\n    final long[] result = new long[longSize];\n    int index = 0;\n    for (final E value : values) {\n        final int valueIndex = value.ordinal();\n        if (valueIndex < 0 || valueIndex >= enumSize) {\n            throw new IllegalArgumentException(String.format(\"Enumeration value out of range: %s\", value));\n        }\n        result[index] |= 1L << valueIndex;\n        if (++index >= longSize) {\n            index = 0;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter old = partialConverters.put(converter.getClass(), converter);\n    if (old != null && old != converter) {\n        partialConverters.put(converter.getClass(), old);\n    }\n    return old;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter replaced = null;\n        for (int i = 0; i < partialConverters.size(); i++) {\n            PartialConverter current = partialConverters.get(i);\n            if (current.getClass().equals(converter.getClass())) {\n                replaced = current;\n                partialConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            partialConverters.add(converter);\n        }\n        return replaced;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converter.getClass() == null) {\n            throw new IllegalArgumentException(\"converter.getClass() == null\");\n        }\n        PartialConverter old = (PartialConverter) partialConverters.put(converter.getClass(), converter);\n        return old;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    // Check for an exact match\n    PartialConverter existing = partialConverters.get(converter);\n    if (existing != null) {\n        return existing;\n    }\n    // Check for a match on the source type\n    existing = partialConverters.get(converter.getSourceType());\n    if (existing != null) {\n        return existing;\n    }\n    // Check for a match on the target type\n    existing = partialConverters.get(converter.getTargetType());\n    if (existing != null) {\n        return existing;\n    }\n    // Check for a match on the target type hierarchy\n    Class<?> targetType = converter.getTargetType();\n    for (Class<?> type : partialConverters.keySet()) {\n        if (targetType.isAssignableFrom(type)) {\n            return partialConverters.get(type);\n        }\n    }\n    // No match found, add the converter\n    partialConverters.put(converter, converter);\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        if (converters == null) {\n            converters = new ArrayList<PartialConverter>();\n        }\n        PartialConverter replaced = null;\n        for (int i = 0; i < converters.size(); i++) {\n            PartialConverter conv = converters.get(i);\n            if (conv.equals(converter)) {\n                replaced = conv;\n                converters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            converters.add(converter);\n        }\n        return replaced;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter replaced = null;\n        for (int i = 0; i < partialConverters.size(); i++) \n        {\n            PartialConverter partialConverter = partialConverters.get(i);\n            if (partialConverter.getClass().equals(converter.getClass())) \n            {\n                replaced = partialConverter;\n                partialConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) \n        {\n            partialConverters.add(converter);\n        }\n        return replaced;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    // check for exact match\n    for (int i = 0; i < converters.size(); i++) {\n        PartialConverter current = converters.get(i);\n        if (current.equals(converter)) {\n            return current;\n        }\n    }\n    // check for match by type\n    for (int i = 0; i < converters.size(); i++) {\n        PartialConverter current = converters.get(i);\n        if (current.getClass().isInstance(converter)) {\n            PartialConverter old = current;\n            converters.set(i, converter);\n            return old;\n        }\n    }\n    // add to list\n    converters.add(converter);\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) \n        {\n            return null;\n        }\n        // check if converter is already in the set\n        PartialConverter old = null;\n        for (PartialConverter conv : partialConverters) \n        {\n            if (conv.equals(converter)) \n            {\n                old = conv;\n                break;\n            }\n        }\n        if (old == null) \n        {\n            partialConverters.add(converter);\n        } \n        else \n        {\n            partialConverters.remove(old);\n            partialConverters.add(converter);\n        }\n        return old;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter old = partialConverters.put(converter.getClass(), converter);\n    return old == null ? null : old;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter replaced = null;\n        for (int i = 0; i < partialConverters.size(); i++) {\n            PartialConverter current = partialConverters.get(i);\n            if (current.getClass().equals(converter.getClass())) {\n                replaced = current;\n                partialConverters.set(i, converter);\n                break;\n            }\n        }\n        if (replaced == null) {\n            partialConverters.add(converter);\n        }\n        return replaced;\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int lexicalScopeDepth = 0;\n  while (scope.getScopeType() != SymbolScope.ScopeType.LEXICAL) \n  {\n    if (scope.getScopeType() == SymbolScope.ScopeType.PROPERTY) \n    {\n      lexicalScopeDepth++;\n    }\n    scope = scope.getParentScope();\n  }\n  return lexicalScopeDepth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null) {\n        if (scope.getScopeType() == SymbolScope.ScopeType.LEXICAL) {\n            return depth + scope.getDepth();\n        }\n        depth++;\n        scope = scope.getParent();\n    }\n    return 0;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null && !(scope instanceof LexicalScope)) {\n        if (scope instanceof PropertyScope) {\n            depth++;\n        }\n        scope = scope.getParentScope();\n    }\n    if (scope instanceof LexicalScope) {\n        depth += ((LexicalScope)scope).getDepth();\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope instanceof LexicalScope) {\n    return scope.getDepth();\n  } else if (scope instanceof PropertyScope) {\n    return scope.getDepth() + getLexicalScopeDepth(scope.getParent());\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (scope != null) {\n    if (scope instanceof LexicalScope) {\n      return depth + scope.getDepth();\n    } else if (scope instanceof PropertyScope) {\n      depth++;\n    }\n    scope = scope.getParent();\n  }\n  return 0;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int lexicalDepth = 0;\n  int propertyDepth = 0;\n  while (scope != null) {\n    if (scope.getScopeType() == SymbolScope.ScopeType.LEXICAL) {\n      lexicalDepth = scope.getDepth();\n    } else if (scope.getScopeType() == SymbolScope.ScopeType.PROPERTY) {\n      propertyDepth++;\n    }\n    scope = scope.getParent();\n  }\n  return lexicalDepth + propertyDepth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int lexicalScopeDepth = 0;\n  while (scope.getType() != SymbolScope.Type.LEXICAL) {\n    if (scope.getType() == SymbolScope.Type.PROPERTY) {\n      lexicalScopeDepth++;\n    }\n    scope = scope.getParent();\n  }\n  return lexicalScopeDepth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (scope != null && !(scope instanceof LexicalScope)) {\n        if (scope instanceof PropertyScope) {\n            depth += ((PropertyScope) scope).getLexicalScopeDepth();\n        }\n        scope = scope.getParentScope();\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (scope.getType() != SymbolScope.Type.LEXICAL) {\n    if (scope.getType() == SymbolScope.Type.PROPERTY) {\n      depth++;\n    }\n    scope = scope.getParent();\n  }\n  return depth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int lexicalScopeDepth = 0;\n    if (scope.isLexicalScope()) {\n        lexicalScopeDepth = scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getLexicalScope();\n        lexicalScopeDepth = lexicalScope.getDepth() + 1;\n    }\n    return lexicalScopeDepth;\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int nRows = rawData.length;\n        final int nCols = rawData[0].length;\n        final int nBlocks = (nRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int nBlocksCols = (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final double[][] blocksData = new double[nBlocks][];\n        for (int iBlock = 0; iBlock < nBlocks; ++iBlock) {\n            final int iOffset = iBlock * BLOCK_SIZE;\n            final int iSize = FastMath.min(BLOCK_SIZE, nRows - iOffset);\n            final double[][] block = new double[iSize][];\n            for (int jBlock = 0; jBlock < nBlocksCols; ++jBlock) {\n                final int jOffset = jBlock * BLOCK_SIZE;\n                final int jSize = FastMath.min(BLOCK_SIZE, nCols - jOffset);\n                final double[] blockJ = new double[iSize * jSize];\n                int k = 0;\n                for (int i = 0; i < iSize; ++i) {\n                    final double[] rawDataI = rawData[iOffset + i];\n                    System.arraycopy(rawDataI, jOffset, blockJ, k, jSize);\n                    k += jSize;\n                }\n                block[jBlock] = blockJ;\n            }\n            blocksData[iBlock] = block;\n        }\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // get rows and columns\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n\n    // check dimensions\n    for (int r = 0; r < nRows; ++r) {\n        if (rawData[r].length != nCols) {\n            throw new DimensionMismatchException(nCols, rawData[r].length);\n        }\n    }\n\n    // compute number of blocks\n    final int nBlockRows = (nRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int nBlockCols = (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create output array\n    final double[][] out = new double[nBlockRows][];\n    for (int r = 0; r < nBlockRows; ++r) {\n        out[r] = new double[nBlockCols * BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    // copy raw data in output array\n    for (int r = 0; r < nRows; ++r) {\n        final int blockRow = r / BLOCK_SIZE;\n        final int rowInBlock = r % BLOCK_SIZE;\n        for (int c = 0; c < nCols; ++c) {\n            final int blockCol = c / BLOCK_SIZE;\n            final int colInBlock = c % BLOCK_SIZE;\n            out[blockRow][blockCol * BLOCK_SIZE * BLOCK_SIZE + rowInBlock * BLOCK_SIZE + colInBlock] = rawData[r][c];\n        }\n    }\n\n    return out;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // Check dimensions.\n    final int n = rawData.length;\n    final int m = rawData[0].length;\n    for (int i = 0; i < n; ++i) {\n        if (rawData[i].length != m) {\n            throw new DimensionMismatchException(n, m, rawData[i].length);\n        }\n    }\n\n    // Allocate the data array in blocks layout.\n    final int blockSize = BLOCK_SIZE;\n    final int nBlocks = (n + blockSize - 1) / blockSize;\n    final int mBlocks = (m + blockSize - 1) / blockSize;\n    final double[][] data = new double[nBlocks * mBlocks][];\n    for (int iBlock = 0; iBlock < nBlocks; ++iBlock) {\n        for (int jBlock = 0; jBlock < mBlocks; ++jBlock) {\n            final int i0 = iBlock * blockSize;\n            final int j0 = jBlock * blockSize;\n            final int i1 = FastMath.min(n, i0 + blockSize);\n            final int j1 = FastMath.min(m, j0 + blockSize);\n            final int size = (i1 - i0) * (j1 - j0);\n            data[iBlock * mBlocks + jBlock] = new double[size];\n        }\n    }\n\n    // Copy the input array in the output array.\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            final int iBlock = i / blockSize;\n            final int jBlock = j / blockSize;\n            final int i0 = iBlock * blockSize;\n            final int j0 = jBlock * blockSize;\n            final int index = (i - i0) * (j1 - j0) + (j - j0);\n            data[iBlock * mBlocks + jBlock][index] = rawData[i][j];\n        }\n    }\n\n    return data;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // check rawData dimensions\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    for (int r = 1; r < nRows; ++r) {\n        if (rawData[r].length != nCols) {\n            throw new DimensionMismatchException(nCols, rawData[r].length);\n        }\n    }\n\n    // compute the number of blocks\n    final int blockSize = BLOCK_SIZE;\n    final int nBlockRows = (nRows + blockSize - 1) / blockSize;\n    final int nBlockCols = (nCols + blockSize - 1) / blockSize;\n\n    // create the blocks layout\n    final double[][] blocks = new double[nBlockRows][];\n    for (int r = 0; r < nBlockRows; ++r) {\n        final int startRow = r * blockSize;\n        final int endRow = FastMath.min(nRows, startRow + blockSize);\n        final int nRowsInBlock = endRow - startRow;\n        blocks[r] = new double[nBlockCols * nRowsInBlock];\n    }\n\n    // fill the blocks\n    for (int r = 0; r < nRows; ++r) {\n        final int blockRow = r / blockSize;\n        final int rowInBlock = r % blockSize;\n        for (int c = 0; c < nCols; ++c) {\n            final int blockCol = c / blockSize;\n            final int colInBlock = c % blockSize;\n            final int index = blockCol * blockSize * nRowsInBlock + rowInBlock * blockSize + colInBlock;\n            blocks[blockRow][index] = rawData[r][c];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // extract dimensions\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    // check dimensions\n    for (int r = 0; r < nRows; ++r) {\n        if (rawData[r].length != nCols) {\n            throw new DimensionMismatchException(nCols, rawData[r].length);\n        }\n    }\n    // create the output array\n    final double[][] blocksData = new double[nRows][nCols];\n    // copy the elements\n    for (int r = 0; r < nRows; ++r) {\n        for (int c = 0; c < nCols; ++c) {\n            blocksData[r][c] = rawData[r][c];\n        }\n    }\n    // return the array\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int n = rawData.length;\n        final int m = rawData[0].length;\n        final int blockSize = (int) Math.sqrt(n);\n        final int nBlocks = (n + blockSize - 1) / blockSize;\n        final int mBlocks = (m + blockSize - 1) / blockSize;\n        final double[][] blocks = new double[nBlocks][mBlocks * blockSize];\n\n        for (int iBlock = 0; iBlock < nBlocks; ++iBlock) {\n            final int i0 = iBlock * blockSize;\n            final int i1 = i0 + blockSize;\n            final int j0 = 0;\n            final int j1 = m;\n            for (int i = i0; i < i1; ++i) {\n                for (int j = j0; j < j1; ++j) {\n                    final int index = i - i0 + (j - j0) * blockSize;\n                    blocks[iBlock][index] = rawData[i][j];\n                }\n            }\n        }\n\n        return blocks;\n\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // check dimensions\n    final int n = rawData.length;\n    final int m = rawData[0].length;\n    for (int i = 1; i < n; ++i) {\n        if (rawData[i].length != m) {\n            throw new DimensionMismatchException(n, m, rawData[i].length);\n        }\n    }\n\n    // compute number of blocks\n    final int nbRowBlocks = (n + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int nbColBlocks = (m + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create output array\n    final double[][] blocks = new double[nbRowBlocks][];\n    for (int iBlock = 0; iBlock < nbRowBlocks; ++iBlock) {\n        blocks[iBlock] = new double[nbColBlocks];\n    }\n\n    // fill output array\n    for (int iBlock = 0; iBlock < nbRowBlocks; ++iBlock) {\n        final int i0 = iBlock * BLOCK_SIZE;\n        final int i1 = FastMath.min(i0 + BLOCK_SIZE, n);\n        final int blockHeight = i1 - i0;\n        for (int jBlock = 0; jBlock < nbColBlocks; ++jBlock) {\n            final int j0 = jBlock * BLOCK_SIZE;\n            final int j1 = FastMath.min(j0 + BLOCK_SIZE, m);\n            final int blockWidth = j1 - j0;\n            int k = 0;\n            for (int i = i0; i < i1; ++i) {\n                for (int j = j0; j < j1; ++j) {\n                    blocks[iBlock][jBlock * blockHeight + k] = rawData[i][j];\n                    ++k;\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // Check dimensions.\n    final int n = rawData.length;\n    if (n == 0) {\n        return new double[0][0];\n    }\n    final int m = rawData[0].length;\n    for (int i = 1; i < n; ++i) {\n        if (rawData[i].length != m) {\n            throw new DimensionMismatchException(n, m, rawData[i].length);\n        }\n    }\n\n    // Allocate the blocks layout array.\n    final int blockSize = (int) Math.sqrt(n);\n    final int numBlocks = (n + blockSize - 1) / blockSize;\n    final double[][] blocks = new double[numBlocks][];\n\n    // Fill the blocks layout array.\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < numBlocks; ++iBlock) {\n        final int blockHeight = Math.min(blockSize, n - iBlock * blockSize);\n        final int blockWidth = Math.min(blockSize, m - iBlock * blockSize);\n        blocks[blockIndex] = new double[blockHeight * blockWidth];\n        for (int i = 0; i < blockHeight; ++i) {\n            final int iOffset = iBlock * blockSize + i;\n            for (int j = 0; j < blockWidth; ++j) {\n                final int jOffset = iOffset * m + j;\n                blocks[blockIndex][i * blockWidth + j] = rawData[iOffset][jOffset];\n            }\n        }\n        ++blockIndex;\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        // get rows and columns\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n\n        // check dimensions\n        for (int r = 0; r < rows; ++r) {\n            if (rawData[r].length != columns) {\n                throw new DimensionMismatchException(columns, rawData[r].length);\n            }\n        }\n\n        // compute blocks layout\n        final int blockSize = BLOCK_SIZE;\n        final int blockRows = (rows + blockSize - 1) / blockSize;\n        final int blockColumns = (columns + blockSize - 1) / blockSize;\n        final double[][] blocks = new double[blockRows][];\n        for (int r = 0; r < blockRows; ++r) {\n            final int startRow = r * blockSize;\n            final int endRow = FastMath.min(startRow + blockSize, rows);\n            final int rowLength = endRow - startRow;\n            blocks[r] = new double[blockColumns * rowLength];\n            for (int c = 0; c < blockColumns; ++c) {\n                final int startColumn = c * blockSize;\n                final int endColumn = FastMath.min(startColumn + blockSize, columns);\n                final int columnLength = endColumn - startColumn;\n                for (int i = 0; i < rowLength; ++i) {\n                    blocks[r][c * rowLength + i] = rawData[startRow + i][startColumn + i];\n                }\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int nRows = rawData.length;\n    final int nCols = rawData[0].length;\n    final int nBlocks = (nRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int nBlocksCols = (nCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[nBlocks][];\n    for (int iBlock = 0; iBlock < nBlocks; ++iBlock) {\n        final int iOffset = iBlock * BLOCK_SIZE;\n        final int iEnd = JdkMath.min(iOffset + BLOCK_SIZE, nRows);\n        final int blockLength = (iEnd - iOffset) * nCols;\n        final double[] block = new double[blockLength];\n        blocks[iBlock] = block;\n        for (int i = iOffset; i < iEnd; ++i) {\n            final double[] rawRow = rawData[i];\n            System.arraycopy(rawRow, 0, block, (i - iOffset) * nCols, nCols);\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values, 0L);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (values == null) \n    {\n        throw new NullPointerException(\"The Iterable of enum values must not be null\");\n    }\n    final long[] bitVectors = generateBitVectors(enumClass, values);\n    if (bitVectors.length > 1) \n    {\n        throw new IllegalArgumentException(\"The Iterable of enum values must not contain more than 64 values\");\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    // TODO: Implement this method\n    return 0;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values, false);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values).longValue();\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return EnumUtils.generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    // TODO: Add code here\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return EnumUtils.generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values).values().iterator().next();\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    // TODO: Complete this method\n    return 0;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isZero()) return Dfp.ONE;\n    if (a.isOne()) return Dfp.E;\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    int n = 1;\n    while (term.abs().compareTo(Dfp.SMALLEST_VALUE) > 0) {\n        result = result.add(term);\n        term = a.pow(n);\n        term = term.divide(n);\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp x2 = x.multiply(x);\n    Dfp x3 = x2.multiply(x);\n    Dfp x4 = x3.multiply(x);\n    Dfp x5 = x4.multiply(x);\n    Dfp x6 = x5.multiply(x);\n    Dfp x7 = x6.multiply(x);\n    Dfp x8 = x7.multiply(x);\n    Dfp x9 = x8.multiply(x);\n    Dfp x10 = x9.multiply(x);\n    Dfp x11 = x10.multiply(x);\n    Dfp x12 = x11.multiply(x);\n    Dfp x13 = x12.multiply(x);\n    Dfp x14 = x13.multiply(x);\n    Dfp x15 = x14.multiply(x);\n    Dfp x16 = x15.multiply(x);\n    Dfp x17 = x16.multiply(x);\n    Dfp x18 = x17.multiply(x);\n    Dfp x19 = x18.multiply(x);\n    Dfp x20 = x19.multiply(x);\n    Dfp x21 = x20.multiply(x);\n    Dfp x22 = x21.multiply(x);\n    Dfp x23 = x22.multiply(x);\n    Dfp x24 = x23.multiply(x);\n    Dfp x25 = x24.multiply(x);\n    Dfp x26 = x25.multiply(x);\n    Dfp x27 = x26.multiply(x);\n    Dfp x28 = x27.multiply(x);\n    Dfp x29 = x28.multiply(x);\n    Dfp x30 = x29.multiply(x);\n    Dfp x31 = x30.multiply(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    int n = 1;\n    while (term.abs().compareTo(Dfp.SQRT_EPSILON) > 0) {\n        result = result.add(term);\n        term = term.multiply(a.divide(new Dfp(n)));\n        ++n;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isZero()) {\n        return Dfp.ONE;\n    }\n    Dfp result = Dfp.ONE;\n    Dfp x = a;\n    Dfp factorial = Dfp.ONE;\n    for (int i = 1; i < 100; i++) {\n        factorial = factorial.multiply(i);\n        result = result.add(x.divide(factorial));\n        x = x.multiply(a);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    int n = 1;\n    while (term.abs().compareTo(Dfp.ONE) > 0) {\n        result = result.add(term);\n        term = a.pow(n).divide(DfpMath.factorial(n));\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp result = Dfp.ONE;\n    int i = 1;\n    while (x.abs().compareTo(Dfp.ONE) > 0) {\n        result = result.add(x.divide(new Dfp(i++)));\n        x = x.multiply(a);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.abs().compareTo(Dfp.ONE) > 0) {\n        throw new IllegalArgumentException(\"Illegal argument\");\n    }\n    Dfp retval = Dfp.ONE;\n    Dfp term = a;\n    int n = 1;\n    while (term.abs().compareTo(Dfp.ONE) > 0) {\n        retval = retval.add(term);\n        term = term.multiply(a.divide(Dfp.valueOf(n++)));\n    }\n    return retval;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = Dfp.ONE;\n    Dfp term = a;\n    int n = 1;\n    while (term.abs() > Dfp.SMALL) {\n        result = result.add(term);\n        term = a.pow(n);\n        term = term.divide(n);\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp sum = new Dfp(1);\n    Dfp term = new Dfp(1);\n    Dfp factorial = new Dfp(1);\n    int i = 1;\n    while (term.abs() > term.ulp()) {\n        term = a.pow(i).divide(factorial);\n        sum = sum.add(term);\n        factorial = factorial.multiply(++i);\n    }\n    return sum;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = new Dfp(1);\n    Dfp term = new Dfp(1);\n    int n = 1;\n    while (term.abs() > 1e-15) {\n        term = a.pow(n).divide(new Dfp(n));\n        result = result.add(term);\n        n++;\n    }\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute the norm of the instance\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    // return the vector orthogonal to the instance\n    return new FieldVector3D<>(getField(), getY().negate(), getX(), getZ().negate());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute the norm of the instance\n    final T norm = getNorm();\n\n    // select one of the two possible orthogonal vectors\n    final T x = getX();\n    final T y = getY();\n    final T z = getZ();\n    final T absX = x.abs();\n    final T absY = y.abs();\n    final T absZ = z.abs();\n    final T max = absX.max(absY).max(absZ);\n    if (max.getReal() == absX.getReal()) {\n        // the instance and its orthogonal vector have the same x coordinate\n        return new FieldVector3D<>(y.negate(), z.negate(), x);\n    } else if (max.getReal() == absY.getReal()) {\n        // the instance and its orthogonal vector have the same y coordinate\n        return new FieldVector3D<>(z.negate(), x, y);\n    } else {\n        // the instance and its orthogonal vector have the same z coordinate\n        return new FieldVector3D<>(x.negate(), y.negate(), z);\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedGeometryFormats.NORM_OF_VECTOR_IS_NULL);\n    }\n    return new FieldVector3D<T>(getX().divide(norm),\n                                getY().divide(norm),\n                                getZ().divide(norm));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedGeometryFormats.NORM_OF_VECTOR_IS_ZERO);\n    }\n    return new FieldVector3D<T>(getField().getOne().subtract(getZ().multiply(getZ())).divide(norm),\n                                getZ().multiply(getY()).subtract(getX().multiply(getZ())).divide(norm),\n                                getX().multiply(getZ()).subtract(getY().multiply(getY())).divide(norm));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T x = this.getX();\n    final T y = this.getY();\n    final T z = this.getZ();\n    T n = this.getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedGeometryFormats.NORM_ZERO);\n    }\n    T one = n.getField().getOne();\n    T zero = n.getField().getZero();\n    if (x.getReal() == 0) {\n        if (y.getReal() == 0) {\n            if (z.getReal() == 0) {\n                throw new MathArithmeticException(LocalizedGeometryFormats.NORM_ZERO);\n            } else {\n                return new FieldVector3D<T>(zero, zero, n);\n            }\n        } else {\n            return new FieldVector3D<T>(zero, n, zero);\n        }\n    } else {\n        if (y.getReal() == 0) {\n            return new FieldVector3D<T>(n, zero, zero);\n        } else {\n            T invNorm = n.reciprocal();\n            T x2 = x.multiply(invNorm);\n            T y2 = y.multiply(invNorm);\n            T z2 = z.multiply(invNorm);\n            return new FieldVector3D<T>(y2.negate(), z2.negate(), x2);\n        }\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final double x = this.getX();\n    final double y = this.getY();\n    final double z = this.getZ();\n\n    double a = 0;\n    double b = 0;\n    double c = 0;\n    if (x != 0) {\n        a = 1;\n        b = -x/y;\n        c = -x/z;\n    } else if (y != 0) {\n        a = 1;\n        b = -y/x;\n        c = -y/z;\n    } else if (z != 0) {\n        a = 1;\n        b = -z/x;\n        c = -z/y;\n    } else {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n\n    final double invNorm = 1.0 / Math.sqrt(a*a + b*b + c*c);\n    return new FieldVector3D<>(a * invNorm, b * invNorm, c * invNorm);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final double norm = getNorm();\n    if (norm == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<>(getX().divide(norm), getY().divide(norm), getZ().divide(norm));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedGeometryFormats.NORM_IS_ZERO_CANNOT_NORMALIZE);\n    }\n\n    final T invNorm = norm.reciprocal();\n    final T x = getX().multiply(invNorm);\n    final T y = getY().multiply(invNorm);\n    final T z = getZ().multiply(invNorm);\n\n    return new FieldVector3D<>(x, y, z);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T x = getX();\n    T y = getY();\n    T z = getZ();\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<>(x.multiply(y.multiply(y).add(z.multiply(z))),\n                               y.multiply(x.multiply(x).add(z.multiply(z))),\n                               x.multiply(x).add(y.multiply(y)).subtract(z.multiply(z)).multiply(z));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedCoreFormats.CANNOT_NORMALIZE_A_NULL_VECTOR);\n    }\n    final T invNorm = norm.reciprocal();\n    final T x = getX().multiply(invNorm);\n    final T y = getY().multiply(invNorm);\n    final T z = getZ().multiply(invNorm);\n    return new FieldVector3D<>(x, y, z);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T start = getStart().compareTo(other.getStart()) <= 0 ? other.getStart() : getStart();\n    final T end = getEnd().compareTo(other.getEnd()) >= 0 ? other.getEnd() : getEnd();\n    return new Range<>(start, end);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other must not be null\");\n    }\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    final T min = getMin().compareTo(other.getMin()) <= 0 ? getMin() : other.getMin();\n    final T max = getMax().compareTo(other.getMax()) >= 0 ? getMax() : other.getMax();\n    return new Range<T>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!this.overlaps(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (this.equals(other)) \n    {\n        return this;\n    }\n    final T start = this.getStart().compareTo(other.getStart()) <= 0 ? this.getStart() : other.getStart();\n    final T end = this.getEnd().compareTo(other.getEnd()) >= 0 ? this.getEnd() : other.getEnd();\n    return new Range<T>(start, end);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other range must not be null\");\n    }\n    if (this.isOverlappedBy(other) == false) {\n        throw new IllegalArgumentException(\"ranges must overlap\");\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    T lower = this.getLower();\n    T upper = this.getUpper();\n    if (other.getLower().compareTo(lower) > 0) {\n        lower = other.getLower();\n    }\n    if (other.getUpper().compareTo(upper) < 0) {\n        upper = other.getUpper();\n    }\n    return new Range<T>(lower, upper);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other must not be null\");\n    }\n    if (other.getMaximum().compareTo(this.getMinimum()) < 0 || other.getMinimum().compareTo(this.getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"other must overlap this\");\n    }\n    if (other.equals(this)) {\n        return this;\n    }\n    final T min = other.getMinimum().compareTo(this.getMinimum()) < 0 ? other.getMinimum() : this.getMinimum();\n    final T max = other.getMaximum().compareTo(this.getMaximum()) > 0 ? other.getMaximum() : this.getMaximum();\n    return new Range<T>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Cannot calculate intersection with null range\");\n    }\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Cannot calculate intersection with non-overlapping range\");\n    }\n    return new Range<>(\n        Math.max(lowerEndpoint(), other.lowerEndpoint()),\n        Math.min(upperEndpoint(), other.upperEndpoint()));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return new Range<>(\n            (this.getMin().compareTo(other.getMin()) <= 0) ? this.getMin() : other.getMin(),\n            (this.getMax().compareTo(other.getMax()) >= 0) ? this.getMax() : other.getMax()\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return new Range<T>(\n        max(getMinimum(), other.getMinimum()),\n        min(getMaximum(), other.getMaximum())\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    T lower = null;\n    if (other.lowerEndpoint().compareTo(lowerEndpoint()) <= 0) {\n        lower = other.lowerEndpoint();\n    } else {\n        lower = lowerEndpoint();\n    }\n    T upper = null;\n    if (other.upperEndpoint().compareTo(upperEndpoint()) >= 0) {\n        upper = other.upperEndpoint();\n    } else {\n        upper = upperEndpoint();\n    }\n    return new Range<T>(lower, upper);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!overlaps(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap.\");\n    }\n    return new Range<T>(\n        (Comparable<T>) Math.max(this.lowerEndpoint(), other.lowerEndpoint()),\n        (Comparable<T>) Math.min(this.upperEndpoint(), other.upperEndpoint()));\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _encoding, _features, _objectCodec, _objectCodec.getDateFormat(), _objectCodec.getBase64Variant());\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, this, _charBuffer, _byteBuffer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _charset);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new JsonGenerator(out, ctxt, _encoding, _features);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        if (!type.getComponentType().isPrimitive()) \n        {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        throw new IllegalArgumentException(\"Unknown primitive type: \" + type.getComponentType());\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n    if (Enum.class.isAssignableFrom(type)) {\n        return ((Enum) o1).ordinal() == ((Enum) o2).ordinal();\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        if (!type.getComponentType().isPrimitive()) {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        throw new IllegalArgumentException(\"Unknown primitive type\");\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isPrimitive()) {\n        return primitiveEquals(type, o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        return arrayEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isPrimitive()) \n    {\n        return primitiveEquals(type, o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        if (!type.getComponentType().isPrimitive()) {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        throw new IllegalArgumentException(\"Invalid primitive type \" + type.getComponentType());\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        if (!type.getComponentType().isPrimitive()) \n        {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        if (!type.getComponentType().isPrimitive()) \n        {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n        throw new IllegalArgumentException(\"Invalid primitive type for array\");\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        if (!type.getComponentType().isPrimitive()) \n        {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        if (!type.getComponentType().isPrimitive()) \n        {\n            return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n        }\n        if (int.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((int[]) o1, (int[]) o2);\n        }\n        if (byte.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((byte[]) o1, (byte[]) o2);\n        }\n        if (char.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((char[]) o1, (char[]) o2);\n        }\n        if (long.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((long[]) o1, (long[]) o2);\n        }\n        if (float.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((float[]) o1, (float[]) o2);\n        }\n        if (double.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((double[]) o1, (double[]) o2);\n        }\n        if (boolean.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n        }\n        if (short.class.equals(type.getComponentType())) \n        {\n            return Arrays.equals((short[]) o1, (short[]) o2);\n        }\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  }\n  else if (type.isUnionType()) \n  {\n    UnionType unionType = type.toMaybeUnionType();\n    ImmutableList<JSType> alternates = unionType.getAlternates();\n    ImmutableList<JSType> filteredAlternates = alternates.stream()\n      .map(JSTypeUtils::filterNoResolvedType)\n      .collect(toImmutableList());\n    return JSType.join(filteredAlternates);\n  }\n  else \n  {\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return null;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return null;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  } \n  else \n  {\n    return type.getGreatestSubtype(type);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isUnionType()) {\n    JSType filtered = type.toMaybeUnionType().filterNoResolvedType();\n    if (filtered.isNoResolvedType()) {\n      return filtered;\n    }\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    if (type.isUnionType()) {\n        JSType filtered = JSType.join(type.getUnionMembers());\n        if (filtered.isNoResolvedType()) {\n            return filtered;\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getLeastSupertype(type);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n    else \n    {\n        return type.restrictByNotNullOrUndefined();\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    if (type.isUnionType()) {\n        UnionType union = type.toMaybeUnionType();\n        if (union.getAlternates().stream().allMatch(JSType::isNoResolvedType)) {\n            return typeRegistry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n        }\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      restrictedType = originalType;\n    }\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      if (!blindScope.isDeclared(name, false)) {\n        return blindScope;\n      }\n      if (blindScope.isNamespace(name)) {\n        return blindScope;\n      }\n      if (restrictedType.isSubtypeOf(blindScope.getDeclaredTypeOf(name))) {\n        return blindScope;\n      }\n      return blindScope.inferSlotType(name, restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    Preconditions.checkArgument(restrictedType.isNominalType());\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isNominalType(),\n        \"Checked unknown type should not be nominal\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isUnionType(),\n        \"Checked unknown type should not be union\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isFunctionType(),\n        \"Checked unknown type should not be function\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isRecordType(),\n        \"Checked unknown type should not be record\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isTemplateType(),\n        \"Checked unknown type should not be template\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isTypeVariable(),\n        \"Checked unknown type should not be type variable\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isEnumElementType(),\n        \"Checked unknown type should not be enum element\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isTypeOfType(),\n        \"Checked unknown type should not be type of\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isAllType(),\n        \"Checked unknown type should not be all\");\n    Preconditions.checkArgument(\n        !restrictedType.isCheckedUnknownType()\n            || !restrictedType.isNoType(),\n        \"Checked unknown type should not be no\");\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      return blindScope.inferSlotType(node.getQualifiedName(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      restrictedType = originalType;\n    }\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      JSType oldType = blindScope.getSlot(name).getType();\n      if (oldType == null || !oldType.isSubtypeOf(restrictedType)) {\n        return blindScope.inferSlotType(name, restrictedType);\n      }\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || !restrictedType.isName()) {\n      return blindScope;\n    }\n\n    if (originalType == null || !originalType.isName()) {\n      return blindScope;\n    }\n\n    if (originalType.equals(restrictedType)) {\n      return blindScope;\n    }\n\n    return blindScope.inferSlotType(node.getQualifiedName(), restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      return blindScope.inferSlotType(node.getString(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      // Create a new flow scope with the restricted type.\n      return blindScope.inferSlotType(node.getQualifiedName(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      return blindScope.inferSlotType(node.getString(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n    if (node.isName()) {\n      String name = node.getString();\n      FlowScope newScope = blindScope.createChildFlowScope();\n      newScope.inferSlotType(name, restrictedType);\n      return newScope;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.equals(originalType)) {\n      return blindScope;\n    }\n\n    Preconditions.checkState(\n        node.isName(), \"Cannot restrict non-name node %s\", node);\n    Preconditions.checkState(\n        !restrictedType.isCheckedUnknownType(),\n        \"Cannot restrict to checked unknown type\");\n\n    return blindScope.inferSlotType(node.getString(), restrictedType);\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node node = new Node(token);\n    node.addChild(parseTypeParameters(token));\n    node.addChild(parseParametersType(token));\n    node.addChild(parseResultType(token));\n    return node;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  // Parse the function signature\n  // and store the function type\n  // in the token\n  //\n  // The function signature\n  // should be in the format\n  // of \"function(param1:type, param2:type):type\"\n  //\n  // The function type should\n  // be stored in the token\n  // as a FunctionType object\n  //\n  // For example, the function\n  // signature \"function(a:number, b:number):number\"\n  // should be parsed and stored\n  // as a FunctionType object\n  // in the token\n  //\n  // The FunctionType object\n  // should have the following\n  // properties:\n  //\n  // - parameters: an array of\n  //   ParameterType objects\n  // - result: a ResultType object\n  //\n  // The ParameterType object\n  // should have the following\n  // properties:\n  //\n  // - name: the name of the parameter\n  // - type: a TypeName object\n  //\n  // The ResultType object\n  // should have the following\n  // properties:\n  //\n  // - type: a TypeName object\n  //\n  // The TypeName object\n  // should have the following\n  // properties:\n  //\n  // - name: the name of the type\n  // - parameters: an array of\n  //   TypeName objects\n  //\n  // For example, the function\n  // signature \"function(a:Array<number>):number\"\n  // should be parsed and stored\n  // as a FunctionType object\n  // in the token\n  //\n  // The FunctionType object\n  // should have the following\n  // properties:\n  //\n  // - parameters: an array of\n  //   ParameterType objects\n  // - result: a ResultType object\n  //\n  // The ParameterType object\n  // should have the following\n  // properties:\n  //\n  // - name: \"a\"\n  // - type: an ArrayType object\n  //\n  // The ArrayType object\n  // should have the following\n  // properties:\n  //\n  // - type: a TypeName object\n  //\n  // The TypeName object\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = new Node(token);\n    functionType.addChild(parseTypeParameters());\n    functionType.addChild(parseFunctionSignatureType());\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = new Node(token);\n  functionType.addChild(parseTypeParameters(token));\n  functionType.addChild(parseFunctionSignature(token));\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = new Node(NodeType.FUNCTION_TYPE);\n    functionType.addChild(parseTypeParameters(token));\n    functionType.addChild(parseParametersType(token));\n    functionType.addChild(parseResultType(token));\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node node = new Node(NodeType.FUNCTION_TYPE);\n    node.addChild(parseTypeParameters());\n    node.addChild(parseParametersType());\n    node.addChild(parseResultType());\n    return node;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node node = new Node(token.getType());\n    node.addChild(parseTypeParameters(token));\n    node.addChild(parseParametersType(token));\n    node.addChild(parseResultType(token));\n    return node;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  // parse the function signature\n  Node functionSignature = parseFunctionSignature(token);\n\n  // parse the function body\n  Node functionBody = parseFunctionBody(token);\n\n  // create a new function type node\n  Node functionType = new Node(NodeType.FUNCTION_TYPE);\n  functionType.addChild(functionSignature);\n  functionType.addChild(functionBody);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = new Node(token.type);\n    Node functionSignatureType = new Node(NodeType.FUNCTION_SIGNATURE_TYPE);\n    functionType.addChild(functionSignatureType);\n\n    if (token.type == JsDocTokenType.FUNCTION) {\n        functionType.addChild(new Node(JsDocTokenType.FUNCTION));\n    }\n\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters != null) {\n        functionSignatureType.addChild(typeParameters);\n    }\n\n    Node parametersType = parseParametersType(token);\n    if (parametersType != null) {\n        functionSignatureType.addChild(parametersType);\n    }\n\n    Node resultType = parseResultType(token);\n    if (resultType != null) {\n        functionSignatureType.addChild(resultType);\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node node = new Node(token);\n    node.addChild(parseTypeParameters(token));\n    node.addChild(parseParametersType(token));\n    node.addChild(parseResultType(token));\n    return node;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s+\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    int start = 0;\n    int end = sz - 1;\n    while (start < sz && Character.isWhitespace(str.charAt(start))) {\n        start++;\n    }\n    while (end > start && Character.isWhitespace(str.charAt(end))) {\n        end--;\n    }\n    return (start == 0 && end == sz - 1) ? str : str.substring(start, end + 1);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s+\", \"\");\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // TODO\n    return null;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    double sum = 0.0;\n    double sumsq = 0.0;\n    long count = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            count += stat.getCount();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n        }\n    }\n    return new StatisticalSummaryValues(sum, sumsq, count, min, max);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics summary = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        summary.addValue(stat.getSum());\n        summary.addValue(stat.getMin());\n        summary.addValue(stat.getMax());\n        summary.addValue(stat.getSumsq());\n        summary.addValue(stat.getN());\n    }\n    return new StatisticalSummaryValues(summary.getSum(), summary.getMin(), summary.getMax(), summary.getSumsq(), summary.getN());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n    if (statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics summary = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        summary.addValue(stat.getMean());\n        summary.addValue(stat.getVariance());\n        summary.addValue(stat.getStandardDeviation());\n        summary.addValue(stat.getSum());\n        summary.addValue(stat.getMin());\n        summary.addValue(stat.getMax());\n        summary.addValue(stat.getN());\n    }\n    return new StatisticalSummaryValues(summary.getMean(), summary.getVariance(),\n            summary.getStandardDeviation(), summary.getSum(), summary.getMin(),\n            summary.getMax(), summary.getN());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null) {\n        return null;\n    }\n    //TODO: Implement this method\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getMin());\n        aggregate.addValue(stat.getMean());\n        aggregate.addValue(stat.getStandardDeviation());\n        aggregate.addValue(stat.getVariance());\n    }\n\n    return new StatisticalSummaryValues(aggregate.getMax(), aggregate.getMin(), aggregate.getMean(),\n            aggregate.getStandardDeviation(), aggregate.getVariance());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // Compute aggregate summary statistics\n    StatisticalSummaryValues summary = new StatisticalSummaryValues();\n    for (SummaryStatistics stat : statistics) \n    {\n        summary.addValue(stat.getMean());\n        summary.addValue(stat.getStandardDeviation());\n        summary.addValue(stat.getVariance());\n        summary.addValue(stat.getSum());\n        summary.addValue(stat.getSumsq());\n        summary.addValue(stat.getCount());\n        summary.addValue(stat.getMin());\n        summary.addValue(stat.getMax());\n    }\n    return summary;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    StatisticalSummaryValues result = new StatisticalSummaryValues();\n    for (SummaryStatistics s : statistics) {\n        result.add(s.getCount());\n        result.add(s.getSum());\n        result.add(s.getMin());\n        result.add(s.getMax());\n        result.add(s.getSumsq());\n    }\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // TODO: implement this method\n    return null;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // TODO\n    return null;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return variance / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(sample1.length, 2, true);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_TTEST,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i]) - meanDifference;\n        }\n        return sum * sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_TEST,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(sample1.length, 2, true);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        double sum = 0;\n        double sumSq = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double diff = sample1[i] - sample2[i];\n            double diffSq = diff * diff;\n            sum += diff;\n            sumSq += diffSq;\n        }\n        return (sumSq - sum * sum / sample1.length) / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_TTEST,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA,\n                    sample1.length, 2, true);\n        }\n\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n\n        return sum / (sample1.length - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) \n        {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) \n        {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) \n        {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        double value = dataset.getValue(i);\n        if (value >= 0.0) \n        {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v >= 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (name == null) {\n        throw new IOException(\"Expected a name but was \" + peek());\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n    // TODO: Implement this method\n    return null;\n  }",
      "public String nextName() throws IOException  {\n    expect(JsonToken.NAME);\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    expect(JsonToken.NAME);\n    String result = getPath();\n    // Consume the token\n    peek();\n    return result;\n}",
      "public String nextName() throws IOException  {\n    expect(JsonToken.NAME);\n    String result = peekedString;\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    String name = nextString();\n    if (name == null) {\n        throw new IOException(\"Expected a name but was \" + peek());\n    }\n    return name;\n}",
      "public String nextName() throws IOException  {\n    String result = null;\n    if (hasNext()) {\n        result = nextToken.name;\n        nextToken = null;\n    }\n    return result;\n}",
      "public String nextName() throws IOException  {\n    // Your code here\n}",
      "public String nextName() throws IOException  {\n    String result = \"\";\n    int peek = peek();\n    if (peek == PEEKED_NONE) {\n        peek = doPeek();\n    }\n\n    if (peek == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (peek == PEEKED_QUOTED_NAME) {\n        result = nextQuotedValue(true);\n    } else {\n        throw new IOException(\"Expected a name but was \" + peekString());\n    }\n    return result;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b);\n    }\n\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else \n    {\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) \n        {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b);\n        }\n        return result;\n    }\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return new int[0];\n    }\n\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else \n    {\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) \n        {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (this.currentChunk == null) \n    {\n        return -1;\n    }\n\n    final int bytesRead = this.currentChunk.read(b, off, len);\n\n    if (bytesRead == -1) \n    {\n        this.currentChunk = this.chunks.poll();\n\n        if (this.currentChunk == null) \n        {\n            return -1;\n        }\n\n        return this.readOnce(b, off, len);\n    }\n\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (this.currentChunk == null) \n    {\n        return -1;\n    }\n    final int toRead = Math.min(len, this.currentChunk.length - this.currentChunkPos);\n    System.arraycopy(this.currentChunk, this.currentChunkPos, b, off, toRead);\n    this.currentChunkPos += toRead;\n    if (this.currentChunkPos == this.currentChunk.length) \n    {\n        this.currentChunk = null;\n    }\n    return toRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n\n    int read = currentChunk.read(b, off, len);\n    if (read == -1) {\n        currentChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int bytesRead = currentChunk.read(b, off, len);\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) \n    {\n        return -1;\n    }\n\n    int bytesRead = 0;\n    while (bytesRead < len) \n    {\n        if (currentChunkOffset == currentChunk.length) \n        {\n            currentChunk = null;\n            currentChunkOffset = 0;\n            break;\n        }\n\n        b[off + bytesRead] = currentChunk[currentChunkOffset];\n        currentChunkOffset++;\n        bytesRead++;\n    }\n\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n    final int chunkSize = currentChunk.length;\n    int read = 0;\n    while (read < len && chunkSize > 0) {\n        final int bytesToRead = Math.min(chunkSize, len - read);\n        System.arraycopy(currentChunk, currentChunkPos, b, off + read, bytesToRead);\n        currentChunkPos += bytesToRead;\n        chunkSize -= bytesToRead;\n        read += bytesToRead;\n    }\n    if (currentChunkPos == currentChunk.length) {\n        currentChunk = null;\n    }\n    return read == 0 ? -1 : read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n\n    int bytesRead = currentChunk.read(b, off, len);\n\n    if (bytesRead == -1) {\n        currentChunk = null;\n    }\n\n    return bytesRead;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (this.currentChunk == null) \n    {\n        return -1;\n    }\n\n    int read = 0;\n    while (read < len) \n    {\n        int chunkRead = this.currentChunk.read(b, off + read, len - read);\n        if (chunkRead == -1) \n        {\n            this.currentChunk = this.nextChunk();\n            if (this.currentChunk == null) \n            {\n                return read == 0 ? -1 : read;\n            }\n        } \n        else \n        {\n            read += chunkRead;\n        }\n    }\n\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentChunk == null) {\n        return -1;\n    }\n\n    int read = 0;\n    while (read < len) {\n        if (currentChunk.offset >= currentChunk.length) {\n            currentChunk = currentChunk.next;\n            if (currentChunk == null) {\n                return read == 0 ? -1 : read;\n            }\n        }\n\n        final int toRead = Math.min(len - read, currentChunk.length - currentChunk.offset);\n        System.arraycopy(currentChunk.buffer, currentChunk.offset, b, off + read, toRead);\n        currentChunk.offset += toRead;\n        read += toRead;\n    }\n\n    return read;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    final Node callNode = site.node;\n    final Node parent = callNode.getParent();\n    final Node grandparent = parent.getParent();\n    if (NodeUtil.isFunctionObjectCall(grandparent)) {\n      // case 1:\n      //   f.call(obj, args...)\n      //   ^\n      //   callNode\n      //   ^\n      //   func\n      //   ^\n      //   obj\n      //   ^\n      //   args...\n      final Node func = callNode.getFirstChild();\n      final Node firstArg = NodeUtil.getImmediateChild(func, 1);\n      if (firstArg.isThis()) {\n        // case 1a:\n        //   f.call(this, args...)\n        //   ^\n        //   callNode\n        //   ^\n        //   func\n        //   ^\n        //   this\n        //   ^\n        //   args...\n        return NodeUtil.getImmediateChild(callNode, argIndex + 1);\n      } else {\n        // case 1b:\n        //   f.call(obj, args...)\n        //   ^\n        //   callNode\n        //   ^\n        //   func\n        //   ^\n        //   obj\n        //   ^\n        //   args...\n        return NodeUtil.getImmediateChild(callNode, argIndex);\n      }\n    } else if (NodeUtil.isFunctionObjectApply(grandparent)) {\n      // case 2:\n      //   f.apply(obj, args...)\n      //   ^\n      //   callNode\n      //   ^\n      //   func\n      //   ^\n      //   obj\n      //   ^\n      //   args...\n      return NodeUtil.getImmediateChild(callNode, argIndex);\n    } else if (NodeUtil.isCallOrNewTarget(callNode)) {\n      // case 3:\n      //   new f(args...)\n      //   ^\n      //   callNode\n      //   ^\n      //   f\n      //   ^\n      //   args...\n      return NodeUtil.getImmediateChild(callNode, argIndex);\n}\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getDirectCallNode();\n    if (node == null) {\n        node = site.getCallNode();\n    }\n    if (node == null) {\n        node = site.getDotCallNode();\n    }\n    if (node == null) {\n        throw new IllegalStateException(\"No call node found.\");\n    }\n    if (node.isCall()) {\n        return node.getSecondChild().getChildAtIndex(argIndex);\n    } else if (node.isNew()) {\n        return node.getChildAtIndex(argIndex);\n    } else if (node.isGetProp()) {\n        return node.getFirstChild().getNext().getChildAtIndex(argIndex);\n    } else {\n        throw new IllegalStateException(\"Unexpected node type: \" + node);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node parent = site.node.getParent();\n        if (parent.isCall()) {\n            return parent.getChildAtIndex(argIndex);\n        } else if (parent.isNew()) {\n            return parent.getChildAtIndex(argIndex);\n        } else if (parent.isGetProp() && parent.getFirstChild().getString().equals(\"call\")) {\n            return parent.getNext().getNext().getChildAtIndex(argIndex);\n        } else {\n            return null;\n        }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.getInvocationSite();\n    Node parent = node.getParent();\n    if (parent.isCall()) {\n        return parent.getChildAtIndex(argIndex);\n    } else if (parent.isNew()) {\n        return parent.getChildAtIndex(argIndex);\n    } else if (parent.isGetProp() && parent.getLastChild().getString().equals(\"call\")) {\n        return parent.getChildAtIndex(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    final Node callNode = site.node;\n    final Node parent = callNode.getParent();\n    if (parent == null) {\n      return null;\n    }\n    if (parent.isCall()) {\n      return parent.getSecondChild();\n    }\n    if (parent.isNew()) {\n      return parent.getFirstChild();\n    }\n    if (parent.isGetProp() && parent.getParent().isCall()) {\n      return parent.getParent().getSecondChild();\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    Node parent = node.getParent();\n    if (parent == null) {\n        return null;\n    }\n    if (parent.isCall() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isNew() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isGetProp() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isCall() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isNew() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isGetProp() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isCall() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isNew() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isGetProp() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isCall() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isNew() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isGetProp() && node.isFirstChildOf(parent)) {\n        return parent.getChildAtIndex(argIndex + 1);\n    } else if (parent.isCall() && node.isFirstChildOf(parent)) {\n}\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node node = site.node;\n        if (node.isCall()) {\n            return node.getFirstChild().getNext().getNext().getChildAtIndex(argIndex);\n        } else if (node.isNew()) {\n            return node.getFirstChild().getNext().getChildAtIndex(argIndex);\n        } else if (node.isGetProp() && node.getFirstChild().isCall()) {\n            return node.getFirstChild().getFirstChild().getNext().getNext().getChildAtIndex(argIndex);\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.isCall()) {\n        return call.getChildAtIndex(argIndex + 1);\n    } else if (call.isNew()) {\n        return call.getFirstChild();\n    } else if (call.isGetProp() && call.getLastChild().getString().equals(\"call\")) {\n        return call.getFirstChild();\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node parent = site.getParent();\n    if (parent.isCall()) {\n        return parent.getChildAtIndex(argIndex);\n    } else if (parent.isNew()) {\n        return parent.getChildAtIndex(argIndex);\n    } else if (parent.isGetProp() && parent.getFirstChild().getString().equals(\"call\")) {\n        return parent.getParent().getChildAtIndex(argIndex);\n    } else {\n        throw new IllegalStateException(\"Unexpected node type: \" + parent.toStringTree());\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node node = site.node;\n        Node parent = node.getParent();\n        if (parent == null) {\n            return null;\n        }\n        Node grandparent = parent.getParent();\n        if (grandparent == null) {\n            return null;\n        }\n        Node greatgrandparent = grandparent.getParent();\n        if (greatgrandparent == null) {\n            return null;\n        }\n        if (greatgrandparent.isCall()) {\n            Node arg = greatgrandparent.getFirstChild();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (grandparent.isNew()) {\n            Node arg = grandparent.getFirstChild();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else if (parent.isGetProp() && parent.getParent().isCall()) {\n            Node arg = parent.getParent().getFirstChild();\n            for (int i = 0; i < argIndex; i++) {\n                arg = arg.getNext();\n            }\n            return arg;\n        } else {\n            return null;\n        }\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    // TODO: Fill this in\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) \n    {\n        return type.getDeprecationReason();\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Check if the cache contains the required entry\n    final String key = tz.getID() + daylight + style + locale.toString();\n    String name = null;\n    synchronized (cCache) {\n        name = cCache.get(key);\n    }\n    if (name == null) {\n        // Cache miss, query the TimeZone\n        name = tz.getDisplayName(daylight, style, locale);\n        // Add to cache\n        synchronized (cCache) {\n            cCache.put(key, name);\n        }\n    }\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String key = tz.getID() + locale.toString() + daylight + style;\n    String value = cache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String key = tz.getID();\n    if (daylight) {\n        key += \"s\";\n    }\n    key += locale.toString() + style;\n    String name = cDisplayNames.get(key);\n    if (name == null) {\n        name = tz.getDisplayName(daylight, style, locale);\n        cDisplayNames.put(key, name);\n    }\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = tz.getID() + daylight + style + locale.toString();\n    String name = null;\n    synchronized (cCache) {\n        name = cCache.get(key);\n        if (name == null) {\n            name = tz.getDisplayName(daylight, style, locale);\n            cCache.put(key, name);\n        }\n    }\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Get the cache key\n    final String key = tz.getID() + (daylight ? \"D\" : \"S\") + style + locale.toString();\n\n    // Lookup in cache\n    String name = CACHE.get(key);\n    if (name == null) \n    {\n        // Calculate the value from the TimeZone\n        name = tz.getDisplayName(daylight, style, locale);\n\n        // Cache the value\n        CACHE.put(key, name);\n    }\n\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Check if the cache contains the name\n    final String key = tz.getID() + daylight + style + locale.toString();\n    if (cachedTimeZoneNames.containsKey(key)) \n    {\n        return cachedTimeZoneNames.get(key);\n    }\n\n    // Lookup the name from the time zone\n    final String name = tz.getDisplayName(daylight, style, locale);\n\n    // Cache the name\n    cachedTimeZoneNames.put(key, name);\n\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = tz.getID() + locale.toString() + daylight;\n    if (cCache.containsKey(key)) \n    {\n        return cCache.get(key);\n    }\n    final String name = tz.getDisplayName(daylight, style, locale);\n    cCache.put(key, name);\n    return name;\n}\n\nstatic final Map<String, String> cCache = new HashMap<>();",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = tz.getID() + daylight + style + locale.toString();\n    String value = null;\n    synchronized (cCache) \n    {\n        value = cCache.get(key);\n        if (value == null) \n        {\n            value = tz.getDisplayName(daylight, style, locale);\n            cCache.put(key, value);\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = tz.getID() + daylight + style + locale.toString();\n    String name = cDisplayNames.get(key);\n    if (name == null) \n    {\n        name = tz.getDisplayName(daylight, style, locale);\n        cDisplayNames.put(key, name);\n    }\n    return name;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    // Check cache\n    final Map<String, Map<String, String>> cache = cCache.get();\n    if (cache != null) \n    {\n        final Map<String, String> map = cache.get(tz.getID());\n        if (map != null) \n        {\n            final String key = (daylight ? \"1\" : \"0\") + style;\n            final String value = map.get(key);\n            if (value != null) \n            {\n                return value;\n            }\n        }\n    }\n\n    // Create value\n    final String value = tz.getDisplayName(daylight, style, locale);\n\n    // Update cache\n    if (cache == null) \n    {\n        cache = new HashMap<String, Map<String, String>>();\n        cCache.set(cache);\n    }\n    Map<String, String> map = cache.get(tz.getID());\n    if (map == null) \n    {\n        map = new HashMap<String, String>();\n        cache.put(tz.getID(), map);\n    }\n    map.put((daylight ? \"1\" : \"0\") + style, value);\n\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    for (int i = 0; i < this.columnKeys.size(); i++) \n    {\n        if (this.columnKeys.get(i).equals(key)) \n        {\n            columnIndex = i;\n            break;\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // code here\n}",
      "public int getColumnIndex(Comparable key)  {\n    // COMPLETE THIS FUNCTION\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    // code here\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    for (int i = 0; i < this.columnKeys.size(); i++) \n    {\n        if (this.columnKeys.get(i).equals(key)) \n        {\n            columnIndex = i;\n            break;\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: implement this method\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    for (int i = 0; i < this.columnKeys.length; i++) \n    {\n        if (this.columnKeys[i].equals(key)) \n        {\n            columnIndex = i;\n            break;\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = 0;\n    for (Comparable c : this.columnKeys) {\n        if (c.compareTo(key) == 0) {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    for (int i = 0; i < this.columnKeys.length; i++) \n    {\n        if (this.columnKeys[i].equals(key)) \n        {\n            columnIndex = i;\n            break;\n        }\n    }\n    return columnIndex;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    // check if point is in the interval\n    if (point < getMin() || point > getMax()) {\n        return Location.OUTSIDE;\n    }\n    // check if point is at the boundary\n    if (Precision.equals(point, getMin(), tolerance) ||\n        Precision.equals(point, getMax(), tolerance)) {\n        return Location.BOUNDARY;\n    }\n    // the point is inside the interval\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    // check point is inside the interval\n    if (point >= getMin() && point <= getMax()) {\n        return Location.INSIDE;\n    }\n    // check point is outside the interval\n    if (point < getMin() || point > getMax()) {\n        return Location.OUTSIDE;\n    }\n    // check point is on the boundary\n    if (point == getMin() || point == getMax()) {\n        return Location.BOUNDARY;\n    }\n    // check point is in the tolerance range\n    if (point > getMin() && point < getMax()) {\n        return Location.INSIDE;\n    }\n    // point is not in the tolerance range\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    // CODE HERE\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    // Check the point is not too close to the left boundary.\n    if (point - tolerance < this.getMin()) {\n        return Location.OUTSIDE;\n    }\n\n    // Check the point is not too close to the right boundary.\n    if (point + tolerance > this.getMax()) {\n        return Location.OUTSIDE;\n    }\n\n    // Check the point is not too close to the left boundary.\n    if (point - tolerance < this.getMin()) {\n        return Location.BOUNDARY;\n    }\n\n    // Check the point is not too close to the right boundary.\n    if (point + tolerance > this.getMax()) {\n        return Location.BOUNDARY;\n    }\n\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBoundary - tolerance || point > upperBoundary + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lowerBoundary + tolerance || point > upperBoundary - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    // check if point is in the interval\n    if (point < getMin() || point > getMax()) {\n        return Location.OUTSIDE;\n    }\n    // check if point is in the tolerance range\n    if (FastMath.abs(point - getMin()) <= tolerance ||\n        FastMath.abs(point - getMax()) <= tolerance) {\n        return Location.BOUNDARY;\n    }\n    // point is in the interval and not in the tolerance range\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\n    if (point < getMin() - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > getMax() + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < getMin() + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > getMax() - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < min - tolerance || point > max + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < min + tolerance || point > max - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n    {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n    {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new LogTickUnitSource(locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    return new TickUnitSource() \n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (Integer column : tableau.getNonBasicColumns()) {\n        double coefficient = tableau.getCoefficient(tableau.getObjectiveRow(), column);\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            pivotColumn = column;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // get the objective function row\n    List<Double> objectiveFunctionRow = tableau.getRow(tableau.getObjectiveFunctionRowIndex());\n\n    // find the column with the most negative coefficient\n    int pivotColumnIndex = 0;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < objectiveFunctionRow.size(); i++) \n    {\n        if (objectiveFunctionRow.get(i) < minCoefficient) \n        {\n            minCoefficient = objectiveFunctionRow.get(i);\n            pivotColumnIndex = i;\n        }\n    }\n\n    return pivotColumnIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Find the column with the most negative coefficient\n    Integer pivotColumn = null;\n    double minValue = Double.MAX_VALUE;\n    for (Integer column : tableau.getColumns()) \n    {\n        double value = tableau.getCoefficient(tableau.getObjectiveFunctionRow(), column);\n        if (value < minValue) \n        {\n            minValue = value;\n            pivotColumn = column;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumColumns(); i++) \n    {\n        double coefficient = tableau.getCoefficient(tableau.getObjectiveRow(), i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) {\n        if (tableau.getCoefficient(0, i) < min) {\n            min = tableau.getCoefficient(0, i);\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumberOfColumns() - 1; i++) \n    {\n        double coefficient = tableau.getCoefficient(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    int pivotColumn = -1;\n    for (int j = 0; j < tableau.getNumberOfColumns(); j++) {\n        double coefficient = tableau.getCoefficient(tableau.getObjectiveFunctionRow(), j);\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int j = 0; j < tableau.getNumberOfColumns(); j++) {\n        double coefficient = tableau.getCoefficient(tableau.getObjectiveFunctionRow(), j);\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Initialize pivot column to the first column\n    int pivotColumn = 0;\n    double minValue = Double.MAX_VALUE;\n\n    // Iterate through all columns\n    for (int column = 0; column < tableau.getNumberOfColumns(); column++) {\n        // If the coefficient is negative and smaller than the current minimum\n        if (tableau.getCoefficient(0, column) < 0 && tableau.getCoefficient(0, column) < minValue) {\n            // Update the minimum and pivot column\n            minValue = tableau.getCoefficient(0, column);\n            pivotColumn = column;\n        }\n    }\n\n    // Return the pivot column\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int minRow = 0;\n    double minValue = tableau.getObjectiveRow().get(0);\n    for (int i = 1; i < tableau.getObjectiveRow().size(); i++) {\n        if (tableau.getObjectiveRow().get(i) < minValue) {\n            minValue = tableau.getObjectiveRow().get(i);\n            minRow = i;\n        }\n    }\n    return minRow;\n}"
    ]
  ]
}