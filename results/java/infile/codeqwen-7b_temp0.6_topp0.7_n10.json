{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.5542713567839195,
    "pass@1": 0.30703517587939705,
    "compile@3": 0.6518844221105526,
    "pass@3": 0.3737018425460635,
    "compile@5": 0.6848129536571748,
    "pass@5": 0.40358538725372894
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime >= startTime && currentTime <= endTime) \n            {\n                result = new Double((currentTime - startTime) / (double) (endTime - startTime) * 100);\n            } \n            else if (currentTime > endTime) \n            {\n                result = new Double(100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        double percent = task.getPercentComplete();\n        result = new Double(percent);\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime > endTime) \n            {\n                result = new Double(100.0);\n            } \n            else if (currentTime < startTime) \n            {\n                result = new Double(0.0);\n            } \n            else \n            {\n                double percentComplete = ((currentTime - startTime) / (double) (endTime - startTime)) * 100.0;\n                result = new Double(percentComplete);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        double percent = task.getPercentComplete();\n        result = new Double(percent);\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime > endTime) \n            {\n                result = new Double(100);\n            } \n            else if (currentTime < startTime) \n            {\n                result = new Double(0);\n            } \n            else \n            {\n                double elapsedTime = currentTime - startTime;\n                double totalTime = endTime - startTime;\n                result = new Double((elapsedTime / totalTime) * 100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = new Date().getTime();\n            if (now > end) \n            {\n                result = new Double(100.0);\n            } \n            else if (now > start) \n            {\n                double percent = (now - start) / (double) (end - start);\n                result = new Double(percent * 100.0);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        double percentComplete = task.getPercentComplete();\n        result = new Double(percentComplete);\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        double percentage = task.getPercentComplete();\n        result = new Double(percentage);\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column or square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else if (m.getRowDimension() == m.getColumnDimension()) \n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Input matrix must be a column or square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) \n    {\n        double[] d = new double[m.getColumnDimension()];\n        for (int i = 0; i < m.getColumnDimension(); i++) \n        {\n            d[i] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else if (m.getColumnDimension() == 1) \n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[c][0] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) \n        {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else if (m.getRowDimension() == m.getColumnDimension()) \n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Input matrix must be a column or square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) \n        {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a square matrix.\");\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create blocks array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    for (int i = 0; i < blocks.length; ++i) {\n        blocks[i] = new double[BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) \n    {\n        if (forceAccess) \n        {\n            field.setAccessible(true);\n        } \n        else \n        {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (forceAccess) \n    {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (forceAccess) \n    {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) \n    {\n        if (forceAccess) \n        {\n            field.setAccessible(true);\n        } \n        else \n        {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (forceAccess) \n    {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    if (forceAccess) \n    {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref != null ? ref.get() : null;\n        if (zone == null) {\n            zone = getProvider().getZone(id);\n            if (zone == null) {\n                zone = getNameProvider().getZone(id);\n            }\n            if (zone == null) {\n                throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n            }\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        if (id.length() < 4) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        if (id.charAt(2) != ':') {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        String key = id.substring(0, 3) + id.substring(4);\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(key);\n        DateTimeZone zone = (ref != null ? ref.get() : null);\n        if (zone == null) {\n            try {\n                zone = new FixedDateTimeZone(id, id, Integer.parseInt(id.substring(0, 3)), Integer.parseInt(id.substring(4, 6)));\n            } catch (NumberFormatException ex) {\n                throw new IllegalArgumentException(\"Invalid ID: \" + id);\n            }\n            iFixedOffsetCache.put(key, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        if (id.equals(\"GMT\")) {\n            return GMT;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            return forOffsetString(id.substring(3));\n        }\n        if (id.equals(\"Z\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"Z+\") || id.startsWith(\"Z-\")) {\n            return forOffsetString(id.substring(1));\n        }\n        return getProvider().getZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        // check for fixed offset\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            if (id.length() != 6) {\n                throw new IllegalArgumentException(\"Invalid offset format: \" + id);\n            }\n            int hours = Character.digit(id.charAt(1), 10);\n            int minutes = Character.digit(id.charAt(3), 10);\n            if (hours < 0 || minutes < 0) {\n                throw new IllegalArgumentException(\"Invalid offset format: \" + id);\n            }\n            return forOffsetHoursMinutes(hours, minutes);\n        }\n        // check for ID\n        try {\n            return of(id);\n        } catch (IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            try {\n                return new FixedDateTimeZone(id, id, Integer.parseInt(id.substring(1, 3)) * 60 + Integer.parseInt(id.substring(4, 6)), 0);\n            } catch (NumberFormatException ex) {\n                throw new IllegalArgumentException(\"Invalid offset format: \" + id);\n            }\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id);\n        if (zone != null) {\n            return zone.get();\n        }\n        try {\n            zone = new FixedDateTimeZone(id, id, TimeZone.getTimeZone(id).getOffset(System.currentTimeMillis()) / 60000, 0);\n        } catch (IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Invalid zone ID: \" + id);\n        }\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = (ref != null ? ref.get() : null);\n        if (zone == null) {\n            try {\n                zone = new FixedDateTimeZone(id, id,\n                        TimeZone.getTimeZone(id).getRawOffset(),\n                        TimeZone.getTimeZone(id).getDSTSavings());\n            } catch (IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n            }\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref != null ? ref.get() : null;\n        if (zone == null) {\n            zone = createZone(id);\n            if (zone == null) {\n                throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n            }\n            iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        return cZoneIdConversion.get(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        // Check for fixed offset\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            try {\n                return new FixedDateTimeZone(id);\n            } catch (IllegalArgumentException ex) {\n                // ignored\n            }\n        }\n        // Check for cached zone\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = ref != null ? ref.get() : null;\n        if (zone != null) {\n            return zone;\n        }\n        // Check for known zone\n        zone = getProvider().getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        // Check for conversion\n        String convertedId = cZoneIdConversion.get(id);\n        if (convertedId != null) {\n            zone = getZone(convertedId);\n            if (zone != null) {\n                return zone;\n            }\n        }\n        // Not found\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            try {\n                return forOffsetString(id);\n            } catch (IllegalArgumentException ex) {\n                // ignored\n            }\n        }\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        DateTimeZone zone = (ref != null ? ref.get() : null);\n        if (zone == null) {\n            zone = createZone(id);\n            if (zone != null) {\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return zone;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    // Allocate a result\n    Dfp result = newInstance(this);\n\n    // Multiply the mantissa\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = mant[i] * x;\n    }\n\n    // Add the carry\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] += carry;\n        carry = result.mant[i] / RADIX;\n        result.mant[i] %= RADIX;\n    }\n\n    // Add the carry to the last mantissa digit\n    result.mant[mant.length] += carry;\n\n    // If there was a carry, we need to shift the mantissa\n    if (result.mant[mant.length] >= RADIX) {\n        for (int i = mant.length; i > 0; i--) {\n            result.mant[i] = result.mant[i - 1];\n        }\n        result.mant[0] = result.mant[mant.length] / RADIX;\n        result.mant[mant.length] %= RADIX;\n    }\n\n    // Fixup the exponent.\n    result.exp = exp;\n\n    // Round the result\n    result.round(0);\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length * 2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = sign;\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, null, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length * 2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i + j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i + j] = r - rh * RADIX;\n        }\n        product[i + mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - mant.length + 1;\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - mant.length + 1;\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, null, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Create a new Dfp to hold the result\n    Dfp result = newInstance(this);\n\n    // Multiply the mantissa\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = (short) (mant[i] * x);\n    }\n\n    // Add the carry from the multiplication\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] += carry;\n        carry = result.mant[i] / RADIX;\n        result.mant[i] -= carry * RADIX;\n    }\n\n    // Add the carry from the multiplication\n    result.mant[mant.length] += carry;\n\n    // If there is a carry left, shift the mantissa\n    if (result.mant[mant.length] >= RADIX) {\n        for (int i = mant.length; i > 0; i--) {\n            result.mant[i] = result.mant[i - 1];\n        }\n        result.mant[0] = 0;\n        result.exp++;\n    }\n\n    // Return the result\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == 1)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, this, result);\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Allocate a result to hold the product.\n    Dfp result = newInstance(this);\n\n    // Multiply the mantissa digits.\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = mant[i] * x;\n    }\n\n    // Compute the new exponent.\n    result.exp = exp;\n\n    // Compute the new sign.\n    result.sign = sign;\n\n    // Round the result.\n    result.round(0);\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    int[] product = new int[mant.length * 2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i + j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i + j] = r - rh * RADIX;\n        }\n        product[i + mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - mant.length + 1;\n    result.sign = sign;\n\n    if (result.mant[mant.length - 1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length - 1)) {\n        excp = result.round(product[md - mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    // Check for special cases\n    if (x == 0 || x == 1) {\n        return this;\n    }\n\n    if (x == RADIX - 1) {\n        return add(this);\n    }\n\n    // Check for overflow\n    if (mant[mant.length - 1] >= RADIX - x) {\n        return add(multiplyFast(x - 1));\n    }\n\n    // Perform multiplication\n    int[] product = new int[mant.length * 2];  // Big enough to hold even the largest result\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i + j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i + j] = r - rh * RADIX;\n        }\n        product[i + mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - mant.length + 1;\n\n    // Round the result\n    result.round(product[md - mant.length]);\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n    if (x == 1) {\n        return this;\n    }\n    if (x == RADIX-1) {\n        return add(this);\n    }\n    if (x == RADIX) {\n        return doubleValue();\n    }\n    if (x == RADIX+1) {\n        return add(doubleValue());\n    }\n\n    // Create a new Dfp to hold the result\n    Dfp result = newInstance(this);\n\n    // Multiply the mantissa\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = result.mant[i] * x;\n    }\n\n    // Add the carry over\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = result.mant[i] + carry;\n        carry = result.mant[i] / RADIX;\n        result.mant[i] = result.mant[i] - carry * RADIX;\n    }\n\n    // Handle the carry over\n    if (carry != 0) {\n        result.mant[mant.length] = carry;\n    }\n\n    // Return the result\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            transformedMap.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            transformedMap.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            transformedMap.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            transformedMap.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            transformedMap.put(transformKey((K) entry.getKey()), transformValue((V) entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            transformedMap.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            transformedMap.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return transformedMap;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    NodeUtil.copyFunctionDeclarationAttributes(exportedFunction, externFunction);\n    NodeUtil.copyFunctionTypingInfo(exportedFunction, externFunction);\n    NodeUtil.markNewScopesChanged(externFunction, compiler);\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create an empty function node with the same name and parameter names as the original function\n    Node externFunction = IR.function(\n        IR.name(exportedFunction.getFirstChild().getString()),\n        IR.paramList(exportedFunction.getSecondChild().cloneTree()),\n        IR.block());\n\n    // Copy the return type and parameter types from the original function to the extern function\n    Node returnType = exportedFunction.getChildAtIndex(3);\n    Node paramTypes = exportedFunction.getChildAtIndex(4);\n    externFunction.addChildAfter(returnType, externFunction.getLastChild());\n    externFunction.addChildAfter(paramTypes, returnType);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Get the function name\n    String functionName = exportedFunction.getFirstChild().getString();\n\n    // Get the function parameters\n    Node parameters = exportedFunction.getSecondChild();\n\n    // Get the function body\n    Node body = exportedFunction.getLastChild();\n\n    // Create a new function node with the same name, parameters, and body\n    Node externFunction = IR.function(IR.name(functionName), parameters, body);\n\n    // Set the function body to an empty block\n    externFunction.getLastChild().setToken(Token.BLOCK);\n\n    // Return the new function node\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    NodeUtil.copyFunctionDeclarationAttributes(exportedFunction, function);\n    NodeUtil.copyFunctionTypingInfo(exportedFunction, function);\n    NodeUtil.copyVarProperties(exportedFunction, function);\n    NodeUtil.markNewScopesChanged(function, compiler);\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = exportedFunction.cloneTree();\n    Node body = functionNode.getLastChild();\n    body.removeChildren();\n    body.addChildToFront(IR.block());\n    body.getFirstChild().addChildToFront(IR.returnNode(IR.empty()));\n    \n    // Check for missing parameter types\n    for (Node param : functionNode.getSecondChild().children()) \n    {\n        if (!param.getFirstChild().getString().equals(\"?\")) \n        {\n            compiler.report(JSError.make(exportedFunction, MISSING_PARAM_TYPE));\n        }\n    }\n    \n    // Check for missing return type\n    if (!functionNode.getLastChild().getFirstChild().getString().equals(\"?\")) \n    {\n        compiler.report(JSError.make(exportedFunction, MISSING_RETURN_TYPE));\n    }\n    \n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = exportedFunction.cloneTree();\n    functionNode.setIsSyntheticBlock(true);\n    functionNode.setJSType(exportedFunction.getJSType());\n    functionNode.setStaticSourceFile(exportedFunction.getStaticSourceFile());\n    functionNode.setSourcePositionFrom(exportedFunction);\n    functionNode.setJSDocInfo(exportedFunction.getJSDocInfo());\n    functionNode.setFirstChild(null);\n    functionNode.setLastChild(null);\n    functionNode.setNext(null);\n    functionNode.setPrevious(null);\n    functionNode.setParent(null);\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    NodeUtil.copyFunctionDeclarationAttributes(exportedFunction, functionNode);\n    NodeUtil.copyFunctionType(exportedFunction, functionNode);\n    NodeUtil.copyVarProperties(exportedFunction, functionNode);\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    NodeUtil.copyFunctionDeclarationAttributes(exportedFunction, externFunction);\n    NodeUtil.setFunctionDisplayName(externFunction, exportedFunction.getString());\n    NodeUtil.setFunctionBody(externFunction, IR.block());\n    NodeUtil.setSourceInformation(externFunction, exportedFunction);\n    NodeUtil.setSourceInformation(externFunction.getFirstChild(), exportedFunction.getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild().getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild());\n    NodeUtil.setSourceInformation(externFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild(), exportedFunction.getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild().getFirstChild());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = exportedFunction.cloneTree();\n    functionNode.setType(Token.FUNCTION);\n    functionNode.removeChildren();\n    functionNode.setIsSyntheticBlock(true);\n    NodeUtil.setFunctionDisplayName(functionNode, null);\n    NodeUtil.setFunctionName(functionNode, null);\n    NodeUtil.setFunctionBody(functionNode, IR.block());\n    NodeUtil.setFunctionParameters(functionNode, new Node(Token.PARAM_LIST));\n    NodeUtil.setFunctionParameters(functionNode, functionNode.getFirstChild().detach());\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    if (function.getJSType() != null) {\n        JSType returnType = function.getJSType().getReturnType();\n        if (returnType != null && returnType.isUnknownType()) {\n            compiler.report(JSError.make(exportedFunction, MISSING_RETURN_TYPE));\n        }\n        JSType parameterType = function.getJSType().getParameterType();\n        if (parameterType != null && parameterType.isUnknownType()) {\n            compiler.report(JSError.make(exportedFunction, MISSING_PARAMETER_TYPE));\n        }\n    }\n    return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[covariances.length];\n        for (int i = 0; i < covariances.length; i++) {\n            sigma[i] = Math.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // Compute the covariance matrix.\n        double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        double[] sigma = new double[cov.length];\n        for (int i = 0; i < cov.length; i++) {\n            sigma[i] = FastMath.sqrt(cov[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covarianceMatrix = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covarianceMatrix.length];\n    for (int i = 0; i < covarianceMatrix.length; i++) {\n        sigma[i] = FastMath.sqrt(covarianceMatrix[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariances.length];\n    for (int i = 0; i < covariances.length; i++) {\n        sigma[i] = Math.sqrt(covariances[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[covariances.length];\n        for (int i = 0; i < covariances.length; i++) {\n            sigma[i] = Math.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covarianceMatrix = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covarianceMatrix.length];\n    for (int i = 0; i < covarianceMatrix.length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covarianceMatrix = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covarianceMatrix.length];\n    for (int i = 0; i < covarianceMatrix.length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[covariances.length];\n        for (int i = 0; i < covariances.length; i++) {\n            sigma[i] = Math.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    double[][] covMatrix = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements.\n    double[] sigma = new double[covMatrix.length];\n    for (int i = 0; i < covMatrix.length; i++) {\n        sigma[i] = FastMath.sqrt(covMatrix[i][i]);\n    }\n\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution in variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution in variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Cyclic substitution in variable: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        final StringBuilder cyclicVarNames = new StringBuilder();\n        for (final String priorVarName : priorVariables) \n        {\n            cyclicVarNames.append(priorVarName).append(\" -> \");\n        }\n        cyclicVarNames.append(varName);\n        throw new IllegalStateException(\"Cyclic substitution: \" + cyclicVarNames);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Create a map to store the dependencies of each input\n    Map<INPUT, List<INPUT>> dependencies = new HashMap<>();\n    for (INPUT root : roots) {\n        dependencies.put(root, new ArrayList<>());\n    }\n\n    // Populate the dependencies map\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            INPUT candidate = provideMap.get(symbol);\n            if (candidate != null) {\n                dependencies.get(root).add(candidate);\n            }\n        }\n    }\n\n    // Perform a topological sort to get the dependencies in order\n    List<INPUT> sortedDependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n        topologicalSort(root, dependencies, visited, sortedDependencies);\n    }\n\n    // If the sorted parameter is false, return the original order of the roots\n    if (!sorted) {\n        List<INPUT> originalOrder = new ArrayList<>();\n        for (INPUT root : roots) {\n            if (sortedDependencies.contains(root)) {\n                originalOrder.add(root);\n            }\n        }\n        return originalOrder;\n    }\n\n    return sortedDependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Your code here\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Your code here\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Your code here\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    \n    for (INPUT root : roots) \n    {\n        visitDependencies(root, visited, result);\n    }\n    \n    if (sorted) \n    {\n        Collections.sort(result, new Comparator<INPUT>() \n        {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    Stack<INPUT> stack = new Stack<>();\n\n    for (INPUT root : roots) {\n        stack.push(root);\n    }\n\n    while (!stack.isEmpty()) {\n        INPUT current = stack.pop();\n        if (!visited.contains(current)) {\n            visited.add(current);\n            dependencies.add(current);\n            for (String symbol : current.getRequires()) {\n                INPUT dependency = provideMap.get(symbol);\n                if (dependency != null) {\n                    stack.push(dependency);\n                }\n            }\n        }\n    }\n\n    if (sorted) {\n        Collections.sort(dependencies, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> visited = new HashSet<>();\n    List<INPUT> dependencies = new ArrayList<>();\n\n    for (INPUT root : roots) {\n        getDependenciesOf(root, visited, dependencies);\n    }\n\n    if (sorted) {\n        Collections.sort(dependencies, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> dependencies = new ArrayList<>();\n  Set<INPUT> visited = new HashSet<>();\n\n  for (INPUT root : roots) \n  {\n    getDependenciesOf(root, visited, dependencies);\n  }\n\n  if (sorted) \n  {\n    Collections.sort(dependencies, Comparator.comparing(INPUT::getProvides));\n  }\n\n  return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Create a multimap to store dependencies\n  Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n\n  // Populate the multimap with dependencies\n  for (INPUT input : provideMap.values()) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      deps.put(candidate, input);\n    }\n  }\n\n  // Create a set to store visited nodes\n  Set<INPUT> visited = new HashSet<>();\n\n  // Create a list to store the sorted dependencies\n  List<INPUT> sortedDependencies = new ArrayList<>();\n\n  // Perform a depth-first search to find all dependencies\n  for (INPUT root : roots) {\n    dfs(root, deps, visited, sortedDependencies);\n  }\n\n  // If sorted is true, sort the list\n  if (sorted) {\n    Collections.sort(sortedDependencies, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Your code here\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    \n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    \n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        \n        if (delimLen != -1) \n        {\n            for (int j = 0; j < delimLen; j++) \n            {\n                if (ch == delimiters[j]) \n                {\n                    uncapitalizeNext = true;\n                    continue;\n                }\n            }\n        }\n        \n        if (uncapitalizeNext && Character.isUpperCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            uncapitalizeNext = false;\n        }\n    }\n    \n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (delimLen != -1 && isDelimiter(ch, delimiters)) {\n            buffer.append(ch);\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer.append(Character.toLowerCase(ch));\n            uncapitalizeNext = false;\n        } else {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return uncapitalize(str, delimiters);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toPlainString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toDebugString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getField().getPrecision()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getChar(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getChar(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toBigDecimal().toPlainString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getField().getPrecision()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getChar(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getChar(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\")) \n        {\n            String[] classes = attr(\"class\").split(\" \");\n            for (String c : classes) \n            {\n                selector.append(\".\").append(c);\n            }\n        }\n        int index = parent().childNodes().indexOf(this);\n        selector.append(\":nth-child(\").append(index + 1).append(\")\");\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            StringBuilder selector = new StringBuilder();\n            selector.append(parent.cssSelector()).append(\" > \");\n            selector.append(tagName());\n            if (hasAttr(\"class\")) \n            {\n                selector.append(\".\").append(attr(\"class\"));\n            }\n            if (parent.children().size() > 1) \n            {\n                selector.append(\":nth-child(\").append(indexInParent() + 1).append(\")\");\n            }\n            return selector.toString();\n        }\n    }\n}",
      "public String cssSelector()  {\n    // Implement the logic to generate a CSS selector for the element\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\")) \n        {\n            selector.append(\".\").append(attr(\"class\").replaceAll(\" \", \".\"));\n        }\n        int index = siblingIndex() + 1;\n        selector.append(\":nth-child(\").append(index).append(\")\");\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\")) \n        {\n            selector.append(\".\").append(attr(\"class\").replace(\" \", \".\"));\n        }\n        int index = siblingIndex() + 1;\n        selector.append(\":nth-child(\").append(index).append(\")\");\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            StringBuilder selector = new StringBuilder(parent.cssSelector());\n            selector.append(\" > \");\n            selector.append(tagName());\n            if (hasAttr(\"class\")) \n            {\n                selector.append(\".\").append(attr(\"class\"));\n            }\n            int index = parent.childIndexOf(this);\n            if (index >= 0) \n            {\n                selector.append(\":nth-child(\").append(index + 1).append(\")\");\n            }\n            return selector.toString();\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            StringBuilder selector = new StringBuilder(parent.cssSelector());\n            selector.append(\" > \");\n            selector.append(tagName());\n            if (hasAttr(\"class\")) \n            {\n                selector.append(\".\").append(attr(\"class\"));\n            }\n            if (parent.children().size() > 1) \n            {\n                int index = parent.children().indexOf(this);\n                selector.append(\":nth-child(\").append(index + 1).append(\")\");\n            }\n            return selector.toString();\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            StringBuilder selector = new StringBuilder(parent.cssSelector());\n            selector.append(\" > \");\n            selector.append(tagName());\n            if (hasAttr(\"class\")) \n            {\n                selector.append(\".\").append(attr(\"class\"));\n            }\n            if (parent.children().size() > 1) \n            {\n                selector.append(\":nth-child(\").append(parent.children().indexOf(this) + 1).append(\")\");\n            }\n            return selector.toString();\n        }\n    }\n}",
      "public String cssSelector()  {\n    // Implement the logic to generate the CSS selector for the element\n    // Use the provided context if possible\n    // Return the CSS selector as a String\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\")) \n        {\n            selector.append(\".\").append(attr(\"class\").replace(\" \", \".\"));\n        }\n        int siblingIndex = siblingIndex();\n        if (siblingIndex > 0) \n        {\n            selector.append(\":nth-child(\").append(siblingIndex + 1).append(\")\");\n        }\n        return selector.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 3; // \"!\"\n    }\n    if (n.getType() == Token.LP) \n    {\n        cost += 2; // \"(\"\n    }\n    if (n.getType() == Token.RP) \n    {\n        cost += 2; // \")\"\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    }\n    if (n.getFirstChild() != null) \n    {\n        cost += estimateCostOneLevel(n.getFirstChild());\n    }\n    if (n.getLastChild() != null) \n    {\n        cost += estimateCostOneLevel(n.getLastChild());\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 2; // \"!\"\n    } \n    else if (n.getType() == Token.LP) \n    {\n        cost += 2; // \"(\"\n    } \n    else if (n.getType() == Token.RP) \n    {\n        cost += 2; // \")\"\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) {\n        cost += 4; // \"!(\" and \")\"\n    }\n    if (n.getFirstChild() != null) {\n        cost += 1; // \"(\"\n    }\n    if (n.getLastChild() != null) {\n        cost += 1; // \")\"\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    }\n    else if (n.getType() == Token.LP) \n    {\n        cost++;\n    }\n    else if (n.getType() == Token.RP) \n    {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    } \n    else if (n.getType() == Token.LP) \n    {\n        cost++;\n    } \n    else if (n.getType() == Token.RP) \n    {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    }\n    if (n.getFirstChild() != null) \n    {\n        cost += estimateCostOneLevel(n.getFirstChild());\n    }\n    if (n.getSecondChild() != null) \n    {\n        cost += estimateCostOneLevel(n.getSecondChild());\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 3; // \"!\"\n    }\n    if (n.getType() == Token.LP) \n    {\n        cost += 2; // \"(\"\n    }\n    if (n.getType() == Token.RP) \n    {\n        cost += 2; // \")\"\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost += 4; // \"!(\" and \")\"\n    }\n    else if (n.getType() == Token.LP) \n    {\n        cost += 2; // \"(\" and \")\"\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.getType() == Token.NOT) \n    {\n        cost++;\n    }\n    else if (n.getType() == Token.LP) \n    {\n        cost++;\n    }\n    else if (n.getType() == Token.RP) \n    {\n        cost++;\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buffer = this.buffer;\n    while (left < right)\n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buf = buffer;\n    while (left < right)\n    {\n        char temp = buf[left];\n        buf[left] = buf[right];\n        buf[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final char[] buf = buffer;\n    int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char temp = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buf = buffer;\n    while (left < right) \n    {\n        char temp = buf[left];\n        buf[left] = buf[right];\n        buf[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final char[] buf = buffer;\n    int len = size;\n    int left = 0;\n    int right = len - 1;\n    char swap;\n    while (left < right) \n    {\n        swap = buf[left];\n        buf[left] = buf[right];\n        buf[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buf = buffer;\n    int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char swap = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final char[] buf = buffer;\n    int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char swap = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final char[] buf = buffer;\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        final char swap = buf[left];\n        buf[left] = buf[right];\n        buf[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buf = buffer;\n    int len = size;\n    for (int i = len - 1; i >= len / 2; i--) \n    {\n        char temp = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = temp;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than current text length\");\n\n    String before = value.substring(0, offset);\n    String after = value.substring(offset);\n\n    // replace this text node's value with the \"before\" part\n    coreValue(before);\n\n    // create a new text node with the \"after\" part, and insert it after this node\n    TextNode afterNode = new TextNode(after);\n    afterNode.parent = parent;\n    afterNode.nextSibling = nextSibling;\n    afterNode.previousSibling = this;\n    if (nextSibling != null)\n        nextSibling.previousSibling = afterNode;\n    nextSibling = afterNode;\n\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Split offset must not be greater than text length\");\n\n    String firstPart = value.substring(0, offset);\n    String secondPart = value.substring(offset);\n\n    // replace this text node's value with the first part\n    value = firstPart;\n\n    // create a new text node with the second part\n    TextNode secondNode = new TextNode(secondPart);\n\n    // insert the new node after this one\n    parent.insertAfter(this, secondNode);\n\n    return secondNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.range(offset, 0, value.length());\n    String firstPart = value.substring(0, offset);\n    String secondPart = value.substring(offset);\n    value = firstPart;\n    TextNode secondNode = new TextNode(secondPart);\n    parent().addChild(secondNode, this.nextSibling());\n    return secondNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than text length\");\n\n    String originalText = value;\n    value = originalText.substring(0, offset);\n\n    TextNode newNode = new TextNode(originalText.substring(offset));\n    parent().addChild(newNode, this.nextSibling());\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Split offset must not be greater than current text length\");\n\n    String firstPart = value.substring(0, offset);\n    String secondPart = value.substring(offset);\n\n    TextNode secondNode = new TextNode(secondPart);\n    parent.insertAfter(this, secondNode);\n    coreValue(firstPart);\n\n    return secondNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.range(offset, 0, value.length());\n    TextNode after = new TextNode(value.substring(offset));\n    after.parent = parent;\n    after.nextSibling = nextSibling;\n    if (nextSibling != null)\n        nextSibling.previousSibling = after;\n    nextSibling = after;\n    value = value.substring(0, offset);\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.range(offset, 0, value.length());\n\n    TextNode right = new TextNode(value.substring(offset));\n    parent.addChild(right, this.nextSibling);\n    value = value.substring(0, offset);\n    return right;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than text length\");\n\n    String firstPart = value.substring(0, offset);\n    String secondPart = value.substring(offset);\n\n    // replace this text node's value with the first part\n    coreValue(firstPart);\n\n    // create a new text node with the second part\n    TextNode secondNode = new TextNode(secondPart);\n\n    // insert the new node after this one\n    parent().insertAfter(this, secondNode);\n\n    return secondNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Offset must not be greater than current text length\");\n\n    TextNode right = new TextNode(value.substring(offset));\n    parent.addChild(right, this.nextSibling());\n    coreValue(value.substring(0, offset));\n    return right;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Split offset must not be greater than current text length\");\n\n    String firstPart = value.substring(0, offset);\n    String secondPart = value.substring(offset);\n\n    // set this node's value to the first part\n    value = firstPart;\n\n    // create a new text node with the second part\n    TextNode newNode = new TextNode(secondPart);\n\n    // insert the new node after this node\n    parent().insertAfter(this, newNode);\n\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_7_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_8_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_0_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_8_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_0_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_0_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).longValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).longValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).longValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).longValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).longValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).longValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).longValue());\n    bytes[7] = (byte) (value.and(BYTE_7_MASK).longValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_0_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_7_MASK).intValue());\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    bytes[0] = (byte) (value.shiftRight(BYTE_1_SHIFT).and(BYTE_1_MASK).intValue());\n    bytes[1] = (byte) (value.shiftRight(BYTE_2_SHIFT).and(BYTE_2_MASK).intValue());\n    bytes[2] = (byte) (value.shiftRight(BYTE_3_SHIFT).and(BYTE_3_MASK).intValue());\n    bytes[3] = (byte) (value.shiftRight(BYTE_4_SHIFT).and(BYTE_4_MASK).intValue());\n    bytes[4] = (byte) (value.shiftRight(BYTE_5_SHIFT).and(BYTE_5_MASK).intValue());\n    bytes[5] = (byte) (value.shiftRight(BYTE_6_SHIFT).and(BYTE_6_MASK).intValue());\n    bytes[6] = (byte) (value.shiftRight(BYTE_7_SHIFT).and(BYTE_7_MASK).intValue());\n    bytes[7] = (byte) (value.and(BYTE_8_MASK).intValue());\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) \n    {\n        ch = str.charAt(i);\n        if (chars.contains(ch)) \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) \n    {\n        ch = str.charAt(i);\n        if (chars.contains(ch)) \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite.\");\n    }\n    \n    double[] eigenvalues = getRealEigenvalues();\n    RealMatrix eigenvectors = getEigenvectors();\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(eigenvectors.getRowDimension(), eigenvectors.getColumnDimension());\n    \n    for (int i = 0; i < eigenvalues.length; i++) \n    {\n        squareRoot.setEntry(i, i, Math.sqrt(eigenvalues[i]));\n    }\n    \n    return squareRoot.multiply(eigenvectors.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        if (realEigenvalues[i] <= 0 || imagEigenvalues[i] != 0) \n        {\n            throw new MathUnsupportedOperationException(\"The matrix is not symmetric or not positive definite.\");\n        }\n    }\n\n    // Compute the square-root of the matrix\n    double[][] sqrtMatrix = new double[realEigenvalues.length][realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        sqrtMatrix[i][i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // Multiply the square-root matrix by the transpose of the eigenvectors matrix\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(sqrtMatrix);\n    RealMatrix eigenvectorsTranspose = MatrixUtils.createRealMatrix(eigenvectors).transpose();\n    return sqrtMatrix.multiply(eigenvectorsTranspose);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite.\");\n    }\n\n    double[] eigenvalues = getRealEigenvalues();\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(eigenvalues.length, eigenvalues.length);\n\n    for (int i = 0; i < eigenvalues.length; i++) \n    {\n        sqrtMatrix.setEntry(i, i, Math.sqrt(eigenvalues[i]));\n    }\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"The matrix must be symmetric and positive definite.\");\n    }\n    \n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(realEigenvalues.length, realEigenvalues.length);\n    \n    // Compute the square root of each eigenvalue\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n    \n    // Multiply the square root by the transpose of the eigenvectors\n    RealMatrix result = squareRoot.multiply(MatrixUtils.createRealMatrix(eigenvectors));\n    \n    return result;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n    \n    // Compute the eigenvalues and eigenvectors\n    double[] eigenvalues = getRealEigenvalues();\n    RealVector[] eigenvectors = getEigenvectors();\n    \n    // Compute the square root of each eigenvalue\n    double[] sqrtEigenvalues = new double[eigenvalues.length];\n    for (int i = 0; i < eigenvalues.length; i++) \n    {\n        sqrtEigenvalues[i] = Math.sqrt(eigenvalues[i]);\n    }\n    \n    // Compute the square root matrix\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(eigenvectors.length, eigenvectors.length);\n    for (int i = 0; i < eigenvectors.length; i++) \n    {\n        for (int j = 0; j < eigenvectors.length; j++) \n        {\n            sqrtMatrix.setEntry(i, j, sqrtEigenvalues[i] * eigenvectors[j].getEntry(j));\n        }\n    }\n    \n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n\n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(realEigenvalues.length, realEigenvalues.length);\n\n    // Compute the square root of each eigenvalue\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n\n    // Multiply the square root matrix by the eigenvectors\n    RealMatrix result = squareRoot.multiply(MatrixUtils.createRealMatrix(eigenvectors));\n\n    return result;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n    }\n\n    // Compute the eigenvalues and eigenvectors\n    double[] eigenvalues = getRealEigenvalues();\n    RealVector[] eigenvectors = getEigenvectors();\n\n    // Compute the square-root of the matrix\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(eigenvectors.length, eigenvectors.length);\n    for (int i = 0; i < eigenvalues.length; i++) \n    {\n        sqrtMatrix.setEntry(i, i, Math.sqrt(eigenvalues[i]));\n    }\n\n    // Multiply the square-root matrix by the transpose of the eigenvectors\n    RealMatrix result = sqrtMatrix.multiply(MatrixUtils.createRealMatrix(eigenvectors).transpose());\n\n    return result;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite.\");\n    }\n\n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = MatrixUtils.createRealMatrix(realEigenvalues.length, realEigenvalues.length);\n\n    // Compute the square root of each eigenvalue and store it in the square root matrix\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n    }\n\n    // Multiply the square root matrix by its transpose to get the square root of the original matrix\n    return squareRoot.multiply(squareRoot.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric and positive definite\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        if (realEigenvalues[i] <= 0 || imagEigenvalues[i] != 0) \n        {\n            throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite\");\n        }\n    }\n\n    // Compute the square-root of the matrix\n    double[][] squareRoot = new double[realEigenvalues.length][realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; i++) \n    {\n        squareRoot[i][i] = Math.sqrt(realEigenvalues[i]);\n    }\n\n    // Multiply the square-root matrix by its transpose\n    RealMatrix result = MatrixUtils.createRealMatrix(squareRoot);\n    return result.multiply(result.transpose());\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or not positive definite.\");\n    }\n\n    // Compute the eigenvalues and eigenvectors\n    double[] eigenvalues = getRealEigenvalues();\n    RealVector[] eigenvectors = getEigenvectors();\n\n    // Compute the square root of the matrix\n    RealMatrix sqrtMatrix = MatrixUtils.createRealMatrix(eigenvectors.length, eigenvectors.length);\n    for (int i = 0; i < eigenvalues.length; i++) \n    {\n        sqrtMatrix.setEntry(i, i, Math.sqrt(eigenvalues[i]));\n    }\n\n    // Multiply the eigenvectors by the square root matrix\n    RealMatrix result = MatrixUtils.createRealMatrix(eigenvectors.length, eigenvectors.length);\n    for (int i = 0; i < eigenvectors.length; i++) \n    {\n        for (int j = 0; j < eigenvectors.length; j++) \n        {\n            result.setEntry(i, j, sqrtMatrix.getEntry(i, j) * eigenvectors[j].getEntry(i));\n        }\n    }\n\n    return result;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_ARRAY) {\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeString(p, ctxt);\n        }\n        if (t.isNumeric()) {\n            return _deserializeNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.mappingException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _valueInstantiator.createUsingDefault(ctxt);\n        }\n        if (_nonStandardInitialization) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t.isNumeric()) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE || t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.mappingException(_valueType);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        JsonToken expToken = JsonToken.FIELD_NAME;\n        while (true) {\n            if (t == expToken) {\n                String propName = p.nextFieldName();\n                if (propName == null) {\n                    break;\n                }\n                expToken = JsonToken.VALUE_NULL;\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n                continue;\n            }\n            if (t == JsonToken.END_OBJECT) {\n                break;\n            }\n            if (t == JsonToken.VALUE_NULL) {\n                if (_skipNullValueProperties) {\n                    t = p.nextToken();\n                    continue;\n                }\n            }\n            if (t == JsonToken.START_ARRAY) {\n                if (_unwrappedPropertyHandler != null) {\n                    return deserializeWithUnwrapped(p, ctxt, bean);\n                }\n                if (_externalTypeIdHandler != null) {\n                    return deserializeWithExternalTypeId(p, ctxt, bean);\n                }\n            }\n            if (t == JsonToken.START_OBJECT) {\n                if (_objectIdReader != null) {\n}\n}\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt, true);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt, false);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        }\n        throw ctxt.mappingException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt, true);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt, false);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.mappingException(handledType());\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return deserializeFromBoolean(p, ctxt, true);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt, false);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            // added to resolve [JACKSON-319], possible related issues\n            return deserializeFromObject(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return _valueInstantiator.createObject(ctxt);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String propName = p.getCurrentName();\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                try {\n                    prop.deserializeAndSet(p, ctxt, _valueInstantiator.createObject(ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _valueInstantiator.createObject(ctxt), propName, ctxt);\n                }\n                return _valueInstantiator.createObject(ctxt);\n            }\n            handleUnknownVanilla(p, ctxt, _valueInstantiator.createObject(ctxt), propName);\n            return _valueInstantiator.createObject(ctxt);\n        }\n        return ctxt.handleUnexpectedToken(_valueInstantiator.handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom serializers\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        String propName;\n\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (t.isFieldName()) {\n                propName = t.asString();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        if (t != JsonToken.END_OBJECT) {\n            do {\n                String propName = p.getCurrentName();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((t = p.nextToken()) != JsonToken.END_OBJECT);\n        }\n        return bean;\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Input arrays must not be empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty.\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Input arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Input arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"At least one of the sample arrays is empty.\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"One or both sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"At least one of the input arrays is empty.\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays must not be empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk.length == 0) {\n            return resetAndStart();\n        }\n        _add(fullChunk);\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[Math.min(MAX_CHUNK, SMALL_CHUNK)]);\n        }\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // First, add completed chunk to linked list\n        if (_tail == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        _size += fullChunk.length;\n\n        // And then return new chunk buffer\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk.length > MAX_CHUNK) {\n            throw new IllegalArgumentException(\"ObjectBuffer chunk size (\"+fullChunk.length+\") exceeds maximum allowed (\"+MAX_CHUNK+\")\");\n        }\n        _size += fullChunk.length;\n        if (_tail == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        return _tail.array;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _append(fullChunk);\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk.length > MAX_CHUNK) {\n            throw new IllegalArgumentException(\"Tried to append chunk with length \"+fullChunk.length);\n        }\n        if (_tail == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        _size += fullChunk.length;\n        return (_freeBuffer = new Object[Math.max(12, fullChunk.length)]);\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _addChunk(fullChunk);\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk.length == 0) {\n            return resetAndStart();\n        }\n        _addCompletedChunk(fullChunk);\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[fullChunk.length + 12]);\n        }\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk.length == 0) {\n            return resetAndStart();\n        }\n        _addChunk(fullChunk);\n        return _nextFreeBuffer(fullChunk.length);\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk == null || fullChunk.length == 0) {\n            return resetAndStart();\n        }\n        int chunkSize = fullChunk.length;\n        _size += chunkSize;\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail.append(fullChunk);\n            if (_tail.array.length > MAX_CHUNK) {\n                // If chunk is too large, split it into smaller chunks\n                int remaining = chunkSize;\n                Object[] newChunk = new Object[SMALL_CHUNK];\n                int offset = 0;\n                while (remaining > 0) {\n                    int chunk = Math.min(remaining, SMALL_CHUNK);\n                    System.arraycopy(fullChunk, offset, newChunk, 0, chunk);\n                    _tail.append(newChunk);\n                    offset += chunk;\n                    remaining -= chunk;\n                }\n            }\n        }\n        return resetAndStart();\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _append(fullChunk);\n        if (_freeBuffer == null) {\n            return (_freeBuffer = new Object[12]);\n        }\n        return _freeBuffer;\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern must not be null or empty\");\n    }\n\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n\n    List<DateTimePrinterParser> parsers = new ArrayList<DateTimePrinterParser>();\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            parsers.add(new NumberPrinterParser(new SimpleNumberField(token), 1, 2, false));\n        } else {\n            parsers.add(new TextPrinterParser(token, null));\n        }\n    }\n\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    \n    List<DateTimeParser> parsers = new ArrayList<DateTimeParser>();\n    List<DateTimePrinter> printers = new ArrayList<DateTimePrinter>();\n    \n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        \n        if (isNumericToken(token)) {\n            parsers.add(new NumericDateTimeParser(token));\n            printers.add(new NumericDateTimePrinter(token));\n        } else {\n            parsers.add(new TextDateTimeParser(token));\n            printers.add(new TextDateTimePrinter(token));\n        }\n    }\n    \n    return new DateTimeFormatter(\n        new CombinedDateTimeParser(parsers),\n        new CombinedDateTimePrinter(printers)\n    );\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    StringBuilder buf = new StringBuilder();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        buf.append(token);\n        if (indexRef[0] < pattern.length()) {\n            buf.append(\" \");\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n    if (pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern must not be empty\");\n    }\n\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    StringBuilder buf = new StringBuilder();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        buf.append(token);\n        if (indexRef[0] < pattern.length()) {\n            buf.append('|');\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n    if (pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern must not be empty\");\n    }\n    \n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    \n    List<DateTimePrinterParser> printerParsers = new ArrayList<DateTimePrinterParser>();\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            printerParsers.add(new NumberPrinterParser(new SimpleNumberField(0, 9), 1, 9, SignStyle.NOT_NEGATIVE));\n        } else {\n            printerParsers.add(new TextPrinterParser(token, null));\n        }\n    }\n    \n    return new DateTimeFormatter(printerParsers);\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    int[] indexRef = new int[1];\n    StringBuilder buf = new StringBuilder();\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            builder.appendValue(DateTimeFieldType.forPattern(token));\n        } else {\n            builder.appendLiteral(token);\n        }\n    }\n\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    int[] indexRef = new int[1];\n    StringBuilder buf = new StringBuilder();\n    List<DateTimeParser> parsers = new ArrayList<DateTimeParser>();\n    List<DateTimePrinter> printers = new ArrayList<DateTimePrinter>();\n    \n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            parsers.add(new NumericParser(token));\n            printers.add(new NumericPrinter(token));\n        } else {\n            parsers.add(new TextParser(token));\n            printers.add(new TextPrinter(token));\n        }\n    }\n    \n    return new DateTimeFormatter(new DateTimePrinter[] { new CompositePrinter(printers) },\n                                new DateTimeParser[] { new CompositeParser(parsers) });\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n\n    List<DateTimeField> fields = new ArrayList<DateTimeField>();\n    List<Integer> widths = new ArrayList<Integer>();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (token.length() == 0) {\n            break;\n        }\n        if (isNumericToken(token)) {\n            fields.add(new NumericDateTimeField(token));\n            widths.add(token.length());\n        } else {\n            fields.add(new TextDateTimeField(token));\n            widths.add(token.length());\n        }\n    }\n\n    if (indexRef[0] != pattern.length()) {\n        throw new IllegalArgumentException(\"Invalid pattern\");\n    }\n\n    return new DateTimeFormatter(fields, widths);\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    int[] indexRef = new int[] { 0 };\n    List<DateTimeField> fields = new ArrayList<DateTimeField>();\n    List<String> tokens = new ArrayList<String>();\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        tokens.add(token);\n\n        if (isNumericToken(token)) {\n            fields.add(new NumericDateTimeField(token));\n        } else {\n            fields.add(new TextualDateTimeField(token));\n        }\n    }\n\n    return new DateTimeFormatter(fields, tokens);\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    int[] indexRef = new int[1];\n    indexRef[0] = 0;\n    \n    StringBuilder buf = new StringBuilder();\n    while (indexRef[0] < pattern.length())\n    {\n        String token = parseToken(pattern, indexRef);\n        buf.append(isNumericToken(token) ? \"dd\" : \"MM\");\n    }\n    \n    return DateTimeFormatter.ofPattern(buf.toString());\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n        String name = getString();\n        next();\n        if (match(JsDocToken.LP)) {\n            // It's a function type.\n            return parseFunctionType(token);\n        } else if (match(JsDocToken.LB)) {\n            // It's a record type.\n            return parseRecordType(token);\n        } else if (match(JsDocToken.LBRACKET)) {\n            // It's an array type.\n            return parseArrayType(token);\n        } else {\n            // It's a type name.\n            return newNode(Token.NAME, name);\n        }\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else if (token == JsDocToken.IDENTIFIER) \n    {\n        return parseTypeName(token);\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(token);\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(token);\n    } \n    else if (token == JsDocToken.LP) \n    {\n        return parseFunctionType(token);\n    } \n    else if (token == JsDocToken.PIPE) \n    {\n        return parseUnionType(token);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (isTypeName(token)) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.UNION) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.RECORD) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.ARRAY) {\n    return parseArrayType(token);\n  }\n\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        Node typeName = parseTypeName(token);\n        if (typeName != null) \n        {\n            return typeName;\n        } \n        else if (token == JsDocToken.FUNCTION) \n        {\n            return parseFunctionType(token);\n        } \n        else if (token == JsDocToken.UNION) \n        {\n            return parseUnionType(token);\n        } \n        else if (token == JsDocToken.RECORD) \n        {\n            return parseRecordType(token);\n        } \n        else if (token == JsDocToken.ARRAY) \n        {\n            return parseArrayType(token);\n        } \n        else \n        {\n            return null;\n        }\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else if (token == JsDocToken.IDENTIFIER) \n    {\n        Node typeName = newNode(Token.NAME, token.value);\n        next();\n        return typeName;\n    } \n    else if (token == JsDocToken.FUNCTION) \n    {\n        return parseFunctionType(token);\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseUnionType(token);\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(token);\n    } \n    else if (token == JsDocToken.LBRACK) \n    {\n        return parseArrayType(token);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else \n    {\n        String typeName = getIdentifier(token);\n        if (typeName != null) \n        {\n            return newNode(Token.NAME, typeName);\n        } \n        else \n        {\n            // Handle FunctionType, UnionType, RecordType, ArrayType\n            // Implement parsing logic for these types here\n            // For example:\n            // return parseFunctionType(token);\n            // return parseUnionType(token);\n            // return parseRecordType(token);\n            // return parseArrayType(token);\n            // If none of the above types match, return null\n            return null;\n        }\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n        return newNode(Token.NAME, token.value);\n    } else if (token == JsDocToken.LP) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LBRACK) {\n        return parseArrayType(token);\n    } else if (token == JsDocToken.PIPE) {\n        return parseUnionType(token);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) {\n        String typeName = getString();\n        return newNode(Token.NAME, typeName);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else if (token == JsDocToken.LP) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.PIPE) {\n        return parseUnionType(token);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.IDENTIFIER) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else if (isTypeName(token)) \n    {\n        return parseTypeName(token);\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(token);\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(token);\n    } \n    else if (token == JsDocToken.LP) \n    {\n        return parseFunctionType(token);\n    } \n    else if (token == JsDocToken.PIPE) \n    {\n        return parseUnionType(token);\n    } \n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int category = 0; category < categoryCount; category++) {\n        double positive = 0.0;\n        double negative = 0.0;\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, category);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive = positive + value;\n                }\n                if (value < 0.0) {\n                    negative = negative + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, negative);\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                }\n            }\n        }\n        for (int s = 0; s < seriesCount; s++) {\n            minimum = Math.min(minimum, negative[s]);\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                }\n            }\n        }\n        for (int s = 0; s < seriesCount; s++) {\n            minimum = Math.min(minimum, negative[s]);\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int series = 0; series < seriesCount; series++) {\n        for (int category = 0; category < categoryCount; category++) {\n            Number number = dataset.getValue(series, category);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n    }\n    return minimum == Double.POSITIVE_INFINITY ? null : minimum;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int categoryCount = dataset.getColumnCount();\n        for (int category = 0; category < categoryCount; category++) {\n            Number number = dataset.getValue(series, category);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n    }\n    return minimum == Double.MAX_VALUE ? null : new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int categoryCount = dataset.getColumnCount();\n        for (int category = 0; category < categoryCount; category++) {\n            Number number = dataset.getValue(series, category);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n    }\n    return minimum == Double.MAX_VALUE ? null : new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                }\n            }\n        }\n        for (int s = 0; s < seriesCount; s++) {\n            minimum = Math.min(minimum, negative[s]);\n        }\n    }\n    return minimum == Double.MAX_VALUE ? null : new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int s = 0; s < seriesCount; s++) {\n            minimum = Math.min(minimum, negative[s]);\n        }\n    }\n    if (minimum == Double.MAX_VALUE) {\n        return null;\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    int seriesCount = dataset.getRowCount();\n    int categoryCount = dataset.getColumnCount();\n    for (int category = 0; category < categoryCount; category++) {\n        double[] positive = new double[seriesCount];\n        double[] negative = new double[seriesCount];\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, category);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[series] = positive[series] + value;\n                }\n                if (value < 0.0) {\n                    negative[series] = negative[series] + value;\n                }\n            }\n        }\n        for (int series = 0; series < seriesCount; series++) {\n            minimum = Math.min(minimum, negative[series]);\n        }\n    }\n    return new Double(minimum);\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        int categoryCount = dataset.getColumnCount();\n        for (int category = 0; category < categoryCount; category++) {\n            Number value = dataset.getValue(series, category);\n            if (value != null) {\n                double v = value.doubleValue();\n                if (v < minimum) {\n                    minimum = v;\n                }\n            }\n        }\n    }\n    return minimum == Double.POSITIVE_INFINITY ? null : new Double(minimum);\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder();\n    char lastChar = ' ';\n    for (final char c : buffer) {\n        if (isDelimiter(c, delimiters)) {\n            lastChar = c;\n        } else if (Character.isLetter(c) && lastChar == ' ') {\n            result.append(c);\n            lastChar = c;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean nextIsInitial = true;\n\n    for (final char c : buffer) {\n        if (nextIsInitial && !Character.isWhitespace(c)) {\n            initials.append(c);\n            nextIsInitial = false;\n        } else if (Character.isWhitespace(c)) {\n            nextIsInitial = true;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    boolean lastWasWhitespace = true;\n    for (final char c : buffer) {\n        if (Character.isLetter(c)) {\n            if (lastWasWhitespace) {\n                result.append(c);\n            }\n            lastWasWhitespace = false;\n        } else if (delimiters != null) {\n            for (final char delimiter : delimiters) {\n                if (c == delimiter) {\n                    lastWasWhitespace = true;\n                    break;\n                }\n            }\n        } else if (Character.isWhitespace(c)) {\n            lastWasWhitespace = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder();\n    boolean lastWasWhitespace = true;\n    for (final char c : buffer) {\n        if (Character.isLetter(c)) {\n            if (lastWasWhitespace) {\n                result.append(c);\n            }\n            lastWasWhitespace = false;\n        } else if (delimiters != null) {\n            for (final char delimiter : delimiters) {\n                if (c == delimiter) {\n                    lastWasWhitespace = true;\n                    break;\n                }\n            }\n        } else if (Character.isWhitespace(c)) {\n            lastWasWhitespace = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    boolean lastWasWhitespace = true;\n    for (final char c : buffer) {\n        if (Character.isLetter(c)) {\n            if (lastWasWhitespace) {\n                result.append(c);\n            }\n            lastWasWhitespace = false;\n        } else if (delimiters != null) {\n            for (final char delimiter : delimiters) {\n                if (c == delimiter) {\n                    lastWasWhitespace = true;\n                    break;\n                }\n            }\n        } else if (Character.isWhitespace(c)) {\n            lastWasWhitespace = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean nextIsInitial = true;\n    for (final char c : buffer) {\n        if (nextIsInitial && !Character.isWhitespace(c)) {\n            initials.append(c);\n            nextIsInitial = false;\n        } else if (Character.isWhitespace(c)) {\n            nextIsInitial = true;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean foundLetter = false;\n    for (final char c : buffer) {\n        if (foundLetter && Character.isWhitespace(c)) {\n            foundLetter = false;\n        } else if (!foundLetter && !Character.isWhitespace(c)) {\n            initials.append(c);\n            foundLetter = true;\n        }\n        if (delimiters != null) {\n            for (final char delimiter : delimiters) {\n                if (c == delimiter) {\n                    foundLetter = false;\n                    break;\n                }\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean foundLetter = false;\n    for (int i = 0; i < buffer.length; i++) {\n        if (foundLetter && Character.isWhitespace(buffer[i])) {\n            foundLetter = false;\n        } else if (!foundLetter) {\n            foundLetter = true;\n            initials.append(buffer[i]);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder initials = new StringBuilder();\n    boolean foundLetter = false;\n    for (int i = 0; i < buffer.length; i++) {\n        if (foundLetter && Character.isWhitespace(buffer[i])) {\n            foundLetter = false;\n        } else if (!foundLetter) {\n            foundLetter = true;\n            if (delimiters != null) {\n                for (final char delimiter : delimiters) {\n                    if (delimiter == buffer[i]) {\n                        foundLetter = false;\n                        break;\n                    }\n                }\n            }\n            if (foundLetter) {\n                initials.append(buffer[i]);\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    boolean lastWasWhitespace = true;\n    for (final char c : buffer) {\n        if (Character.isLetter(c)) {\n            if (lastWasWhitespace) {\n                result.append(c);\n            }\n            lastWasWhitespace = false;\n        } else if (delimiters != null) {\n            for (final char delimiter : delimiters) {\n                if (c == delimiter) {\n                    lastWasWhitespace = true;\n                    break;\n                }\n            }\n        } else if (Character.isWhitespace(c)) {\n            lastWasWhitespace = true;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) \n    {\n        double value = data.getValue(row, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        double value = data.getValue(row, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        double value = data.getValue(r, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        double value = data.getValue(row, column);\n        total += value;\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) \n    {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        double value = data.getValue(row, column);\n        total += value;\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(source, BigFraction.class);\n        }\n        \n        String numeratorString = source.substring(0, slashIndex);\n        String denominatorString = source.substring(slashIndex + 1);\n        \n        BigInteger numerator = new BigInteger(numeratorString);\n        BigInteger denominator = new BigInteger(denominatorString);\n        \n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] parts = source.split(\"/\");\n        if (parts.length != 2) \n        {\n            throw new MathParseException(\"Invalid fraction format\", source, 0);\n        }\n        BigInteger numerator = new BigInteger(parts[0].trim());\n        BigInteger denominator = new BigInteger(parts[1].trim());\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String str = source.trim();\n        int slashIndex = str.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, 0);\n        }\n        String numeratorStr = str.substring(0, slashIndex);\n        String denominatorStr = str.substring(slashIndex + 1);\n        try \n        {\n            BigInteger numerator = new BigInteger(numeratorStr);\n            BigInteger denominator = new BigInteger(denominatorStr);\n            return new BigFraction(numerator, denominator);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, 0);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(source, 0, 0, LocalizedFormats.CANNOT_PARSE_FRACTION);\n        }\n        \n        String numeratorString = source.substring(0, slashIndex);\n        String denominatorString = source.substring(slashIndex + 1);\n        \n        BigInteger numerator = new BigInteger(numeratorString);\n        BigInteger denominator = new BigInteger(denominatorString);\n        \n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(source, 0, 0, LocalizedFormats.CANNOT_PARSE_FRACTION);\n        }\n        String numeratorStr = source.substring(0, slashIndex);\n        String denominatorStr = source.substring(slashIndex + 1);\n        try \n        {\n            BigInteger numerator = new BigInteger(numeratorStr);\n            BigInteger denominator = new BigInteger(denominatorStr);\n            return new BigFraction(numerator, denominator);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new MathParseException(source, 0, 0, LocalizedFormats.CANNOT_PARSE_FRACTION);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String str = source.trim();\n        int slashIndex = str.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, 0);\n        }\n        String numeratorStr = str.substring(0, slashIndex);\n        String denominatorStr = str.substring(slashIndex + 1);\n        try \n        {\n            BigInteger numerator = new BigInteger(numeratorStr);\n            BigInteger denominator = new BigInteger(denominatorStr);\n            return new BigFraction(numerator, denominator);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, source, 0);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(source, slashIndex, LocalizedFormats.NO_SLASH_IN_FRACTION);\n        }\n        String numeratorString = source.substring(0, slashIndex);\n        String denominatorString = source.substring(slashIndex + 1);\n        BigInteger numerator = new BigInteger(numeratorString);\n        BigInteger denominator = new BigInteger(denominatorString);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) \n        {\n            throw new MathParseException(source, pos.getErrorIndex(), \"Unparseable fraction\");\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) {\n            throw new MathParseException(source, 0, 0);\n        }\n        String numeratorString = source.substring(0, slashIndex);\n        String denominatorString = source.substring(slashIndex + 1);\n        try {\n            BigInteger numerator = new BigInteger(numeratorString);\n            BigInteger denominator = new BigInteger(denominatorString);\n            return new BigFraction(numerator, denominator);\n        } catch (NumberFormatException e) {\n            throw new MathParseException(source, 0, 0);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        int slashIndex = source.indexOf(\"/\");\n        if (slashIndex == -1) \n        {\n            throw new MathParseException(source, 0, source.length(), LocalizedFormats.CANNOT_PARSE_AS_FRACTION);\n        }\n        String numeratorString = source.substring(0, slashIndex);\n        String denominatorString = source.substring(slashIndex + 1);\n        BigInteger numerator = new BigInteger(numeratorString);\n        BigInteger denominator = new BigInteger(denominatorString);\n        return new BigFraction(numerator, denominator);\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list.size());\n    set.addAll(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.removeAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.removeAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.removeAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list.size());\n    set.addAll(list);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.retainAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list.size());\n    set.addAll(list);\n    list.retainAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.removeAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.removeAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.retainAll(set);\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = new Range(0.0, 0.0);\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        range = Range.combine(range, plot.getDataRange(axis));\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) \n    {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        result = Range.combine(result, plot.getDataRange(axis));\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = new Range(0.0, 0.0);\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        range = Range.combine(range, plot.getDataRange(axis));\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) \n    {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        result = Range.combine(result, plot.getDataRange(axis));\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n    return new Range(min, max);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (int i = 0; i < this.subplots.size(); i++) \n    {\n        CategoryPlot plot = (CategoryPlot) this.subplots.get(i);\n        Range range = plot.getDataRange(axis);\n        if (range != null) \n        {\n            min = Math.min(min, range.getLowerBound());\n            max = Math.max(max, range.getUpperBound());\n        }\n    }\n\n    if (min > max) \n    {\n        return new Range(0.0, 1.0);\n    } \n    else \n    {\n        return new Range(min, max);\n    }\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    double logVal = Math.log10(val);\n    if (val < 10.0) \n    {\n        logVal = logVal + (1.0 - val) * 10.0;\n    }\n    return logVal;\n}",
      "public double adjustedLog10(double val)  {\n    double result = Math.log10(Math.abs(val));\n    if (val < 10.0) \n    {\n        result += 1.0 - val;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) \n    {\n        val = -val;\n    }\n    if (val < 10) \n    {\n        val = val / 10.0;\n    }\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    double logVal = Math.log10(val);\n    if (val < 10.0) {\n        logVal = logVal + (1.0 - logVal) * val;\n    }\n    return logVal;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) \n    {\n        val = -val;\n    }\n    double result = Math.log10(val);\n    if (val < 1) \n    {\n        result = result + (1 - val) * 10;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    double log10Val = Math.log10(val);\n    double adjustedVal = log10Val + 1.0 / Math.log10(val);\n    return adjustedVal;\n}",
      "public double adjustedLog10(double val)  {\n    double result = Math.log10(val);\n    if (val < 10.0) \n    {\n        result = result * val / 10.0;\n    }\n    return result;\n}",
      "public double adjustedLog10(double val)  {\n    if (val <= 0.0) \n    {\n        return Double.NaN;\n    } \n    else \n    {\n        double log10Val = Math.log10(val);\n        double adjustedVal = log10Val + (1.0 - log10Val) * val;\n        return adjustedVal;\n    }\n}",
      "public double adjustedLog10(double val)  {\n    if (val <= 0.0) \n    {\n        return Double.NaN;\n    } \n    else \n    {\n        double log10 = Math.log10(val);\n        if (log10 < 0.0) \n        {\n            log10 = -log10;\n        }\n        return log10;\n    }\n}",
      "public double adjustedLog10(double val)  {\n    double log10 = Math.log10(val);\n    if (val < 10) \n    {\n        log10 = log10 + (1 - val) * 10;\n    }\n    return log10;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) \n  {\n    if (node.getValue() == null) \n    {\n      // Entry node or implicit return node\n      continue;\n    }\n    if (!node.getValue().isReturn()) \n    {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  boolean foundReturn = false;\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getOutEdges(cfg.getImplicitReturn())) \n  {\n    if (edge.getValue() == ControlFlowGraph.Branch.ON_TRUE) \n    {\n      foundReturn = true;\n      break;\n    }\n  }\n  return foundReturn;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n    if (node.getValue() == null) \n    {\n      continue;\n    }\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) \n    {\n      if (edge.getValue() == Branch.ON_EX) \n      {\n        continue;\n      }\n      if (edge.getDestination().getValue() == cfg.getImplicitReturn()) \n      {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : \n      cfg.getOutgoingEdges(cfg.getImplicitReturn())) \n  {\n    if (!edge.getValue().isOnTrue()) \n    {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If there is no implicit return, there is no way to return.\n  if (cfg.getImplicitReturn() == null) \n  {\n    return true;\n  }\n\n  // If there is no entry node, there is no way to enter the function.\n  if (cfg.getEntry() == null) \n  {\n    return true;\n  }\n\n  // If there is no path from the entry node to the implicit return node,\n  // there is no way to return.\n  if (!cfg.hasPath(cfg.getEntry(), cfg.getImplicitReturn())) \n  {\n    return true;\n  }\n\n  // If there is a path from the entry node to the implicit return node,\n  // there is a way to return.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n    if (node.getValue() == null) \n    {\n      continue;\n    }\n    if (node.getValue().isReturn()) \n    {\n      continue;\n    }\n    if (node.getValue().isBranch()) \n    {\n      DiGraphNode<Node, ControlFlowGraph.Branch> trueTarget = cfg.getTarget(node, Branch.ON_TRUE);\n      DiGraphNode<Node, ControlFlowGraph.Branch> falseTarget = cfg.getTarget(node, Branch.ON_FALSE);\n      if (trueTarget == null || falseTarget == null) \n      {\n        continue;\n      }\n      if (fastAllPathsReturnCheck(cfg, trueTarget) && fastAllPathsReturnCheck(cfg, falseTarget)) \n      {\n        continue;\n      }\n    }\n    return false;\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If there is no implicit return node, then all paths must return.\n  if (cfg.getImplicitReturn() == null) \n  {\n    return true;\n  }\n\n  // If there is no entry node, then there are no paths.\n  if (cfg.getEntry() == null) \n  {\n    return true;\n  }\n\n  // If there is no exit node, then there are no paths.\n  if (cfg.getExit() == null) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getImplicitReturn()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getExit()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getImplicitReturn() == cfg.getExit()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getImplicitReturn() && cfg.getImplicitReturn() == cfg.getExit()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getImplicitReturn() && cfg.getImplicitReturn() == cfg.getExit()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getImplicitReturn() && cfg.getImplicitReturn() == cfg.getExit()) \n  {\n    return true;\n  }\n\n  // If there is only one node, then there is one path.\n  if (cfg.getEntry() == cfg.getImplicitReturn() && cfg.getImplicitReturn() == cfg.getExit()) \n  {\n    return true;\n  }\n\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Create a set of all return nodes in the control flow graph.\n  Set<Node> returnNodes = new HashSet<>();\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n    if (node.getValue() != null && node.getValue().isReturn()) \n    {\n      returnNodes.add(node.getValue());\n    }\n  }\n\n  // Create a set of all nodes reachable from the entry node.\n  Set<Node> reachableNodes = new HashSet<>();\n  Queue<Node> queue = new LinkedList<>();\n  queue.add(cfg.getEntry().getValue());\n  while (!queue.isEmpty()) \n  {\n    Node node = queue.remove();\n    if (reachableNodes.contains(node)) \n    {\n      continue;\n    }\n    reachableNodes.add(node);\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getOutEdges(node)) \n    {\n      queue.add(edge.getDestination().getValue());\n    }\n  }\n\n  // If all return nodes are reachable from the entry node, then all paths\n  // in the control flow graph return.\n  return returnNodes.containsAll(reachableNodes);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) \n  {\n    if (node.getValue() == null) \n    {\n      continue;\n    }\n    if (node.getValue().isReturn()) \n    {\n      continue;\n    }\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getOutEdges(node)) \n    {\n      if (edge.getValue() == Branch.ON_EX) \n      {\n        continue;\n      }\n      if (edge.getValue() == Branch.ON_TRUE) \n      {\n        if (!fastAllPathsReturnCheck(cfg)) \n        {\n          return false;\n        }\n      }\n      if (edge.getValue() == Branch.ON_FALSE) \n      {\n        continue;\n      }\n    }\n    return false;\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the implicit return node has any outgoing edges, then there is at least\n  // one path that does not return.\n  return !cfg.getImplicitReturn().getOutEdges().iterator().hasNext();\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a.clone();\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n\n    spy[0] = a[0].subtract(a[1]);\n    spy[1] = a[0].add(a[1]);\n\n    spz[0] = spy[0].divide(spy[1]);\n    spz[1] = a[1].multiply(spy[0].divide(spy[1]));\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        int p2 = 0;\n        Dfp lr;\n        int ix;\n\n        lr = a[0].log10K();\n\n        a[0] = a[0].divide(pow(a[0].getField().getOne(), lr));  /* This puts x in the range 0-10000 */\n        ix = a[0].floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n        Dfp[] spx = split(a[0]);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a[0].getField().getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a[0].getField().getOne().divide(a[0].getField().newInstance(\"1.33333\"));    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(a[0].getField().getTwo());\n            spx[1] = spx[1].divide(a[0].getField().getTwo());\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a[0].getField().newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a[0].getField().getZero();\n        spy = splitMult(a[0].getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    x[0] = a[0].subtract(a[1]);\n    x[1] = a[0].add(a[1]);\n\n    return split(x[0].divide(x[1]));\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp lr, p2 = a.getField().getZero();\n\n    lr = a[0].log10K();\n\n    x[0] = a[0].divide(pow(a[0].getField().getOneHundred(), lr));  /* This puts x in the range 0-10000 */\n    x[1] = a[1].divide(pow(a[0].getField().getOneHundred(), lr));\n\n    int ix = x[0].floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2 = p2.add(a[0].getField().getOne());\n    }\n\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[0].getField().getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[0].getField().getOneThreeThirds();    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(a[0].getField().getTwo());\n        spx[1] = spx[1].divide(a[0].getField().getTwo());\n        p2 = p2.add(a[0].getField().getOne());\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n\n    spx[0] = a[0].getField().getNewInstance(new StringBuilder().append(p2.add(a[0].getField().getFour().multiply(lr))).toString());\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp lr, x, spx[], spy[], spz[];\n    int ix, p2 = 0;\n\n    lr = a[0].log10K();\n\n    x = a[0].divide(pow(a[0].getField().getOne(), lr));  /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    spx = split(x);\n    spy = new Dfp[2];\n    spy[0] = pow(a[0].getField().getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[0].newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    spz = logInternal(spx);\n\n    spx[0] = a[0].newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx[1] = a[0].getZero();\n    spy = splitMult(a[0].getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    spx[0] = a[0].newInstance(new StringBuilder().append(4*lr).toString());\n    spx[1] = a[0].getZero();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    int p2 = 0;\n    Dfp lr;\n    lr = a[0].log10K();\n\n    a[0] = a[0].divide(pow(a[0].getField().getOne(), lr));  /* This puts a[0] in the range 0-1 */\n    int ix = a[0].floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a[0].getField().getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[0].getField().getOne().divide(a[0].getField().getThree());    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(a[0].getField().getTwo());\n        spx[1] = spx[1].divide(a[0].getField().getTwo());\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n\n    spx[0] = a[0].getField().getOne().add(a[0].getField().getOne());\n    spx[1] = a[0].getField().getZero();\n    spy = splitMult(a[0].getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    x[0] = a[0].subtract(a[1]);\n    x[1] = a[0].add(a[1]);\n    x[0] = x[0].divide(x[1]);\n    x[1] = x[1].divide(x[1]);\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        int ix = a[0].floor().intValue();\n        Dfp[] spx = new Dfp[2];\n        Dfp[] spy = new Dfp[2];\n\n        spx[0] = a[0].subtract(a[1]);\n        spx[1] = a[0].add(a[1]);\n\n        spy[0] = spx[0].divide(spx[1]);\n        spy[1] = a[1].divide(spx[1]);\n\n        spx[0] = a[0].subtract(spy[1]);\n        spx[1] = spy[0];\n\n        return spx;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        int p2 = 0;\n        Dfp lr = a[0].log10K();\n\n        a[0] = a[0].divide(pow(a[0].getField().getTwo(), lr));  /* This puts a[0] in the range 0-2 */\n\n        while (a[0].greaterThan(a[0].getField().getOne())) {\n            a[0] = a[0].divide(a[0].getField().getTwo());\n            p2++;\n        }\n\n        Dfp[] spx = split(a[0]);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a[0].getField().getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a[0].getField().getOneThird();    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(a[0].getField().getTwo());\n            spx[1] = spx[1].divide(a[0].getField().getTwo());\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a[0].getField().newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a[0].getField().getZero();\n        spy = splitMult(a[0].getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        int ix;\n        int p2 = 0;\n        Dfp lr;\n        Dfp x = a[0].add(a[1]);\n        Dfp y = a[0].subtract(a[1]);\n\n        lr = x.log10K();\n\n        x = x.divide(pow(a[0].newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n        ix = x.floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n        Dfp[] spx = split(x);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a[0].getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a[0].newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a[0].newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a[0].getZero();\n        spy = splitMult(a[0].getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        spx[0] = a[0].newInstance(new StringBuilder().append(4*lr).toString());\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Collection<V> coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Collection<V> coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            return false;\n        }\n        \n        Collection<V> values = decorated().get(key);\n        if (values == null) \n        {\n            return false;\n        }\n        \n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n        Collection<V> coll = get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> coll = get(key);\n        if (coll != null && coll.remove(value)) \n        {\n            if (coll.isEmpty()) \n            {\n                super.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n\n        final Collection<V> values = get(key);\n        if (values == null) {\n            return false;\n        }\n\n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            return false;\n        }\n\n        Collection<V> values = get(key);\n        if (values == null) {\n            return false;\n        }\n\n        boolean result = values.remove(value);\n        if (values.isEmpty()) {\n            remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            return false;\n        }\n        \n        Collection<V> values = get(key);\n        if (values == null) \n        {\n            return false;\n        }\n        \n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            return false;\n        }\n        \n        Collection<V> values = get(key);\n        if (values == null) \n        {\n            return false;\n        }\n        \n        boolean removed = values.remove(value);\n        if (values.isEmpty()) \n        {\n            super.remove(key);\n        }\n        \n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> coll = get(key);\n        if (coll == null) \n        {\n            return false;\n        }\n        boolean removed = coll.remove(value);\n        if (coll.isEmpty()) \n        {\n            remove(key);\n        }\n        return removed;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    if (node.getType() == Token.STRING) \n    {\n        node.setQuoted(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setQuoted(true);\n    }\n    else if (node.getType() == Token.STRING) \n    {\n        node.setQuoted(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setQuoted(true);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuoted(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  }\n  if (node.getType() == Token.STRING) {\n    node.setQuoted(true);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) \n  {\n    node.setType(Token.STRING);\n    node.setQuoted(true);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) \n  {\n    node.setType(Token.STRING);\n  }\n  if (node.getType() == Token.STRING) \n  {\n    node.setQuoted(true);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuoted(true);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuoted(true);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n    }\n    if (node.getType() == Token.STRING) \n    {\n        node.setQuoted(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    }\n    if (node.getType() == Token.STRING) {\n        node.setQuoted(true);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) \n  {\n    node.setType(Token.STRING);\n    node.setQuoted(true);\n  } \n  else if (node.getType() == Token.STRING) \n  {\n    node.setQuoted(true);\n  }\n  return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = base;\n    for (int i = 0; i < includedRows.length; i++) {\n        double v = dataset.getValue(includedRows[i], category).doubleValue();\n        if (asPercentages) {\n            v /= dataset.getColumnTotal(category).doubleValue();\n        }\n        total += v;\n        values.add(new Double(v));\n    }\n    values.add(new Double(total));\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null includedRows array.\");\n    }\n    List values = new ArrayList();\n    double total = base;\n    for (int row = 0; row < dataset.getRowCount(); row++) {\n        if (includedRows[row]) {\n            double v = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                v /= dataset.getTotalValue(category).doubleValue();\n            }\n            total += v;\n            values.add(new Double(v));\n        }\n    }\n    values.add(new Double(total));\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = base;\n    for (int row = 0; row < includedRows.length; row++) {\n        double value = dataset.getValue(includedRows[row], category).doubleValue();\n        if (value >= 0.0) {\n            total += value;\n        }\n        if (asPercentages) {\n            result.add(new Double(value / total));\n        }\n        else {\n            result.add(new Double(value + base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = base;\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows[row]) {\n            double value = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                value /= total;\n            }\n            values.add(new Double(value));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = base;\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category).doubleValue();\n        if (asPercentages) {\n            value /= dataset.getColumnCount();\n        }\n        values.add(new Double(value));\n        total += value;\n    }\n    if (asPercentages) {\n        total = 1.0;\n    }\n    for (int i = 0; i < values.size(); i++) {\n        double value = ((Double) values.get(i)).doubleValue();\n        values.set(i, new Double(value / total));\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = base;\n    for (int row = 0; row < includedRows.length; row++) {\n        double value = dataset.getValue(includedRows[row], category).doubleValue();\n        if (asPercentages) {\n            total += value;\n        }\n        result.add(new Double(value + base));\n        if (!asPercentages) {\n            base += value;\n        }\n    }\n    if (asPercentages) {\n        for (int i = 0; i < result.size(); i++) {\n            double value = ((Double) result.get(i)).doubleValue();\n            result.set(i, new Double(value / total));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category\");\n    }\n    List result = new ArrayList();\n    double total = base;\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (includedRows[i]) {\n            double value = dataset.getValue(i, category).doubleValue();\n            if (asPercentages) {\n                value /= dataset.getColumnTotal(category).doubleValue();\n            }\n            total += value;\n            result.add(new Double(value));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    result.add(new Double(total));\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = base;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        if (includedRows[series]) {\n            double value = dataset.getValue(series, category).doubleValue();\n            if (asPercentages) {\n                value /= dataset.getColumnTotal(category).doubleValue();\n            }\n            total += value;\n            result.add(new Double(total));\n        }\n        else {\n            result.add(new Double(total));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = base;\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows[row]) {\n            Number n = dataset.getValue(row, category);\n            if (n != null) {\n                double value = n.doubleValue();\n                total += value;\n                if (asPercentages) {\n                    value /= total;\n                }\n                values.add(new Double(value));\n            }\n            else {\n                values.add(null);\n            }\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null includedRows array\");\n    }\n\n    List result = new ArrayList();\n    double total = base;\n    int rowCount = dataset.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows[row]) {\n            double value = dataset.getValue(row, category).doubleValue();\n            if (asPercentages) {\n                value /= total;\n            }\n            result.add(new Double(value));\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    // Your implementation goes here\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) \n    {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes()) \n        {\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    // Your implementation here\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    List<Node> childNodes = childNodes();\n    List<Element> childElements = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof Element) \n        {\n            childElements.add((Element) node);\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    if (hash < 0) {\n        hash = -hash;\n    }\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() & 0x7fffffff;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    int he = Math.abs(hashCode % buckets.length);\n    return he;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash ^ (hash >>> 16);\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n\n    // If the hashCode is negative, we flip the sign and subtract 1.\n    // This ensures that the hashCode is always positive.\n    if (hashCode < 0) \n    {\n        hashCode = ~hashCode;\n        hashCode--;\n    }\n\n    // We then take the modulus of the hashCode and the number of buckets.\n    // This gives us the exact hash entry for the key.\n    return hashCode % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n\n    if (hashCode < 0) \n    {\n        hashCode = -hashCode;\n    }\n\n    return hashCode % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    return Math.abs(hashCode % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() & 0x7fffffff;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hashCode = key.hashCode();\n    return Math.abs(hashCode % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c - k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c <= k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c <= k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++) \n    {\n        for (int c = 0; c < cols; c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            if (r > c + k) {\n                d[r][c] = 0;\n            } else {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.RIGHT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.LEFT_HIGH;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double eps = 1e-14; // Define a tolerance for small values\n    double threshold = norm * eps;\n    for (int i = startIdx; i > 0; i--) {\n        if (FastMath.abs(matrixT[i][i - 1]) <= threshold) {\n            return i;\n        }\n    }\n    return 0; // If no small sub-diagonal element is found, return 0\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double eps = 1e-14; // tolerance for considering an element small\n    int iu = startIdx;\n    while (iu > 0 && (FastMath.abs(matrixT[iu][iu - 1]) * norm) < eps) {\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    double threshold = norm * EPSILON;\n    while (iu > 0 && matrixT[iu - 1][iu - 1] > threshold) {\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    double eps = norm * 1e-14;\n    while (iu > 0 && matrixT[iu - 1][iu - 1] > eps * norm) {\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    while (iu >= 0) {\n        final double threshold = norm * EPSILON;\n        if (FastMath.abs(matrixT[iu][iu - 1]) <= threshold) {\n            break;\n        }\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double eps = 1e-10; // tolerance for considering an element small\n    int idx = startIdx;\n    double absValue = FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n    double threshold = norm * eps;\n    while (idx < matrixT.length - 1 && absValue < threshold) {\n        idx++;\n        absValue += FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    double threshold = norm * 1.0e-14;\n    while (iu > 0 && matrixT[iu - 1][iu - 1] > threshold) {\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double eps = norm * 1e-10;\n    int iu = startIdx;\n    while (iu >= 0 && Math.abs(matrixT[iu][iu - 1]) > eps) {\n        iu--;\n    }\n    return iu;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double threshold = norm * EPSILON;\n    for (int i = startIdx; i < matrixT.length - 1; i++) {\n        double absDiag = FastMath.abs(matrixT[i][i]);\n        double absSubDiag = FastMath.abs(matrixT[i + 1][i]);\n        if (absSubDiag <= threshold * absDiag) {\n            idx = i;\n            break;\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int iu = startIdx;\n    double eps = norm * 1.0e-14;\n    while (iu > 0 && (FastMath.abs(matrixT[iu][iu - 1]) > eps * norm)) {\n        iu--;\n    }\n    return iu;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node current = top;\n    while (current != null) {\n        if (current.element.compareTo(reference) >= 0) {\n            return current;\n        }\n        current = current.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) \n    {\n        Node node = top;\n        while (node != null) \n        {\n            if (node.element.compareTo(reference) >= 0) \n            {\n                return node;\n            }\n            node = node.getNext();\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        int comparison = node.element.compareTo(reference);\n        if (comparison < 0) {\n            node = node.getNext();\n        } else if (comparison > 0) {\n            return node;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) \n    {\n        Node node = top;\n        while (node != null) \n        {\n            int comparisonResult = node.element.compareTo(reference);\n            if (comparisonResult == 0) \n            {\n                return node;\n            } else if (comparisonResult > 0) \n            {\n                node = node.getNext();\n            } else \n            {\n                return node;\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        int comparison = node.element.compareTo(reference);\n        if (comparison == 0) {\n            return node;\n        } else if (comparison < 0) {\n            node = node.getNext();\n        } else {\n            return node.getPrevious();\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) \n    {\n        Node node = top;\n        while (node != null) \n        {\n            int comparisonResult = node.element.compareTo(reference);\n            if (comparisonResult <= 0) \n            {\n                node = node.getNext();\n            } \n            else \n            {\n                return node;\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) \n    {\n        return null;\n    }\n    Node node = top;\n    while (node != null) \n    {\n        int comparison = node.element.compareTo(reference);\n        if (comparison > 0) \n        {\n            node = node.getPrevious();\n        } \n        else if (comparison < 0) \n        {\n            node = node.getNext();\n        } \n        else \n        {\n            return node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) {\n        return null;\n    }\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.getNext();\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) \n    {\n        Node node = top;\n        while (node != null) \n        {\n            int comparison = node.element.compareTo(reference);\n            if (comparison >= 0) \n            {\n                return node;\n            } else \n            {\n                node = node.getNext();\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference == null) \n    {\n        return null;\n    }\n    Node node = top;\n    while (node != null) \n    {\n        int comparison = node.element.compareTo(reference);\n        if (comparison == 0) \n        {\n            return node;\n        } \n        else if (comparison > 0) \n        {\n            node = node.getPrevious();\n        } \n        else \n        {\n            node = node.getNext();\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int i = 0;\n    while (true) {\n        i = indexOf(str, i);\n        if (i == -1) {\n            break;\n        }\n        deleteImpl(i, i + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    \n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n        index++;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int len = str.length();\n    int i = 0;\n    while ((i = indexOf(str, i)) != -1) \n    {\n        deleteImpl(i, i + len, len);\n        i += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(0)) {\n            int j = i + 1;\n            int k = 1;\n            while (j < size && k < len && buffer[j] == str.charAt(k)) {\n                j++;\n                k++;\n            }\n            if (k == len) {\n                deleteImpl(i, j, len);\n                i -= len;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null || str.length() == 0) {\n        return this;\n    }\n    \n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n        index++;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    \n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    \n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) \n    {\n        delete(index, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + len, len);\n        index++;\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    // Check if the node is a NAME in a parameter or variable declaration\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && (node.getParent() instanceof FunctionParamList\n            || node.getParent() instanceof VariableDeclaration)) {\n        \n        // Get the inline JSDocInfo from the node\n        JSDocInfo inlineJsDocInfo = node.getJSDocInfo();\n        \n        // If there is inline JSDocInfo, transform the node with the inline JSDocInfo\n        if (inlineJsDocInfo != null) {\n            Node transformedNode = transform(node);\n            transformedNode.setJSDocInfo(inlineJsDocInfo);\n            return transformedNode;\n        }\n    }\n    \n    // If the node is not a NAME in a parameter or variable declaration with inline JSDocInfo,\n    // just transform the node and return it\n    return transform(node);\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        final Set<E> set = new HashSet<>(list);\n        return new SetUniqueList<>(list, set);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> uniqueList = new SetUniqueList<>(list, set);\n    // remove duplicates\n    for (final Iterator<E> it = list.iterator(); it.hasNext();) {\n        if (!set.add(it.next())) {\n            it.remove();\n        }\n    }\n    return new SetUniqueList<>(uniqueList, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> result = new SetUniqueList<>(list, set);\n    set.addAll(list);\n    return new SetUniqueList<>(result, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> result = new SetUniqueList<>(list, set);\n    set.addAll(list);\n    return new SetUniqueList<>(result, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        final Set<E> set = new HashSet<>(list);\n        list.retainAll(set);\n        return new SetUniqueList<>(list, set);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> result = new SetUniqueList<>(list, set);\n    set.addAll(list);\n    return new SetUniqueList<>(result, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        final Set<E> set = new HashSet<>(list);\n        return new SetUniqueList<>(list, set);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> result = new SetUniqueList<>(list, set);\n    set.addAll(list);\n    return new SetUniqueList<>(result, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>();\n    final List<E> uniqueList = new SetUniqueList<>(list, set);\n    set.addAll(list);\n    return new SetUniqueList<>(uniqueList, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<>(list);\n    list.retainAll(set);\n    return new SetUniqueList<>(list, set);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  token = next();\n  skipEOLs();\n  if (match(JsDocToken.ELLIPSIS)) \n  {\n    Node rest = newNode(Token.ELLIPSIS);\n    rest.addChildToBack(parseTypeExpression(next()));\n    arrayType.addChildToBack(rest);\n  } \n  else \n  {\n    do \n    {\n      if (arrayType.getChildCount() > 0) \n      {\n        skipEOLs();\n        token = next();\n        Preconditions.checkState(\n          token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n        if (token == JsDocToken.ELLIPSIS) \n        {\n          Node rest = newNode(Token.ELLIPSIS);\n          rest.addChildToBack(parseTypeExpression(next()));\n          arrayType.addChildToBack(rest);\n          break;\n        }\n      }\n      Node expr = parseTypeExpression(token);\n      if (expr == null) \n      {\n        return null;\n      }\n      arrayType.addChildToBack(expr);\n    } while (match(JsDocToken.COMMA));\n  }\n  skipEOLs();\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n        return null;\n    }\n    next();\n\n    Node arrayType = newNode(Token.ARRAYLIT);\n    Node expr = null;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                    token == JsDocToken.COMMA || token == JsDocToken.RB);\n\n            if (match(JsDocToken.RB)) \n            {\n                next();\n                return arrayType;\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(expr);\n    } while (match(JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  Node expr = null;\n  do \n  {\n    if (expr != null) \n    {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(\n          token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n      boolean isPipe = token == JsDocToken.PIPE;\n      if (isPipe && match(JsDocToken.PIPE)) \n      {\n        // We support double pipes for backwards compatibility.\n        next();\n      }\n      skipEOLs();\n      token = next();\n    }\n    expr = parseTypeExpression(token);\n    if (expr == null) \n    {\n      return null;\n    }\n\n    arrayType.addChildToBack(expr);\n    // We support commas for backwards compatibility.\n  } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LB)) {\n        return null;\n    }\n    next();\n\n    Node arrayType = newNode(Token.ARRAYLIT);\n    Node expr = null;\n    do {\n        if (expr != null) {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                    token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n\n            boolean isEllipsis = token == JsDocToken.ELLIPSIS;\n            if (isEllipsis && match(JsDocToken.ELLIPSIS)) {\n                // We support double ellipsis for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) {\n            return null;\n        }\n\n        arrayType.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.ARRAYLIT);\n    Node expr = null;\n    boolean isVarArgs = false;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                    token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n            boolean isPipe = token == JsDocToken.PIPE;\n            if (isPipe && match(JsDocToken.PIPE)) \n            {\n                // We support double pipes for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        array.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAYLIT);\n    if (!match(JsDocToken.LB)) {\n        return null;\n    }\n    next();\n    Node elementType = null;\n    do \n    {\n        if (elementType != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n            if (token == JsDocToken.ELLIPSIS) \n            {\n                next();\n                elementType = newNode(Token.ELLIPSIS, elementType);\n            }\n            skipEOLs();\n            token = next();\n        }\n        elementType = parseTypeExpression(token);\n        if (elementType == null) \n        {\n            return null;\n        }\n        arrayType.addChildToBack(elementType);\n    } \n    while (match(JsDocToken.COMMA));\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.ARRAYLIT);\n    Node expr = null;\n    boolean isVarArgs = false;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n            boolean isPipe = token == JsDocToken.PIPE;\n            if (isPipe && match(JsDocToken.PIPE)) \n            {\n                // We support double pipes for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        if (isVarArgs) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n        }\n\n        array.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAYLIT);\n    Node elementType = null;\n\n    if (match(JsDocToken.LB)) \n    {\n        next();\n        if (!match(JsDocToken.RB)) \n        {\n            elementType = parseTypeExpression(next());\n            if (elementType == null) \n            {\n                return null;\n            }\n            arrayType.addChildToBack(elementType);\n            while (match(JsDocToken.COMMA)) \n            {\n                next();\n                elementType = parseTypeExpression(next());\n                if (elementType == null) \n                {\n                    return null;\n                }\n                arrayType.addChildToBack(elementType);\n            }\n            if (!match(JsDocToken.RB)) \n            {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            next();\n        }\n    }\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.ARRAYLIT);\n  if (!match(JsDocToken.LB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n  next();\n  Node expr = null;\n  do \n  {\n    if (expr != null) \n    {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(\n          token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n      if (token == JsDocToken.ELLIPSIS) \n      {\n        next();\n      }\n      skipEOLs();\n      token = next();\n    }\n    expr = parseTypeExpression(token);\n    if (expr == null) \n    {\n      return null;\n    }\n    arrayType.addChildToBack(expr);\n  } \n  while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.ARRAYLIT);\n    Node expr = null;\n\n    if (!match(JsDocToken.LB)) \n    {\n        return null;\n    }\n    next();\n\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                    token == JsDocToken.RB || token == JsDocToken.COMMA);\n\n            boolean isRB = token == JsDocToken.RB;\n            if (isRB && match(JsDocToken.RB)) \n            {\n                // We support double brackets for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.RB, JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n  double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n  double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n  double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n  double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n  double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n  return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    \n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            try \n            {\n                if (i + 2 >= bytes.length) \n                {\n                    throw new DecoderException(\"Invalid encoding\");\n                }\n                final int u = Character.digit((char) bytes[i + 1], 16);\n                final int l = Character.digit((char) bytes[i + 2], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid encoding\");\n                }\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            try \n            {\n                if (i + 2 >= bytes.length) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: partial hex escape (missing two characters)\");\n                }\n                final int u = Character.digit((char) bytes[i + 1], 16);\n                final int l = Character.digit((char) bytes[i + 2], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: illegal hex characters\");\n                }\n                buffer.write((char) ((u << 4) + l));\n                i += 3;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \" + e.getMessage());\n            }\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            try \n            {\n                if (i + 2 >= bytes.length) \n                {\n                    throw new DecoderException(\"Invalid encoding\");\n                }\n                final int hex1 = Character.digit((char) bytes[i + 1], RADIX);\n                final int hex2 = Character.digit((char) bytes[i + 2], RADIX);\n                if (hex1 == -1 || hex2 == -1) \n                {\n                    throw new DecoderException(\"Invalid encoding\");\n                }\n                buffer.write((char) ((hex1 << 4) + hex2));\n                i += 3;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    \n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Character.digit((char) bytes[i + 1], 16);\n            final int l = Character.digit((char) bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((char) ((u << 4) + l));\n            i += 3;\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", new String(bytes));\n            }\n            final int b1 = Character.digit((char) bytes[i + 1], 16);\n            final int b2 = Character.digit((char) bytes[i + 2], 16);\n            if (b1 == -1 || b2 == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", new String(bytes));\n            }\n            buffer.write((byte) ((b1 << 4) + b2));\n            i += 3;\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Character.digit((char) bytes[i + 1], 16);\n            final int l = Character.digit((char) bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((u << 4) + l);\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    \n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            try \n            {\n                if (i + 2 >= bytes.length) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: \", new String(bytes));\n                }\n                final int u = Character.digit((char) bytes[i + 1], 16);\n                final int l = Character.digit((char) bytes[i + 2], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: \", new String(bytes));\n                }\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", new String(bytes));\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            final int hex1 = Character.digit((char) bytes[i + 1], 16);\n            final int hex2 = Character.digit((char) bytes[i + 2], 16);\n            if (hex1 == -1 || hex2 == -1) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            buffer.write((char) ((hex1 << 4) + hex2));\n            i += 3;\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        if (bytes[i] == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (bytes[i] == '%') \n        {\n            try \n            {\n                if (i + 2 >= bytes.length) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: incomplete trailing character pair\");\n                }\n                final int u = Character.digit((char) bytes[i + 1], 16);\n                final int l = Character.digit((char) bytes[i + 2], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: illegal character pair\");\n                }\n                buffer.write((char) ((u << 4) + l));\n                i += 3;\n            } \n            catch (final NumberFormatException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: illegal character pair\", e);\n            }\n        } \n        else \n        {\n            buffer.write(bytes[i]);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding:\");\n            }\n            final int u = Character.digit((char) bytes[i + 1], 16);\n            final int l = Character.digit((char) bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding:\");\n            }\n            buffer.write((u << 4) + l);\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(size - 1);\n    DateTimeField field2 = partial.getField(size - 2);\n    return field1.getRangeDurationField() == field2;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field = partial.getField(0);\n    DateTimeField nextField = partial.getField(1);\n    if (field.getRangeDurationField() != nextField.getRangeDurationField()) {\n        return false;\n    }\n    for (int i = 1; i < size - 1; i++) {\n        field = partial.getField(i);\n        nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getRangeDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    \n    DateTimeField[] fields = partial.getFields();\n    for (int i = 0; i < fields.length - 1; i++) {\n        if (!fields[i].getRangeDurationField().equals(fields[i + 1].getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(size - 1);\n    DateTimeField field2 = partial.getField(size - 2);\n    return field1.getRangeDurationField() == field2;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field = partial.getField(size - 1);\n    DateTimeField nextField = partial.getField(size - 2);\n    return field.getRangeEnd(partial.getValue(size - 1)) == nextField.getRangeStart(partial.getValue(size - 2));\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    \n    int size = partial.size();\n    if (size <= 1) {\n        return true;\n    }\n    \n    DateTimeField field = partial.getField(0);\n    DateTimeField nextField = partial.getField(1);\n    \n    return field.getRangeDurationField().equals(nextField.getDurationField());\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    if (partial.size() <= 1) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(0);\n    DateTimeField field2 = partial.getField(1);\n    return field1.getRangeDurationField() == field2.getDurationField();\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() <= 1) {\n        return true;\n    }\n    DateTimeField[] fields = partial.getFields();\n    DateTimeField startField = fields[0];\n    DateTimeField endField = fields[fields.length - 1];\n    return startField.getRangeDurationField() == endField.getRangeDurationField();\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    \n    // Check if the partial is contiguous\n    for (int i = 0; i < partial.size() - 1; i++) {\n        if (!partial.getFieldType(i).getRange().contains(partial.getValue(i + 1))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DateTimeField[] fields = partial.getFields();\n    int size = fields.length;\n    for (int i = 0; i < size - 1; i++) {\n        if (fields[i].getRangeDurationField() != fields[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, Integer.MAX_VALUE);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, Integer.MAX_VALUE);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) {\n        helper.setCardinality(obj, Integer.MAX_VALUE);\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, Integer.MAX_VALUE);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : a) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    for (O obj : b) \n    {\n        helper.setCardinality(obj, 1);\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  for (Node param : params.children()) \n  {\n    result.add(IR.string(param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.substring(0, 1).toUpperCase() + str.substring(1);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    str = capitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.substring(0, 1).toUpperCase() + str.substring(1);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) \n    {\n        convertedIds = new HashMap<String, String>();\n        convertedIds.put(\"CST6CDT\", \"America/Chicago\");\n        convertedIds.put(\"EST5EDT\", \"America/New_York\");\n        convertedIds.put(\"MST7MDT\", \"America/Denver\");\n        convertedIds.put(\"PST8PDT\", \"America/Los_Angeles\");\n        convertedIds.put(\"Japan\", \"Asia/Tokyo\");\n        convertedIds.put(\"Navajo\", \"America/Denver\");\n        convertedIds.put(\"Mexico_City\", \"America/Mexico_City\");\n        convertedIds.put(\"Chicago\", \"America/Chicago\");\n        convertedIds.put(\"New_York\", \"America/New_York\");\n        convertedIds.put(\"Denver\", \"America/Denver\");\n        convertedIds.put(\"Los_Angeles\", \"America/Los_Angeles\");\n        convertedIds.put(\"Hawaii\", \"Pacific/Honolulu\");\n        convertedIds.put(\"Australia/Perth\", \"Australia/Perth\");\n        convertedIds.put(\"Asia/Tokyo\", \"Asia/Tokyo\");\n        convertedIds.put(\"Europe/London\", \"Europe/London\");\n        convertedIds.put(\"Europe/Paris\", \"Europe/Paris\");\n        convertedIds.put(\"Europe/Berlin\", \"Europe/Berlin\");\n        convertedIds.put(\"Europe/Rome\", \"Europe/Rome\");\n        convertedIds.put(\"Europe/Madrid\", \"Europe/Madrid\");\n        convertedIds.put(\"Europe/Zurich\", \"Europe/Zurich\");\n        convertedIds.put(\"Europe/Brussels\", \"Europe/Brussels\");\n        convertedIds.put(\"Europe/Stockholm\", \"Europe/Stockholm\");\n        convertedIds.put(\"Europe/Istanbul\", \"Europe/Istanbul\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) {\n        convertedIds = new HashMap<String, String>();\n        // Add some known conversions\n        convertedIds.put(\"EST\", \"-05:00\");\n        convertedIds.put(\"EDT\", \"-04:00\");\n        convertedIds.put(\"CST\", \"-06:00\");\n        convertedIds.put(\"CDT\", \"-05:00\");\n        convertedIds.put(\"MST\", \"-07:00\");\n        convertedIds.put(\"MDT\", \"-06:00\");\n        convertedIds.put(\"PST\", \"-08:00\");\n        convertedIds.put(\"PDT\", \"-07:00\");\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) {\n        convertedIds = new HashMap<String, String>();\n        // Add your mappings here\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) \n    {\n        convertedIds = new HashMap<String, String>();\n        convertedIds.put(\"EST\", \"-05:00\");\n        convertedIds.put(\"EDT\", \"-04:00\");\n        convertedIds.put(\"CST\", \"-06:00\");\n        convertedIds.put(\"CDT\", \"-05:00\");\n        convertedIds.put(\"MST\", \"-07:00\");\n        convertedIds.put(\"MDT\", \"-06:00\");\n        convertedIds.put(\"PST\", \"-08:00\");\n        convertedIds.put(\"PDT\", \"-07:00\");\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) {\n        convertedIds = new HashMap<String, String>();\n        convertedIds.put(\"EST\", \"America/New_York\");\n        convertedIds.put(\"EDT\", \"America/New_York\");\n        convertedIds.put(\"CST\", \"America/Chicago\");\n        convertedIds.put(\"CDT\", \"America/Chicago\");\n        convertedIds.put(\"MST\", \"America/Denver\");\n        convertedIds.put(\"MDT\", \"America/Denver\");\n        convertedIds.put(\"PST\", \"America/Los_Angeles\");\n        convertedIds.put(\"PDT\", \"America/Los_Angeles\");\n        convertedIds.put(\"JST\", \"Asia/Tokyo\");\n        convertedIds.put(\"IST\", \"Asia/Kolkata\");\n        convertedIds.put(\"BST\", \"Europe/London\");\n        convertedIds.put(\"GMT\", \"Etc/GMT\");\n        convertedIds.put(\"UTC\", \"Etc/UTC\");\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) {\n        convertedIds = new HashMap<String, String>();\n        String[] oldIds = new String[] {\n            \"CST6CDT\", \"EST5EDT\", \"MST7MDT\", \"PST8PDT\", \"Navajo\", \"Mexico/BajaNorte\",\n            \"Mexico/BajaSur\", \"Mexico/Cancun\", \"Mexico/General\", \"Mexico/Puebla\",\n            \"Mexico/Tijuana\", \"Mexico/Winnipeg\", \"Canada/Atlantic\", \"Canada/Central\",\n            \"Canada/Eastern\", \"Canada/Mountain\", \"Canada/Newfoundland\", \"Canada/Pacific\",\n            \"Canada/Saskatchewan\", \"Canada/Yukon\", \"Etc/GMT+12\", \"Etc/GMT+11\",\n            \"Etc/GMT+10\", \"Etc/GMT+9\", \"Etc/GMT+8\", \"Etc/GMT+7\", \"Etc/GMT+6\",\n            \"Etc/GMT+5\", \"Etc/GMT+4\", \"Etc/GMT+3\", \"Etc/GMT+2\", \"Etc/GMT+1\",\n            \"Etc/GMT\", \"Etc/GMT-1\", \"Etc/GMT-2\", \"Etc/GMT-3\", \"Etc/GMT-4\",\n            \"Etc/GMT-5\", \"Etc/GMT-6\", \"Etc/GMT-7\", \"Etc/GMT-8\", \"Etc/GMT-9\",\n            \"Etc/GMT-10\", \"Etc/GMT-11\", \"Etc/GMT-12\", \"Etc/GMT-13\", \"Etc/GMT-14\",\n            \"Pacific/Honolulu\", \"Pacific/Niue\", \"Pacific/PagoPago\", \"Pacific/Rarotonga\",\n}\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) \n    {\n        convertedIds = new HashMap<String, String>();\n        // Add any known conversions here\n        convertedIds.put(\"CST6CDT\", \"America/Chicago\");\n        convertedIds.put(\"EST5EDT\", \"America/New_York\");\n        convertedIds.put(\"MST7MDT\", \"America/Denver\");\n        convertedIds.put(\"PST8PDT\", \"America/Los_Angeles\");\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) \n    {\n        convertedIds = new HashMap<String, String>();\n        // Add your mappings here\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) \n    {\n        convertedIds = new HashMap<String, String>();\n        // Add conversions here\n        convertedIds.put(\"EST\", \"America/New_York\");\n        convertedIds.put(\"EDT\", \"America/New_York\");\n        convertedIds.put(\"CST\", \"America/Chicago\");\n        convertedIds.put(\"CDT\", \"America/Chicago\");\n        convertedIds.put(\"MST\", \"America/Denver\");\n        convertedIds.put(\"MDT\", \"America/Denver\");\n        convertedIds.put(\"PST\", \"America/Los_Angeles\");\n        convertedIds.put(\"PDT\", \"America/Los_Angeles\");\n    }\n    return convertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (convertedIds == null) {\n        convertedIds = new HashMap<String, String>();\n        convertedIds.put(\"EST\", \"-05:00\");\n        convertedIds.put(\"EDT\", \"-04:00\");\n        convertedIds.put(\"CST\", \"-06:00\");\n        convertedIds.put(\"CDT\", \"-05:00\");\n        convertedIds.put(\"MST\", \"-07:00\");\n        convertedIds.put(\"MDT\", \"-06:00\");\n        convertedIds.put(\"PST\", \"-08:00\");\n        convertedIds.put(\"PDT\", \"-07:00\");\n    }\n    return convertedIds.get(id);\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian of the objective function.\n    double[][] jacobian = jF.jacobian(params);\n\n    // Check the dimension of the Jacobian.\n    if (jacobian.length != rows) {\n        throw new DimensionMismatchException(jacobian.length, rows);\n    }\n    if (jacobian[0].length != cols) {\n        throw new DimensionMismatchException(jacobian[0].length, cols);\n    }\n\n    // Compute the weighted Jacobian.\n    RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian);\n    weightedJacobian = weightedJacobian.multiply(weightMatrixSqrt);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Check if the Jacobian dimension matches the problem dimension.\n    if (params.length != jF.getDimension()) {\n        throw new DimensionMismatchException(params.length, jF.getDimension());\n    }\n\n    // Compute the Jacobian matrix.\n    final double[][] jacobian = jF.partialDerivative(params);\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(jacobian).multiply(weightMatrixSqrt);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian of the objective function.\n    final RealMatrix jacobian = jF.jacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    final RealMatrix sqrtWeightMatrix = weightMatrixSqrt;\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = sqrtWeightMatrix.multiply(jacobian);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = jF.jacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    final RealMatrix weightMatrixSqrt = this.weightMatrixSqrt;\n\n    // Multiply the Jacobian by the square-root of the weight matrix.\n    return jacobian.multiply(weightMatrixSqrt);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian of the objective function.\n    final double[][] jacobian = jF.partialDerivative(params);\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian);\n    return weightedJacobian.multiply(weightMatrixSqrt);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    RealMatrix jacobian = jF.jacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    RealMatrix sqrtWeightMatrix = weightMatrixSqrt;\n\n    // Multiply the Jacobian by the square-root of the weight matrix.\n    return jacobian.multiply(sqrtWeightMatrix);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian of the objective function.\n    final RealMatrix jacobian = jF.jacobian(params);\n\n    // Compute the square-root of the weight matrix.\n    final RealMatrix sqrtWeightMatrix = weightMatrixSqrt;\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = sqrtWeightMatrix.multiply(jacobian);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    if (jF == null) {\n        throw new IllegalStateException(\"Objective function has not been set\");\n    }\n    if (params.length != point.length) {\n        throw new DimensionMismatchException(params.length, point.length);\n    }\n    // Compute the Jacobian of the objective function.\n    final MultivariateDifferentiableVectorFunction jF = getObjectiveFunction();\n    final DerivativeStructure[] ds = jF.value(params);\n    final int dim = ds.length;\n    final RealMatrix jacobian = new Array2DRowRealMatrix(dim, point.length);\n    for (int i = 0; i < dim; i++) {\n        for (int j = 0; j < point.length; j++) {\n            jacobian.setEntry(i, j, ds[i].getPartialDerivative(j));\n        }\n    }\n    // Multiply by the square root of the weight matrix.\n    return weightMatrixSqrt.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix\n    RealMatrix jacobian = jF.jacobian(params);\n\n    // Compute the square-root of the weight matrix\n    RealMatrix sqrtWeightMatrix = weightMatrixSqrt;\n\n    // Multiply the Jacobian by the square-root of the weight matrix\n    RealMatrix weightedJacobian = sqrtWeightMatrix.multiply(jacobian);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    RealMatrix jacobian = jF.jacobian(params);\n\n    // Check the dimension of the Jacobian matrix.\n    if (jacobian.getRowDimension() != rows || jacobian.getColumnDimension() != cols) {\n        throw new DimensionMismatchException(jacobian.getRowDimension(), rows);\n    }\n\n    // Compute the weighted Jacobian: W<sup>1/2</sup> J.\n    RealMatrix weightedJacobian = jacobian.multiply(weightMatrixSqrt);\n\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    checkNotStarted();\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            set(i);\n        }\n        if (leastIndex == -1 || (comparator != null && comparator.compare(values.get(i), values.get(leastIndex)) < 0)) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i) && set(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i)) \n        {\n            if (!set(i)) \n            {\n                continue;\n            }\n        }\n        if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n        {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i) && set(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i) && set(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i) && set(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i) && set(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i) && set(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i)) \n        {\n            if (!set(i)) \n            {\n                continue;\n            }\n        }\n        if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n        {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator is set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (!valueSet.get(i) && set(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implementation goes here\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String propertyName = step.getName();\n    return new PropertyPointer(parentPointer, propertyName);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implementation of createChildPointerForStep method\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Your implementation here\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implement the logic to create the child pointer for the given step\n    // based on the parent pointer and the step information\n    // ...\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String propertyName = step.getName();\n    return new PropertyPointer(parentPointer, propertyName);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Your implementation here\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implement the logic to create the child pointer for the given step\n    // based on the parent pointer and the step information.\n    // Return the child pointer.\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implement the logic to create the child pointer for the given step\n    // based on the parent pointer and the step details.\n    // Return the child pointer.\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Implementation goes here\n}"
    ],
    [
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        return getLowerBound();\n    }\n}",
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        return getLowerBound();\n    }\n}",
      "public double getInf()  {\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) \n    {\n        inf = Math.min(inf, interval.getInf());\n    }\n    return inf;\n}",
      "public double getInf()  {\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) \n    {\n        if (interval.getInf() < inf) \n        {\n            inf = interval.getInf();\n        }\n    }\n    return inf;\n}",
      "public double getInf()  {\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) {\n        inf = Math.min(inf, interval.getInf());\n    }\n    return inf;\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return ((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) {\n        if (interval.getInf() < inf) {\n            inf = interval.getInf();\n        }\n    }\n    return inf;\n}",
      "public double getInf()  {\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) \n    {\n        inf = Math.min(inf, interval.getInf());\n    }\n    return inf;\n}",
      "public double getInf()  {\n    if (isEmpty()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    double inf = Double.POSITIVE_INFINITY;\n    for (final Interval interval : asList()) {\n        inf = Math.min(inf, interval.getInf());\n    }\n    return inf;\n}",
      "public double getInf()  {\n    double inf = Double.NEGATIVE_INFINITY;\n    for (final Interval interval : asList()) {\n        if (interval.getInf() > inf) {\n            inf = interval.getInf();\n        }\n    }\n    return inf;\n}",
      "public double getInf()  {\n    double inf = Double.NEGATIVE_INFINITY;\n    for (final Interval interval : asList()) \n    {\n        if (interval.getInf() > inf) \n        {\n            inf = interval.getInf();\n        }\n    }\n    return inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get( definingCalendar.getLocale() );\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent( definingCalendar.getLocale(), strategy );\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get( definingCalendar.getLocale() );\n    if ( strategy == null ) \n    {\n        strategy = new TextStrategy( field, definingCalendar );\n        final Strategy inCache = cache.putIfAbsent( definingCalendar.getLocale(), strategy );\n        if ( inCache != null ) \n        {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get( definingCalendar.getLocale() );\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent( definingCalendar.getLocale(), strategy );\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get( definingCalendar.getLocale() );\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent( definingCalendar.getLocale(), strategy );\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(definingCalendar.getLocale());\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar);\n        final Strategy inCache = cache.putIfAbsent(definingCalendar.getLocale(), strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Compute the Schur decomposition of the input matrix.\n    final SchurTransformer schur = new SchurTransformer(matrix);\n\n    // Compute the eigenvalues of the input matrix.\n    final double[] eigenvalues = schur.getEigenvalues();\n\n    // Compute the eigenvectors of the input matrix.\n    final RealMatrix eigenvectors = schur.getV();\n\n    // Create a new EigenDecomposition object with the eigenvalues and eigenvectors.\n    return new SchurTransformer(eigenvalues, eigenvectors);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Compute the Schur form of the matrix\n    final SchurTransformer schur = new SchurTransformer(matrix);\n\n    // Get the eigenvalues from the Schur form\n    final double[] eigenvalues = schur.getRealEigenvalues();\n\n    // Sort the eigenvalues and eigenvectors in increasing order\n    Arrays.sort(eigenvalues);\n\n    // Create the eigenvectors\n    final RealMatrix eigenvectors = schur.getV();\n    final int n = eigenvalues.length;\n    final ArrayRealVector[] eigenvectorArray = new ArrayRealVector[n];\n    for (int i = 0; i < n; i++) {\n        eigenvectorArray[i] = new ArrayRealVector(eigenvectors.getColumn(i));\n    }\n\n    // Create the result object\n    return new SchurTransformer(eigenvalues, eigenvectorArray);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Compute the Schur form of the matrix\n    final SchurTransformer schur = new SchurTransformer(matrix);\n\n    // Compute the eigenvalues\n    final double[] eigenvalues = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        eigenvalues[i] = schur.getEigenvalue(i).getReal();\n    }\n\n    return new SchurTransformer(schur.getTransformedMatrix(), eigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Compute the Schur decomposition of the matrix\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    \n    // Get the eigenvalues from the Schur decomposition\n    final double[] eigenvalues = transformer.getRealEigenvalues();\n    \n    // Return the Schur transformer\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Get the size of the matrix\n    final int n = matrix.getColumnDimension();\n\n    // Create a copy of the matrix to avoid modifying the original one\n    final RealMatrix copy = matrix.copy();\n\n    // Create a new matrix to store the eigenvalues\n    final double[] eigenvalues = new double[n];\n\n    // Create a new matrix to store the eigenvectors\n    final double[][] eigenvectors = new double[n][n];\n\n    // Create a new Schur transform object\n    final SchurTransformer schur = new SchurTransformer(copy, eigenvalues, eigenvectors);\n\n    // Return the Schur transform object\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Get the size of the matrix\n    final int n = matrix.getColumnDimension();\n\n    // Create a copy of the matrix\n    final RealMatrix copy = matrix.copy();\n\n    // Create a Schur transformer\n    final SchurTransformer transformer = new SchurTransformer(copy);\n\n    // Get the transformed matrix\n    final RealMatrix transformed = transformer.getTransformedMatrix();\n\n    // Get the eigenvalues\n    final double[] eigenvalues = transformer.getEigenvalues();\n\n    // Create a new array of eigenvectors\n    final ArrayRealVector[] eigenvectors = new ArrayRealVector[n];\n\n    // Get the eigenvectors\n    for (int i = 0; i < n; i++) {\n        eigenvectors[i] = new ArrayRealVector(transformer.getEigenvector(i));\n    }\n\n    // Create a new Schur transform\n    return new SchurTransformer(transformed, eigenvalues, eigenvectors);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final RealMatrix schurMatrix = transformer.getTransformedMatrix();\n    final double[] eigenvalues = transformer.getRealEigenvalues();\n    return new SchurTransformer(schurMatrix, eigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getColumnDimension();\n    final double[][] z = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        z[i][i] = 1.0;\n    }\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final RealMatrix t = schur.getT();\n    final RealMatrix q = schur.getQ();\n    final double[] e = new double[n];\n    double maxAbsoluteValue;\n    int j;\n    for (int m = n - 1; m >= 0; m--) {\n        double p = 0.0;\n        double q = 0.0;\n        double r = 0.0;\n        if (m > 0) {\n            e[m - 1] = t.getEntry(m - 1, m);\n        }\n        for (j = m; j < n; j++) {\n            r = r + FastMath.abs(e[j]);\n        }\n        if (r == 0.0) {\n            realEigenvalues[m] = t.getEntry(m, m);\n            imagEigenvalues[m] = 0.0;\n            e[m] = 0.0;\n        } else {\n            int l;\n            do {\n                l = j;\n                j++;\n                if (j == n) {\n                    j = l + 1;\n                    break;\n                }\n                p = e[l];\n                q = t.getEntry(l, j);\n                r = r - FastMath.abs(p) - FastMath.abs(q);\n                if (r >= 0.0) {\n                    break;\n                }\n                e[j - 1] = 0.0;\n            } while (true);\n            if (j == l + 1) {\n                double t1 = q - p;\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Create a copy of the matrix to avoid modifying the original\n    final RealMatrix copy = matrix.copy();\n    final int n = copy.getColumnDimension();\n    final double[] realEigenvalues = new double[n];\n    final double[][] z = new double[n][n];\n    final SchurTransformer transformer = new SchurTransformer(copy, realEigenvalues, z);\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // Get the size of the matrix\n    final int n = matrix.getColumnDimension();\n\n    // Create a copy of the matrix to be transformed\n    final RealMatrix copy = matrix.copy();\n\n    // Create a new matrix to store the eigenvalues\n    final double[] eigenvalues = new double[n];\n\n    // Create a new matrix to store the eigenvectors\n    final double[][] eigenvectors = new double[n][n];\n\n    // Perform the transformation\n    for (int i = n - 1; i >= 0; i--) {\n        // Compute the shift\n        double shift = copy.getEntry(i, i);\n        for (int j = i + 1; j < n; j++) {\n            shift += copy.getEntry(j, j);\n        }\n        shift /= n;\n\n        // Compute the Wilkinson shift\n        double w = copy.getEntry(i, i);\n        double wp = copy.getEntry(i + 1, i + 1);\n        double wpp = copy.getEntry(i + 2, i + 2);\n        double wppp = copy.getEntry(i + 3, i + 3);\n        double delta = (w - shift) * (w - shift) + wp * wp;\n        double phi = 0.5 * (delta + Math.sqrt(delta) * Math.sqrt(wpp - wp * wp + wppp - wpp * wp));\n        double q = Math.sqrt(phi + Math.sqrt(phi * phi + wpp - wp * wp));\n        double p = (w - shift) + q;\n        if (p < 0) {\n            p = -p;\n        }\n        double t = 0.0;\n\n        // Compute the Householder transformation\n        for (int j = i; j < n; j++) {\n            double e = copy.getEntry(j, i);\n            double f = e - p;\n            double g = 0.0;\n            if (j != i) {\n                g = copy.getEntry(j, i + 1);\n            }\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((value & (1L << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[index + i * Long.SIZE]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[index + i * Long.SIZE]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            if ((value & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + Long.numberOfTrailingZeros(value)]);\n            }\n            value >>>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & (Long.SIZE - 1));\n            final E constant = enumClass.getEnumConstants()[index];\n            result.add(constant);\n            value >>>= Long.SIZE;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((value & 1) == 1) \n            {\n                result.add(enumClass.getEnumConstants()[(i * Long.SIZE + j)]);\n            }\n            value >>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = Long.numberOfTrailingZeros(value);\n            result.add(enumClass.getEnumConstants()[i * Long.SIZE + index]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long newInstant = oldInstant + offset;\n    int newOffset = newZone.getOffset(newInstant);\n    if (offset != newOffset) {\n        long newInstant2 = newInstant + newOffset - offset;\n        // Check for overflow\n        if ((newInstant ^ newInstant2) < 0) {\n            throw new ArithmeticException(\"Converting time zone caused overflow\");\n        }\n        newInstant = newInstant2;\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertLocalToUTC(oldInstant, true), true);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID(), newZone.getID());\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant + offset;\n    long newInstant = newZone.convertLocalToUTC(localInstant, true);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertLocalToUTC(oldInstant, false), false);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID(), newZone.getID());\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), true);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID());\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant + offset;\n    long newOffset = newZone.getOffset(localInstant);\n    return localInstant - newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), false);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID());\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), false);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID());\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), true);\n    if (newInstant != oldInstant) {\n        throw new IllegalArgumentException(\"Instant must be in the same local time in the new zone\");\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), true);\n    if (newInstant != oldInstant) {\n        throw new IllegalInstantException(oldInstant, getID(), newZone.getID());\n    }\n    return newInstant;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int value = calendar.get(field);\n    calendar.clear(field);\n    calendar.set(field, value + 1);\n    Date nextDate = calendar.getTime();\n    return nextDate;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int value = calendar.get(unit.getCalendarField());\n    int years, months, days, hours;\n    switch (unit.getUnit()) {\n        case YEAR:\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                months = 0;\n                days = 1;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                months = 6;\n                days = 1;\n            }\n            else {\n                months = 11;\n                days = 31;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(value, months, days, 0, 0, 0);\n            Date d3 = calendar.getTime();\n            if (d3.getTime() >= date.getTime()) {\n                calendar.set(Calendar.YEAR, value + 1);\n                d3 = calendar.getTime();\n            }\n            return d3;\n        case MONTH:\n            years = calendar.get(Calendar.YEAR);\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, value, 1, 0, 0, 0);\n            Month month = new Month(calendar.getTime(), this.timeZone,\n                    this.locale);\n            Date standardDate = calculateDateForPosition(\n                    month, this.tickMarkPosition);\n            long millis = standardDate.getTime();\n            if (millis >= date.getTime()) {\n                month = (Month) month.next();\n                // need to peg the month in case the time zone isn't the\n                // default - see bug 2078057\n                month.peg(Calendar.getInstance(this.timeZone));\n                standardDate = calculateDateForPosition(\n                        month, this.tickMarkPosition);\n            }\n            return standardDate;\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int value = unit.getValue();\n    int years;\n    int months;\n    int hours;\n    int minutes;\n    int seconds;\n    if (field == Calendar.YEAR) {\n        years = value;\n        months = 0;\n        days = 1;\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (field == Calendar.MONTH) {\n        years = calendar.get(Calendar.YEAR);\n        months = value;\n        days = 1;\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (field == Calendar.DAY_OF_MONTH) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = value;\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (field == Calendar.HOUR_OF_DAY) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DAY_OF_MONTH);\n        hours = value;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (field == Calendar.MINUTE) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        days = calendar.get(Calendar.DAY_OF_MONTH);\n        hours = calendar.get(Calendar.HOUR_OF_DAY);\n        minutes = value;\n        seconds = 0;\n    }\n    else if (field == Calendar.SECOND) {\n        years = calendar.get(Calendar.YEAR);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int value = calendar.get(unit.getCalendarField());\n    int years, months, days, hours;\n    if (unit.equals(DateTickUnit.DAY)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.DAY_OF_MONTH, 1);\n    }\n    else if (unit.equals(DateTickUnit.HOUR)) {\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.HOUR_OF_DAY, 1);\n    }\n    else if (unit.equals(DateTickUnit.MINUTE)) {\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.MINUTE, 1);\n    }\n    else if (unit.equals(DateTickUnit.SECOND)) {\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.SECOND, 1);\n    }\n    else if (unit.equals(DateTickUnit.MILLISECOND)) {\n        calendar.add(Calendar.MILLISECOND, 1);\n    }\n    else if (unit.equals(DateTickUnit.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = getCalendarField(unit);\n    int value = calendar.get(field);\n    calendar.clear(field);\n    calendar.set(field, value + 1);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int value = calendar.get(unit.getCalendarField());\n    int years, months, days, hours;\n    switch (unit.getType()) {\n        case SECOND:\n            seconds++;\n            if (seconds >= 60) {\n                seconds = 0;\n                minutes++;\n                if (minutes >= 60) {\n                    minutes = 0;\n                    hours++;\n                    if (hours >= 24) {\n                        hours = 0;\n                        calendar.add(Calendar.DATE, 1);\n                    }\n                }\n            }\n            break;\n        case MINUTE:\n            minutes++;\n            if (minutes >= 60) {\n                minutes = 0;\n                hours++;\n                if (hours >= 24) {\n                    hours = 0;\n                    calendar.add(Calendar.DATE, 1);\n                }\n            }\n            break;\n        case HOUR:\n            hours++;\n            if (hours >= 24) {\n                hours = 0;\n                calendar.add(Calendar.DATE, 1);\n            }\n            break;\n        case DAY:\n            calendar.add(Calendar.DATE, 1);\n            break;\n        case WEEK:\n            calendar.add(Calendar.DATE, 7);\n            break;\n        case MONTH:\n            calendar.add(Calendar.MONTH, 1);\n            break;\n        case YEAR:\n            calendar.add(Calendar.YEAR, 1);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unsupported unit type.\");\n    }\n    calendar.set(Calendar.SECOND, seconds);\n    calendar.set(Calendar.MINUTE, minutes);\n    calendar.set(Calendar.HOUR_OF_DAY, hours);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int value = unit.getValue();\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n    if (field == Calendar.DAY_OF_MONTH) {\n        if (value == 1) {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n            calendar.add(Calendar.DAY_OF_MONTH, 1);\n        }\n        else {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n            calendar.add(Calendar.DAY_OF_MONTH, value - 1);\n        }\n    }\n    else if (field == Calendar.DAY_OF_YEAR) {\n        if (value == 1) {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n            calendar.add(Calendar.DAY_OF_YEAR, 1);\n        }\n        else {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = unit.getCalendarField();\n    int value = calendar.get(field);\n    int years, months, days, hours;\n    switch (unit.getUnit()) {\n        case YEAR:\n            if (this.tickMarkPosition == DateTickMarkPosition.START) {\n                months = 0;\n                days = 1;\n            }\n            else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n                months = 6;\n                days = 1;\n            }\n            else {\n                months = 11;\n                days = 31;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(value, months, days, 0, 0, 0);\n            Date d3 = calendar.getTime();\n            if (d3.getTime() >= date.getTime()) {\n                calendar.set(Calendar.YEAR, value + 1);\n                d3 = calendar.getTime();\n            }\n            return d3;\n        case MONTH:\n            years = calendar.get(Calendar.YEAR);\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, value, 1, 0, 0, 0);\n            Month month = new Month(calendar.getTime(), this.timeZone,\n                    this.locale);\n            Date standardDate = calculateDateForPosition(\n                    month, this.tickMarkPosition);\n            long millis = standardDate.getTime();\n            if (millis >= date.getTime()) {\n                month = (Month) month.next();\n                // need to peg the month in case the time zone isn't the\n                // default - see bug 2078057\n                month.peg(Calendar.getInstance(this.timeZone));\n                standardDate = calculateDateForPosition(\n                        month, this.tickMarkPosition);\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int field = getCalendarField(unit);\n    int value = calendar.get(field);\n    calendar.set(field, value + 1);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n    int value = calendar.get(unit.getCalendarField());\n    int years, months, hours, minutes, seconds, days;\n\n    if (unit.equals(DateTickUnit.YEAR)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            months = 0;\n            days = 1;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            months = 6;\n            days = 1;\n        }\n        else {\n            months = 11;\n            days = 31;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(value + 1, months, days, 0, 0, 0);\n        Date d3 = calendar.getTime();\n        return d3;\n    }\n    else if (unit.equals(DateTickUnit.MONTH)) {\n        years = calendar.get(Calendar.YEAR);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, value + 1, 1, 0, 0, 0);\n        Month month = new Month(calendar.getTime(), this.timeZone,\n                this.locale);\n        Date standardDate = calculateDateForPosition(\n                month, this.tickMarkPosition);\n        return standardDate;\n    }\n    else if (unit.equals(DateTickUnit.DAY)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        hours = 23;\n        minutes = 59;\n        seconds = 59;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value + 1, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        return d2;\n    }\n    else {\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    VariableResolver resolver = getVariableResolver();\n    if (resolver != null) \n    {\n        return resolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Implementation of resolveVariable method\n    // Use the variable resolver to get the value of the variable\n    VariableResolver resolver = getVariableResolver();\n    if (resolver != null) {\n        return resolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Your implementation here\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Your implementation here\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Implementation using the getVariableResolver() method\n    VariableResolver resolver = getVariableResolver();\n    if (resolver != null) \n    {\n        return resolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Add your implementation here\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Implementation using the default variable resolver\n    VariableResolver resolver = getVariableResolver();\n    if (resolver != null) \n    {\n        return resolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.resolve(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    VariableResolver resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.resolve(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    VariableResolver resolver = getVariableResolver();\n    if (resolver != null) \n    {\n        return resolver.resolve(variableName);\n    }\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastCode = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char code = map(c);\n        if (code != '0' && code != lastCode) \n        {\n            sb.append(code);\n        }\n        lastCode = code;\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastCode = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char code = map(c);\n        if (code != '0' && code != lastCode) \n        {\n            sb.append(code);\n            lastCode = code;\n        }\n    }\n    while (sb.length() < this.maxLength) \n    {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    char firstChar = str.charAt(0);\n    StringBuilder sb = new StringBuilder(MAX_SOUNDEX_LENGTH);\n    sb.append(firstChar);\n    char lastConsonant = map(firstChar);\n    for (int i = 1; i < str.length(); i++) {\n        char c = str.charAt(i);\n        char mappedChar = map(c);\n        if (mappedChar != lastConsonant) {\n            sb.append(mappedChar);\n            lastConsonant = mappedChar;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        final char current = map(str.charAt(i));\n        if (current != last) {\n            if (current != '0') {\n                sb.append(current);\n            }\n            last = current;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    char last = map(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char current = map(chars[i]);\n        if (current != last && current != '0') {\n            sb.append(current);\n            last = current;\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    char last = map(chars[0]);\n    for (int i = 1; i < chars.length; i++) \n    {\n        char c = map(chars[i]);\n        if (c != last) \n        {\n            sb.append(c);\n            last = c;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char current = map(str.charAt(i));\n        if (current != '0' && current != last) \n        {\n            sb.append(current);\n            last = current;\n        }\n    }\n    while (sb.length() < this.maxLength) \n    {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] out = new char[4];\n    out[0] = str.charAt(0);\n    int j = 1, count = 1;\n    for (int i = 1; i < str.length() && j < 4; i++) \n    {\n        char current = str.charAt(i);\n        char previous = str.charAt(i - 1);\n        if (current == previous) \n        {\n            continue;\n        }\n        char mapped = map(current);\n        if (mapped != '0') \n        {\n            if (count == 1) \n            {\n                out[j++] = mapped;\n            } \n            else \n            {\n                if (mapped != out[j - 1]) \n                {\n                    out[j++] = mapped;\n                }\n            }\n            count++;\n        }\n    }\n    while (j < 4) \n    {\n        out[j++] = '0';\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] out = new char[4];\n    out[0] = str.charAt(0);\n    char last = map(str.charAt(0));\n    int count = 1;\n    for (int i = 1; i < str.length() && count < 4; i++) \n    {\n        char c = map(str.charAt(i));\n        if (c != last) \n        {\n            if (c != '0') \n            {\n                out[count++] = c;\n            }\n            last = c;\n        }\n    }\n    while (count < 4) \n    {\n        out[count++] = '0';\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char current = map(str.charAt(i));\n        if (current != '0' && current != last) \n        {\n            sb.append(current);\n            last = current;\n        }\n    }\n    while (sb.length() < 4) \n    {\n        sb.append('0');\n    }\n    return sb.toString();\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == List.class) {\n        return CORE_TYPE_LIST;\n    } else if (clz == Map.class) {\n        return CORE_TYPE_MAP;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    // Add more well-known types here if needed\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHARACTER;\n    }\n    if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Float.class || clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class || clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Short.class || clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Byte.class || clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Character.class || clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Void.class || clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    // Add more if needed\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n        if (lhs.isGetProp() && rhs.isFunction()) {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n    Node getProp = lhs;\n    Node obj = getProp.getFirstChild();\n    if (!obj.isGetProp() || !obj.getLastChild().getString().equals(\"prototype\")) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(getProp, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && NodeUtil.isPrototypeProperty(lhs)) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isAssign()) {\n    return null;\n  }\n\n  Node lhs = n.getFirstChild();\n  Node rhs = n.getLastChild();\n\n  if (!lhs.isGetProp() || !lhs.getLastChild().getString().equals(\"prototype\")) {\n    return null;\n  }\n\n  Node prototypeOwner = lhs.getFirstChild();\n  if (!prototypeOwner.isGetProp() || !prototypeOwner.getLastChild().getString().equals(\"prototype\")) {\n    return null;\n  }\n\n  Node classNameNode = prototypeOwner.getFirstChild();\n  if (!classNameNode.isName()) {\n    return null;\n  }\n\n  return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isAssign()) \n  {\n    return null;\n  }\n  Node lhs = n.getFirstChild();\n  if (!lhs.isGetProp() || !lhs.getLastChild().getString().equals(\"prototype\")) \n  {\n    return null;\n  }\n  Node rhs = n.getLastChild();\n  if (!rhs.isFunction()) \n  {\n    return null;\n  }\n  return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp()) \n    {\n        Node lhs = n.getFirstChild();\n        if (NodeUtil.getPrototypePropertyName(lhs) != null) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign()) \n  {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp() && NodeUtil.isPrototypeProperty(lhs)) \n    {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n    Node rhs = n.getLastChild();\n    if (!rhs.isFunction()) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isAssign()) {\n    return null;\n  }\n  Node lhs = n.getFirstChild();\n  Node rhs = n.getLastChild();\n  if (!lhs.isGetProp() || !lhs.getLastChild().getString().equals(\"prototype\")) {\n    return null;\n  }\n  lhs = lhs.getFirstChild();\n  if (!lhs.isGetProp() || !lhs.getLastChild().getString().equals(\"prototype\")) {\n    return null;\n  }\n  lhs = lhs.getFirstChild();\n  if (!lhs.isName()) {\n    return null;\n  }\n  return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp() && n.getFirstChild().getFirstChild().isGetProp()) \n    {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n        if (lhs.getLastChild().getString().equals(\"prototype\")) \n        {\n            return new PrototypeMemberDeclaration(lhs, rhs);\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int row = mat.getRowDimension();\n    int col = mat.getColumnDimension();\n    double[][] result = new double[row * n][col * m];\n    for (int i = 0; i < row; i++) \n    {\n        for (int j = 0; j < col; j++) \n        {\n            for (int r = 0; r < n; r++) \n            {\n                for (int c = 0; c < m; c++) \n                {\n                    result[i * n + r][j * m + c] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix with the desired dimensions\n    RealMatrix result = new Array2DRowRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n\n    // Copy the input matrix into the result matrix\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            result.setSubMatrix(mat.getSubMatrix(0, mat.getRowDimension() - 1, 0, mat.getColumnDimension() - 1), i * mat.getRowDimension(), j * mat.getColumnDimension());\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] result = new double[rows * n][cols * m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < rows; k++) {\n                for (int l = 0; l < cols; l++) {\n                    result[i * rows + k][j * cols + l] = mat.getEntry(k, l);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] result = new double[rows * n][cols * m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < rows; r++) {\n                for (int c = 0; c < cols; c++) {\n                    result[i * rows + r][j * cols + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix with the desired dimensions\n    RealMatrix result = new Array2DRowRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n\n    // Copy the original matrix into the result matrix\n    for (int i = 0; i < mat.getRowDimension(); i++) {\n        for (int j = 0; j < mat.getColumnDimension(); j++) {\n            result.setEntry(i * n + (i % n), j * m + (j % m), mat.getEntry(i, j));\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix with the desired dimensions\n    RealMatrix result = new Array2DRowRealMatrix(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n\n    // Copy the original matrix into the result matrix\n    for (int i = 0; i < mat.getRowDimension(); i++) {\n        for (int j = 0; j < mat.getColumnDimension(); j++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < m; c++) {\n                    result.setEntry(i * n + r, j * m + c, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    // Create a new matrix with the desired dimensions\n    RealMatrix result = new Array2DRowRealMatrix(n * mat.getRowDimension(), m * mat.getColumnDimension());\n\n    // Copy the original matrix into the result matrix\n    for (int i = 0; i < mat.getRowDimension(); i++) {\n        for (int j = 0; j < mat.getColumnDimension(); j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    result.setEntry(i + k * mat.getRowDimension(), j + l * mat.getColumnDimension(), mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int originalRowCount = mat.getRowDimension();\n    int originalColumnCount = mat.getColumnDimension();\n    double[][] result = new double[originalRowCount * n][originalColumnCount * m];\n    \n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < originalRowCount; k++) \n            {\n                for (int l = 0; l < originalColumnCount; l++) \n                {\n                    result[i * originalRowCount + k][j * originalColumnCount + l] = mat.getEntry(k, l);\n                }\n            }\n        }\n    }\n    \n    return new Array2DRowRealMatrix(result, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    if (top == null) \n    {\n        return null;\n    }\n    Node node = top;\n    while (node != null) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return node;\n            }\n            node = node.left;\n        } \n        else \n        {\n            if (node.right == null) \n            {\n                return node;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesRead) {\n        bytesInflated += (current.bytesRead - bytesInflated) % (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesInflated();\n    if (result < current.bytesRead) {\n        result += (1L << 32);\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long infCount = inf.getBytesInflated();\n    if (infCount < current.bytesRead) \n    {\n        infCount += (current.bytesRead - infCount) >>> 32;\n    }\n    return infCount;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesInflated();\n    if (result < current.bytesRead) {\n        result += (1L << 32);\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesRead) \n    {\n        bytesInflated += (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesRead;\n    final long bytesReadFromStream = current.bytesReadFromStream;\n    final int diff = (int) (bytesReadFromStream - bytesRead);\n    return bytesRead - diff;\n}",
      "private long getBytesInflated()  {\n    long infBytes = inf.getBytesInflated();\n    long totalBytes = current.bytesReadFromStream;\n    if (infBytes > totalBytes) \n    {\n        long diff = infBytes - totalBytes;\n        if (diff < Integer.MAX_VALUE) \n        {\n            return totalBytes;\n        }\n        return infBytes;\n    }\n    return infBytes;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesRead) \n    {\n        bytesInflated += (current.bytesRead - bytesInflated) % (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesInflated();\n    if (result < current.bytesRead) \n    {\n        result += (1L << 32);\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesRead) {\n        bytesInflated += (1L << 32);\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    boolean isEmpty = false;\n    if (object instanceof Map<?,?>) \n    {\n        isEmpty = ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        isEmpty = ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        isEmpty = !((Iterable<?>) object).iterator().hasNext();\n    } \n    else if (object instanceof Object[]) \n    {\n        isEmpty = ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        isEmpty = !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        isEmpty = !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            isEmpty = Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return isEmpty;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?,?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?,?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    boolean isEmpty = false;\n    if (object instanceof Map<?,?>) \n    {\n        isEmpty = ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        isEmpty = ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        isEmpty = !IterableUtils.iterator((Iterable<?>) object).hasNext();\n    } \n    else if (object instanceof Object[]) \n    {\n        isEmpty = ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        isEmpty = !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        isEmpty = !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            isEmpty = Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return isEmpty;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    boolean isEmpty = false;\n    if (object instanceof Map<?,?>) \n    {\n        isEmpty = ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        isEmpty = ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        isEmpty = IterableUtils.isEmpty((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        isEmpty = ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        isEmpty = !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        isEmpty = !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            isEmpty = Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return isEmpty;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n        return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!TokenStream.isJSIdentifier(name)) \n    {\n        return false;\n    }\n    int index = name.indexOf(\".\");\n    if (index == -1) \n    {\n        return isValidSimpleName(name);\n    }\n    return isValidQualifiedName(name.substring(0, index)) &&\n        isValidSimpleName(name.substring(index + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.contains(\".\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name) && !name.contains(\".\");\n}\n  // so that the results are different for es5 and es3.",
      "public static boolean isValidQualifiedName(String name)  {\n  int dotIndex = name.indexOf('.');\n  if (dotIndex == -1) \n  {\n    return isValidSimpleName(name);\n  } \n  else \n  {\n    String left = name.substring(0, dotIndex);\n    String right = name.substring(dotIndex + 1);\n    return isValidSimpleName(left) && isValidQualifiedName(right);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    double[] h = new double[matrixT.length];\n    double norm = getNorm();\n    int l = findSmallSubDiagonalElement(startIdx, norm);\n    computeShift(l, iu, iteration, shift);\n    for (int i = l; i < matrixT.length; i++) {\n        h[i] = matrixT[i][i] - shift.x;\n    }\n    double scale = FastMath.abs(h[l]);\n    for (int i = l + 1; i < matrixT.length; i++) {\n        scale = FastMath.max(scale, FastMath.abs(h[i]));\n    }\n    if (scale == 0.0) {\n        scale = norm;\n    }\n    for (int i = l; i < matrixT.length; i++) {\n        h[i] /= scale;\n    }\n    double beta = scale * FastMath.sqrt(h[l] * h[l] + h[l + 1] * h[l + 1]);\n    double gamma = FastMath.abs(h[l] + beta);\n    if (gamma == 0.0) {\n        gamma = norm;\n    }\n    double theta = h[l + 1] / gamma;\n    double tau = (gamma - beta) / (2.0 * theta);\n    double sigma = FastMath.sqrt(tau * tau + 1.0);\n    double tauP = tau;\n    if (theta < 0.0) {\n        tauP = -sigma;\n    } else if (theta > 0.0) {\n        tauP = sigma;\n    }\n    double p = (gamma + beta) / (2.0 * theta);\n    double q = tauP * p;\n    double r = FastMath.sqrt(p * p + q * q);\n    double t1 = gamma - r;\n    double t2 = beta + r;\n    double t3 = tauP * t2;\n    double t4 = t1 * t2;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Compute the householder vector for the QR step\n    double maxElem = 0.0;\n    int startIdx = il;\n    for (int i = il; i <= iu; i++) {\n        double absElem = FastMath.abs(matrixT[i][il]);\n        if (absElem > maxElem) {\n            maxElem = absElem;\n            startIdx = i;\n        }\n    }\n\n    // Compute the householder vector\n    double scale = 0.0;\n    for (int i = il; i <= iu; i++) {\n        hVec[i] = matrixT[i][il] / maxElem;\n        scale += hVec[i] * hVec[i];\n    }\n    scale = FastMath.sqrt(scale);\n    if (hVec[startIdx] < 0.0) {\n        scale = -scale;\n    }\n    hVec[startIdx] += scale;\n\n    // Compute the Householder transformation matrix\n    for (int i = il; i <= iu; i++) {\n        for (int j = il; j <= iu; j++) {\n            if (i == j) {\n                matrixT[i][j] = -scale;\n            } else {\n                matrixT[i][j] = hVec[i] * hVec[j];\n            }\n        }\n    }\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the householder vectors for the QR step\n    int startIdx = il;\n    if (shift.y != 0.0) {\n        // Compute the Householder vector for the QR step\n        double norm = 0.0;\n        for (int i = il; i <= iu; i++) {\n            norm += FastMath.abs(matrixT[i][il]);\n        }\n        double scale = FastMath.sqrt(norm);\n        double beta = scale * (matrixT[il][il] - shift.x);\n        double gamma = scale * (matrixT[il][il] - shift.y);\n        double tau = (beta - gamma) / (beta + gamma);\n        double theta = 0.5 * (tau * (beta + gamma) + (tau * tau - 1.0) * (beta - gamma));\n        double psi = 0.5 * (theta + FastMath.sqrt(theta * theta + 1.0));\n        double c = 1.0 / FastMath.sqrt(1.0 + psi * psi);\n        double s = psi * c;\n        double t = c * c;\n        hVec[0] = 1.0;\n        for (int i = 1; i <= iu - il; i++) {\n            double temp = matrixT[il + i][il];\n            matrixT[il + i][il] = t * temp - s * matrixT[il + i][il + 1];\n            matrixT[il + i][il + 1] = s * temp + t * matrixT[il + i][il + 1];\n            hVec[i] = t * hVec[i - 1] - s * hVec[i];\n        }\n        hVec[iu - il] = s * hVec[iu - il - 1];\n        matrixT[iu][iu] = t * matrixT[iu][iu] - s * matrixT[iu][iu - 1];\n        hVec[iu - il] = c * hVec[iu - il];\n        startIdx = il + 1;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    double s = 0.0;\n    double t = 0.0;\n    double p = 0.0;\n\n    if (il < iu) {\n        // Compute the Householder transformation for the current column\n        for (int i = il; i < iu; i++) {\n            s += FastMath.abs(matrixT[i][il]);\n        }\n        if (s != 0.0) {\n            p = matrixT[iu][il] / s;\n            t = 1.0 / (p * p + 1.0);\n            for (int i = il; i < iu; i++) {\n                hVec[i] = matrixT[i][il] / s;\n                matrixT[i][il] = p * hVec[i];\n            }\n            for (int j = il; j < iu; j++) {\n                double q = 0.0;\n                for (int i = il; i < iu; i++) {\n                    q += hVec[i] * matrixT[i][j];\n                }\n                double r = t * (q + p * matrixT[iu][j]);\n                for (int i = il; i < iu; i++) {\n                    matrixT[i][j] -= r * hVec[i];\n                }\n            }\n        }\n    } else {\n        // If the column is already zero, no Householder transformation is needed\n        startIdx = il + 1;\n    }\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    double hNorm = 0.0;\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i - il] = matrixT[i][i] - shift.x;\n        hNorm += hVec[i - il] * hVec[i - il];\n    }\n    hNorm = FastMath.sqrt(hNorm);\n    double scale = hVec[il - il] / hNorm;\n    for (int i = il; i <= iu; i++) \n    {\n        hVec[i - il] = scale * hVec[i - il];\n    }\n    hVec[iu - il] += 1.0;\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    double[] hVecCopy = Arrays.copyOf(hVec, hVec.length);\n\n    for (int i = il; i < iu; i++) {\n        // Compute the householder vector\n        double norm = 0.0;\n        for (int j = i; j < matrixT.length; j++) {\n            norm += FastMath.abs(matrixT[j][i]);\n        }\n        if (norm == 0.0) {\n            norm = getNorm();\n        }\n        double beta = FastMath.sqrt(norm * norm + shift.w);\n        if (shift.w == 0.0) {\n            if (matrixT[i][i] < 0.0) {\n                beta = -beta;\n            }\n        } else {\n            double t = (matrixT[i][i] - shift.x) * (matrixT[i][i] - shift.x) + shift.w;\n            if (t < 0.0) {\n                beta = -beta;\n            }\n        }\n        hVec[i] = (beta - matrixT[i][i]) / norm;\n        matrixT[i][i] = -beta;\n\n        // Apply the householder vector to the remaining sub-matrix\n        for (int j = i + 1; j < matrixT.length; j++) {\n            double dotProduct = 0.0;\n            for (int k = i; k < matrixT.length; k++) {\n                dotProduct += matrixT[j][k] * hVecCopy[k];\n            }\n            for (int k = i; k < matrixT.length; k++) {\n                matrixT[j][k] -= dotProduct * hVec[k];\n            }\n        }\n\n        // Check if the sub-matrix is now triangular\n        if (matrixT[i + 1][i] == 0.0) {\n            startIdx = i + 1;\n            break;\n        }\n    }\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    if (il < iu) \n    {\n        // Compute the Householder transformation for the current QR step\n        double norm = 0.0;\n        for (int i = il; i < iu; i++) \n        {\n            norm += FastMath.abs(matrixT[i][i]);\n        }\n        if (norm > 0.0) \n        {\n            double scale = FastMath.abs(matrixT[il][il]);\n            for (int i = il + 1; i < iu; i++) \n            {\n                scale = FastMath.max(scale, FastMath.abs(matrixT[i][i]));\n            }\n            double s = 0.0;\n            for (int i = il; i < iu; i++) \n            {\n                hVec[i] = matrixT[i][i] / scale;\n                s += hVec[i] * hVec[i];\n            }\n            double tau = scale * Math.sqrt(s);\n            if (hVec[il] < 0.0) \n            {\n                tau = -tau;\n            }\n            hVec[il] += tau;\n            for (int i = il; i < iu; i++) \n            {\n                matrixT[i][i] = -tau * hVec[i];\n            }\n            for (int j = il; j < iu; j++) \n            {\n                double v = 0.0;\n                for (int i = il; i < iu; i++) \n                {\n                    v += hVec[i] * matrixT[i][j];\n                }\n                for (int i = il; i < iu; i++) \n                {\n                    matrixT[i][j] -= v * hVec[i];\n                }\n            }\n            startIdx = il + 1;\n        }\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    if (shift.y != 0.0) {\n        double tau = computeTau(iu, shift.y, hVec);\n        performQRStep(il, iu, shift, tau, hVec);\n        startIdx = iu;\n    }\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    if (shift.w != 0.0) \n    {\n        double tau = 0.0;\n        double c = 1.0;\n        double s = 0.0;\n        double x = matrixT[iu - 1][iu - 1] - shift.x;\n        double y = matrixT[iu][iu - 1];\n        double z = 0.0;\n\n        // Generate Householder vector\n        for (int i = iu - 1; i >= il; i--) \n        {\n            double h = FastMath.sqrt(x * x + y * y + z * z);\n            if (h == 0.0) \n            {\n                hVec[i] = 0.0;\n            } \n            else \n            {\n                hVec[i] = h;\n                double invH = 1.0 / h;\n                double u = x * invH;\n                double v = y * invH;\n                double w = z * invH;\n                x = matrixT[i][i] - shift.x;\n                y = matrixT[i + 1][i];\n                z = matrixT[i + 1][i + 1] - shift.x;\n                tau = (u * x + v * y + w * z) / 2.0;\n                double t = tau * tau;\n                double cs = 1.0 - t / (u * u + v * v + w * w);\n                double sn = t / (u * u + v * v + w * w);\n                c *= cs;\n                s *= sn;\n                tau *= sn;\n                matrixT[i][i] = x * cs + y * sn + z * tau;\n                matrixT[i + 1][i] = 0.0;\n                matrixT[i + 1][i + 1] = x * -sn + y * cs + z * tau;\n            }\n        }\n\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = il;\n    if (shift.w != 0.0) {\n        // Compute the Householder vector hVec\n        double norm = 0.0;\n        for (int i = il; i <= iu; i++) {\n            hVec[i] = matrixT[i][il] - shift.x;\n            norm += hVec[i] * hVec[i];\n        }\n        norm = FastMath.sqrt(norm);\n        if (hVec[il] > 0.0) {\n            norm = -norm;\n        }\n        hVec[il] += norm;\n        norm = 1.0 / norm;\n\n        // Apply the Householder transformation to the matrix T\n        for (int j = il; j <= iu; j++) {\n            double s = 0.0;\n            for (int i = il; i <= iu; i++) {\n                s += hVec[i] * matrixT[i][j];\n            }\n            for (int i = il; i <= iu; i++) {\n                matrixT[i][j] -= s * hVec[i] * norm;\n            }\n        }\n\n        // Check if the Householder transformation has reduced the size of the matrix T\n        if (matrixT[iu][iu] == 0.0) {\n            startIdx = iu - 1;\n        }\n    }\n    return startIdx;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isInclude()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) \n    {\n        if (!this.includedSegments.contains(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isInclude()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isInclude()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isIncludeSegment()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (long i = this.segmentStart; i <= this.segmentEnd; i++) \n    {\n        if (!isIncludedSegment(i)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n    return start.isIncludeSegment() && end.isIncludeSegment();\n}",
      "public boolean inIncludeSegments()  {\n    for (int i = 0; i < segmentCount; i++) \n    {\n        Segment segment = getSegment(segmentStart + i * segmentSize);\n        if (!segment.isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    Segment start = getSegment(this.segmentStart);\n    Segment end = getSegment(this.segmentEnd);\n    for (Segment s = start; s != end; s = s.getNextSegment()) \n    {\n        if (!s.isIncluded()) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = FieldUtils.safeSubtract(end.get(i), start.get(i));\n    }\n    return zeroInstance.toPeriodType().normalizeStandard(new MutablePeriod(values)).get(zeroInstance.getPeriodType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartials must have the same set of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        values[i] = endValue - startValue;\n    }\n    return zeroInstance.toPeriodType().buildPeriod(values);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (!start.isSupported(zeroInstance.getFieldType(0))) {\n        throw new IllegalArgumentException(\"Field types must match\");\n    }\n    int amount = 0;\n    for (int i = 0; i < zeroInstance.size(); i++) {\n        amount += FieldUtils.safeSubtract(end.get(i), start.get(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (!start.isSupported(zeroInstance.getFieldType(0))) {\n        throw new IllegalArgumentException(\"Field types must match\");\n    }\n    int amount = 0;\n    for (int i = 0; i < zeroInstance.size(); i++) {\n        amount += start.get(i) - end.get(i);\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartials must have the same number of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = end.get(i) - start.get(i);\n    }\n    return zeroInstance.toPeriod().withValues(values).get(zeroInstance.getPeriodType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        DurationField field = start.getField(i);\n        if (field.isPrecise()) {\n            values[i] = FieldUtils.safeSubtract(endValue, startValue);\n        } else {\n            values[i] = field.getDifference(endValue, startValue);\n        }\n    }\n    return zeroInstance.withValues(values).getPeriod();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        int fieldType = start.getFieldType(i).getField(ISOChronology.getInstance()).getType();\n        values[i] = FieldUtils.safeSubtract(end.getValue(i), start.getValue(i));\n    }\n    return zeroInstance.withValues(values).get(zeroInstance.getFieldType(0));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0; i < values.length; i++) {\n        values[i] = end.get(i) - start.get(i);\n    }\n    return zeroInstance.toPeriodType().indexOf(DurationFieldType.standardDays()) >= 0 ?\n        FieldUtils.safeMultiply(FieldUtils.safeAdd(FieldUtils.safeAdd(values[0], values[1]), values[2]), 365) +\n        FieldUtils.safeMultiply(FieldUtils.safeAdd(values[3], values[4]), 30) +\n        FieldUtils.safeAdd(values[5], values[6]) :\n        FieldUtils.safeAdd(FieldUtils.safeAdd(values[0], values[1]), values[2]);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (!start.isSupported(zeroInstance.getFieldType(0))) {\n        throw new IllegalArgumentException(\"Field types must match\");\n    }\n    int amount = 0;\n    for (int i = 0; i < zeroInstance.size(); i++) {\n        amount += FieldUtils.safeSubtract(end.get(i), start.get(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (!start.isSupported(DurationFieldType.days()) || !end.isSupported(DurationFieldType.days())) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must support days\");\n    }\n    int days = end.get(DurationFieldType.days()) - start.get(DurationFieldType.days());\n    return days;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    Title subtitle = this.subtitles.get(index);\n    if (subtitle instanceof LegendTitle) {\n        return (LegendTitle) subtitle;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    Title title = this.subtitles.get(index);\n    if (title instanceof LegendTitle) \n    {\n        return (LegendTitle) title;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    Title title = this.subtitles.get(index);\n    if (title instanceof LegendTitle) {\n        return (LegendTitle) title;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    Title title = this.subtitles.get(index);\n    if (title instanceof LegendTitle) \n    {\n        return (LegendTitle) title;\n    }\n    return null;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(physicalOrderEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    sortedEntries.sort(Comparator.comparingInt(ZipArchiveEntry::getPhysicalOffset));\n    return Collections.enumeration(sortedEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(physicalOrderEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    sortedEntries.sort(Comparator.comparingLong(ZipArchiveEntry::getCrc));\n    return Collections.enumeration(sortedEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    sortedEntries.sort(Comparator.comparingLong(ZipArchiveEntry::getLocalHeaderOffset));\n    return Collections.enumeration(sortedEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    sortedEntries.sort(Comparator.comparingLong(ZipArchiveEntry::getCrc));\n    return Collections.enumeration(sortedEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(physicalOrderEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    sortedEntries.sort(Comparator.comparingLong(ZipArchiveEntry::getLocalHeaderOffset));\n    return Collections.enumeration(sortedEntries);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (match(JsDocToken.EQ)) \n      {\n        next();\n        typeNode = new Node(Token.OPTIONAL_PARAM, typeNode);\n      }\n      else if (match(JsDocToken.ELLIPSIS)) \n      {\n        next();\n        typeNode = new Node(Token.REST_PARAM, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.EQUALS, typeNode, parseTopLevelTypeExpression(next()));\n            }\n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.ELLIPSIS, typeNode);\n            }\n\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQ)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.ASSIGN, typeNode, parseTopLevelTypeExpression(next()));\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.ELLIPSIS, typeNode);\n            }\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                typeNode.setIsOptional(true);\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                typeNode.setIsRepeated(true);\n            } \n            else \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (match(JsDocToken.EQUALS)) \n      {\n        next();\n        skipEOLs();\n        typeNode = new Node(Token.EQUALS, typeNode);\n      }\n      else if (match(JsDocToken.ELLIPSIS)) \n      {\n        next();\n        skipEOLs();\n        typeNode = new Node(Token.ELLIPSIS, typeNode);\n      }\n      else if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                typeNode.setIsOptional(true);\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                typeNode.setIsVarArgs(true);\n            } \n            else \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQ)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.OPTIONAL_PARAM, typeNode);\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                skipEOLs();\n                typeNode = new Node(Token.REST_PARAM, typeNode);\n            } \n            else if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                skipEOLs();\n                typeNode.setIsOptional(true);\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                skipEOLs();\n                typeNode.setIsVarArgs(true);\n            } \n            else \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else if (token == JsDocToken.ELLIPSIS) \n    {\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            return typeNode;\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                skipEOLs();\n                typeNode.setIsOptional(true);\n            }\n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                skipEOLs();\n                typeNode.setIsVarArgs(true);\n            }\n            else \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) {\n        for (final StackTraceElement element : cause.getStackTrace()) {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) {\n        for (final StackTraceElement element : cause.getStackTrace()) {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return Collections.emptyList();\n    }\n\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return Collections.emptyList();\n    }\n    \n    final List<String> stackFrames = new ArrayList<String>();\n    for (final StackTraceElement element : t.getStackTrace()) \n    {\n        stackFrames.add(element.toString());\n    }\n    \n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return new ArrayList<String>();\n    }\n    else \n    {\n        final List<String> stackFrames = new ArrayList<String>();\n        final String stackTrace = getStackTrace(t);\n        final String[] frames = getStackFrames(stackTrace);\n        for (int i = 0; i < frames.length; i++) \n        {\n            stackFrames.add(frames[i]);\n        }\n        return stackFrames;\n    }\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    for (Throwable cause = t; cause != null; cause = cause.getCause()) \n    {\n        final String stackTrace = getStackTrace(cause);\n        final String[] stackFrames = getStackFrames(stackTrace);\n        for (String stackFrame : stackFrames) \n        {\n            frames.add(stackFrame);\n        }\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) {\n        for (final StackTraceElement element : cause.getStackTrace()) {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    for (Throwable cause = t; cause != null; cause = cause.getCause()) \n    {\n        final String stackTrace = cause.getStackTraceAsString();\n        final String[] stackFrames = getStackFrames(stackTrace);\n        for (String frame : stackFrames) \n        {\n            frames.add(frame);\n        }\n    }\n    return frames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) \n    {\n        result = true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        result = false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    return true;\n  } \n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    return false;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) \n    {\n        result = true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        result = false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        return true;\n    }\n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        return false;\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) \n    {\n        result = true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        result = false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) \n    {\n        result = true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        result = false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    return true;\n  } \n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    return false;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen >= size) {\n        return str;\n    }\n    final int pads = size - strLen;\n    final char[] padding = new char[pads];\n    for (int i = 0; i < pads; i++) {\n        padding[i] = padChar;\n    }\n    final String paddingStr = new String(padding);\n    return paddingStr.substring(0, pads / 2) + str + paddingStr.substring(pads / 2);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    if (strLen >= size) {\n        return str;\n    }\n    final int pads = size - strLen;\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str).concat(new String(padding));\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(size);\n    sb.append(repeat(padChar, pads / 2));\n    sb.append(str);\n    sb.append(repeat(padChar, pads - pads / 2));\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(size);\n    sb.append(repeat(padChar, pads / 2));\n    sb.append(str);\n    sb.append(repeat(padChar, pads - pads / 2));\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(repeat(padChar, pads / 2));\n    sb.append(str);\n    sb.append(repeat(padChar, pads - pads / 2));\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    int strLen = str.length();\n    int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(repeat(padChar, pads / 2));\n    sb.append(str);\n    sb.append(repeat(padChar, pads - pads / 2));\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    final char[] padding = new char[pads];\n    Arrays.fill(padding, padChar);\n    return new String(padding).concat(str).concat(padding);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    final char[] buf = new char[size];\n    int leftPadding = pads / 2;\n    int rightPadding = pads - leftPadding;\n    Arrays.fill(buf, 0, leftPadding, padChar);\n    Arrays.fill(buf, leftPadding, size - rightPadding, str.charAt(0));\n    Arrays.fill(buf, size - rightPadding, size, padChar);\n    return new String(buf);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(size);\n    sb.append(repeat(padChar, pads / 2));\n    sb.append(str);\n    sb.append(repeat(padChar, pads - pads / 2));\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    char[] buf = new char[size];\n    int leftPadding = pads / 2;\n    Arrays.fill(buf, 0, leftPadding, padChar);\n    System.arraycopy(str.toCharArray(), 0, buf, leftPadding, strLen);\n    Arrays.fill(buf, strLen + leftPadding, size, padChar);\n    return new String(buf);\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node firstArg = call.getSecondChild();\n    while (firstArg != null) \n    {\n        if (firstArg.hasSideEffects()) \n        {\n            return true;\n        }\n        firstArg = firstArg.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node child = args.getFirstChild(); child != null; child = child.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(child)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.children()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getLastChild();\n    for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node firstArg = call.getSecondChild();\n    while (firstArg != null) \n    {\n        if (firstArg.isFunction()) \n        {\n            return true;\n        }\n        firstArg = firstArg.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.getSecondChild().children()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getSecondChild();\n    for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg : call.children()) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getSecondChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                if (i == pivot[j]) \n                {\n                    cachedP.setEntry(i, j, field.getOne());\n                    break;\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                if (j == pivot[i]) \n                {\n                    cachedP.setEntry(i, j, field.getOne());\n                } \n                else \n                {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                if (i == pivot[j]) \n                {\n                    cachedP.setEntry(i, j, field.getOne());\n                    break;\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                if (i == pivot[j]) \n                {\n                    cachedP.setEntry(i, j, field.getOne());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                if (j == pivot[i]) \n                {\n                    cachedP.setEntry(i, j, field.getOne());\n                } \n                else \n                {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int len = 0;\n    for (final ZipExtraField element : data) {\n        len += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[len];\n    int pos = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] local = element.getLocalFileDataData();\n        System.arraycopy(local, 0, result, pos, local.length);\n        pos += local.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    int totalSize = 0;\n    for (final ZipExtraField element : data) {\n        totalSize += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[totalSize];\n    int pos = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] localData = element.getLocalFileDataData();\n        System.arraycopy(localData, 0, result, pos, localData.length);\n        pos += localData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    int totalsize = 0;\n    for (final ZipExtraField element : data) {\n        totalsize += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[totalsize];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] localdata = element.getLocalFileDataData();\n        System.arraycopy(localdata, 0, result, start, localdata.length);\n        start += localdata.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField element : data) {\n        baos.write(element.getLocalFileDataData());\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int totalSize = 0;\n    for (final ZipExtraField element : data) {\n        totalSize += element.getLocalFileDataLength().getValue();\n    }\n\n    final byte[] result = new byte[totalSize];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] localData = element.getLocalFileDataData();\n        System.arraycopy(localData, 0, result, start, localData.length);\n        start += localData.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    for (final ZipExtraField element : data) {\n        baos.write(element.getHeaderId().getBytes());\n        baos.write(element.getLocalFileDataLength().getBytes());\n        baos.write(element.getLocalFileDataData());\n    }\n    return baos.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int totalSize = 0;\n        for (final ZipExtraField element : data) {\n            totalSize += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[totalSize];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            final byte[] localData = element.getLocalFileDataData();\n            System.arraycopy(localData, 0, result, start, localData.length);\n            start += localData.length;\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int size = 0;\n    for (final ZipExtraField element : data) {\n        size += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[size];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] local = element.getLocalFileDataData();\n        System.arraycopy(local, 0, result, start, local.length);\n        start += local.length;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        for (final ZipExtraField element : data) {\n            baos.write(element.getLocalFileDataData());\n        }\n        return baos.toByteArray();\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int totalSize = 0;\n    for (final ZipExtraField element : data) {\n        totalSize += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[totalSize];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        final byte[] localData = element.getLocalFileDataData();\n        System.arraycopy(localData, 0, result, start, localData.length);\n        start += localData.length;\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (ch == delimiter) \n        {\n            token.type = TOKEN;\n            break;\n        } \n        else if (ch == '\\n' || ch == '\\r') \n        {\n            token.type = EORECORD;\n            break;\n        } \n        else if (ch == '\\0') \n        {\n            token.type = EOF;\n            break;\n        } \n        else \n        {\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (ch == reader.getLastChar()) \n        {\n            ch = reader.read();\n        }\n        if (isEndOfLine(ch) || isEndOfFile(ch)) \n        {\n            token.type = EORECORD;\n            break;\n        }\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        }\n        if (isEscapeChar(ch)) \n        {\n            ch = reader.read();\n            if (isEscapeChar(ch) || isDelimiter(ch) || isQuoteChar(ch)) \n            {\n                token.content.append((char) ch);\n            } \n            else \n            {\n                // unescaped escape char: append escape char and continue\n                token.content.append(reader.getEscapeChar());\n                token.content.append((char) ch);\n            }\n        } \n        else \n        {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (ch == reader.getLastChar()) \n        {\n            ch = reader.read();\n            if (ch == '\\n') \n            {\n                token.type = EORECORD;\n                return token;\n            }\n        }\n\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true;\n            return token;\n        }\n\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            return token;\n        }\n\n        if (isEscapeChar(ch)) \n        {\n            ch = reader.read();\n            if (isDelimiter(ch)) \n            {\n                token.content.append(ch);\n            } \n            else \n            {\n                token.content.append(ESCAPE_CHAR);\n                token.content.append(ch);\n            }\n        } \n        else \n        {\n            token.content.append(ch);\n        }\n\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            break;\n        } \n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        } \n        else if (isEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            break;\n        } \n        else \n        {\n            if (ch == escapeChar) \n            {\n                ch = reader.read();\n                if (isEndOfFile(ch)) \n                {\n                    token.type = EOF;\n                    break;\n                } \n                else if (isDelimiter(ch)) \n                {\n                    token.content.append(escapeChar);\n                } \n                else \n                {\n                    token.content.append(escapeChar);\n                    token.content.append(ch);\n                }\n            } \n            else \n            {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean eol = false;\n    while (!eol) \n    {\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        } \n        else if (readEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            break;\n        } \n        else \n        {\n            token.content.append((char) ch);\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) \n    {\n        // add removed blanks when not ignoring whitespace chars...\n        if (!ignoreSurroundingSpaces && isWhitespace(ch)) \n        {\n            token.content.append(' ');\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } \n        else if (readEndOfLine(ch)) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } \n        else \n        {\n            // next token must be a simple token\n            token.content.append((char) ch);\n            ch = reader.read();\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (ch == reader.getLastChar()) \n        {\n            token.type = EORECORD;\n            break;\n        }\n        if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            break;\n        }\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        }\n        if (isEscapeChar(ch)) \n        {\n            ch = reader.read();\n            if (isEndOfFile(ch)) \n            {\n                token.type = EOF;\n                break;\n            }\n            if (isDelimiter(ch)) \n            {\n                token.content.append(escapeChar);\n            } \n            else \n            {\n                token.content.append(ch);\n            }\n        } \n        else \n        {\n            token.content.append(ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (isEndOfLine(ch)) \n        {\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            break;\n        } \n        else if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        } \n        else if (isEscapeChar(ch)) \n        {\n            ch = reader.read();\n            if (isEndOfFile(ch)) \n            {\n                token.type = EOF;\n                break;\n            } \n            else \n            {\n                token.content.append(ch);\n            }\n        } \n        else \n        {\n            token.content.append(ch);\n        }\n        ch = reader.read();\n    }\n    token.isReady = true;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) {\n        // add removed blanks when not ignoring whitespace chars...\n        if (!ignoreSurroundingSpaces && isWhitespace(ch)) {\n            token.content.append(ch);\n        }\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (readEndOfLine(ch)) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append(ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (ch == reader.getLastChar()) \n        {\n            // reached end of line\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(ch)) \n        {\n            // reached end of file\n            token.type = EOF;\n            break;\n        } \n        else if (isDelimiter(ch)) \n        {\n            // reached delimiter\n            token.type = TOKEN;\n            break;\n        } \n        else if (isEscapeChar(ch)) \n        {\n            // escaped delimiter\n            ch = reader.read();\n            if (isDelimiter(ch)) \n            {\n                token.content.append(ch);\n            } \n            else \n            {\n                // not an escaped delimiter, treat as regular char\n                token.content.append(reader.getLastChar());\n                token.content.append(ch);\n            }\n        } \n        else \n        {\n            // regular char\n            token.content.append(ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    \n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = tIndex / uniCounterOffset[i];\n        tIndex %= uniCounterOffset[i];\n    }\n    \n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize)\n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    \n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++)\n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    \n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = tIndex / uniCounterOffset[i];\n        tIndex %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize)\n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n\n    for (int i = 0; i < dimension; i++)\n    {\n        counts[i] = tempIndex / uniCounterOffset[i];\n        tempIndex %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize)\n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = 0; i < dimension; i++)\n    {\n        counts[i] = tIndex / uniCounterOffset[i];\n        tIndex %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize)\n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = 0; i < dimension; i++)\n    {\n        counts[i] = tIndex / uniCounterOffset[i];\n        tIndex %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    JsonPointer current = this;\n    while (current != null) {\n        tail = current;\n        current = current.getParent();\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    JsonPointer context = this;\n    while (context != null) {\n        tail = context;\n        context = context.getParent();\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current.getParent() != null) \n    {\n        current = current.getParent();\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n    JsonPointer context = this;\n    while (context != null) {\n        tail = context;\n        context = context.getParent();\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[1024];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  if (obj == null) {\n        return null;\n    }\n    try {\n        if (obj instanceof Cloneable) {\n            final Object result = obj.getClass().getMethod(\"clone\").invoke(obj);\n            if (result != obj) {\n                return (T) result;\n            }\n        }\n    } catch (final NoSuchMethodException e) {\n        // ignored\n    } catch (final IllegalAccessException e) {\n        // ignored\n    } catch (final InvocationTargetException e) {\n        throw new CloneFailedException(\"Unable to clone object\", e.getCause());\n    }\n    throw new CloneFailedException(\"Unable to clone object\");\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (NoSuchMethodException e) {\n            throw new CloneFailedException(\"Cloneable type has no clone method\", e);\n        } catch (IllegalAccessException e) {\n            throw new CloneFailedException(\"Cannot clone Cloneable type\", e);\n        } catch (InvocationTargetException e) {\n            throw new CloneFailedException(\"Exception cloning Cloneable type\", e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            if (!cloneMethod.isAccessible()) \n            {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } \n        catch (final NoSuchMethodException e) \n        {\n            // ignore, no valid clone method\n        } \n        catch (final IllegalAccessException e) \n        {\n            // ignore, no valid clone method\n        } \n        catch (final InvocationTargetException e) \n        {\n            // ignore, no valid clone method\n        } \n        catch (final SecurityException e) \n        {\n            // ignore, no valid clone method\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (final NoSuchMethodException e) {\n            // ignored\n        } catch (final IllegalAccessException e) {\n            // ignored\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(e.getCause());\n        }\n    }\n    throw new CloneFailedException(\"Unable to clone object of type: \" + obj.getClass());\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            return cloneMethod.invoke(obj);\n        } catch (final NoSuchMethodException e) {\n            throw new CloneFailedException(e);\n        } catch (final IllegalAccessException e) {\n            throw new CloneFailedException(e);\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            return cloneMethod.invoke(obj);\n        } catch (final NoSuchMethodException e) {\n            // cloning not supported\n        } catch (final IllegalAccessException e) {\n            // cloning not supported\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  if (obj instanceof Cloneable) {\n        try {\n            return obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cannot clone object\", ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Object \" + obj.getClass().getName() + \n                                          \" doesn't have a clone method\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Exception cloning object\", ex.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            return cloneMethod.invoke(obj);\n        } \n        catch (NoSuchMethodException e) \n        {\n            throw new IllegalArgumentException(\"Cloneable type without a clone method: \" + obj.getClass());\n        } \n        catch (IllegalAccessException e) \n        {\n            throw new CloneFailedException(\"Cannot clone: \" + obj, e);\n        } \n        catch (InvocationTargetException e) \n        {\n            throw new CloneFailedException(\"Exception cloning: \" + obj, e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  if (obj instanceof Cloneable) {\n        try {\n            return obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (final NoSuchMethodException e) {\n            throw new IllegalArgumentException(\"Cloneable type without clone method: \" + obj.getClass());\n        } catch (final IllegalAccessException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e);\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(\"Exception cloning object\", e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            return cloneMethod.invoke(obj, (Object[]) null);\n        } catch (NoSuchMethodException e) {\n            // cloning not supported\n        } catch (IllegalAccessException e) {\n            // cloning not supported\n        } catch (InvocationTargetException e) {\n            throw new CloneFailedException(e.getCause());\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.isFunction()) \n  {\n    SymbolScope scope = getScope(sym);\n    if (scope != null) \n    {\n      for (Symbol param : scope.getSymbols()) \n      {\n        if (param.isParameter() && param.getName().equals(paramName)) \n        {\n          return param;\n        }\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.isFunction()) \n  {\n    for (Reference ref : sym.references.values()) \n    {\n      Node fnNode = ref.getNode();\n      if (fnNode.isFunction()) \n      {\n        Node paramList = fnNode.getFirstChild().getNext();\n        for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) \n        {\n          if (param.getString().equals(paramName)) \n          {\n            return symbols.get(paramName);\n          }\n        }\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) {\n    return null;\n  }\n  Node functionNode = sym.getDeclarationNode();\n  if (functionNode == null || !functionNode.isFunction()) {\n    return null;\n  }\n  Node paramList = functionNode.getFirstChild().getNext();\n  Node param = paramList.getFirstChild();\n  while (param != null) {\n    if (param.getString().equals(paramName)) {\n      return getSymbolForNode(param);\n    }\n    param = param.getNext();\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) \n    {\n        for (Symbol param : getReferenceList(sym)) \n        {\n            if (param.name.equals(paramName)) \n            {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isFunction()) \n    {\n        for (Symbol param : sym.getFunctionParameters()) \n        {\n            if (param.getName().equals(paramName)) \n            {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getType().isFunctionType()) \n    {\n        FunctionType functionType = sym.getType().toMaybeFunctionType();\n        if (functionType.hasParameters()) \n        {\n            for (Symbol parameter : functionType.getParameters()) \n            {\n                if (parameter.getName().equals(paramName)) \n                {\n                    return parameter;\n                }\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.isFunction()) \n  {\n    SymbolScope functionScope = getScope(sym);\n    if (functionScope != null) \n    {\n      for (Symbol param : functionScope.getAllSymbols()) \n      {\n        if (param.isParameter() && param.getName().equals(paramName)) \n        {\n          return param;\n        }\n      }\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) \n  {\n    return null;\n  }\n\n  Node functionNode = sym.getDeclarationNode();\n  if (functionNode == null) \n  {\n    return null;\n  }\n\n  Node paramList = functionNode.getSecondChild();\n  if (paramList == null) \n  {\n    return null;\n  }\n\n  for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) \n  {\n    if (param.getString().equals(paramName)) \n    {\n      return getSymbolForNode(param);\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) \n  {\n    return null;\n  }\n\n  Node functionNode = sym.getDeclarationNode();\n  if (functionNode == null || !functionNode.isFunction()) \n  {\n    return null;\n  }\n\n  Node paramList = functionNode.getFirstChild().getNext();\n  for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) \n  {\n    if (param.getString().equals(paramName)) \n    {\n      return new Symbol(paramName, param, null, null);\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) \n  {\n    return null;\n  }\n\n  Node functionNode = sym.getDeclarationNode();\n  if (functionNode == null || !functionNode.isFunction()) \n  {\n    return null;\n  }\n\n  Node params = functionNode.getFirstChild().getNext();\n  for (Node param = params.getFirstChild(); param != null; param = param.getNext()) \n  {\n    if (param.getString().equals(paramName)) \n    {\n      return new Symbol(paramName, param, null);\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of rows (observations)\n    int n = matrix.getRowDimension();\n\n    // Compute the mean of each column\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < means.length; i++) {\n        means[i] = matrix.getColumnVector(i).getMean();\n    }\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < matrix.getColumnDimension(); k++) {\n                double x = matrix.getEntry(i, k) - means[k];\n                double y = matrix.getEntry(j, k) - means[k];\n                sum += x * y;\n            }\n            if (biasCorrected) {\n                covarianceMatrix.setEntry(i, j, sum / (n - 1));\n            } else {\n                covarianceMatrix.setEntry(i, j, sum / n);\n            }\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] covMatrix = new double[n][n];\n\n    // Calculate mean of each column\n    for (int i = 0; i < n; i++) {\n        double sum = 0;\n        for (int j = 0; j < data[i].length; j++) {\n            sum += data[i][j];\n        }\n        mean[i] = sum / data[i].length;\n    }\n\n    // Calculate covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < data[i].length; k++) {\n                sum += (data[i][k] - mean[i]) * (data[j][k] - mean[j]);\n            }\n            covMatrix[i][j] = sum / (data[i].length - biasCorrected);\n        }\n    }\n\n    return new Array2DRowRealMatrix(covMatrix);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of rows (observations)\n    int n = matrix.getRowDimension();\n\n    // Compute the mean of each column\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < means.length; i++) {\n        means[i] = matrix.getColumnVector(i).getL1Norm() / n;\n    }\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(means.length, means.length);\n    for (int i = 0; i < means.length; i++) {\n        for (int j = 0; j < means.length; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < n; k++) {\n                double x = matrix.getEntry(k, i) - means[i];\n                double y = matrix.getEntry(k, j) - means[j];\n                sum += x * y;\n            }\n            double covariance = sum / (n - biasCorrected);\n            covarianceMatrix.setEntry(i, j, covariance);\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] cov = new double[n][n];\n\n    // Calculate mean of each column\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < data[i].length; j++) {\n            mean[i] += data[i][j];\n        }\n        mean[i] /= data[i].length;\n    }\n\n    // Calculate covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < data[i].length; k++) {\n                cov[i][j] += (data[i][k] - mean[i]) * (data[j][k] - mean[j]);\n            }\n            cov[i][j] /= data[i].length - (biasCorrected ? 0 : 1);\n        }\n    }\n\n    return new Array2DRowRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Compute the mean of each column\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < means.length; i++) {\n        means[i] = matrix.getColumnVector(i).getL1Norm() / matrix.getRowDimension();\n    }\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        for (int j = 0; j < matrix.getColumnDimension(); j++) {\n            double sum = 0.0;\n            for (int k = 0; k < matrix.getRowDimension(); k++) {\n                sum += (matrix.getEntry(k, i) - means[i]) * (matrix.getEntry(k, j) - means[j]);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (matrix.getRowDimension() - biasCorrected));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    \n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"Input matrix must have at least two rows and one column\");\n    }\n    \n    RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix).scalarDivide(rows - (biasCorrected ? 1 : 0));\n    \n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n\n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\n            LocalizedFormats.INSUFFICIENT_ROWS_OR_COLUMNS,\n            rows, cols, 2, 1);\n    }\n\n    RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarDivide(rows);\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarDivide(rows - 1);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of rows and columns in the matrix\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n\n    // Initialize the covariance matrix\n    RealMatrix covarianceMatrix = MatrixUtils.createRealMatrix(p, p);\n\n    // Compute the covariance matrix\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < n; k++) {\n                double x = matrix.getEntry(k, i);\n                double y = matrix.getEntry(k, j);\n                sum += (x - mean(matrix, i)) * (y - mean(matrix, j));\n            }\n            if (biasCorrected) {\n                covarianceMatrix.setEntry(i, j, sum / (n - 1));\n            } else {\n                covarianceMatrix.setEntry(i, j, sum / n);\n            }\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has at least two rows and one column\n    if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(\"Input matrix must have at least two rows and one column\");\n    }\n\n    // Compute the mean of each column\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        means[i] = matrix.getColumn(i).getMean();\n    }\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = matrix.copy();\n    for (int i = 0; i < matrix.getRowDimension(); i++) {\n        for (int j = 0; j < matrix.getColumnDimension(); j++) {\n            double value = matrix.getEntry(i, j);\n            covarianceMatrix.setEntry(i, j, (value - means[j]) * (value - means[j]));\n        }\n    }\n\n    // Divide by (n-1) if bias correction is not requested\n    if (!biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarDivide(n - 1);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] covMatrix = new double[n][n];\n\n    // Calculate mean of each column\n    for (int i = 0; i < n; i++) {\n        double sum = 0;\n        for (int j = 0; j < data.length; j++) {\n            sum += data[j][i];\n        }\n        mean[i] = sum / data.length;\n    }\n\n    // Calculate covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < data.length; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            covMatrix[i][j] = sum / (data.length - biasCorrected);\n        }\n    }\n\n    return new Array2DRowRealMatrix(covMatrix);\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | read;\n        bitsCachedSize += 8;\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) + read;\n        bitsCachedSize += 8;\n    }\n\n    long result = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        result = Long.reverse(result);\n    }\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) + read;\n        bitsCachedSize += 8;\n    }\n\n    final long bits = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Invalid count: \" + count);\n    }\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            bitsCached = (bitsCached << 8) | read;\n        } else {\n            bitsCached = (bitsCached | read) << 8;\n        }\n        bitsCachedSize += 8;\n    }\n    long result = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result >>>= (bitsCachedSize - count);\n    } else {\n        result <<= (bitsCachedSize - count);\n    }\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | b;\n        bitsCachedSize += 8;\n    }\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsCached = Integer.reverseBytes((int) bitsCached);\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | read;\n        bitsCachedSize += 8;\n    }\n\n    long result = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        result = Integer.reverseBytes((int) result);\n    }\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int read = in.read();\n        if (read == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | read;\n        bitsCachedSize += 8;\n    }\n\n    final long result;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        result = bitsCached >>> (bitsCachedSize - count);\n    } else {\n        result = bitsCached & MASKS[count];\n    }\n\n    bitsCached <<= count;\n    bitsCachedSize -= count;\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) | b;\n        bitsCachedSize += 8;\n    }\n\n    long result = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        result = reverseBits(result, count);\n    }\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) + b;\n        bitsCachedSize += 8;\n    }\n    long bits = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bits = Integer.reverseBytes((int) bits);\n    }\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Invalid count: \" + count);\n    }\n\n    while (bitsCachedSize < count) {\n        final int b = in.read();\n        if (b == -1) {\n            return -1;\n        }\n        bitsCached = (bitsCached << 8) + b;\n        bitsCachedSize += 8;\n    }\n\n    long result = bitsCached & MASKS[count];\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        result = Long.reverseBytes(result);\n    }\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return result;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  Node labeled = target;\n  while (labeled != null && !labeled.isLabel()) \n  {\n    labeled = labeled.getParent();\n  }\n  return labeled != null && labeled.getFirstChild().getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  if (target.isLabel()) \n  {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  return target.isLabel() && target.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  if (target.isLabel()) \n  {\n    return target.getFirstChild().getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  return target.getFirstChild().getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.getType() != Token.LABEL) {\n    return false;\n  }\n  return target.getFirstChild().getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getString());\n  }\n  if (target.isDo() || target.isFor() || target.isSwitch() ||\n      target.isWhile()) {\n    return target.getFirstChild().getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  if (!target.isLabel()) \n  {\n    return false;\n  }\n  return target.getFirstChild().getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  \n  if (target.isLabel()) \n  {\n    return target.getFirstChild().getString().equals(label);\n  }\n  \n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  if (target.isLabel()) \n  {\n    return target.getString().equals(label);\n  }\n  return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        if (item >= 0 && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        if (item >= 0 && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        if (item >= 0 && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        if (item >= 0 && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty index\");\n    }\n    int i = 0;\n    int result = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        result = (result * 10) + (c - '0');\n        ++i;\n    }\n    if (i == len) {\n        return result;\n    }\n    throw new IllegalArgumentException(\"Invalid index: \" + str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Invalid index: empty string\");\n    }\n    int i = 0;\n    int result = 0;\n    if (str.charAt(0) == '-') {\n        if (len == 1) {\n            throw new IllegalArgumentException(\"Invalid index: '-'\");\n        }\n        ++i;\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: '\"+str+\"'\");\n        }\n        result = (result * 10) + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Invalid index: empty string\");\n    }\n    if (str.charAt(0) == '-') {\n        if (len == 1) {\n            throw new IllegalArgumentException(\"Invalid index: '-'\");\n        }\n        return Integer.parseInt(str.substring(1));\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer index: empty string\");\n    }\n    int i = 0;\n    if (str.charAt(0) == '-') {\n        // negative index\n        if (len == 1) {\n            throw new IllegalArgumentException(\"Invalid JSON Pointer index: '-'\");\n        }\n        i = 1;\n    }\n    int index = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid JSON Pointer index: '\" + str + \"'\");\n        }\n        index = (index * 10) + (c - '0');\n        i++;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        throw new IllegalArgumentException(\"Empty index string\");\n    }\n    if (str.charAt(0) == '-') {\n        throw new IllegalArgumentException(\"Negative index not allowed: \"+str);\n    }\n    int index = 0;\n    for (int i = 0; i < str.length(); ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Illegal index character: \"+c);\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Invalid index: empty string\");\n    }\n    if (str.charAt(0) == '-') {\n        throw new IllegalArgumentException(\"Invalid index: minus sign not allowed\");\n    }\n    int i = 0;\n    int result = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: not a digit\");\n        }\n        result = (result * 10) + (c - '0');\n        ++i;\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty index\");\n    }\n    int i = 0;\n    if (str.charAt(0) == '-') {\n        ++i;\n    }\n    if (i == len) {\n        throw new IllegalArgumentException(\"Invalid index: \"+str);\n    }\n    int result = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \"+str);\n        }\n        result = result * 10 + (c - '0');\n        ++i;\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        throw new IllegalArgumentException(\"Empty index string\");\n    }\n    int i = 0;\n    int c = str.charAt(i);\n    if (c == '-') {\n        if (str.length() == 1) {\n            throw new IllegalArgumentException(\"Invalid index string\");\n        }\n        ++i;\n        c = str.charAt(i);\n    }\n    if ((c < '0') || (c > '9')) {\n        throw new IllegalArgumentException(\"Invalid index string\");\n    }\n    int result = 0;\n    while (i < str.length()) {\n        c = str.charAt(i);\n        if ((c < '0') || (c > '9')) {\n            break;\n        }\n        result = (result * 10) + (c - '0');\n        ++i;\n    }\n    if (i < str.length()) {\n        throw new IllegalArgumentException(\"Invalid index string\");\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty index\");\n    }\n    int i = 0;\n    if (str.charAt(0) == '-') {\n        if (len == 1) {\n            throw new IllegalArgumentException(\"Empty index\");\n        }\n        ++i;\n    }\n    int value = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        value = value * 10 + (c - '0');\n        ++i;\n    }\n    if (i == len) {\n        return value;\n    }\n    throw new IllegalArgumentException(\"Invalid index: \" + str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Empty index\");\n    }\n    int i = 0;\n    int result = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        result = result * 10 + (c - '0');\n        ++i;\n    }\n    return result;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE, k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    Object[] index = c.toArray();\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newQName(compiler, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),\n          methodName, srcref);\n      callNode.addChildToFront(argumentNode);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),\n                                                  methodName,\n                                                  srcref);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention().getGlobalObject(), methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformationFrom(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(), methodName, srcref);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, Comparator.comparingDouble(i -> doubles[i]));\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                if (i == j) \n                {\n                    qtData[i][j] = 1.0;\n                } \n                else if (i < j) \n                {\n                    qtData[i][j] = householderVectors[j][i];\n                } \n                else \n                {\n                    qtData[i][j] = 0.0;\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                double sum = 0.0;\n                for (int k = 0; k <= i; k++) \n                {\n                    sum += householderVectors[k][j] * householderVectors[k][i];\n                }\n                cachedQt.setEntry(j, i, sum);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            double norm = FastMath.sqrt(householderVectors[i][i]);\n            for (int j = 0; j < householderVectors[i].length; j++) \n            {\n                householderVectors[i][j] /= norm;\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        int m = householderVectors.length;\n        double[][] qtData = new double[m][m];\n        for (int i = 0; i < m; i++) \n        {\n            double[] qtRow = qtData[i];\n            double[] qRow = householderVectors[i];\n            double norm = qRow[i];\n            for (int j = i; j < m; j++) \n            {\n                qtRow[j] = qRow[j] / norm;\n            }\n            for (int j = 0; j < i; j++) \n            {\n                double dot = 0;\n                for (int k = i; k < m; k++) \n                {\n                    dot += qRow[k] * qtRow[k];\n                }\n                for (int k = i; k < m; k++) \n                {\n                    qtRow[k] -= dot * qRow[k];\n                }\n            }\n        }\n        cachedQt = new Array2DRowRealMatrix(qtData);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            double norm = FastMath.sqrt(householderVectors[i][i] * householderVectors[i][i] + secondary[i] * secondary[i]);\n            for (int j = 0; j < householderVectors[i].length; j++) \n            {\n                householderVectors[i][j] /= norm;\n            }\n            householderVectors[i][i] += 1.0;\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            double h = householderVectors[i][i];\n            for (int j = 0; j < i; j++) \n            {\n                double s = 0.0;\n                for (int k = j; k < i; k++) \n                {\n                    s += householderVectors[i][k] * householderVectors[j][k];\n                }\n                s *= h;\n                for (int k = j; k < i; k++) \n                {\n                    householderVectors[i][k] -= s * householderVectors[j][k];\n                }\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        int m = householderVectors.length;\n        double[][] qt = new double[m][m];\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < m; j++) \n            {\n                if (i == j) \n                {\n                    qt[i][j] = 1.0;\n                } \n                else if (i < j) \n                {\n                    double sum = 0.0;\n                    for (int k = i; k < j; k++) \n                    {\n                        sum += householderVectors[i][k] * qt[k][j];\n                    }\n                    qt[i][j] = sum;\n                    qt[j][i] = -sum;\n                } \n                else \n                {\n                    qt[i][j] = 0.0;\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> decoratedSet = new TransformedSet<>(set, transformer);\n    for (E element : set) {\n        decoratedSet.add(transformer.transform(element));\n    }\n    return decoratedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> decoratedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        decoratedSet.add(transformer.transform(element));\n    }\n    return decoratedSet;\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] oldBuffer = buffer;\n        buffer = new char[Math.max(capacity, oldBuffer.length * 3 / 2)];\n        System.arraycopy(oldBuffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] oldBuffer = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(oldBuffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuffer = new char[capacity * 2];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < dataset.getColumnCount(); i++) {\n        double total = 0.0;\n        for (int j = 0; j < dataset.getRowCount(); j++) {\n            double value = dataset.getValue(j, i).doubleValue();\n            if (!Double.isNaN(value)) {\n                total += value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n        double runningTotal = 0.0;\n        for (int c = 0; c < dataset.getColumnCount(); c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        int columnCount = dataset.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int c = 0; c < categoryCount; c++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getValue(s, c).doubleValue();\n            if (!Double.isNaN(value)) {\n                total += value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        int columnCount = dataset.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number n = dataset.getValue(r, c);\n            if (n != null) {\n                runningTotal += n.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    if (min <= max) {\n        return new Range(min, max);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int r = 0; r < dataset.getRowCount(); r++) {\n        double total = 0.0;\n        for (int c = 0; c < dataset.getColumnCount(); c++) {\n            double value = dataset.getValue(r, c).doubleValue();\n            if (!Double.isNaN(value)) {\n                total += value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double total = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int category = 0; category < categoryCount; category++) {\n            Number value = dataset.getValue(series, category);\n            if (value != null) {\n                total += value.doubleValue();\n                min = Math.min(min, total);\n                max = Math.max(max, total);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        int columnCount = dataset.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int category = 0; category < categoryCount; category++) {\n            double value = dataset.getValue(series, category).doubleValue();\n            runningTotal += value;\n            minimum = Math.min(minimum, runningTotal);\n            maximum = Math.max(maximum, runningTotal);\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    int columnCount = dataset.getColumnCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        for (int c = 0; c < columnCount; c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    if (min == Double.POSITIVE_INFINITY && max == Double.NEGATIVE_INFINITY) {\n        return new Range(0.0, 0.0);\n    }\n    return new Range(min, max);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute out of range: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(hoursOffset * 60 + minutesOffset);\n    long offset = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value is out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value is out of range: \" + minutesOffset);\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value is out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value is out of range: \" + minutesOffset);\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset == 0L) {\n        return DateTimeZone.UTC;\n    } else {\n        String id = printOffset(offset);\n        return fixedOffsetZone(id, offset);\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    long offset = ((long) hoursOffset) * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    long offset = ((long) hoursOffset) * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    long offset = ((long) hoursOffset * 60L + minutesOffset) * 60L * 1000L;\n    if (offset == 0L) \n    {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset is out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset is out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Negative minutes offset with positive hours offset: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    long offset = ((long) hoursOffset) * 60 * 60 * 1000 + ((long) minutesOffset) * 60 * 1000;\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    long offset = ((long) hoursOffset * 60L + minutesOffset) * 60000L;\n    if (offset > 86399999L || offset < -86399999L) \n    {\n        throw new IllegalArgumentException(\"Offset is too large: \" + offset);\n    }\n    return fixedOffsetZone(printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be between -23 and 23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be between -59 and 59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    String id = printOffset(hoursOffset * 60 + minutesOffset);\n    return fixedOffsetZone(id, hoursOffset * 60 + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"The hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"The minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    String id = printOffset(offset);\n    return fixedOffsetZone(id, offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int balance = 0;\n    StringBuilder sb = new StringBuilder();\n    boolean escaped = false;\n    while (!isEmpty())\n    {\n        char c = queue.charAt(pos++);\n        if (escaped)\n        {\n            sb.append(c);\n            escaped = false;\n        }\n        else if (c == '\\\\')\n            escaped = true;\n        else if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        if (balance < 0)\n            break;\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int balance = 0;\n    int start = pos;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            if (balance > 0) \n            {\n                balance--;\n            } \n            else \n            {\n                break;\n            }\n        } \n        else if (c == '\\\\') \n        {\n            pos++;\n            continue;\n        } \n        else if (c == '\\'' || c == '\\\"') \n        {\n            char quote = c;\n            pos++;\n            while (!isEmpty()) \n            {\n                c = queue.charAt(pos);\n                if (c == quote) \n                {\n                    break;\n                } \n                else if (c == '\\\\') \n                {\n                    pos++;\n                    continue;\n                }\n                pos++;\n            }\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int balance = 0;\n    int start = pos;\n    boolean escaped = false;\n    while (!isEmpty() && (balance != 0 || !escaped)) \n    {\n        char c = queue.charAt(pos++);\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n        } \n        else if (c == '\\\\') \n        {\n            escaped = !escaped;\n        } \n        else if (c == '\\'' || c == '\\\"') \n        {\n            // Ignore quotes\n        }\n    }\n\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int balance = 1;\n    while (!isEmpty() && balance > 0) {\n        char c = queue.charAt(pos);\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        else if (c == '\\\\')\n            pos++; // skip next char, since it's escaped\n        pos++;\n    }\n\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    boolean escaped = false;\n    while (!isEmpty())\n    {\n        char c = queue.charAt(pos);\n        if (escaped)\n        {\n            sb.append(c);\n            escaped = false;\n        }\n        else if (c == '\\\\')\n        {\n            escaped = true;\n        }\n        else if (c == open)\n        {\n            depth++;\n            sb.append(c);\n        }\n        else if (c == close)\n        {\n            if (depth == 0)\n                break;\n            depth--;\n            sb.append(c);\n        }\n        else\n        {\n            sb.append(c);\n        }\n        pos++;\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int balance = 0;\n    StringBuilder sb = new StringBuilder();\n    while (!isEmpty())\n    {\n        char c = peek();\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        \n        if (balance < 0)\n            break;\n        \n        sb.append(c);\n        pos++;\n    }\n    \n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int balance = 1;\n    while (!isEmpty() && balance > 0) \n    {\n        char c = queue.charAt(pos);\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        else if (c == '\\\\') \n        {\n            pos++;\n            continue;\n        }\n        pos++;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int balance = 0;\n    boolean escaped = false;\n    while (!isEmpty() && !(balance == 0 && matches(close))) \n    {\n        char c = queue.charAt(pos++);\n        if (escaped) \n        {\n            sb.append(c);\n            escaped = false;\n        } \n        else if (c == '\\\\') \n        {\n            escaped = true;\n        } \n        else if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n        } \n        else \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int balance = 0;\n    boolean escaped = false;\n    while (!isEmpty() && (balance > 0 || !escaped)) {\n        char c = queue.charAt(pos++);\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        else if (c == '\\\\')\n            escaped = !escaped;\n        else if (c == '\\'' || c == '\\\"')\n            escaped = true;\n    }\n\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int balance = 1;\n    boolean escaped = false;\n    while (!isEmpty() && balance > 0) {\n        char c = queue.charAt(pos);\n        if (escaped) {\n            escaped = false;\n        } else if (c == '\\\\') {\n            escaped = true;\n        } else if (c == open) {\n            balance++;\n        } else if (c == close) {\n            balance--;\n        }\n        pos++;\n    }\n\n    return queue.substring(start, pos);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTranspose = getX().transpose();\n        RealMatrix xTransposeX = xTranspose.multiply(getX());\n        RealMatrix inverseXTransposeX = xTransposeX.getInverse();\n        return inverseXTransposeX;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XTX = getX().transpose().operate(getX());\n        RealMatrix invXTX = new LUDecomposition(XTX).getSolver().getInverse();\n        RealMatrix R = qr.getR();\n        RealMatrix invR = new LUDecomposition(R).getSolver().getInverse();\n        RealMatrix invRT = invR.transpose();\n        RealMatrix invRX = invRT.operate(getX());\n        RealMatrix invRXinvXTXinvR = invRX.operate(invXTX.operate(invR));\n        return invRXinvXTXinvR;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix varCovar = qr.getQ().multiply(qr.getR().transpose());\n        varCovar = varCovar.getSubMatrix(0, getX().getColumnDimension() - 1, 0, getX().getColumnDimension() - 1);\n        varCovar = varCovar.getInverse();\n        return varCovar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(getX());\n        RealMatrix r = qr.getR();\n        RealMatrix rT = r.transpose();\n        RealMatrix xT = getX().transpose();\n\n        // Calculate (X^T * X)^(-1)\n        RealMatrix xTX = xT.multiply(getX());\n        RealMatrix xTXInv = xTX.getInverse();\n\n        // Calculate (R^T * R)^(-1)\n        RealMatrix rTRInv = rT.multiply(r).getInverse();\n\n        // Calculate Var(b) = (X^T * X)^(-1) * (R^T * R)^(-1)\n        RealMatrix betaVar = xTXInv.multiply(rTRInv);\n\n        return betaVar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix xTranspose = getX().transpose();\n        RealMatrix xTransposeX = xTranspose.multiply(getX());\n        RealMatrix xTransposeXInverse = xTransposeX.getInverse();\n        return xTransposeXInverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix varCovar = qr.getQ().transpose().multiply(qr.getQ()).getInverse();\n        return varCovar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix covarianceMatrix = qr.getQ().multiply(qr.getR()).getTranspose().multiply(qr.getQ().transpose());\n        RealMatrix inverseMatrix = new LUDecomposition(covarianceMatrix).getSolver().getInverse();\n        return inverseMatrix;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate the QR decomposition of the X matrix\n        QRDecomposition qr = new QRDecomposition(getX());\n\n        // Get the upper triangular matrix R from the QR decomposition\n        RealMatrix R = qr.getQ().multiply(qr.getR());\n\n        // Calculate the inverse of R\n        RealMatrix RInverse = R.getInverse();\n\n        // Calculate the variance-covariance matrix of the regression parameters\n        RealMatrix betaVariance = RInverse.multiply(RInverse.transpose());\n\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = getX().transpose().operate(getX());\n        RealMatrix invXtX = XtX.getInverse();\n        return invXtX;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the QR decomposition of the X matrix\n        QRDecomposition qr = getQRDecomposition();\n        // Get the R matrix from the QR decomposition\n        RealMatrix r = qr.getR();\n        // Get the number of columns in the X matrix\n        int p = getX().getColumnDimension();\n        // Create a new matrix of size p x p\n        RealMatrix varCovar = MatrixUtils.createRealMatrix(p, p);\n        // Calculate the inverse of the R matrix\n        RealMatrix rInverse = r.getInverse();\n        // Calculate the variance-covariance matrix\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < p; j++) {\n                varCovar.setEntry(i, j, rInverse.getEntry(i, i) * rInverse.getEntry(j, j));\n            }\n        }\n        return varCovar;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset % (60 * 60 * 1000)) / (60 * 1000);\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset % (60 * 60 * 1000)) / (60 * 1000);\n    return String.format(\"%+03d%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    return String.format(\"%+03d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    return String.format(\"%+03d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) \n    {\n        sb.append('-');\n        hours = -hours;\n    } \n    else \n    {\n        sb.append('+');\n    }\n    sb.append(String.format(\"%02d\", hours));\n    sb.append(':');\n    sb.append(String.format(\"%02d\", minutes));\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    return String.format(\"%+03d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    sb.append(String.format(\"%02d\", hours));\n    sb.append(':');\n    sb.append(String.format(\"%02d\", minutes));\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) \n    {\n        sb.append('-');\n        hours = -hours;\n    } \n    else \n    {\n        sb.append('+');\n    }\n    if (hours < 10) \n    {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) \n    {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) \n    {\n        sb.append('-');\n        hours = -hours;\n    } \n    else \n    {\n        sb.append('+');\n    }\n    sb.append(String.format(\"%02d\", hours));\n    sb.append(':');\n    sb.append(String.format(\"%02d\", minutes));\n    return sb.toString();\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not allowed.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not allowed.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key argument.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    return (index != null ? index.intValue() : -1);\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : cache.allSlots()) {\n        if (slot.getDeclarationType() == DeclarationType.VAR) {\n            slots.put(slot.getName(), slot);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : cache.slots.values()) {\n        if (!slot.isFinalized()) {\n            slots.put(slot.getName(), slot);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (StaticSlot<JSType> slot : getAllSlots()) {\n        if (slot.getDeclarationNode() != null &&\n            slot.getDeclarationNode().getParent() != null &&\n            slot.getDeclarationNode().getParent().getParent() == this) {\n            flowSlots.put(slot.getName(), slot);\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : cache.getAllSlots()) {\n        if (slot.getType() != null) {\n            slots.put(slot.getName(), slot);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : getSlotMap().values()) {\n    if (slot.getType() != null) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (String name : cache.dirtySymbols) {\n        slots.put(name, getSlot(name));\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (StaticSlot<JSType> slot : cache.getAllSlots()) {\n    if (!slot.isDeclaredInBlock() && !slot.isDeclaredInFunction()) {\n      slots.put(slot.getName(), slot);\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (StaticSlot<JSType> slot : getSymbolTable().values()) {\n        if (slot.getDeclaration() != null && slot.getDeclaration().getScope() == this) {\n            flowSlots.put(slot.getName(), slot);\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  for (StaticSlot<JSType> slot : getAllSlots()) {\n    if (slot.getDeclarationNode() != null &&\n        slot.getDeclarationNode().getParent() == getFunctionNode()) {\n      flowSlots.put(slot.getName(), slot);\n    }\n  }\n  return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n  for (String name : cache.dirtySymbols) \n  {\n    flowSlots.put(name, getSlot(name));\n  }\n  return flowSlots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(a * 2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        result = FastMath.log((1 + a) / (1 - a));\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) \n    {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) \n    {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(2 * a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } \n    else \n    {\n        result = FastMath.log(1 + a) - FastMath.log(1 - a);\n    }\n\n    if (negate) \n    {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(2 * a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        result = 0.5 * FastMath.log((1 + a) / (1 - a));\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.999) {\n        result = FastMath.log(2 * a / (1 - a));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a * 2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        result = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a * 2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a < 0) {\n        return -atanh(-a);\n    }\n    if (a > 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a < 1e-5) {\n        return a;\n    }\n    double x = a;\n    double x2 = x * x;\n    double result = x;\n    double term = x2;\n    int i = 2;\n    do {\n        term = term / (2 * i + 1) / (2 * i + 2);\n        result += term;\n        i += 1;\n    } while (Math.abs(term) > 1e-10);\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a < 0) {\n        return -atanh(-a);\n    }\n    if (a > 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a < 0.5) {\n        return a + a * a * a * a * a / 3.0;\n    }\n    return 1.0 - 1.0 / (a + a * a * a * a * a / 3.0);\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.999) {\n        result = Math.PI / 2 - Math.log(1 - a);\n    } else if (a > 0.5) {\n        result = Math.PI / 2 - Math.log(1 + a) / 2;\n    } else {\n        result = a / (1 - a);\n    }\n\n    return negate ? -result : result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(2.0 * a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        result = 0.5 * FastMath.log((1 + a) / (1 - a));\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(a * 2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        result = 0.5 * FastMath.log((1 + a) / (1 - a));\n    }\n\n    if (negate) {\n        result = -result;\n    }\n\n    return result;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum must be finite, but was \" + normalizedSum);\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isNaN(value) || Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array must not contain infinite or NaN values\");\n        }\n        sum += value;\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array must not sum to zero\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        normalizedValues[i] = values[i] * normalizedSum / sum;\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(\n                LocalizedFormats.NORMALIZE_ZERO_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum must be finite and non-NaN.\");\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; ++i) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isNaN(sum) || Double.isInfinite(sum) || sum == 0.0) {\n        throw new MathArithmeticException(\"Input array must contain finite, non-NaN elements and sum to non-zero.\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZE_INFINITE_OR_NAN_SUM, normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isNaN(sum) || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_INFINITE_SUM, sum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum cannot be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum cannot be infinite\");\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Input array contains infinite elements\");\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Array contains infinite elements\");\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(\"Array contains infinite value\");\n        }\n        sum += values[i];\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum is infinite or NaN\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i];\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                \"Normalized sum must be finite, but was \" + normalizedSum);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; ++i) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(\n                    \"Array contains infinite element\");\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\n                \"Array sums to zero\");\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = values[i];\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            \"Normalized sum must be a finite number.\");\n    }\n\n    double sum = 0.0;\n    int len = values.length;\n    double[] result = new double[len];\n\n    for (int i = 0; i < len; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n\n    if (Double.isInfinite(sum) || sum == 0.0) {\n        throw new MathArithmeticException(\n            \"Cannot normalize an array with infinite or zero sum.\");\n    }\n\n    for (int i = 0; i < len; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZATION_SUM_IS_NOT_NUMBER, normalizedSum);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.NORMALIZATION_SUM_IS_INFINITE, normalizedSum);\n    }\n    double sum = 0.0;\n    int len = values.length;\n    for (int i = 0; i < len; ++i) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\n                LocalizedFormats.INFINITE_ARRAY_ELEMENTS);\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\n                LocalizedFormats.ZERO_ARRAY_ELEMENTS);\n    }\n    double[] normalizedValues = new double[len];\n    for (int i = 0; i < len; ++i) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n\n        if (delimiters != null && isDelimiter(c, delimiters)) {\n            buffer.append(c);\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            buffer.append(Character.toTitleCase(c));\n            nextTitleCase = false;\n        } else {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n\n        if (delimiters != null && isDelimiter(c, delimiters)) {\n            buffer.append(c);\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            buffer.append(Character.toTitleCase(c));\n            nextTitleCase = false;\n        } else {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n\n        if (delimiters != null && isDelimiter(c, delimiters)) {\n            buffer.append(c);\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            buffer.append(Character.toTitleCase(c));\n            nextTitleCase = false;\n        } else {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n\n        if (delimiters != null && isDelimiter(c, delimiters)) {\n            buffer.append(c);\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            buffer.append(Character.toTitleCase(c));\n            nextTitleCase = false;\n        } else {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (delimiters != null && isDelimiter(c, delimiters)) {\n            buffer.append(c);\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            buffer.append(Character.toTitleCase(c));\n            nextTitleCase = false;\n        } else {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInvX = XT.multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOmegaInvXInv = XTOmegaInvX.getInverse();\n        RealVector XTOmegaInvY = XT.multiply(getOmegaInverse()).operate(getY());\n        return XTOmegaInvXInv.operate(XTOmegaInvY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInverse = XT.operate(getOmegaInverse());\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.operate(getX());\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.getInverse();\n        RealMatrix XTOmegaInversey = XTOmegaInverse.operate(getY());\n        return XTOmegaInverseXInverse.operate(XTOmegaInversey);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInverse = XT.multiply(getOmegaInverse());\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.multiply(getX());\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.getInverse();\n        RealMatrix XTOmegaInversey = XTOmegaInverse.operate(getY());\n        return XTOmegaInverseXInverse.operate(XTOmegaInversey);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInverseX = XT.multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.getInverse();\n        RealVector XTOmegaInverseY = XT.multiply(getOmegaInverse()).operate(getY());\n        return XTOmegaInverseXInverse.operate(XTOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Xt = getXt();\n        RealMatrix XtOmegaInvX = Xt.multiply(getOmegaInverse()).multiply(Xt.transpose());\n        RealMatrix XtOmegaInvXInv = XtOmegaInvX.getInverse();\n        RealMatrix XtOmegaInvY = Xt.multiply(getOmegaInverse()).operate(getY());\n        return XtOmegaInvXInv.operate(XtOmegaInvY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Xt = getXt();\n        RealMatrix XtOmegaInverse = Xt.multiply(getOmegaInverse());\n        RealMatrix XtOmegaInverseX = XtOmegaInverse.multiply(getX());\n        RealMatrix XtOmegaInverseXt = XtOmegaInverseX.transpose();\n        RealMatrix XtOmegaInverseXtXtOmegaInverse = XtOmegaInverseXt.multiply(XtOmegaInverse);\n        RealVector XtOmegaInverseY = XtOmegaInverse.operate(getY());\n        RealVector beta = XtOmegaInverseXtXtOmegaInverse.operate(XtOmegaInverseY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = X.transpose();\n        RealMatrix XTOmegaInvX = XT.multiply(getOmegaInverse()).multiply(X);\n        RealMatrix XTOmegaInvXInv = new LUDecomposition(XTOmegaInvX).getSolver().getInverse();\n        RealMatrix XTOmegaInvY = XT.multiply(getOmegaInverse()).operate(y);\n        return XTOmegaInvXInv.operate(XTOmegaInvY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix Xt = getXt();\n        RealMatrix XtOmegaInverse = Xt.multiply(getOmegaInverse());\n        RealMatrix XtOmegaInverseX = XtOmegaInverse.multiply(getX());\n        RealMatrix XtOmegaInverseXt = XtOmegaInverseX.transpose();\n        RealVector y = getY();\n        RealVector beta = XtOmegaInverseXt.operate(y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOmegaInverse = XT.operate(getOmegaInverse());\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.operate(getX());\n        RealMatrix XTOmegaInverseXInverse = XTOmegaInverseX.getInverse();\n        RealMatrix XTOmegaInversey = XTOmegaInverse.operate(getY());\n        return XTOmegaInverseXInverse.operate(XTOmegaInversey);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XT = new Array2DRowRealMatrix(getX()).transpose();\n        RealMatrix XTOmegaInverse = XT.multiply(getOmegaInverse());\n        RealMatrix XTOmegaInverseX = XTOmegaInverse.multiply(new Array2DRowRealMatrix(getX()));\n        RealMatrix XTOmegaInverseXInverse = new LUDecomposition(XTOmegaInverseX).getSolver().getInverse();\n        RealMatrix XTOmegaInversey = XTOmegaInverse.operate(new Array2DRowRealMatrix(getY()));\n        return XTOmegaInverseXInverse.operate(XTOmegaInversey);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null || id.isEmpty()) \n    {\n        return null;\n    }\n\n    if (this.id().equals(id)) \n    {\n        return this;\n    }\n\n    for (Element child : this.children()) \n    {\n        Element foundElement = child.getElementById(id);\n        if (foundElement != null) \n        {\n            return foundElement;\n        }\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (this.id().equals(id)) \n    {\n        return this;\n    }\n    Elements children = this.children();\n    for (Element child : children) \n    {\n        Element found = child.getElementById(id);\n        if (found != null) \n        {\n            return found;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collectFirst(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    if (id == null || id.isEmpty()) \n    {\n        return null;\n    }\n\n    if (this.id().equals(id)) \n    {\n        return this;\n    }\n\n    Elements elements = this.getElementsByAttributeValue(\"id\", id);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null || id.length() == 0)\n        return null;\n\n    for (Element el : this.getElementsByTag(\"*\"))\n    {\n        if (el.id().equals(id))\n            return el;\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int index = 0;\n    int customIndex = 0;\n    while (index < pattern.length()) \n    {\n        char c = pattern.charAt(index);\n        if (c == START_FE) \n        {\n            result.append(START_FE);\n            result.append(customPatterns.get(customIndex++));\n            result.append(END_FE);\n        } \n        else \n        {\n            result.append(c);\n        }\n        index++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int index = 0;\n    while (index < pattern.length()) \n    {\n        char c = pattern.charAt(index);\n        if (c == START_FE) \n        {\n            int end = pattern.indexOf(END_FE, index);\n            if (end == -1) \n            {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + index);\n            }\n            String desc = pattern.substring(index + 1, end);\n            Format format = getFormat(desc);\n            if (format != null) \n            {\n                result.append(format.toPattern());\n            } \n            else \n            {\n                result.append(START_FE).append(desc).append(END_FE);\n            }\n            index = end + 1;\n        } \n        else if (c == QUOTE) \n        {\n            String str = getQuotedString(pattern, index, false);\n            result.append(str);\n            index += str.length();\n        } \n        else \n        {\n            result.append(c);\n            index++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int customIndex = 0;\n    int pos = 0;\n    while (pos < pattern.length()) \n    {\n        char c = pattern.charAt(pos);\n        if (c == START_FE) \n        {\n            result.append(pattern.substring(pos, pos + 1));\n            pos++;\n            int depth = 1;\n            while (depth > 0) \n            {\n                if (pos >= pattern.length()) \n                {\n                    throw new IllegalArgumentException(\"Unterminated format element at position \" + (pos - 1));\n                }\n                c = pattern.charAt(pos);\n                if (c == START_FE) \n                {\n                    depth++;\n                } \n                else if (c == END_FE) \n                {\n                    depth--;\n                }\n                result.append(c);\n                pos++;\n            }\n        } \n        else if (c == QUOTE) \n        {\n            result.append(pattern.substring(pos, pos + 1));\n            pos++;\n            getQuotedString(pattern, pos, false);\n        } \n        else \n        {\n            if (customIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(customIndex));\n                customIndex++;\n            } \n            else \n            {\n                result.append(c);\n            }\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    int customIndex = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int end = pattern.indexOf(END_FE, pos);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n            }\n            String formatDesc = pattern.substring(pos + 1, end);\n            Format format = getFormat(formatDesc);\n            if (format == null) {\n                throw new IllegalArgumentException(\"Unknown format element: \" + formatDesc);\n            }\n            String customPattern = customPatterns.get(customIndex++);\n            result.append(customPattern);\n            pos = end + 1;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int customIndex = 0;\n    int i = 0;\n    while (i < pattern.length()) {\n        if (pattern.charAt(i) == START_FE) {\n            result.append(pattern.substring(i, i + 1));\n            if (customIndex < customPatterns.size()) {\n                result.append(customPatterns.get(customIndex++));\n            }\n            i++;\n        } else if (pattern.charAt(i) == END_FE) {\n            result.append(pattern.substring(i, i + 1));\n            i++;\n        } else {\n            result.append(pattern.charAt(i));\n            i++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int customIndex = 0;\n    int i = 0;\n    while (i < pattern.length()) \n    {\n        if (pattern.charAt(i) == START_FE) \n        {\n            int end = pattern.indexOf(END_FE, i);\n            if (end == -1) \n            {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + i);\n            }\n            String formatDesc = pattern.substring(i + 1, end);\n            Format format = getFormat(formatDesc);\n            if (format != null) \n            {\n                result.append(format.toPattern());\n            } \n            else \n            {\n                result.append(START_FE).append(formatDesc).append(END_FE);\n            }\n            i = end + 1;\n        } \n        else if (pattern.charAt(i) == QUOTE) \n        {\n            String quoted = getQuotedString(pattern, i, false);\n            result.append(quoted);\n            i += quoted.length();\n        } \n        else \n        {\n            result.append(pattern.charAt(i));\n            i++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int patternIndex = 0;\n    int customIndex = 0;\n    while (patternIndex < pattern.length()) \n    {\n        char c = pattern.charAt(patternIndex);\n        if (c == START_FE) \n        {\n            if (customIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(customIndex));\n            }\n            customIndex++;\n        } \n        else if (c == END_FE) \n        {\n            // Do nothing, we're just skipping over the end of format element marker\n        } \n        else \n        {\n            result.append(c);\n        }\n        patternIndex++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int patternIndex = 0;\n    int customIndex = 0;\n    while (patternIndex < pattern.length()) \n    {\n        char c = pattern.charAt(patternIndex);\n        if (c == START_FE) \n        {\n            result.append(START_FE);\n            if (customIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(customIndex));\n            }\n            result.append(END_FE);\n            customIndex++;\n        } \n        else \n        {\n            result.append(c);\n        }\n        patternIndex++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int i = 0;\n    while (i < pattern.length()) \n    {\n        char c = pattern.charAt(i);\n        if (c == START_FE) \n        {\n            int end = pattern.indexOf(END_FE, i);\n            if (end == -1) \n            {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + i);\n            }\n            String fmt = pattern.substring(i + 1, end);\n            Format format = getFormat(fmt);\n            if (format != null) \n            {\n                result.append(format.toPattern());\n            } \n            else \n            {\n                result.append(START_FE).append(fmt).append(END_FE);\n            }\n            i = end + 1;\n        } \n        else \n        {\n            result.append(c);\n            i++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        char c = pattern.charAt(pos);\n        if (c == START_FE) {\n            int end = pattern.indexOf(END_FE, pos);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n            }\n            String formatDesc = pattern.substring(pos + 1, end);\n            Format format = getFormat(formatDesc);\n            if (format != null) {\n                result.append(format.toPattern());\n            } else {\n                result.append(START_FE).append(formatDesc).append(END_FE);\n            }\n            pos = end + 1;\n        } else if (c == QUOTE) {\n            String quoted = getQuotedString(pattern, pos, false);\n            result.append(quoted);\n            pos += quoted.length();\n        } else {\n            result.append(c);\n            pos++;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!equal(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> var = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(var.getName());\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> var = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(var.getName());\n      }\n\n      if (!typeEquals(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fa = fromArgs[i];\n      Type ta = toArgs[i];\n\n      if (fa instanceof TypeVariable<?>) {\n        TypeVariable<?> tv = (TypeVariable<?>) fa;\n        fa = typeVarMap.get(tv.getName());\n      }\n\n      if (ta instanceof TypeVariable<?>) {\n        TypeVariable<?> tv = (TypeVariable<?>) ta;\n        ta = typeVarMap.get(tv.getName());\n      }\n\n      if (!typeEquals(fa, ta, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n\n      if (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> var = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(var.getName());\n      }\n\n      if (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> var = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(var.getName());\n      }\n\n      if (!typeEquals(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fa = fromArgs[i];\n      Type ta = toArgs[i];\n\n      if (fa instanceof TypeVariable<?>) {\n        TypeVariable<?> tv = (TypeVariable<?>) fa;\n        fa = typeVarMap.get(tv.getName());\n      }\n\n      if (ta instanceof TypeVariable<?>) {\n        TypeVariable<?> tv = (TypeVariable<?>) ta;\n        ta = typeVarMap.get(tv.getName());\n      }\n\n      if (!typeEquals(fa, ta, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fa = fromArgs[i];\n      Type ta = toArgs[i];\n      if (fa instanceof TypeVariable<?>) {\n        fa = typeVarMap.get(((TypeVariable<?>) fa).getName());\n      }\n      if (ta instanceof TypeVariable<?>) {\n        ta = typeVarMap.get(((TypeVariable<?>) ta).getName());\n      }\n      if (!typeEquals(fa, ta, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fArg = fromArgs[i];\n      Type tArg = toArgs[i];\n\n      if (fArg instanceof TypeVariable<?>) {\n        fArg = typeVarMap.get(((TypeVariable<?>) fArg).getName());\n      }\n\n      if (tArg instanceof TypeVariable<?>) {\n        tArg = typeVarMap.get(((TypeVariable<?>) tArg).getName());\n      }\n\n      if (!typeEquals(fArg, tArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof UnmodifiableIterator) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator instanceof UnmodifiableIterator) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    int color = (int)graph.getNode(node).getAnnotation();\n    if (colorToNodeMap[color] == null) \n    {\n        colorToNodeMap[color] = node;\n    }\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = (int) graph.getNode(node).getAnnotation();\n    if (colorToNodeMap[color] == null) \n    {\n        colorToNodeMap[color] = node;\n    }\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = (int) graph.getNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = (int)graph.getNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getNodeColor(node);\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = (int)graph.getNode(node).getAnnotation();\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getNodeColor(node);\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Preconditions.checkNotNull(node);\n  return colorToNodeMap[getColor(node)];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getNodeColor(node);\n    if (colorToNodeMap[color] == null) \n    {\n        colorToNodeMap[color] = node;\n    }\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getNodeColor(node);\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key) || !map2.get(key).equals(map1.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key) || !map2.get(key).equals(map1.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) \n    {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Object key : map1.keySet()) \n    {\n        if (!map2.containsKey(key) || !map1.get(key).equals(map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString() && expr.getString().length() > 10) \n    {\n        String encoded = encodeString(expr.getString());\n        Node encodedNode = IR.string(encoded);\n        parent.replaceChild(expr, encodedNode);\n        t.reportCodeChange();\n        return encodedNode;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        if (str.length() > 3) \n        {\n            // Create a new short string expression node.\n            Node shortStr = new Node(Token.STRING, str.substring(0, 3));\n            shortStr.setLength(3);\n            parent.replaceChild(expr, shortStr);\n            t.reportCodeChange();\n            return shortStr;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String original = expr.getString();\n        String encoded = encodeString(original);\n        Node replacement = IR.string(encoded);\n        parent.replaceChild(expr, replacement);\n        t.reportCodeChange();\n        return replacement;\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String str = expr.getString();\n    if (str.length() > 3) \n    {\n      str = str.substring(0, 3) + \"...\";\n      expr = Node.newString(str);\n      parent.replaceChild(expr, expr);\n      t.reportCodeChange();\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        // Encode the string.\n        String encodedStr = encodeString(str);\n        // Create a new string node with the encoded string.\n        Node encodedExpr = Node.newString(encodedStr);\n        // Replace the original string node with the new node.\n        parent.replaceChild(expr, encodedExpr);\n        // Return the new node.\n        return encodedExpr;\n    }\n    // If the expression is not a string, return the original expression.\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String str = expr.getString();\n    // Perform the replacement here\n    // For example, you could replace the string with a shortened version\n    // or encode the string in some way\n    // Here's a simple example:\n    str = str.substring(0, 5); // Replace the string with the first 5 characters\n    expr.setString(str);\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String originalString = expr.getString();\n    String encodedString = encodeString(originalString);\n    Node encodedNode = IR.string(encodedString);\n    parent.replaceChild(expr, encodedNode);\n    t.reportCodeChange();\n    return encodedNode;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String str = expr.getString();\n    if (str.length() > 10) \n    {\n      String shortStr = str.substring(0, 7) + \"...\" + str.substring(str.length() - 2);\n      Node shortStrNode = Node.newString(shortStr);\n      parent.replaceChild(expr, shortStrNode);\n      t.reportCodeChange();\n      return shortStrNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String str = expr.getString();\n        if (str.length() > 10) \n        {\n            String shortStr = str.substring(0, 10);\n            Node newExpr = Node.newString(shortStr);\n            parent.replaceChild(expr, newExpr);\n            t.reportCodeChange();\n            return newExpr;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String original = expr.getString();\n        String encoded = encodeString(original);\n        Node replacement = Node.newString(encoded);\n        parent.replaceChild(expr, replacement);\n        t.reportCodeChange();\n        return replacement;\n    }\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction() || node.isAssign()) {\n      Node jsDocNode = NodeUtil.getBestJsDocNode(node);\n      if (jsDocNode != null) {\n        JSDocInfo info = jsDocNode.getJSDocInfo();\n        if (info != null) {\n          String desc = info.getDescription();\n          if (desc != null && !desc.isEmpty()) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction()) {\n      Node jsDocNode = node.getFirstChild();\n      if (jsDocNode != null && jsDocNode.isDoc()) {\n        Node descNode = jsDocNode.getFirstChild();\n        while (descNode != null) {\n          if (descNode.isComment() && descNode.getString().contains(\"@desc\")) {\n            String desc = descNode.getString().split(\"@desc\")[1].trim();\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n          descNode = descNode.getNext();\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction()) {\n      Node jsDocNode = node.getFirstChild();\n      if (jsDocNode != null && jsDocNode.isJsDoc()) {\n        Node descNode = jsDocNode.getFirstChild();\n        while (descNode != null) {\n          if (descNode.isDocType()) {\n            descNode = descNode.getNext();\n          } else if (descNode.isDocComment()) {\n            String comment = descNode.getString();\n            if (comment.contains(\"@desc\")) {\n              int start = comment.indexOf(\"@desc\") + 6;\n              int end = comment.indexOf(\"\\n\", start);\n              if (end == -1) {\n                end = comment.length();\n              }\n              String desc = comment.substring(start, end).trim();\n              if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n              } else {\n                builder.setDesc(desc);\n              }\n              return true;\n            } else {\n              descNode = descNode.getNext();\n            }\n          } else {\n            descNode = descNode.getNext();\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction() || node.isAssign()) {\n      Node jsDocNode = NodeUtil.getBestJSDocInfoNode(node);\n      if (jsDocNode != null) {\n        JSDocInfo jsDoc = jsDocNode.getJSDocInfo();\n        if (jsDoc != null) {\n          String desc = jsDoc.getDescription();\n          if (desc != null) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction() || node.isAssign()) {\n      Node jsDocNode = NodeUtil.getBestJSDocInfoNode(node);\n      if (jsDocNode != null) {\n        JSDocInfo info = jsDocNode.getJSDocInfo();\n        if (info != null) {\n          String desc = info.getDescription();\n          if (desc != null && !desc.isEmpty()) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc != null) {\n      Description description = jsDoc.getDescription();\n      if (description != null) {\n        String desc = description.getDescription();\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction() || node.isAssign()) {\n      Node jsDocNode = NodeUtil.getBestJSDocInfoNode(node);\n      if (jsDocNode != null) {\n        JSDocInfo jsDoc = jsDocNode.getJSDocInfo();\n        if (jsDoc != null) {\n          String desc = jsDoc.getDescription();\n          if (desc != null) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction()) {\n      Node jsDocNode = node.getFirstChild();\n      if (jsDocNode != null && jsDocNode.isDoc()) {\n        Node descNode = jsDocNode.getFirstChild();\n        while (descNode != null) {\n          if (descNode.isDocString()) {\n            String jsDocString = descNode.getString();\n            if (jsDocString.contains(\"@desc\")) {\n              String desc = jsDocString.substring(jsDocString.indexOf(\"@desc\") + 6).trim();\n              if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n              } else {\n                builder.setDesc(desc);\n              }\n              return true;\n            }\n          }\n          descNode = descNode.getNext();\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isFunction() || node.isAssign()) {\n      Node jsDocNode = NodeUtil.getBestJSDocInfoNode(node);\n      if (jsDocNode != null) {\n        JSDocInfo jsDocInfo = jsDocNode.getJSDocInfo();\n        if (jsDocInfo != null) {\n          String desc = jsDocInfo.getDescription();\n          if (desc != null) {\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n              builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n              builder.setIsHidden(true);\n            } else {\n              builder.setDesc(desc);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc != null) {\n      String desc = jsDoc.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int index = getNearestClusterIndex(clusters, point);\n            if (assignments[i] != index) {\n                changes++;\n            }\n            assignments[i] = index;\n            clusters.get(index).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            int closestClusterIndex = 0;\n            double minDistance = distance(point, clusters.get(0).getCenter());\n            for (int j = 1; j < clusters.size(); j++) {\n                final double distance = distance(point, clusters.get(j).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestClusterIndex = j;\n                }\n            }\n            if (assignments[i] != closestClusterIndex) {\n                changes++;\n            }\n            assignments[i] = closestClusterIndex;\n            clusters.get(closestClusterIndex).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int index = findClosestCluster(clusters, point);\n            if (assignments[i] != index) {\n                changes++;\n            }\n            assignments[i] = index;\n            clusters.get(index).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = points.iterator().next();\n            int index = getNearestClusterIndex(clusters, point);\n            if (index != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = index;\n            clusters.get(index).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int oldClusterIndex = assignments[i];\n            final CentroidCluster<T> oldCluster = clusters.get(oldClusterIndex);\n            final int newClusterIndex = getNearestClusterIndex(clusters, point);\n            final CentroidCluster<T> newCluster = clusters.get(newClusterIndex);\n            if (newClusterIndex != oldClusterIndex) {\n                oldCluster.removePoint(point);\n                newCluster.addPoint(point);\n                assignments[i] = newClusterIndex;\n                changes++;\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            T point = points.iterator().next();\n            int index = getNearestClusterIndex(clusters, point);\n            if (index != assignments[i]) {\n                changes++;\n            }\n            assignments[i] = index;\n            clusters.get(index).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.iterator().next();\n        int index = getNearestClusterIndex(clusters, point);\n        if (assignments[i] != index) {\n            changes++;\n        }\n        assignments[i] = index;\n        clusters.get(index).addPoint(point);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        int index = 0;\n        for (final T point : points) {\n            final int oldClusterIndex = assignments[index++];\n            final int newClusterIndex = findNearestCluster(clusters, point);\n            if (oldClusterIndex != newClusterIndex) {\n                changes++;\n            }\n            assignments[index - 1] = newClusterIndex;\n            clusters.get(newClusterIndex).addPoint(point);\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        int index = 0;\n        for (final T point : points) {\n            int minIndex = 0;\n            double minDistance = distance(point, clusters.get(0).getCenter());\n            for (int i = 1; i < clusters.size(); i++) {\n                double distance = distance(point, clusters.get(i).getCenter());\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = i;\n                }\n            }\n            if (minIndex != assignments[index]) {\n                changes++;\n            }\n            assignments[index++] = minIndex;\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int changes = 0;\n        for (int i = 0; i < points.size(); i++) {\n            final T point = points.iterator().next();\n            final int oldClusterIndex = assignments[i];\n            final CentroidCluster<T> oldCluster = clusters.get(oldClusterIndex);\n            final double[] pointArray = point.toArray();\n            final int newClusterIndex = findClosestCluster(clusters, pointArray);\n            final CentroidCluster<T> newCluster = clusters.get(newClusterIndex);\n            if (newClusterIndex != oldClusterIndex) {\n                oldCluster.removePoint(point);\n                newCluster.addPoint(point);\n                assignments[i] = newClusterIndex;\n                changes++;\n            }\n        }\n        return changes;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must be of the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"At least two data points are required\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double v : xArray) {\n        meanX += v;\n    }\n    for (double v : yArray) {\n        meanY += v;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return sum / (xArray.length - (biasCorrected ? 1 : 0));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must contain at least two elements\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double value : xArray) {\n        meanX += value;\n    }\n    for (double value : yArray) {\n        meanY += value;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"The arrays lengths do not match.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data.\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double value : xArray) {\n        meanX += value;\n    }\n    for (double value : yArray) {\n        meanY += value;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must have at least two elements.\");\n    }\n    double meanX = 0.0;\n    double meanY = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"The arrays lengths do not match.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data.\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"The length of xArray and yArray must be the same.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"The length of xArray and yArray must be at least 2.\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double value : xArray) {\n        meanX += value;\n    }\n    for (double value : yArray) {\n        meanY += value;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return sum / (xArray.length - (biasCorrected ? 1 : 0));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must contain at least two elements.\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double v : xArray) {\n        meanX += v;\n    }\n    for (double v : yArray) {\n        meanY += v;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must contain at least two elements\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double x : xArray) {\n        meanX += x;\n    }\n    for (double y : yArray) {\n        meanY += y;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return sum / (xArray.length - (biasCorrected ? 1 : 0));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must be of the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must contain at least two elements\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Arrays must have at least two elements\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (double x : xArray) {\n        meanX += x;\n    }\n    for (double y : yArray) {\n        meanY += y;\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return sum / (xArray.length - (biasCorrected ? 1 : 0));\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long bytesRead = in.skip(value - skipped);\n        if (bytesRead == 0) \n        {\n            break;\n        }\n        skipped += bytesRead;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) \n    {\n        remaining -= in.skip(remaining);\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) \n    {\n        long skipped = in.skip(remaining);\n        if (skipped <= 0) \n        {\n            throw new EOFException(\"EOF reached while skipping \" + remaining + \" bytes\");\n        }\n        remaining -= skipped;\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0)\n    {\n        long skipped = in.skip(remaining);\n        if (skipped <= 0)\n        {\n            break;\n        }\n        remaining -= skipped;\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) \n    {\n        remaining -= in.skip(remaining);\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        skipped += in.skip(value - skipped);\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    int len = (int) value;\n    while (len > 0) \n    {\n        len -= in.read(buf.array(), 0, Math.min(len, buf.capacity()));\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) \n    {\n        long skipped = in.skip(remaining);\n        if (skipped <= 0) \n        {\n            throw new EOFException(\"Premature EOF while skipping\");\n        }\n        remaining -= skipped;\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        skipped += in.skip(value - skipped);\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0)\n    {\n        remaining -= in.skip(remaining);\n    }\n    bytesRead += value;\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"SHA-256\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        byte[] bytes = part.toString().getBytes(StandardCharsets.UTF_8);\n        md.update(bytes);\n    }\n    byte[] digest = md.digest();\n    for (byte b : digest) {\n        sb.append(String.format(\"%02x\", b));\n    }\n    return sb.toString().substring(0, 12).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance(\"SHA-256\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(\"SHA-256 algorithm not found\", e);\n    }\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        md.update(part.toString().getBytes(StandardCharsets.UTF_8));\n    }\n    byte[] digest = md.digest();\n    for (byte b : digest) {\n        sb.append(String.format(\"%02x\", b));\n    }\n    return sb.toString().substring(0, 12).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder fingerprintBuilder = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        fingerprintBuilder.append(part.toString());\n    }\n    return fingerprintBuilder.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement the fingerprint logic here\n    // ...\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement the fingerprint generation logic here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Your implementation here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Your implementation here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Your code here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        sb.append(part);\n    }\n    return DigestUtils.md5Hex(sb.toString()).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    return Hashing.md5().newHasher().putString(sb.toString(), StandardCharsets.UTF_8).hash().toString();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minDistance = minDistanceFromEnd;\n    long maxDistance = maxDistanceFromEnd;\n    if (minDistance > maxDistance) {\n        throw new IllegalArgumentException(\"minDistanceFromEnd > maxDistanceFromEnd\");\n    }\n    if (minDistance < 0 || maxDistance < 0) {\n        throw new IllegalArgumentException(\"minDistanceFromEnd or maxDistanceFromEnd < 0\");\n    }\n    if (minDistance > archive.length()) {\n        minDistance = archive.length();\n    }\n    if (maxDistance > archive.length()) {\n        maxDistance = archive.length();\n    }\n    if (minDistance > maxDistance) {\n        return false;\n    }\n    final byte[] buffer = new byte[(int) (maxDistance - minDistance + 1)];\n    archive.seek(minDistance);\n    IOUtils.readFully(archive, buffer);\n    final int bufferLength = buffer.length;\n    for (int i = bufferLength - sig.length; i >= 0; i--) {\n        if (buffer[i] == sig[0]) {\n            boolean match = true;\n            for (int j = 1; j < sig.length; j++) {\n                if (buffer[i + j] != sig[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                archive.seek(minDistance + i);\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        archive.seek(archive.length() - distanceFromEnd);\n        byte[] b = new byte[sig.length];\n        archive.read(b);\n        if (Arrays.equals(sig, b)) {\n            return true;\n        }\n        distanceFromEnd++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minDistance = minDistanceFromEnd;\n    long maxDistance = maxDistanceFromEnd;\n    long distance = maxDistance;\n    long position = archive.length() - distance;\n    while (distance >= minDistance) {\n        archive.position(position);\n        byteBuf.rewind();\n        IOUtils.readFully(archive, byteBuf);\n        if (Arrays.equals(byteBuf, sig)) {\n            return true;\n        }\n        distance -= WORD;\n        position = archive.length() - distance;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    archive.seek(archive.length() - distanceFromEnd);\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        byte[] buffer = new byte[sig.length];\n        archive.read(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n        distanceFromEnd++;\n        archive.seek(archive.length() - distanceFromEnd);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long minPos = archive.length() - maxDistanceFromEnd;\n    long pos = Math.max(minPos, archive.position());\n    archive.position(pos);\n    final byte[] buffer = new byte[sig.length];\n    while (pos >= minPos) {\n        archive.read(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(pos);\n            return true;\n        }\n        pos--;\n        archive.position(pos);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = maxDistanceFromEnd;\n    while (distanceFromEnd >= minDistanceFromEnd) {\n        archive.seek(archive.length() - distanceFromEnd);\n        byte[] buf = new byte[sig.length];\n        IOUtils.readFully(archive, buf);\n        if (Arrays.equals(sig, buf)) {\n            return true;\n        }\n        distanceFromEnd--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = maxDistanceFromEnd;\n    while (distanceFromEnd >= minDistanceFromEnd) \n    {\n        archive.seek(archive.length() - distanceFromEnd);\n        final byte[] buffer = new byte[sig.length];\n        archive.read(buffer);\n        if (Arrays.equals(sig, buffer)) \n        {\n            return true;\n        }\n        distanceFromEnd--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long minPos = archive.length() - maxDistanceFromEnd;\n    final long maxPos = archive.length() - minDistanceFromEnd;\n    archive.seek(maxPos);\n    byte[] buffer = new byte[sig.length];\n    int read;\n    while ((read = archive.read(buffer)) == sig.length) {\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n        archive.seek(archive.getFilePointer() - 1);\n    }\n    if (read != -1) {\n        archive.seek(archive.getFilePointer() - read);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - minDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    long end = archive.length() - maxDistanceFromEnd;\n    if (end < 0) {\n        end = 0;\n    }\n    while (pos >= end) {\n        archive.position(pos);\n        final byte[] b = new byte[sig.length];\n        IOUtils.readFully(archive, b);\n        if (Arrays.equals(sig, b)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        archive.seek(archive.length() - distanceFromEnd);\n        byte[] b = new byte[sig.length];\n        IOUtils.readFully(archive, b);\n        if (Arrays.equals(sig, b)) {\n            return true;\n        }\n        distanceFromEnd++;\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = RectangleEdge.TOP;\n    if (location == AxisLocation.BOTTOM_OR_RIGHT) \n    {\n        edge = RectangleEdge.BOTTOM;\n    } \n    else if (location == AxisLocation.TOP_OR_LEFT) \n    {\n        edge = RectangleEdge.TOP;\n    } \n    else if (location == AxisLocation.CENTER) \n    {\n        edge = RectangleEdge.CENTER;\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisLocations.size()) \n    {\n        AxisLocation location = (AxisLocation) this.domainAxisLocations.get(index);\n        if (location == AxisLocation.TOP_OR_RIGHT) \n        {\n            result = RectangleEdge.TOP;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_LEFT) \n        {\n            result = RectangleEdge.BOTTOM;\n        } \n        else if (location == AxisLocation.TOP_OR_LEFT) \n        {\n            result = RectangleEdge.LEFT;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) \n        {\n            result = RectangleEdge.RIGHT;\n        }\n    }\n    if (result == null) \n    {\n        result = RectangleEdge.TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == null) {\n        throw new IllegalArgumentException(\"Null 'location' for index \" + index);\n    }\n    RectangleEdge result = RectangleEdge.opposite(location.getEdge());\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisLocations.size()) \n    {\n        AxisLocation location = (AxisLocation) this.domainAxisLocations.get(index);\n        if (location == AxisLocation.TOP_OR_LEFT) \n        {\n            result = RectangleEdge.TOP;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) \n        {\n            result = RectangleEdge.BOTTOM;\n        } \n        else if (location == AxisLocation.TOP_OR_RIGHT) \n        {\n            result = RectangleEdge.RIGHT;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_LEFT) \n        {\n            result = RectangleEdge.LEFT;\n        }\n    }\n    if (result == null) \n    {\n        result = RectangleEdge.TOP;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = RectangleEdge.TOP;\n    AxisLocation loc = getDomainAxisLocation(index);\n    if (loc == AxisLocation.BOTTOM_OR_RIGHT) \n    {\n        result = RectangleEdge.BOTTOM;\n    } \n    else if (loc == AxisLocation.TOP_OR_LEFT) \n    {\n        result = RectangleEdge.TOP;\n    } \n    else if (loc == AxisLocation.LEFT_OR_TOP) \n    {\n        result = RectangleEdge.LEFT;\n    } \n    else if (loc == AxisLocation.RIGHT_OR_BOTTOM) \n    {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == null) \n    {\n        throw new IllegalArgumentException(\"Null axis location.\");\n    }\n    RectangleEdge result = RectangleEdge.TOP;\n    if (location == AxisLocation.BOTTOM) \n    {\n        result = RectangleEdge.BOTTOM;\n    }\n    else if (location == AxisLocation.LEFT) \n    {\n        result = RectangleEdge.LEFT;\n    }\n    else if (location == AxisLocation.RIGHT) \n    {\n        result = RectangleEdge.RIGHT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = RectangleEdge.TOP;\n    if (index < this.domainAxisLocations.size()) \n    {\n        AxisLocation location = (AxisLocation) this.domainAxisLocations.get(index);\n        if (location == AxisLocation.BOTTOM_OR_LEFT) \n        {\n            result = RectangleEdge.BOTTOM;\n        } \n        else if (location == AxisLocation.TOP_OR_RIGHT) \n        {\n            result = RectangleEdge.TOP;\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    if (index < this.domainAxisLocations.size()) \n    {\n        AxisLocation location = (AxisLocation) this.domainAxisLocations.get(index);\n        if (location == AxisLocation.TOP_OR_LEFT) \n        {\n            result = RectangleEdge.TOP;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) \n        {\n            result = RectangleEdge.BOTTOM;\n        } \n        else if (location == AxisLocation.TOP_OR_RIGHT) \n        {\n            result = RectangleEdge.RIGHT;\n        } \n        else if (location == AxisLocation.BOTTOM_OR_LEFT) \n        {\n            result = RectangleEdge.LEFT;\n        }\n    }\n    if (result == null) \n    {\n        result = RectangleEdge.LEFT;\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    RectangleEdge result = null;\n    AxisLocation loc = getDomainAxisLocation(index);\n    if (loc != null) \n    {\n        if (getOrientation() == PlotOrientation.HORIZONTAL) \n        {\n            if (loc == AxisLocation.TOP_OR_LEFT) \n            {\n                result = RectangleEdge.TOP;\n            } \n            else if (loc == AxisLocation.BOTTOM_OR_RIGHT) \n            {\n                result = RectangleEdge.BOTTOM;\n            } \n            else \n            {\n                result = RectangleEdge.LEFT;\n            }\n        } \n        else \n        {\n            if (loc == AxisLocation.TOP_OR_LEFT) \n            {\n                result = RectangleEdge.LEFT;\n            } \n            else if (loc == AxisLocation.BOTTOM_OR_RIGHT) \n            {\n                result = RectangleEdge.RIGHT;\n            } \n            else \n            {\n                result = RectangleEdge.TOP;\n            }\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    if (location == null) \n    {\n        throw new IllegalArgumentException(\"Null axis location.\");\n    }\n    RectangleEdge result = RectangleEdge.opposite(location.getEdge());\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    // Your code here\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    // Implementation goes here\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    // Implement the logic to return the input stream with the buffered data and any remaining content\n    // from the original stream.\n    // Your implementation should handle the case where the original stream is null.\n    // If the original stream is null, you should return a new InputStream that includes the buffered data.\n    // If the original stream is not null, you should return a new InputStream that includes the buffered data\n    // followed by any remaining content from the original stream.\n    // Your implementation should also handle the case where the buffered data is null or empty.\n    // If the buffered data is null or empty, you should return a new InputStream that includes only the remaining content from the original stream.\n    // Your implementation should also handle the case where the remaining content from the original stream is null or empty.\n    // If the remaining content from the original stream is null or empty, you should return a new InputStream that includes only the buffered data.\n    // Your implementation should also handle the case where the buffered data and the remaining content from the original stream are both null or empty.\n    // If the buffered data and the remaining content from the original stream are both null or empty, you should return a new InputStream that is empty.\n    // Your implementation should handle the case where the original stream is closed or has an error.\n    // If the original stream is closed or has an error, you should return a new InputStream that is empty.\n    // Your implementation should handle the case where the buffered data is not a valid input for the JsonFactory.\n    // If the buffered data is not a valid input for the JsonFactory, you should return a new InputStream that is empty.\n    // Your implementation should handle the case where the remaining content from the original stream is not a valid input for the JsonFactory.\n    // If the remaining content from the original stream is not a valid input for the JsonFactory, you should return a new InputStream that is empty.\n    // Your implementation should handle the case where the buffered data and the remaining content from the original stream are both not valid inputs for the JsonFactory.\n    // If the buffered data and the remaining content from the original stream are both not valid inputs for the JsonFactory, you should return a new InputStream that is empty.\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    // Create a new ByteArrayInputStream from the buffered data\n    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    \n    // Create a new SequenceInputStream from the original stream and the ByteArrayInputStream\n    SequenceInputStream sequenceInputStream = new SequenceInputStream(byteArrayInputStream, _originalStream);\n    \n    return sequenceInputStream;\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < getSectionCount()) {\n        key = getSectionKey(section);\n    }\n    if (key == null) {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) \n    {\n        key = getSectionKey(section);\n    }\n    else \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) \n    {\n        key = getSectionKey(section);\n    }\n    else \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) \n    {\n        key = getSectionKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getDataset().getItemCount()) \n    {\n        key = getDataset().getKey(section);\n    } \n    else \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getDataset().getSeriesCount()) \n    {\n        key = getDataset().getSeriesKey(section);\n    } \n    else \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = Integer.toString(section);\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return Double.isNaN((Double) ob);\n                }\n                return false;\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                }\n                if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return Double.isNaN((Double) ob);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return Double.isNaN((Double) ob);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                return Double.isNaN(n.doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                return Double.isNaN(n.doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                return n.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                return n.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = (Number) _currentObject();\n                return Double.isNaN(n.doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return Double.isNaN((Double) ob);\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (ignoreCase) {\n        return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n    }\n    return str.startsWith(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (ignoreCase) {\n        return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n    }\n    return str.startsWith(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (ignoreCase) {\n        return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n    }\n    return str.startsWith(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (ignoreCase) {\n        return str.toString().toLowerCase().startsWith(prefix.toString().toLowerCase());\n    }\n    return str.toString().startsWith(prefix.toString());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return str.subSequence(0, prefix.length()).equalsIgnoreCase(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == prefix;\n    }\n    if (ignoreCase) {\n        return str.toString().toLowerCase().startsWith(prefix.toString().toLowerCase());\n    }\n    return str.toString().startsWith(prefix.toString());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n        result = String.valueOf(nextDouble());\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    result = String.valueOf(peekedLong);\n    peeked = PEEKED_NONE;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_LONG || p == PEEKED_NUMBER) \n    {\n        result = Long.toString(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    result = String.valueOf(peekedLong);\n    peeked = PEEKED_NONE;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    result = String.valueOf(peekedLong);\n    peeked = PEEKED_NONE;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_LONG || p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_LONG || p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuilder out = new StringBuilder(maxWidth);\n    out.append(str, 0, offset);\n    out.append(\"...\");\n    out.append(str, str.length() - (maxWidth - 3), str.length());\n    return out.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return s2 == null;\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) \n    {\n        return true;\n    }\n    if ((s1 == null) || (s2 == null)) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) \n  {\n    return index;\n  } \n  else \n  {\n    index = nameMap.size();\n    nameMap.put(symbolName, index);\n    return index;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (!symbolNameMap.containsKey(symbolName)) \n    {\n        symbolNameMap.put(symbolName, symbolNameMap.size());\n    }\n    return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (!symbolNameMap.containsKey(symbolName)) \n    {\n        symbolNameMap.put(symbolName, symbolNameMap.size());\n    }\n    return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n  if (!symbolNameMap.containsKey(symbolName)) \n  {\n    symbolNameMap.put(symbolName, symbolNameMap.size());\n  }\n  return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  Integer index = nameMap.get(symbolName);\n  if (index != null) \n  {\n    return index;\n  } \n  else \n  {\n    index = nameMap.size();\n    nameMap.put(symbolName, index);\n    return index;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (!symbolNameMap.containsKey(symbolName)) \n    {\n        symbolNameMap.put(symbolName, symbolNameMap.size());\n    }\n    return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n    if (!symbolNameMap.containsKey(symbolName)) \n    {\n        symbolNameMap.put(symbolName, symbolNameMap.size());\n    }\n    return symbolNameMap.get(symbolName);\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String number = new String(buffer, pos, peekedNumberLength);\n        peeked = PEEKED_NONE;\n        result = Double.parseDouble(number);\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String number = nextUnquotedValue();\n        result = Double.parseDouble(number);\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        String number = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        result = Double.parseDouble(number);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String value = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(value);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new IllegalStateException(\"Expected a double but was \" + value + locationString(), e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String number = new String(buffer, pos, peekedNumberLength);\n        peeked = PEEKED_NONE;\n        result = Double.parseDouble(number);\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String number = nextUnquotedValue();\n        result = Double.parseDouble(number);\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        String number = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        result = Double.parseDouble(number);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String number = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        try \n        {\n            result = Double.parseDouble(number);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(e);\n        }\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        String number = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        try \n        {\n            result = Double.parseDouble(number);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String numberAsString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        try \n        {\n            result = Double.parseDouble(numberAsString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new IllegalStateException(\"Expected a double but was \" + numberAsString + locationString(), e);\n        }\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String numberAsString = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(numberAsString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new IllegalStateException(\"Expected a double but was \" + numberAsString + locationString(), e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String value = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(value);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Expected a double but was \" + value + locationString(), e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String numberAsString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        try \n        {\n            result = Double.parseDouble(numberAsString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Expected a double but was \" + numberAsString + locationString(), e);\n        }\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String numberAsString = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(numberAsString);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Expected a double but was \" + numberAsString + locationString(), e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String value = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(value);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new MalformedJsonException(\"Cannot parse double value: \" + value, e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        String numberAsString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        result = Double.parseDouble(numberAsString);\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String numberAsString = nextUnquotedValue();\n        result = Double.parseDouble(numberAsString);\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        String numberAsString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        result = Double.parseDouble(numberAsString);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    if (isLenient()) \n    {\n        return result;\n    }\n    if (Double.isInfinite(result) || Double.isNaN(result)) \n    {\n        throw new MalformedJsonException(\"JSON cannot represent non-finite numbers\");\n    }\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = peekedLong;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = Double.parseDouble(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String value = nextUnquotedValue();\n        try \n        {\n            result = Double.parseDouble(value);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Cannot parse double value from unquoted literal: \" + value, e);\n        }\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n        String value = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        try \n        {\n            result = Double.parseDouble(value);\n        } \n        catch (NumberFormatException e) \n        {\n            throw new JsonSyntaxException(\"Cannot parse double value from quoted literal: \" + value, e);\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Trimming",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Substring",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    // Padding\n    //-----------------------------------------------------------------------"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField();\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField();\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField();\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n    // ContainsAny",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n    // ContainsAny",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}\n    // ContainsAny",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator it = map.entrySet().iterator(); it.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) it.next();\n        CategoryDataset dataset = (CategoryDataset) entry.getKey();\n        clone.put(dataset, ((Marker) entry.getValue()).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        Object value = map.get(key);\n        if (value instanceof Marker) \n        {\n            Marker marker = (Marker) value;\n            clone.put(key, marker.clone());\n        } \n        else \n        {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        clone.put(key, ((Marker) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        clone.put(key, ((Marker) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        List markers = (List) map.get(key);\n        List clonedMarkers = new ArrayList();\n        for (Object marker : markers) \n        {\n            clonedMarkers.add((Marker) marker.clone());\n        }\n        clone.put(key, clonedMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        Object value = map.get(key);\n        if (value instanceof Marker) \n        {\n            Marker marker = (Marker) value;\n            clone.put(key, marker.clone());\n        } \n        else \n        {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        Object value = map.get(key);\n        if (value instanceof Cloneable) \n        {\n            Object clonedValue = ((Cloneable) value).clone();\n            clone.put(key, clonedValue);\n        } \n        else \n        {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        clone.put(entry.getKey(), ((Marker) entry.getValue()).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        List markers = (List) map.get(key);\n        List clonedMarkers = new ArrayList();\n        for (Object marker : markers) \n        {\n            if (marker instanceof Cloneable) \n            {\n                Cloneable clonedMarker = (Cloneable) marker.clone();\n                clonedMarkers.add(clonedMarker);\n            } \n            else \n            {\n                throw new CloneNotSupportedException(\"Marker is not cloneable.\");\n            }\n        }\n        clone.put(key, clonedMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        List values = (List) map.get(key);\n        List clonedValues = new ArrayList();\n        for (Object value : values) \n        {\n            if (value instanceof Marker) \n            {\n                Marker marker = (Marker) value;\n                Marker clonedMarker = (Marker) marker.clone();\n                clonedValues.add(clonedMarker);\n            } \n            else \n            {\n                clonedValues.add(value);\n            }\n        }\n        clone.put(key, clonedValues);\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // iterates over collection\n        for (E element : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (E object : coll) \n        {\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // check if the collection is not null\n        if (coll == null) {\n            throw new NullPointerException(\"Collection must not be null\");\n        }\n        // check if the collection is not empty\n        if (coll.isEmpty()) {\n            return false;\n        }\n        // iterate over the collection\n        for (E element : coll) {\n            // add the element to the list if it is not already present\n            if (add(element) == false) {\n                // if the element is already present, remove it from the collection\n                coll.remove(element);\n            }\n        }\n        // return true if the collection changed\n        return !coll.isEmpty();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // flag to indicate if any element was added\n        boolean added = false;\n\n        // iterates over the collection\n        for (E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n                added = true;\n            }\n        }\n\n        // returns the flag\n        return added;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // flag to detect if collection changed\n        boolean changed = false;\n\n        // iterates over collection\n        for (final E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n\n        // returns flag\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // flag to indicate if collection changed\n        boolean changed = false;\n\n        // iterates over the collection\n        for (final E object : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n\n        // returns the flag\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // flag to indicate if any elements were added\n        boolean changed = false;\n\n        // iterates over the collection\n        for (final E element : coll) \n        {\n            // adds the element if it is not already in the set\n            if (set.contains(element) == false) \n            {\n                // adds the element to the list\n                super.add(index, element);\n                // adds the element to the set\n                set.add(element);\n                // sets the flag to true\n                changed = true;\n            }\n        }\n\n        // returns the flag\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // flag to indicate if any elements were added\n        boolean changed = false;\n\n        // iterates over the collection\n        for (E element : coll) \n        {\n            // adds element if it is not contained already\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n\n        // returns the flag\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if they are not contained already\n        for (E object : coll)\n        {\n            add(index, object);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n        if (evaluations.getCount() >= maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n        if (evaluations.getCount() >= maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.increment();\n    if (evaluations.getCount() > maxEvaluations) {\n        throw new TooManyEvaluationsException(maxEvaluations);\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n        evaluations.incrementCount();\n        if (evaluations.getCount() > maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n        evaluations.incrementCount();\n        if (evaluations.getCount() > maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n        if (evaluations.getCount() >= maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.increment();\n    if (evaluations.getCount() > maxEvaluations) {\n        throw new TooManyEvaluationsException(maxEvaluations);\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n        evaluations.increment();\n        if (evaluations.getCount() > maxEvaluations) {\n            throw new TooManyEvaluationsException(maxEvaluations);\n        }\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    if (evaluations.getCount() > maxEvaluations) {\n        throw new TooManyEvaluationsException(maxEvaluations);\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    if (evaluations.getCount() > maxEvaluations) {\n        throw new TooManyEvaluationsException(maxEvaluations);\n    }\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double constantTerm = constraint.getValue();\n        if (constantTerm < 0) \n        {\n            // Flip the relationship and negate the coefficients\n            Relationship newRelationship = (constraint.getRelationship() == Relationship.LEQ) ? Relationship.GEQ : Relationship.LEQ;\n            RealVector newCoefficients = constraint.getCoefficients().mapMultiply(-1);\n            LinearConstraint newConstraint = new LinearConstraint(newCoefficients, newRelationship, -constantTerm);\n            normalizedConstraints.add(newConstraint);\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double value = constraint.getValue();\n        if (value < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients();\n            double constantTerm = constraint.getConstantTerm();\n            coefficients = coefficients.mapMultiply(-1);\n            constantTerm = -1 * constantTerm;\n            normalizedConstraints.add(new LinearConstraint(coefficients, Relationship.GEQ, constantTerm));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double value = constraint.getValue();\n        if (value < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients();\n            double constantTerm = constraint.getConstantTerm();\n            coefficients = coefficients.mapMultiply(-1);\n            constantTerm = -1 * constantTerm;\n            normalizedConstraints.add(new LinearConstraint(coefficients, Relationship.GEQ, constantTerm));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double constantTerm = constraint.getValue();\n        RealVector coefficients = constraint.getCoefficients();\n        double maxCoefficient = coefficients.getL1Norm();\n        double scaleFactor = constantTerm / maxCoefficient;\n        RealVector scaledCoefficients = coefficients.mapMultiply(scaleFactor);\n        LinearConstraint normalizedConstraint = new LinearConstraint(scaledCoefficients, Relationship.EQ, constantTerm);\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients();\n            double constantTerm = constraint.getValue();\n            Relationship relationship = constraint.getRelationship();\n            if (relationship == Relationship.LEQ) \n            {\n                relationship = Relationship.GEQ;\n            } \n            else if (relationship == Relationship.GEQ) \n            {\n                relationship = Relationship.LEQ;\n            }\n            normalizedConstraints.add(new LinearConstraint(coefficients, relationship, constantTerm));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getRelationship() == Relationship.LEQ) \n        {\n            // If the constraint is less than or equal to, add it as is\n            normalizedConstraints.add(constraint);\n        } \n        else \n        {\n            // If the constraint is greater than or equal to, add its negation\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), Relationship.LEQ, -constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double constantTerm = constraint.getValue();\n        RealVector coefficients = constraint.getCoefficients();\n        double maxCoefficient = coefficients.getL1Norm();\n        double multiplier = constantTerm / maxCoefficient;\n        RealVector normalizedCoefficients = coefficients.mapMultiply(multiplier);\n        LinearConstraint normalizedConstraint = new LinearConstraint(normalizedCoefficients, Relationship.EQ, constantTerm);\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double value = constraint.getValue();\n        if (value < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients();\n            double constantTerm = constraint.getConstantTerm();\n            normalizedConstraints.add(new LinearConstraint(coefficients.mapMultiply(-1), Relationship.GEQ, -1 * constantTerm));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double constantTerm = constraint.getValue();\n        if (constantTerm < 0) \n        {\n            // Flip the sign of the coefficients and the constant term\n            RealVector coefficients = constraint.getCoefficients().mapMultiply(-1);\n            constantTerm = -constantTerm;\n            // Create a new constraint with the flipped coefficients and constant term\n            LinearConstraint newConstraint = new LinearConstraint(coefficients, Relationship.GEQ, constantTerm);\n            normalizedConstraints.add(newConstraint);\n        } else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double constantTerm = constraint.getValue();\n        RealVector coefficients = constraint.getCoefficients();\n        double maxCoefficient = coefficients.getL1Norm();\n        if (maxCoefficient == 0) \n        {\n            throw new IllegalArgumentException(\"Constraint has no non-zero coefficients.\");\n        }\n        double multiplier = Math.abs(constantTerm) / maxCoefficient;\n        RealVector normalizedCoefficients = coefficients.mapMultiply(multiplier);\n        double normalizedConstantTerm = constantTerm * multiplier;\n        LinearConstraint normalizedConstraint = new LinearConstraint(normalizedCoefficients,\n                constraint.getRelationship(), normalizedConstantTerm);\n        normalizedConstraints.add(normalizedConstraint);\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null bin\");\n    }\n    return this.upperBound > bin.getLowerBound() && this.lowerBound < bin.getUpperBound();\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null bin argument.\");\n    }\n    \n    // Check if the bins are adjacent\n    if (this.upperBound == bin.getLowerBound()) \n    {\n        return true;\n    }\n    \n    // Check if the bins are adjacent\n    if (this.lowerBound == bin.getUpperBound()) \n    {\n        return true;\n    }\n    \n    // Check if the bins overlap\n    return (this.lowerBound <= bin.getUpperBound()) && \n           (this.upperBound >= bin.getLowerBound());\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.getLowerBound() > this.getUpperBound()) {\n        return false;\n    }\n    if (bin.getUpperBound() < this.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null bin\");\n    }\n    \n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (bin.getLowerBound() <= this.upperBound && bin.getUpperBound() >= this.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.upperBound > bin.getLowerBound() && this.lowerBound < bin.getUpperBound();\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null bin argument.\");\n    }\n    \n    // Check if the bins are adjacent\n    if (this.upperBound == bin.getLowerBound()) \n    {\n        return true;\n    }\n    \n    // Check if the bins are adjacent\n    if (this.lowerBound == bin.getUpperBound()) \n    {\n        return true;\n    }\n    \n    // Check if the bins overlap\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound()) \n    {\n        return true;\n    }\n    \n    // The bins do not overlap\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && \n            this.upperBound >= bin.lowerBound);\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final List<String> list = new ArrayList<>();\n    int i = 0;\n    int lastMatch = false;\n    int sizePlus1 = 0;\n    while (i < str.length()) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == Character.UPPERCASE_LETTER && camelCase && lastMatch) {\n            sizePlus1++;\n        } else {\n            sizePlus1++;\n        }\n        lastMatch = type == Character.LOWERCASE_LETTER;\n        i++;\n    }\n    final String[] array = new String[sizePlus1];\n    int j = 0;\n    i = 0;\n    lastMatch = false;\n    while (i < str.length()) {\n        final int type = Character.getType(str.charAt(i));\n        if (type == Character.UPPERCASE_LETTER && camelCase && lastMatch) {\n            array[j++] = str.substring(i - 1, i);\n        } else {\n            array[j++] = str.substring(i, i + 1);\n        }\n        lastMatch = type == Character.LOWERCASE_LETTER;\n        i++;\n    }\n    return array;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0;\n    int start = 0;\n    char[] chars = str.toCharArray();\n    char lastChar = Character.MIN_VALUE;\n    while (i < len) {\n        char c = chars[i];\n        int type = Character.getType(c);\n        if (camelCase && lastChar == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        } else {\n            if (type == Character.UPPERCASE_LETTER) {\n                if (i > start) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            } else if (type == Character.LOWERCASE_LETTER) {\n                if (i > start && !camelCase) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            } else {\n                if (i > start) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        }\n        lastChar = c;\n        i++;\n    }\n    if (i > start) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0;\n    char ch = str.charAt(i);\n    char type = Character.getType(ch);\n    while (i < len) {\n        if (camelCase && type == Character.UPPERCASE_LETTER && i > 0 &&\n            Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(i - 1, i));\n        } else {\n            int start = i;\n            while (i < len) {\n                ch = str.charAt(i);\n                if (Character.getType(ch) != type) {\n                    break;\n                }\n                i++;\n            }\n            list.add(str.substring(start, i));\n        }\n        if (i == len) {\n            break;\n        }\n        type = Character.getType(ch);\n    }\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0;\n    char ch = str.charAt(i);\n    char lastCh = Character.MIN_VALUE;\n    while (i < len) {\n        ch = str.charAt(i);\n        if (Character.getType(ch) == Character.getType(lastCh)) {\n            list.add(str.substring(i, i + 1));\n        } else if (camelCase && Character.isUpperCase(ch) && Character.isLowerCase(lastCh)) {\n            list.set(list.size() - 1, list.get(list.size() - 1) + ch);\n        } else {\n            list.add(str.substring(i, i + 1));\n        }\n        lastCh = ch;\n        i++;\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final List<String> list = new ArrayList<>();\n    int i = 0;\n    int j = 0;\n    while (j < str.length()) {\n        final int type = Character.getType(str.charAt(j));\n        if (type == Character.UPPERCASE_LETTER && camelCase && j > 0 && i < j) {\n            list.add(str.substring(i, j));\n            i = j;\n        } else if (type != Character.LOWERCASE_LETTER || !camelCase) {\n            while (j < str.length() && Character.getType(str.charAt(j)) == type) {\n                j++;\n            }\n            list.add(str.substring(i, j));\n            i = j;\n        } else {\n            j++;\n        }\n    }\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final List<String> list = new ArrayList<>();\n    int i = 0;\n    int j = 0;\n    while (i < str.length()) {\n        final int type1 = Character.getType(str.charAt(i));\n        while (j < str.length()) {\n            final int type2 = Character.getType(str.charAt(j));\n            if (type1 != type2) {\n                break;\n            }\n            j++;\n        }\n        if (camelCase && type1 == Character.UPPERCASE_LETTER && j < str.length() && Character.getType(str.charAt(j)) == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(i, j - 1));\n            list.add(str.substring(j - 1, j));\n        } else {\n            list.add(str.substring(i, j));\n        }\n        i = j;\n    }\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final List<String> list = new ArrayList<>();\n    int i = 0;\n    int j = 0;\n    while (i < str.length()) {\n        final int type = Character.getType(str.charAt(i));\n        if (camelCase && type == Character.UPPERCASE_LETTER && i > 0 && j > 0) {\n            list.add(str.substring(j, i));\n            j = i;\n        } else if (type != Character.LOWERCASE_LETTER || !camelCase) {\n            while (i < str.length() && Character.getType(str.charAt(i)) == type) {\n                i++;\n            }\n            list.add(str.substring(j, i));\n            j = i;\n        } else {\n            i++;\n        }\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0, start = 0;\n    char ch = str.charAt(0);\n    char type = Character.getType(ch);\n    while (i < len) {\n        ch = str.charAt(i);\n        if (camelCase && Character.getType(ch) == Character.LOWERCASE_LETTER && Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER) {\n            list.add(str.substring(start, i - 1));\n            start = i - 1;\n        }\n        if (Character.getType(ch) != type) {\n            list.add(str.substring(start, i));\n            start = i;\n            type = Character.getType(ch);\n        }\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0;\n    char c = 0;\n    char lastc = 0;\n    while (i < len) {\n        c = str.charAt(i);\n        if (Character.getType(c) == Character.UPPERCASE_LETTER && camelCase &&\n                i > 0 && Character.getType(lastc) == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(i - 1, i));\n        } else {\n            list.add(str.substring(i, i + 1));\n        }\n        lastc = c;\n        i++;\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final ArrayList<String> list = new ArrayList<>();\n    int i = 0;\n    char ch = str.charAt(0);\n    char lastCh = Character.MIN_VALUE;\n    while (i < len) {\n        ch = str.charAt(i);\n        if (camelCase && Character.isUpperCase(ch) && Character.isLowerCase(lastCh)) {\n            if (i > 1) {\n                list.add(str.substring(0, i - 1));\n            }\n            list.add(Character.toString(lastCh));\n            list.add(str.substring(i - 1, i));\n        } else {\n            if (ch != lastCh) {\n                list.add(Character.toString(ch));\n            }\n        }\n        lastCh = ch;\n        i++;\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0L, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Unable to parse the date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 1970);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Unable to parse the date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0L, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Text cannot be parsed\");\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 1970);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Unable to parse the date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0L, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Unable to parse the date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Parse failed at position \" + ~newPos + \": \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Failed to parse date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Text cannot be parsed\");\n    }\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0, ISOChronology.getInstance(), iLocale, iPivotYear, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos < 0) {\n        throw new IllegalArgumentException(\"Unable to parse the date: \" + text);\n    }\n    return bucket.computeMillis(false, text);\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      new MeasuredNode(n, 0),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(new MeasuredNode(n), new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(new MeasuredNode(n), new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() != null);\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  MeasuredNode p = new MeasuredNode(n);\n  MeasuredNode n = new MeasuredNode(new Node(Token.SCRIPT));\n  n.length = Integer.MAX_VALUE;\n  return new MinimizedCondition(p, n).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = new MeasuredNode(n, 0);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE);\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT));\n    negative.length = Integer.MAX_VALUE;\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode p = new MeasuredNode(n);\n    MeasuredNode n = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE);\n    return new MinimizedCondition(p, n);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  MeasuredNode positive = new MeasuredNode(n, n.getLength());\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE);\n  return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> list = new ArrayList<>();\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        list.add(constant);\n    }\n    final int size = list.size();\n    final long[] result = new long[size];\n    for (int i = 0; i < size; i++) \n    {\n        result[i] = 1L << list.get(i).ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    int size = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        size = Math.max(size, constant.ordinal());\n    }\n    long[] bitVectors = new long[size / 64 + 1];\n    for (final E constant : values) \n    {\n        bitVectors[constant.ordinal() / 64] |= 1L << (constant.ordinal() % 64);\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<Long> bitVectors = new ArrayList<>();\n    long currentBitVector = 0;\n    int bitIndex = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        currentBitVector |= 1L << constant.ordinal();\n        bitIndex++;\n        if (bitIndex == Long.SIZE) \n        {\n            bitVectors.add(currentBitVector);\n            currentBitVector = 0;\n            bitIndex = 0;\n        }\n    }\n    if (bitIndex > 0) \n    {\n        bitVectors.add(currentBitVector);\n    }\n    return bitVectors.toArray(new long[bitVectors.size()]);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    long current = 0;\n    int count = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        current |= 1L << constant.ordinal();\n        count++;\n        if (count == 64) \n        {\n            bitVectors.add(current);\n            current = 0;\n            count = 0;\n        }\n    }\n    if (count > 0) \n    {\n        bitVectors.add(current);\n    }\n    return bitVectors.toArray(new long[0]);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    long current = 0;\n    int count = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        current |= 1L << constant.ordinal();\n        count++;\n        if (count == 64) \n        {\n            bitVectors.add(current);\n            current = 0;\n            count = 0;\n        }\n    }\n    if (count > 0) \n    {\n        bitVectors.add(current);\n    }\n    return bitVectors.toArray(new long[0]);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final int maxOrdinal = enumClass.getEnumConstants().length - 1;\n    final long[] bitVectors = new long[(maxOrdinal >> 6) + 1];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        bitVectors[constant.ordinal() >> 6] |= 1L << (constant.ordinal() & 63);\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    int size = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        size++;\n    }\n    long[] result = new long[size];\n    int i = 0;\n    for (final E constant : values) \n    {\n        result[i++] = 1L << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<E> valueList = new ArrayList<>();\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        valueList.add(constant);\n    }\n    final int size = valueList.size();\n    final long[] bitVectors = new long[size / 64 + 1];\n    for (int i = 0; i < size; i++) \n    {\n        bitVectors[i / 64] |= 1L << (i % 64);\n    }\n    return bitVectors;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final List<Long> bitVectors = new ArrayList<>();\n    long currentBitVector = 0;\n    int currentBitIndex = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        currentBitVector |= 1L << constant.ordinal();\n        currentBitIndex++;\n        if (currentBitIndex == Long.SIZE) \n        {\n            bitVectors.add(currentBitVector);\n            currentBitVector = 0;\n            currentBitIndex = 0;\n        }\n    }\n    if (currentBitIndex > 0) \n    {\n        bitVectors.add(currentBitVector);\n    }\n    return bitVectors.stream().mapToLong(Long::longValue).toArray();\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        int ordinal = constant.ordinal();\n        int index = ordinal / 64;\n        while (bitVectors.size() <= index) \n        {\n            bitVectors.add(0L);\n        }\n        bitVectors.set(index, bitVectors.get(index) | (1L << (ordinal % 64)));\n    }\n    return bitVectors.stream().mapToLong(Long::longValue).toArray();\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getDepth();\n  }\n  else if (scope.isPropertyScope()) \n  {\n    SymbolScope lexicalScope = getNearestLexicalScope(scope);\n    return lexicalScope.getDepth() + 1;\n  }\n  else \n  {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope())\n  {\n    return scope.getDepth();\n  }\n  else if (scope.isPropertyScope())\n  {\n    SymbolScope lexicalScope = getLexicalScope(scope);\n    return lexicalScope.getDepth() + 1;\n  }\n  else if (scope.isDocInfoScope())\n  {\n    return 0;\n  }\n  else\n  {\n    throw new IllegalStateException(\"Unexpected scope type\");\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getDepth();\n  }\n  else \n  {\n    SymbolScope lexicalScope = getLexicalScope(scope);\n    return lexicalScope.getDepth() + 1;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getDepth();\n  } \n  else if (scope.isPropertyScope()) \n  {\n    int depth = 0;\n    SymbolScope currentScope = scope;\n    while (!currentScope.isLexicalScope()) \n    {\n      currentScope = currentScope.getParentScope();\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  } \n  else \n  {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    int depth = 0;\n    while (!scope.isLexicalScope()) \n    {\n        depth++;\n        scope = scope.getParentScope();\n    }\n    return depth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getDepth();\n  } \n  else if (scope.isPropertyScope()) \n  {\n    int depth = 0;\n    while (!scope.isLexicalScope()) \n    {\n      scope = scope.getParentScope();\n      depth++;\n    }\n    return depth + scope.getDepth();\n  } \n  else \n  {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getDepth();\n    }\n    else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        while (!scope.isLexicalScope()) \n        {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getDepth();\n    }\n    else if (scope.isDocInfoScope()) \n    {\n        return 0;\n    }\n    else \n    {\n        throw new IllegalArgumentException(\"Unknown scope type\");\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope())\n  {\n    return scope.getDepth();\n  }\n  else if (scope.isPropertyScope())\n  {\n    int depth = 0;\n    while (!scope.isLexicalScope())\n    {\n      scope = scope.getParentScope();\n      depth++;\n    }\n    return depth + scope.getDepth();\n  }\n  else if (scope.isDocInfoScope())\n  {\n    return 0;\n  }\n  else\n  {\n    throw new IllegalStateException(\"Unknown scope type\");\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getDepth();\n    } \n    else \n    {\n        int depth = 0;\n        while (!scope.isLexicalScope()) \n        {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getDepth();\n    } \n    else if (scope.isPropertyScope()) \n    {\n        SymbolScope lexicalScope = getLexicalScope(scope);\n        return lexicalScope.getDepth() + 1;\n    } \n    else \n    {\n        return 0;\n    }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        throw new DimensionMismatchException(rawData.length, rawData[0].length);\n    }\n    int blockRows = (rawData.length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (rawData[0].length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        int iHeight = Math.min(BLOCK_SIZE, rawData.length - iBlock * BLOCK_SIZE);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            int jWidth = Math.min(BLOCK_SIZE, rawData[0].length - jBlock * BLOCK_SIZE);\n            blocks[index] = new double[iHeight * jWidth];\n            int k = 0;\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < jWidth; ++j) {\n                    blocks[index][k++] = rawData[iBlock * BLOCK_SIZE + i][jBlock * BLOCK_SIZE + j];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // Check that the input array is rectangular\n        for (int i = 1; i < rows; i++) {\n            if (rawData[i].length != columns) {\n                throw new DimensionMismatchException(rawData[i].length, columns);\n            }\n        }\n\n        // Allocate the blocks layout array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n\n        // Fill the blocks layout array\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                final int jWidth = blockWidth(jBlock);\n                blocks[index] = new double[iHeight * jWidth];\n                for (int i = 0; i < iHeight; ++i) {\n                    System.arraycopy(rawData[i + iBlock * BLOCK_SIZE],\n                                     jBlock * BLOCK_SIZE,\n                                     blocks[index],\n                                     i * jWidth,\n                                     jWidth);\n                }\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blockData = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int iWidth = blockWidth(jBlock);\n            blockData[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blockData[index],\n                                 i * iWidth,\n                                 iWidth);\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData == null || rawData.length == 0 || rawData[0].length == 0) {\n        throw new IllegalArgumentException(\"Input array must be rectangular\");\n    }\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int iWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i], jBlock * BLOCK_SIZE,\n                                 blocks[index], i * iWidth, iWidth);\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        if (rawData == null || rawData.length == 0 || rawData[0].length == 0) {\n            throw new DimensionMismatchException(rawData == null ? 0 : rawData.length,\n                                                 rawData == null || rawData.length == 0 ? 0 : rawData[0].length);\n        }\n\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blockData = new double[blockRows * blockColumns][];\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                blockData[index] = new double[iHeight * blockWidth(jBlock)];\n                for (int i = 0; i < iHeight; ++i) {\n                    System.arraycopy(rawData[iBlock * BLOCK_SIZE + i], jBlock * BLOCK_SIZE,\n                                     blockData[index], i * blockWidth(jBlock),\n                                     blockWidth(jBlock));\n                }\n            }\n        }\n\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData == null || rawData.length == 0 || rawData[0].length == 0) {\n        throw new IllegalArgumentException(\"Input array must be non-null and rectangular\");\n    }\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int iWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i], jBlock * BLOCK_SIZE,\n                                 blocks[index], i * iWidth, iWidth);\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    // number of blocks\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // check if the matrix is rectangular\n    for (int i = 1; i < rows; i++) {\n        if (rawData[i].length != columns) {\n            throw new DimensionMismatchException(rawData[i].length, columns);\n        }\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; i++) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index],\n                                 i * blockWidth(jBlock),\n                                 blockWidth(jBlock));\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        return new double[0][0];\n    }\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int iWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index],\n                                 i * iWidth,\n                                 iWidth);\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        if (rawData.length == 0 || rawData[0].length == 0) {\n            throw new DimensionMismatchException(rawData.length, rawData[0].length);\n        }\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                blocks[index] = new double[iHeight * blockWidth(jBlock)];\n                for (int i = 0; i < iHeight; ++i) {\n                    System.arraycopy(rawData[i + iBlock * BLOCK_SIZE],\n                                     jBlock * BLOCK_SIZE,\n                                     blocks[index],\n                                     i * blockWidth(jBlock),\n                                     blockWidth(jBlock));\n                }\n            }\n        }\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData == null) {\n        throw new NullPointerException(\"Input array is null\");\n    }\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        throw new DimensionMismatchException(\"Input array is empty\");\n    }\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            final int iWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                 jBlock * BLOCK_SIZE,\n                                 blocks[index],\n                                 i * iWidth,\n                                 iWidth);\n            }\n        }\n    }\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final EnumSet<E> enumSet = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        enumSet.add(value);\n    }\n    if (enumSet.size() > 64) {\n        throw new IllegalArgumentException(\"The enumClass \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    int i = 0;\n    for (final E value : enumClass.getEnumConstants()) {\n        if (enumSet.contains(value)) {\n            bitVector |= 1L << i;\n        }\n        i++;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The enum class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final long[] bitVectors = generateBitVectors(enumClass, values);\n    if (bitVectors.length > 1) {\n        throw new IllegalArgumentException(\"More than one bit vector was generated\");\n    }\n    return bitVectors[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The enum class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum class\");\n    }\n    final Enum<?>[] enumConstants = enumClass.getEnumConstants();\n    if (enumConstants == null || enumConstants.length > 64) {\n        throw new IllegalArgumentException(\"The enum class \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"One of the enum values is null\");\n        }\n        final int index = ArrayUtils.indexOf(enumConstants, value);\n        if (index == -1) {\n            throw new IllegalArgumentException(\"The enum value \" + value + \" is not part of the enum class \" + enumClass.getName());\n        }\n        bitVector |= 1L << index;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    final int maxLength = EnumSet.allOf(enumClass).size();\n    if (maxLength > 64) \n    {\n        throw new IllegalArgumentException(\"The enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"One of the values in the iterable is null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    final int maxOrdinal = EnumSet.allOf(enumClass).size() - 1;\n    if (maxOrdinal > 63) \n    {\n        throw new IllegalArgumentException(\"The enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    long bitVector = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"The enum value must not be null\");\n        }\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (values == null) \n    {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    long bitVector = 0;\n    int count = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"One of the values is null\");\n        }\n        bitVector |= 1L << value.ordinal();\n        count++;\n        if (count > 64) \n        {\n            throw new IllegalArgumentException(\"You can't have more than 64 values in an enum\");\n        }\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"The enum class must not be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum class\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    final long[] bitVectors = new long[64];\n    int count = 0;\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"The values must not contain null\");\n        }\n        final int index = value.ordinal();\n        if (index >= 64) {\n            throw new IllegalArgumentException(\"The enum \" + enumClass.getName() + \" has more than 64 values\");\n        }\n        bitVectors[index] = 1L << index;\n        count++;\n    }\n    long result = 0;\n    for (int i = 0; i < count; i++) {\n        result |= bitVectors[i];\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (values == null) \n    {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    long bitVector = 0;\n    int count = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"One or more values in the iterable are null\");\n        }\n        bitVector |= 1L << value.ordinal();\n        count++;\n    }\n    if (count > 64) \n    {\n        throw new IllegalArgumentException(\"The enumClass \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass must not be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The class \" + enumClass.getName() + \" is not an enum\");\n    }\n    if (values == null) \n    {\n        throw new NullPointerException(\"The values must not be null\");\n    }\n    long bitVector = 0;\n    int count = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"One or more values in the iterable are null\");\n        }\n        bitVector |= 1L << value.ordinal();\n        count++;\n    }\n    if (count > 64) \n    {\n        throw new IllegalArgumentException(\"The enum \" + enumClass.getName() + \" has more than 64 values\");\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) \n    {\n        throw new NullPointerException(\"The enumClass cannot be null\");\n    }\n    if (!enumClass.isEnum()) \n    {\n        throw new IllegalArgumentException(\"The supplied class is not an enum\");\n    }\n    if (values == null) \n    {\n        throw new NullPointerException(\"The values cannot be null\");\n    }\n    final long[] bitVectors = new long[EnumSet.allOf(enumClass).size()];\n    int i = 0;\n    for (final E value : values) \n    {\n        if (value == null) \n        {\n            throw new IllegalArgumentException(\"The values cannot contain null\");\n        }\n        bitVectors[i++] = 1L << value.ordinal();\n    }\n    return Arrays.stream(bitVectors).reduce(0L, (a, b) -> a | b);\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a.getField().getOne();\n    Dfp a2 = a.multiply(a);\n    int n = 1;\n    while (term.isFinite()) {\n        term = term.divide(n);\n        result = result.add(term.multiply(a2));\n        a2 = a2.multiply(a);\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a.getField().getOne();\n        int n = 1;\n\n        while (term.isFinite()) \n        {\n            term = term.divide(n);\n            result = result.add(term);\n            n++;\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a.getField().getOne();\n        int i = 1;\n\n        while (term.isFinite()) {\n            term = term.multiply(a).divide(i);\n            result = result.add(term);\n            i++;\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a.getField().getOne();\n        int n = 1;\n        while (term.abs().compareTo(a.getField().getEpsilon()) > 0) {\n            term = term.multiply(a).divide(n);\n            result = result.add(term);\n            n++;\n        }\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a;\n        int i = 1;\n        while (term.isFinite()) \n        {\n            result = result.add(term);\n            term = term.multiply(a).divide(i);\n            i++;\n        }\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp result = a.getField().getOne();\n    final Dfp term = a.getField().getOne();\n    final Dfp factorial = a.getField().getOne();\n    final Dfp two = a.getField().getTwo();\n    Dfp x = a;\n\n    int i = 1;\n    while (term.abs().compareTo(a.getField().getEpsilon()) > 0) \n    {\n        factorial = factorial.multiply(factorial.add(two));\n        term = term.divide(factorial);\n        x = x.multiply(a);\n        result = result.add(term);\n        i++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int i = 1;\n    while (term.isFinite()) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(i);\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int i = 1;\n    while (term.abs().compareTo(a.getField().getEpsilon()) > 0) \n    {\n        result = result.add(term);\n        term = term.divide(i);\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a.getField().getOne();\n        int i = 1;\n\n        while (term.getScale() > 0) {\n            term = term.divide(i);\n            result = result.add(term);\n            i++;\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getField().getOne();\n        Dfp term = a;\n        int n = 1;\n\n        while (term.abs().compareTo(a.getField().getEpsilon()) > 0) {\n            result = result.add(term);\n            term = term.divide(n);\n            n++;\n        }\n\n        return result;\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    if (norm.getReal() == 1) {\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getZero(), z.getField().getOne());\n    }\n    return new FieldVector3D<T>(y.getField().getOne(), z.getField().getZero(), x.getField().getZero());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.negate(), z, x.negate());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    // find the smallest component\n    double min = Math.abs(x.getReal());\n    double compY = Math.abs(y.getReal());\n    double compZ = Math.abs(z.getReal());\n    if (compY < min) {\n        min = compY;\n    }\n    if (compZ < min) {\n        min = compZ;\n    }\n    // create a vector with all components equal to the smallest one\n    FieldVector3D<T> smallest = new FieldVector3D<T>(min, min, min);\n    // subtract the smallest vector from the instance to get a vector\n    // with all components non-zero\n    FieldVector3D<T> nonZero = subtract(smallest);\n    // compute the cross product with the smallest vector to get a vector\n    // orthogonal to the instance\n    return crossProduct(smallest);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    if (norm.getReal() == 1) {\n        return new FieldVector3D<T>(y.getField().getZero(), z, x.negate(), y);\n    }\n    return new FieldVector3D<T>(y.getField().getZero(), z, x.negate().divide(norm), y.divide(norm));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.getField().getZero(), z, x.negate(), y);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    // Pick an arbitrary vector that is not the instance itself\n    FieldVector3D<T> other = new FieldVector3D<T>(x.getField().getOne(), x, y.getField().getOne(), y);\n    // Compute the cross product with the instance\n    return crossProduct(other);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    // Pick a random vector, compute its cross product with this vector, and normalize the result\n    FieldVector3D<T> randomVector = new FieldVector3D<T>(x.getField().getOne(), x.getField().getZero(), x.getField().getZero());\n    FieldVector3D<T> crossProduct = crossProduct(randomVector);\n    return crossProduct.normalize();\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_TO_A_ZERO_NORM_VECTOR);\n    }\n    if (norm.getReal() == 1) {\n        return new FieldVector3D<T>(x.getField().getZero(), y.getField().getOne(), z.getField().getZero());\n    }\n    return new FieldVector3D<T>(y.negate(), x, z.negate());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_ORTHOGONAL_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    if (Math.abs(norm.getReal() - 1.0) < 1.0e-10) \n    {\n        return new FieldVector3D<T>(y.negate(), z, x.negate());\n    } \n    else \n    {\n        return new FieldVector3D<T>(y.negate().divide(norm), z.divide(norm), x.negate().divide(norm));\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T norm = getNorm();\n    if (norm.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (Math.abs(x.getReal()) > Math.abs(y.getReal())) \n    {\n        if (Math.abs(x.getReal()) > Math.abs(z.getReal())) \n        {\n            return new FieldVector3D<T>(y.negate(), z, x.negate());\n        } \n        else \n        {\n            return new FieldVector3D<T>(z.negate(), x, y.negate());\n        }\n    } \n    else \n    {\n        if (Math.abs(y.getReal()) > Math.abs(z.getReal())) \n        {\n            return new FieldVector3D<T>(z.negate(), x, y.negate());\n        } \n        else \n        {\n            return new FieldVector3D<T>(x.negate(), y, z.negate());\n        }\n    }\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = getComparator().compare(minimum, other.minimum) > 0 ? other.minimum : minimum;\n    T max = getComparator().compare(maximum, other.maximum) < 0 ? other.maximum : maximum;\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n\n    final T lowerBound = getComparator().max(this.minimum, other.minimum);\n    final T upperBound = getComparator().min(this.maximum, other.maximum);\n\n    return new Range<>(lowerBound, upperBound, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = this.minimum;\n    if (other.minimum.compareTo(min) > 0) {\n        min = other.minimum;\n    }\n    T max = this.maximum;\n    if (other.maximum.compareTo(max) < 0) {\n        max = other.maximum;\n    }\n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(\n        maximum(minimum, other.minimum),\n        minimum(maximum, other.maximum)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(\n        maximum(minimum, other.minimum),\n        minimum(maximum, other.maximum)\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    \n    T min = getComparator().max(minimum, other.minimum);\n    T max = getComparator().min(maximum, other.maximum);\n    \n    return new Range<>(min, max);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T lowerBound = getComparator().max(this.minimum, other.minimum);\n    T upperBound = getComparator().min(this.maximum, other.maximum);\n    return new Range<>(lowerBound, upperBound);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n\n    T lowerBound = maximum(minimum, other.minimum);\n    T upperBound = minimum(maximum, other.maximum);\n\n    return new Range<>(lowerBound, upperBound);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n\n    T min = getComparator().compare(other.minimum, minimum) < 0 ? other.minimum : minimum;\n    T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(\n        comparator.max(minimum, other.minimum),\n        comparator.min(maximum, other.maximum)\n    );\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            _bufferRecycler.allocUTF8Encoder(), _maximumNonEscapedChar,\n            _characterEscapes, _rootValueSeparator);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            _byteBufferRecyclable ? _byteBuffer : null);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Utf8JsonGenerator gen = new Utf8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return toString((Annotation) o1).equals(toString((Annotation) o2));\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) \n    {\n        return true;\n    }\n    if (o1 == null || o2 == null) \n    {\n        return false;\n    }\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationEquals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  } \n  else \n  {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType()) {\n        return type.toMaybeUnionType().filterNoResolvedType();\n    }\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  }\n  return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType()) {\n        UnionType unionType = type.toMaybeUnionType();\n        Set<JSType> types = new HashSet<>();\n        for (JSType t : unionType.getAlternates()) {\n            if (!t.isNoResolvedType()) {\n                types.add(t);\n            }\n        }\n        if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.registry.createNoResolvedType();\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  } else {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnionType()) {\n    JSType[] types = type.toMaybeUnionType().getAlternates();\n    JSType[] filteredTypes = new JSType[types.length];\n    int index = 0;\n    for (JSType t : types) {\n      if (!t.isNoResolvedType()) {\n        filteredTypes[index++] = t;\n      }\n    }\n    if (index == 0) {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (index == types.length) {\n      return type;\n    } else {\n      return type.registry.createUnionType(filteredTypes);\n    }\n  } else {\n    return type.isNoResolvedType() ? type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE) : type;\n  }\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    // If we did create a more precise scope, blindScope has a child and\n    // it is frozen. We can't just throw it away to return it. So we\n    // must create a child instead.\n    FlowScope informed = blindScope == node.getScope() ?\n        blindScope : blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    // If we did create a more precise scope, blindScope has a child and\n    // it is frozen. We can't just throw it away to return it. So we\n    // must create a child instead.\n    FlowScope informed = blindScope == node.getParent() ?\n        blindScope : blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    String name = node.getString();\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(name, restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    String name = node.getString();\n    if (blindScope.hasSlot(name)) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      informed.inferSlotType(name, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    String name = node.getString();\n    if (blindScope.hasSlot(name)) {\n      return blindScope.createChildFlowScope();\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(name, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getString(), restrictedType);\n    return newScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    String name = node.getString();\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(name, restrictedType);\n    return informed;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    String name = node.getString();\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(name, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isEquivalentTo(originalType)) {\n      return blindScope;\n    }\n    FlowScope informed = blindScope.createChildFlowScope();\n    informed.inferSlotType(node.getString(), restrictedType);\n    return informed;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  \n  String typeName = stream.getString();\n  if (!\"function\".equals(typeName)) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  \n  skipEOLs();\n  Node functionTypeNode = newNode(Token.FUNCTION_TYPE);\n  \n  // TypeParameters\n  if (match(JsDocToken.LT)) \n  {\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) \n    {\n      functionTypeNode.addChildToFront(typeParameters);\n      \n      skipEOLs();\n      if (!match(JsDocToken.GT)) \n      {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n      \n      next();\n    }\n  }\n  \n  // '('\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  \n  // 'this'\n  skipEOLs();\n  if (!match(JsDocToken.STRING)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  String thisKeyword = stream.getString();\n  if (!\"this\".equals(thisKeyword)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  \n  // ':'\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  \n  // TypeName\n  skipEOLs();\n  Node typeNameNode = parseTypeName(next());\n  if (typeNameNode == null) \n  {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String functionType = stream.getString();\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n\n  if (\"function\".equals(functionType)) \n  {\n    skipEOLs();\n    return parseFunctionSignatureType(next());\n  } \n  else \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  \n  String typeName = stream.getString();\n  if (\"function\".equals(typeName)) \n  {\n    skipEOLs();\n    return parseFunctionSignatureType(next());\n  } \n  else \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION_TYPE);\n    skipEOLs();\n    if (match(JsDocToken.LP)) {\n        next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType != null) {\n            functionType.addChildToFront(thisType);\n            skipEOLs();\n            if (!match(JsDocToken.COLON)) {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n            }\n            next();\n            skipEOLs();\n            Node parametersType = parseParametersType(next());\n            if (parametersType != null) {\n                functionType.addChildToFront(parametersType);\n                skipEOLs();\n                if (!match(JsDocToken.RPAREN)) {\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n                }\n                next();\n                skipEOLs();\n                Node resultType = parseResultType(next());\n                if (resultType != null) {\n                    functionType.addChildToFront(resultType);\n                }\n            }\n        }\n    }\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String typeName = stream.getString();\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n\n  if (\"function\".equals(typeName)) \n  {\n    skipEOLs();\n    Node functionType = newNode(Token.FUNCTION_TYPE);\n    functionType.setLineno(lineno);\n    functionType.setCharno(charno);\n\n    if (match(JsDocToken.LT)) \n    {\n      next();\n      skipEOLs();\n      Node typeParameters = parseTypeParameters(next());\n      if (typeParameters != null) \n      {\n        functionType.addChildToFront(typeParameters);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n    Node thisType = newNode(Token.THIS_TYPE);\n    thisType.setLineno(lineno);\n    thisType.setCharno(charno);\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeNameNode = parseTypeName(next());\n    if (typeNameNode != null) \n    {\n      thisType.addChildToFront(typeNameNode);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) \n    {\n}\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    \n    String typeName = stream.getString();\n    if (\"function\".equals(typeName)) \n    {\n        skipEOLs();\n        return parseFunctionSignatureType(next());\n    } \n    else \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    String string = stream.getString();\n    if (\"function\".equals(string)) \n    {\n        skipEOLs();\n        return parseFunctionSignatureType(next());\n    } \n    else \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String function = stream.getString();\n  if (!function.equals(\"function\")) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  Node functionType = newNode(Token.FUNCTION);\n\n  skipEOLs();\n  if (match(JsDocToken.LP)) \n  {\n    next();\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n      next();\n      skipEOLs();\n      if (match(JsDocToken.COLON)) \n      {\n        next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType != null) \n        {\n          functionType.addChildToFront(thisType);\n\n          skipEOLs();\n          if (match(JsDocToken.COMMA)) \n          {\n            next();\n            skipEOLs();\n            Node parametersType = parseParametersType(next());\n            if (parametersType != null) \n            {\n              functionType.addChildToFront(parametersType);\n\n              skipEOLs();\n              if (match(JsDocToken.RPAREN)) \n              {\n                next();\n                skipEOLs();\n                Node resultType = parseResultType(next());\n                if (resultType != null) \n                {\n                  functionType.addChildToFront(resultType);\n                }\n                else \n                {\n                  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n                }\n              }\n              else \n              {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n              }\n            }\n            else \n            {\n              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n            }\n          }\n          else \n          {\n}\n}\n}\n}\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String typeName = stream.getString();\n  if (\"function\".equals(typeName)) \n  {\n    skipEOLs();\n    return parseFunctionSignatureType(next());\n  } \n  else \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  String typeName = stream.getString();\n  int lineno = stream.getLineno();\n  int charno = stream.getCharno();\n\n  Node functionTypeNode = newStringNode(typeName, lineno, charno);\n\n  if (match(JsDocToken.LT)) \n  {\n    next();\n    skipEOLs();\n    Node memberType = parseTypeExpressionList(next());\n    if (memberType != null) \n    {\n      functionTypeNode.addChildToFront(memberType);\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) \n      {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n  }\n  return functionTypeNode;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            sb.append(str.charAt(i));\n        }\n    }\n    return sb.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            sb.append(str.charAt(i));\n        }\n    }\n    return sb.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder buffer = new StringBuilder(chars.length);\n    for (char c : chars) {\n        if (!Character.isWhitespace(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            sb.append(str.charAt(i));\n        }\n    }\n    return sb.toString();\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return new String(chs, 0, count);\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chs, 0, count);\n}\n    // Delete",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}\n    // Delete"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumOfSquares = 0.0;\n    double sumOfLogs = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    double mean = 0.0;\n    double variance = 0.0;\n    double geometricMean = 1.0;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        sumOfLogs += stat.getSumOfLogs();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    if (n > 0) \n    {\n        mean = sum / n;\n        variance = sumOfSquares / n - mean * mean;\n        geometricMean = Math.exp(sumOfLogs / n);\n    }\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double mean = 0;\n    double variance = 0;\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double mean = 0;\n    double variance = 0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double mean = 0.0;\n    double variance = 0.0;\n    double sum = 0.0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        sum += stat.getSum();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double mean = 0.0;\n    double variance = 0.0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double mean = 0;\n    double variance = 0;\n    double sum = 0;\n    double sumsq = 0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0;\n    double sumOfSquares = 0;\n    double sumOfLogs = 0;\n    double variance = 0;\n    double min = Double.MAX_VALUE;\n    double max = Double.MIN_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        sumOfLogs += stat.getSumOfLogs();\n        variance += stat.getVariance();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    variance = (sumOfSquares / n) - (mean * mean);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumOfSquares = 0.0;\n    double sumOfLogs = 0.0;\n    double variance = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        sum += stat.getSum();\n        sumOfSquares += stat.getSumsq();\n        sumOfLogs += stat.getSumOfLogs();\n        variance += stat.getVariance();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    variance /= n;\n    double geometricMean = Math.exp(sumOfLogs / n);\n    double secondMoment = sumOfSquares / n - mean * mean;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double mean = 0;\n    double variance = 0;\n    double sum = 0;\n    double sumOfLogs = 0;\n    double geometricMean = 1;\n    double sumsq = 0;\n    double secondMoment = 0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        sum += stat.getSum();\n        sumOfLogs += stat.getSumOfLogs();\n        geometricMean *= Math.pow(stat.getGeometricMean(), stat.getN());\n        sumsq += stat.getSumsq();\n        secondMoment += stat.getSecondMoment();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n\n    geometricMean = Math.pow(geometricMean, 1.0 / n);\n    variance /= n;\n    secondMoment /= n;\n\n    return new StatisticalSummaryValues(mean / n, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    \n    double sum = 0.0;\n    double sumsq = 0.0;\n    double mean = 0.0;\n    double variance = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    long n = 0;\n    \n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        mean += stat.getMean();\n        variance += stat.getVariance();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        n += stat.getN();\n    }\n    \n    // Calculate mean and variance\n    if (n > 0) {\n        mean /= n;\n        variance /= n;\n    }\n    \n    // Calculate variance\n    variance = sumsq / n - mean * mean;\n    \n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i] - meanDifference;\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            result += diff * diff;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += (diff - meanDifference) * (diff - meanDifference);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i] - meanDifference;\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += (sample1[i] - sample2[i] - meanDifference) *\n                  (sample1[i] - sample2[i] - meanDifference);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            result += diff * diff;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += (diff - meanDifference) * (diff - meanDifference);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            result += diff * diff;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff - meanDifference * meanDifference;\n    }\n    return result / (n - 1);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getCategories().size(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < dataset.getCategories().size(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int c = nextNonWhitespace();\n    if (c == '\"') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\'') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ')') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '(') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '[') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ']') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '{') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '}') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ',') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ':') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ';') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '=') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ' ') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\t') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\f') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\r') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\n') \n    {\n        return nextQuotedValue();\n    }\n    throw new IOException(\"Expected a name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NAME) {\n    peeked = PEEKED_NONE;\n    return getPreviousName();\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek());\n  }\n}",
      "public String nextName() throws IOException  {\n  int c = nextNonWhitespace();\n  String result;\n  switch (c) \n  {\n    case '\"':\n      result = nextQuotedString();\n      break;\n    case '{':\n      case '}':\n      case '[':\n      case ']':\n      case ',':\n      case ':':\n      case ' ':\n      case '\\t':\n      case '\\f':\n      case '\\r':\n      case '\\n':\n        throw new IOException(\"Expected property name but was \" + peek() + \" at line \" + line + \" column \" + column);\n    default:\n      pos--;\n      result = nextUnquotedString();\n  }\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_NAME) {\n        peeked = PEEKED_NONE;\n        return getPreviousName();\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n  int c = nextNonWhitespace();\n  StringBuilder name = new StringBuilder();\n  if (c == '\"') \n  {\n    name.append(nextQuotedValue());\n  } \n  else if (isLiteral(c)) \n  {\n    name.append((char) c);\n    appendToName(name);\n  } \n  else \n  {\n    throw syntaxError(\"Expected a name but was \" + (char) c);\n  }\n  return name.toString();\n}",
      "public String nextName() throws IOException  {\n  int c = nextNonWhitespace();\n  String result;\n  switch (c) {\n    case '\"':\n      result = nextQuotedValue();\n      break;\n    case '{':\n    case '}':\n    case '[':\n    case ']':\n    case ',':\n    case ':':\n    case ' ':\n    case '\\t':\n    case '\\f':\n    case '\\r':\n    case '\\n':\n      throw new IOException(\"Expected property name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n    default:\n      StringBuilder builder = new StringBuilder();\n      do {\n        builder.append((char) c);\n        c = next();\n      } while (c != -1 && !isLiteral((char) c));\n      result = builder.toString();\n      if (result.isEmpty()) {\n        throw new IOException(\"Expected property name but was \" + peek() + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n      }\n  }\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int c = nextNonWhitespace();\n    if (c == '\"') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\'') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ')') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '(') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '[') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ']') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '{') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '}') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ',') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ':') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ';') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '#') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '=') \n    {\n        return nextQuotedValue();\n    }\n    if (c == ' ') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\t') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\f') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\r') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\n') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\\\') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '/') \n    {\n        return nextQuotedValue();\n    }\n}",
      "public String nextName() throws IOException  {\n  int c = nextNonWhitespace();\n  String result;\n  if (c == '\"') \n  {\n    result = nextQuotedValue();\n  } \n  else if (c == '\\'') \n  {\n    result = nextQuotedValue();\n  } \n  else if (isLiteral(c)) \n  {\n    StringBuilder builder = new StringBuilder();\n    builder.append((char) c);\n    while (true) \n    {\n      c = nextNonWhitespace();\n      if (isLiteral(c)) \n      {\n        builder.append((char) c);\n      } \n      else \n      {\n        back(c);\n        break;\n      }\n    }\n    result = builder.toString();\n  } \n  else \n  {\n    throw syntaxError(\"Expected a name but was \" + peek());\n  }\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int c = nextNonWhitespace();\n    String result;\n    switch (c) {\n    case '\"':\n        result = nextQuotedValue();\n        break;\n    case '{':\n        result = \"{}\";\n        break;\n    case '[':\n        result = \"[]\";\n        break;\n    case 't':\n        checkMatch(\"true\", 4);\n        result = \"true\";\n        break;\n    case 'f':\n        checkMatch(\"false\", 5);\n        result = \"false\";\n        break;\n    case 'n':\n        checkMatch(\"null\", 4);\n        result = \"null\";\n        break;\n    default:\n        throw new IllegalStateException(\"Expected a name but was \" + (char) c);\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}\n}",
      "public String nextName() throws IOException  {\n    int c = nextNonWhitespace();\n    if (c == '\"') \n    {\n        return nextQuotedValue();\n    }\n    if (c == '\\'') \n    {\n        return nextQuotedValue();\n    }\n    throw syntaxError(\"Expected a name but was \" + (char) c);\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.getNode();\n    if (callOrNewOrDotCall.isCall() || callOrNewOrDotCall.isNew()) {\n        return callOrNewOrDotCall.getSecondChild();\n    } else if (callOrNewOrDotCall.isGetProp() && callOrNewOrDotCall.getNext().isCall()) {\n        return callOrNewOrDotCall.getNext().getSecondChild();\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getNode();\n    if (call.isCall() || call.isNew()) {\n        return call.getSecondChild();\n    } else if (call.isDotCall()) {\n        return call.getLastChild();\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.isCall() || call.isNew()) {\n        return call.getChildAtIndex(argIndex + 1);\n    } else if (call.isGetProp() || call.isGetElem()) {\n        return call.getLastChild();\n    } else {\n        throw new IllegalStateException(\"Unexpected node type: \" + call);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.getParent().isNew()) {\n        call = call.getParent();\n    }\n    if (call.isCall() || call.isNew()) {\n        Node arg = call.getFirstChild().getNext();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.getChildCount() <= argIndex) {\n        return null;\n    }\n    return call.getChildAtIndex(argIndex);\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.node;\n    Node arg = callOrNewOrDotCall.getFirstChild();\n    int i = 0;\n    while (arg != null && i < argIndex) {\n        arg = arg.getNext();\n        i++;\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.isCall() || call.isNew()) {\n        Node arg = call.getFirstChild().getNext();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    } else if (call.isGetProp() && call.getParent().isCall()) {\n        Node arg = call.getParent().getFirstChild().getNext();\n        for (int i = 0; i < argIndex; i++) {\n            arg = arg.getNext();\n        }\n        return arg;\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.getChildCount() <= argIndex) {\n        return null;\n    }\n    return call.getChildAtIndex(argIndex);\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.isCall() || call.isNew()) {\n        Node args = call.getSecondChild();\n        for (int i = 0; i < argIndex; i++) {\n            args = args.getNext();\n        }\n        return args;\n    } else if (call.isGetProp()) {\n        Node args = call.getNext();\n        for (int i = 0; i < argIndex; i++) {\n            args = args.getNext();\n        }\n        return args;\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.node;\n    if (callOrNewOrDotCall.isNew()) {\n        callOrNewOrDotCall = callOrNewOrDotCall.getFirstChild();\n    }\n    if (callOrNewOrDotCall.isCall() || callOrNewOrDotCall.isGetProp()) {\n        return callOrNewOrDotCall.getSecondChild().getChildAtIndex(argIndex);\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) \n    {\n      JSDocInfo info = objType.getJSDocInfo();\n      if (info != null && info.isDeprecated()) \n      {\n        return info.getDeprecationReason();\n      }\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) \n  {\n    return null;\n  }\n  JSDocInfo info = type.getJSDocInfo();\n  if (info == null) \n  {\n    return null;\n  }\n  return info.getDeprecationReason();\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) \n    {\n      JSDocInfo info = objType.getJSDocInfo();\n      if (info != null) \n      {\n        return info.getDeprecationReason();\n      }\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null && type.isDeprecated()) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null) \n    {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType != null) \n    {\n      JSDocInfo info = objectType.getJSDocInfo();\n      if (info != null) \n      {\n        return info.getDeprecationReason();\n      }\n    }\n  }\n  return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (this.underlying != null) \n    {\n        columnIndex = this.underlying.getColumnIndex(key);\n        if (columnIndex >= this.firstCategoryIndex && columnIndex <= this.lastCategoryIndex()) \n        {\n            return columnIndex;\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex >= this.firstCategoryIndex && columnIndex <= this.lastCategoryIndex()) \n    {\n        return columnIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= this.lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex >= this.firstCategoryIndex && columnIndex <= this.lastCategoryIndex()) \n    {\n        return columnIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= this.lastCategoryIndex()) \n    {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = this.underlying.getColumnIndex(key);\n    if (columnIndex >= this.firstCategoryIndex && columnIndex <= this.lastCategoryIndex()) \n    {\n        return columnIndex;\n    }\n    return -1;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point <= lower + tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else if (point >= upper - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point <= lower + tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else if (point >= upper - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point < lower + tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else if (point > upper - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point <= lower + tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else if (point >= upper - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    DecimalFormat df = new DecimalFormat(\"0.###\", new DecimalFormatSymbols(locale));\n    return new NumberTickUnitSource(df, 10.0, 1.0);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    DecimalFormat df = new DecimalFormat(\"#.#\", new DecimalFormatSymbols(locale));\n    List<TickUnit> units = new ArrayList<>();\n    units.add(new NumberTickUnit(1, df));\n    units.add(new NumberTickUnit(2, df));\n    units.add(new NumberTickUnit(5, df));\n    units.add(new NumberTickUnit(10, df));\n    units.add(new NumberTickUnit(20, df));\n    units.add(new NumberTickUnit(50, df));\n    units.add(new NumberTickUnit(100, df));\n    units.add(new NumberTickUnit(200, df));\n    units.add(new NumberTickUnit(500, df));\n    units.add(new NumberTickUnit(1000, df));\n    return new TickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    DecimalFormat df = new DecimalFormat(\"0.0##\", \n        new DecimalFormatSymbols(locale));\n    return new FixedTickUnitSource(new TickUnit[] {\n        new TickUnit(1, df.toPattern(), 1),\n        new TickUnit(2, df.toPattern(), 2),\n        new TickUnit(5, df.toPattern(), 5),\n        new TickUnit(10, df.toPattern(), 10)\n    });\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> units = new ArrayList<>();\n    DecimalFormat df = new DecimalFormat(\"0.###\", DecimalFormatSymbols.getInstance(locale));\n    units.add(new TickUnit(1.0, df, 1));\n    units.add(new TickUnit(2.0, df, 2));\n    units.add(new TickUnit(5.0, df, 3));\n    units.add(new TickUnit(10.0, df, 4));\n    units.add(new TickUnit(20.0, df, 5));\n    units.add(new TickUnit(50.0, df, 6));\n    units.add(new TickUnit(100.0, df, 7));\n    units.add(new TickUnit(200.0, df, 8));\n    units.add(new TickUnit(500.0, df, 9));\n    units.add(new TickUnit(1000.0, df, 10));\n    return new DefaultTickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    NumberFormat nf = NumberFormat.getInstance(locale);\n    List<TickUnit> result = new ArrayList<>();\n    result.add(new TickUnit(1.0, nf, 0));\n    result.add(new TickUnit(2.0, nf, 1));\n    result.add(new TickUnit(5.0, nf, 2));\n    result.add(new TickUnit(10.0, nf, 3));\n    return new FixedTickUnitSource(result);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> result = new ArrayList<TickUnit>();\n    NumberFormat nf = NumberFormat.getInstance(locale);\n    result.add(new TickUnit(1.0, nf, 0));\n    result.add(new TickUnit(2.0, nf, 1));\n    result.add(new TickUnit(5.0, nf, 2));\n    result.add(new TickUnit(10.0, nf, 3));\n    return new TickUnitSource() {\n}\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> units = new ArrayList<TickUnit>();\n    DecimalFormat format = new DecimalFormat(\"0\", DecimalFormatSymbols.getInstance(locale));\n    units.add(new TickUnit(1.0, format, 1));\n    units.add(new TickUnit(2.0, format, 2));\n    units.add(new TickUnit(5.0, format, 3));\n    units.add(new TickUnit(10.0, format, 4));\n    return new FixedTickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(locale);\n    df.applyPattern(\"0.#\");\n    List<TickUnit> units = new ArrayList<TickUnit>();\n    units.add(new NumberTickUnit(1.0, df, TickUnitSource.ABSOLUTE));\n    units.add(new NumberTickUnit(2.0, df, TickUnitSource.ABSOLUTE));\n    units.add(new NumberTickUnit(5.0, df, TickUnitSource.ABSOLUTE));\n    units.add(new NumberTickUnit(10.0, df, TickUnitSource.ABSOLUTE));\n    return new FixedTickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> units = new ArrayList<TickUnit>();\n    NumberFormat nf = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1.0, nf));\n    units.add(new NumberTickUnit(2.0, nf));\n    units.add(new NumberTickUnit(5.0, nf));\n    units.add(new NumberTickUnit(10.0, nf));\n    units.add(new NumberTickUnit(20.0, nf));\n    units.add(new NumberTickUnit(50.0, nf));\n    units.add(new NumberTickUnit(100.0, nf));\n    units.add(new NumberTickUnit(200.0, nf));\n    units.add(new NumberTickUnit(500.0, nf));\n    units.add(new NumberTickUnit(1000.0, nf));\n    units.add(new NumberTickUnit(2000.0, nf));\n    units.add(new NumberTickUnit(5000.0, nf));\n    units.add(new NumberTickUnit(10000.0, nf));\n    units.add(new NumberTickUnit(20000.0, nf));\n    units.add(new NumberTickUnit(50000.0, nf));\n    units.add(new NumberTickUnit(100000.0, nf));\n    units.add(new NumberTickUnit(200000.0, nf));\n    units.add(new NumberTickUnit(500000.0, nf));\n    units.add(new NumberTickUnit(1000000.0, nf));\n    units.add(new NumberTickUnit(2000000.0, nf));\n    units.add(new NumberTickUnit(5000000.0, nf));\n    units.add(new NumberTickUnit(10000000.0, nf));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> result = new ArrayList<>();\n    NumberFormat nf = NumberFormat.getInstance(locale);\n    result.add(new NumberTickUnit(1, nf));\n    result.add(new NumberTickUnit(2, nf));\n    result.add(new NumberTickUnit(5, nf));\n    result.add(new NumberTickUnit(10, nf));\n    return new FixedTickUnitSource(result);\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = -1;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double coefficient = tableau.getObjectiveCoefficient(i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int minIndex = -1;\n    double minValue = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double value = tableau.getObjectiveCoefficient(i);\n        if (value < minValue) \n        {\n            minValue = value;\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double coefficient = tableau.getObjectiveFunctionCoefficient(i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int j = 0; j < tableau.getNumberOfColumns(); j++) \n    {\n        double coeff = tableau.getObjectiveFunctionCoefficient(j);\n        if (coeff < min) \n        {\n            min = coeff;\n            pivotColumn = j;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.NEGATIVE_INFINITY;\n    Integer pivotColumn = null;\n\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double coefficient = tableau.getObjectiveFunctionCoefficient(i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double coeff = tableau.getObjectiveCoefficient(i);\n        if (coeff < min) \n        {\n            min = coeff;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = -1;\n    double min = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumberOfColumns(); i++) \n    {\n        double coeff = tableau.getObjectiveCoefficient(i);\n        if (coeff < min) \n        {\n            min = coeff;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.MIN_VALUE;\n    Integer pivotColumn = null;\n\n    for (int j = 0; j < tableau.getNumberOfColumns(); j++) \n    {\n        double coefficient = tableau.getObjectiveFunctionCoefficient(j);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = j;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.MIN_VALUE;\n    Integer pivotColumn = null;\n\n    for (int i = 0; i < tableau.getNumberOfConstraints(); i++) \n    {\n        double coefficient = tableau.getObjectiveFunctionCoefficient(i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getNumberOfConstraints(); i++) \n    {\n        double coefficient = tableau.getObjectiveCoefficient(i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}