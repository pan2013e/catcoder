{
  "benchmark": "javaeval_if",
  "lastest_eval": {
    "compile@1": 0.40753768844221117,
    "pass@1": 0.1979899497487437,
    "compile@3": 0.545979899497487,
    "pass@3": 0.2808207705192631,
    "compile@5": 0.5997846374730796,
    "pass@5": 0.31815825157533695
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"value type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getEnd().getTime());\n            result = result / new Long(task.getDuration().getDuration());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getEnd().getTime() - duration.getStart().getTime());\n        }\n        result = result / task.getDuration().getUnit().toMillis(100);\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, 0);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(0, len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index == 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return new Iterable<E>()\n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return () -> iterator;\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getRowDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getColumnDimension() == m.getRowDimension()) {\n        double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getColumnDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"m must be a column vector or a square matrix\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1)\n        {\n                final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n                for (int r = 0; r < m.getRowDimension(); r++) {\n                        d[r][r] = m.getEntry(r, 0);\n                }\n                return new Array2DRowRealMatrix(d, false);\n        }\n        else if (m.getRowDimension() == m.getColumnDimension())\n        {\n                final double[][] d = new double[m.getRowDimension()][1];\n                for (int r = 0; r < m.getRowDimension(); r++) {\n                        d[r][0] = m.getEntry(r, r);\n                }\n                return new Array2DRowRealMatrix(d, false);\n        }\n        else\n        {\n                throw new IllegalArgumentException(\"Matrix must be column or square\");\n        }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getRowDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getRowDimension() == m.getColumnDimension())\n    {\n        double[][] d = new double[m.getColumnDimension()][1];\n        for (int r = 0; r < m.getColumnDimension(); r++)\n        {\n            for (int c = 0; c < 1; c++)\n            {\n                d[r][c] = m.getEntry(r, r);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        System.out.println(\"Invalid Matrix Dimensions\");\n        return null;\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1)\n        {\n                RealMatrix result = new Array2DRowRealMatrix(m.getRowDimension(), 1);\n                for (int r = 0; r < m.getRowDimension(); r++) \n                {\n                        result.setEntry(r, 0, m.getEntry(r, 0));\n                }\n                return result;\n        }\n        else \n        {\n                RealMatrix result = new Array2DRowRealMatrix(m.getColumnDimension(), 1);\n                for (int r = 0; r < m.getColumnDimension(); r++) \n                {\n                        result.setEntry(r, 0, m.getEntry(r, r));\n                }\n                return result;\n        }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            for (int c = 0; c < m.getColumnDimension(); c++) \n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int r = 0; r < m.getColumnDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    }\n    else if (m.getColumnDimension() == m.getRowDimension())\n    {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0.0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        throw new IllegalArgumentException(\"Input matrix is not a column matrix or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        int r = m.getRowDimension();\n        double[][] d = new double[r][r];\n        for (int i = 0; i < r; i++)\n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getRowDimension() == m.getColumnDimension())\n    {\n        int r = m.getRowDimension();\n        double[][] d = new double[r][r];\n        for (int i = 0; i < r; i++)\n        {\n            d[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else \n    {\n        throw new IllegalArgumentException(\"Matrix must be column or square\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1) \n        {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int r = 0; r < m.getRowDimension(); r++) \n            {\n                d[r][r] = m.getEntry(r, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } \n        else \n        {\n            final double[][] d = new double[m.getColumnDimension()][1];\n            for (int r = 0; r < m.getColumnDimension(); r++) \n            {\n                d[r][0] = m.getEntry(r, r);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getRowDimension() == m.getColumnDimension()) \n    {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        throw new RuntimeException(\"Invalid matrix dimensions for diag operation.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        return m;\n    }\n    else\n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            for (int c = 0; c < m.getColumnDimension(); c++)\n            {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    if (rows <= 0 || columns <= 0) {\n        throw new IllegalArgumentException(\"rows (\" + rows + \") and columns (\"\n                + columns + \") must be positive\");\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int jWidth = blockWidth(jBlock);\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * jWidth];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int index = iBlock * blockColumns + jBlock;\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate new data array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // initialize block with zeros\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int q = qStart; q < qEnd; ++q) {\n                    block[index++] = 0.0;\n                }\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int blockIndex = iBlock * blockColumns + jBlock;\n            final double[] block = new double[iHeight * blockWidth(jBlock)];\n            blocks[blockIndex] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    if (rows % BLOCK_SIZE != 0 || columns % BLOCK_SIZE != 0) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = pStart + BLOCK_SIZE;\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = qStart + BLOCK_SIZE;\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // initialize with zeros\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                for (int q = qStart; q < qEnd; ++q) {\n                    block[index++] = 0.0;\n                }\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int index = iBlock * blockColumns + jBlock;\n            // allocate new block\n            final double[] block = new double[iHeight * blockWidth(jBlock)];\n            blocks[index] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            blocks[iBlock * blockColumns + jBlock] = new double[iHeight * blockWidth(jBlock)];\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    if (rows % BLOCK_SIZE != 0 || columns % BLOCK_SIZE != 0) {\n        throw new DimensionMismatchException(rows, columns);\n    }\n\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[(iBlock * blockColumns) + jBlock] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws DimensionMismatchException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field \" + field + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field \" + field + \" is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field \" + field.getName() + \" is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field \" + field.getName() + \" cannot be accessed\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field cannot be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field is not static\");\n    }\n\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"The field '\" + field.getName() + \"' is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field must be static\");\n    }\n    try {\n        if (!MemberUtils.isAccessible(field)) {\n            if (forceAccess) {\n                field.setAccessible(true);\n            } else {\n                throw new IllegalAccessException(\"The field is not accessible\");\n            }\n        }\n        return field.get(null);\n    } catch (final IllegalArgumentException e) { // NOPMD\n        throw new IllegalAccessException(e.getMessage());\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field is not accessible\");\n        }\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"Field must be static\");\n    }\n    if (!MemberUtils.isAccessible(field)) {\n        if (forceAccess) {\n            field.setAccessible(true);\n        } else {\n            throw new IllegalAccessException(\"Field not accessible\");\n        }\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() > 5 && id.charAt(0) == '+') {\n            return forOffsetHoursMinutes(id.substring(1));\n        }\n        if (id.length() > 6 && id.charAt(0) == '-') {\n            return forOffsetHoursMinutes(id.substring(1));\n        }\n        synchronized(iFixedOffsetCache) {\n            SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n            DateTimeZone zone = ref == null ? null : ref.get();\n            if (zone == null) {\n                zone = DateTimeZone.forID(id);\n                iFixedOffsetCache.put(id, new SoftReference<>(zone));\n            }\n            return zone;\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (!cAvailableIDs.contains(id)) {\n            throw new IllegalArgumentException(\"Unknown timezone id: \" + id);\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id).get();\n        if (zone != null) {\n            return zone;\n        }\n        try {\n            zone = TimeZone.getTimeZone(id).toDateTimeZone();\n        } catch (IllegalArgumentException e) {\n            String msg = \"Error converting ID to DateTimeZone: \" + id;\n            throw new IllegalArgumentException(msg, e);\n        }\n        iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(UTC.getID())) {\n            return UTC;\n        }\n        DateTimeZone zone = cAvailableIDs.stream().filter(id::equalsIgnoreCase).findFirst().map(DateTimeZone::forID).orElse(null);\n        if (zone == null) {\n            try {\n                zone = forTimeZone(TimeZone.getTimeZone(id));\n            } catch (IllegalArgumentException ex) {\n                // Ignore - fall through to exception\n            }\n        }\n        if (zone == null) {\n            zone = parseOffset(id);\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Unrecognised time zone id: \" + id);\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            id = cZoneIdConversion.get(id);\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id).get();\n        if (zone != null) {\n            return zone;\n        }\n        try {\n            zone = DateTimeZone.forID(id);\n        } catch (RuntimeException ex) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id, ex);\n        }\n        iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.intern();\n        if (cAvailableIDs.contains(id)) {\n            return forIDInternal(id);\n        }\n        int pos = id.indexOf(':');\n        if (pos == 3) {\n            try {\n                return forOffsetHoursMinutes(id.charAt(0) == '-' ? id.substring(1) : id);\n            } catch (IllegalArgumentException ex) {\n                // ignore, try the full id format\n            }\n        }\n        if (cZoneIdConversion.containsKey(id)) {\n            id = cZoneIdConversion.get(id);\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id).get();\n        if (zone == null) {\n            zone = new DateTimeZone(id, id);\n            iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.length() > 5 && id.charAt(0) == '+') {\n            return forOffsetHoursMinutes(id.substring(1));\n        } else if (id.length() > 6 && id.charAt(0) == '-') {\n            return forOffsetHoursMinutes(id.substring(1));\n        } else {\n            final SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n            DateTimeZone zone = ref != null ? ref.get() : null;\n            if (zone == null) {\n                zone = cZoneIdConversion.get(id) != null ? forID(cZoneIdConversion.get(id)) : new DateTimeZone(id);\n                iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\n            }\n            return zone;\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(UTC.getID())) {\n            return UTC;\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id).get();\n        if (zone != null) {\n            return zone;\n        }\n        try {\n            zone = DateTimeZone.forID(id);\n        } catch (IllegalArgumentException e) {\n            // fall through\n        }\n        if (zone == null) {\n            String newID = cZoneIdConversion.get(id);\n            if (newID != null) {\n                zone = forID(newID);\n            } else {\n                throw new IllegalArgumentException(\"Unrecognised time zone id: \" + id);\n            }\n        }\n        iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(UTC.getID())) {\n            return UTC;\n        }\n        DateTimeZone zone = iFixedOffsetCache.get(id).get();\n        if (zone != null) {\n            return zone;\n        }\n        for (Map.Entry<String, String> entry : cZoneIdConversion.entrySet()) {\n            if (id.equalsIgnoreCase(entry.getKey())) {\n                id = entry.getValue();\n                break;\n            }\n        }\n        try {\n            zone = DateTimeZone.forID(id);\n        } catch (IllegalArgumentException ex) {\n            zone = forOffsetHoursMinutes(0, 0);\n        }\n        iFixedOffsetCache.put(id, new SoftReference<>(zone));\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // Check for fixed offset\n        if (id.length() == 6 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffset(id.substring(1));\n        }\n        // Check for cached zone\n        SoftReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\n        if (ref != null) {\n            DateTimeZone zone = ref.get();\n            if (zone != null) {\n                return zone;\n            }\n        }\n        // Check for known IDs\n        String newID = cZoneIdConversion.get(id);\n        if (newID != null) {\n            id = newID;\n        }\n        try {\n            DateTimeZone zone = DateTimeZone.forID(id);\n            if (zone.getID().equals(id)) {\n                // Found a valid zone, cache it\n                iFixedOffsetCache.put(id, new SoftReference<>(zone));\n            }\n            return zone;\n        } catch (IllegalArgumentException ex) {\n            // Not a valid id, try the legacy methods\n            try {\n                DateTimeZone zone = forTimeZone(TimeZone.getTimeZone(id));\n                if (zone.getID().equals(id)) {\n                    // Found a valid zone, cache it\n                    iFixedOffsetCache.put(id, new SoftReference<>(zone));\n                }\n                return zone;\n            } catch (IllegalArgumentException ex2) {\n                throw new IllegalArgumentException(\"Unrecognized time zone id: \" + id, ex2);\n            }\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n\n        DateTimeZone zone = cAvailableIDs.get(id);\n        if (zone != null) {\n            return zone;\n        }\n\n        synchronized(cZoneIdConversion) {\n            zone = cZoneIdConversion.get(id);\n            if (zone == null) {\n                zone = forID(getID(id));\n                cZoneIdConversion.put(id, zone.getID());\n            }\n        }\n        return zone;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    Dfp result;\n    final int nans = field.getIEEEFlagsBits() & DfpField.MASK_NANS;\n\n    if (nans != 0) {\n        if (nans == INFINITE && x == 0) {\n            result = newInstance(this);\n            result.exp = 0;\n            return result;\n        }\n\n        if (nans == FINITE && x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            return result;\n        }\n    }\n\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + x + md - 2 * mant.length + 1;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result;\n    final int nans = getIEEEFlagsBits();\n\n    if (exp == 0) {\n        // x is zero, result is zero\n        result = getZero();\n    } else {\n\n        if (nans == INFINITE || nans == QNAN) {\n            // Special cases: x is infinite or NaN\n            if (x == 0) {\n                // x is zero, result is zero\n                result = getZero();\n            } else {\n                // x is infinite or NaN, return an invalid result\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = nans;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n            }\n\n        } else {\n            // General case: x is finite and non-zero\n\n            if (x == 1) {\n                // Shortcut, no multiplication needed\n                result = newInstance(this);\n            } else {\n\n                // Multiply the mantissas and add the products of the exponents\n                int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n                for (int i = 0; i < mant.length; i++) {\n                    int rh = 0;  // acts as a carry\n                    for (int j=0; j<mant.length; j++) {\n                        int r = mant[i] * x;    // multiply the 2 digits\n                        r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                        rh = r / RADIX;\n                        product[i+j] = r - rh * RADIX;\n                    }\n                    product[i+mant.length] = rh;\n                }\n\n                // Find the most sig digit\n                int md = mant.length * 2 - 1;  // default, in case result is zero\n                for (int i = mant.length * 2 - 1; i >= 0; i--) {\n                    if (product[i] != 0) {\n                        md = i;\n                        break;\n                    }\n                }\n\n}\n}\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    int carry = 0;  // acts as a carry\n    for (int i = 0; i < mant.length; i++) {\n        int r = mant[i] * x + carry;  // multiply the 2 digits\n        carry = r / RADIX;\n        mant[i] = r - carry * RADIX;\n    }\n\n    // Fixup the exponent.\n    exp = exp + x.exp + mant.length - 2;\n\n    final int excp;\n    if (x >= mant.length-1) {\n        excp = round(product[x-mant.length]);\n    } else {\n        excp = round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        return dotrap(excp, MULTIPLY_TRAP, x, this);\n    }\n\n    return this;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    } else {\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            int prod = mant[i] * x + carry;\n            mant[i] = (byte) (prod % RADIX);\n            carry = prod / RADIX;\n        }\n        if (carry != 0) {\n            mant[mant.length] = (byte) carry;\n        }\n        exp += x.exp - 1;\n        return this;\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result;\n\n    int rh = 0;  // acts as a carry\n    int r;\n    for (int i=0; i<mant.length; i++) {\n        r = mant[i] * x + rh;  // multiply the 2 digits\n        rh = r / RADIX;\n        mant[i] = r - rh * RADIX;\n    }\n\n    // Find the most sig digit\n    int md = mant.length - 1;  // default, in case result is zero\n    for (int i = mant.length - 1; i >= 0; i--) {\n        if (mant[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = mant[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - (mant.length - 1);\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(mant[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + x.exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result;\n\n    int rh = 0;  // acts as a carry\n    for (int j=0; j<mant.length; j++) {\n        int r = mant[j] * x;    // multiply the 2 digits\n        r = r + product[j] + rh;  // add to the product digit with carry in\n\n        rh = r / RADIX;\n        product[j] = r - rh * RADIX;\n    }\n\n    product[mant.length] = rh;\n\n    // Find the most sig digit\n    int md = mant.length - 1;  // default, in case result is zero\n    for (int i = mant.length - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    final int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, this, result);\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + x + md - 2 * mant.length + 1;\n    result.sign = (byte)((sign == x.sign)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = this;\n    int sign = result.sign;\n\n    // Multiply the significand of the result by the digit x.\n    for (int i = 0; i < mant.length; i++) {\n        int r = result.mant[i] * x;    // multiply the 2 digits\n        r += result.mant[i + mant.length] * x;\n        result.mant[i + mant.length] = r / RADIX;\n        result.mant[i] = r - result.mant[i + mant.length] * RADIX;\n    }\n\n    // Fixup the exponent.\n    result.exp += x - 1;\n\n    final int excp;\n    if (result.mant[mant.length - 1] == 0) {\n        excp = result.round(result.mant[mant.length - 2]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, this, result);\n    }\n\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformed.put(key, value);\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> transformed = (Map<K, V>) map.entrySet().stream()\n                .collect(Collectors.toMap(e -> transformKey(e.getKey()), e -> transformValue(e.getValue())));\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            K key = transformKey(entry.getKey());\n            V value = transformValue(entry.getValue());\n            transformed.put(key, value);\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>(map.size());\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = transformKey((K) entry.getKey());\n            V value = transformValue((V) entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> transformed = (Map<K, V>) map.entrySet().stream()\n                .map(entry -> new AbstractMap.SimpleEntry<>(transformKey(entry.getKey()),\n                        transformValue(entry.getValue())))\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<>(map.size());\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet())\n        {\n            K key = entry.getKey();\n            V value = entry.getValue();\n            transformed.put(transformKey(key), transformValue(value));\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        final Map<K, V> transformed = (Map<K, V>) map.entrySet().stream()\n                .collect(Collectors.toMap(\n                        e -> transformKey((K) e.getKey()),\n                        e -> transformValue((V) e.getValue()),\n                        (a, b) -> a,\n                        LinkedHashMap::new));\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<K, V>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = entry.getKey();\n            V value = entry.getValue();\n            key = transformKey(key);\n            value = transformValue(value);\n            transformed.put(key, value);\n        }\n        return transformed;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformedMap = new HashMap<>(map.size());\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            K key = (K) transformKey(entry.getKey());\n            V value = (V) transformValue(entry.getValue());\n            transformedMap.put(key, value);\n        }\n        return transformedMap;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        Map<K, V> transformed = new HashMap<>();\n        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            K key = entry.getKey();\n            V value = entry.getValue();\n            transformed.put(transformKey(key), transformValue(value));\n        }\n        return transformed;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n\nPreconditions.checkState(exportedFunction.isFunction());\n\nList<Node> params = exportedFunction.getFunction().getReceiverParameterList().getReceiverParameterTypes();\n\nList<Node> paramNames = exportedFunction.getFunction().getReceiverParameterList().getReceiverParameterNames();\n\nList<Node> newParams = new ArrayList<>();\n\nfor (int i=0; i<params.size(); i++) {\n\nNode param = params.get(i);\n\nNode name = paramNames.get(i);\n\nif (param.isPrimitiveType()) {\n\nString primitiveName = NodeUtil.getPrimitiveName(param);\n\nNode typeName = IR.primitiveType(primitiveName);\n\nnewParams.add(IR.param(typeName, name));\n\n} else {\n\nnewParams.add(IR.param(param, name));\n\n}\n\n}\n\nNode returnType = exportedFunction.getFunction().getReceiverParameterList().getReceiverParameterTypes().get(params.size());\n\nNode newReturnType = returnType;\n\nif (returnType.isPrimitiveType()) {\n\nString primitiveName = NodeUtil.getPrimitiveName(returnType);\n\nnewReturnType = IR.primitiveType(primitiveName);\n\n}\n\nNode externFunction = IR.func(newParams, newReturnType, IR.nullLiteral());\n\nreturn externFunction;\n\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkState(exportedFunction.isFunction(),\n        \"Cannot create extern function from a non-function\");\n\n    List<Node> parameters = exportedFunction.getParameters();\n    Preconditions.checkState(!parameters.isEmpty(),\n        \"Cannot create extern function from a function with no parameters\");\n\n    List<String> parameterNames = Lists.newArrayList();\n\n    for (Node parameter : parameters) {\n      parameterNames.add(parameter.getName().toString());\n    }\n\n    IR.FunctionType functionType = (IR.FunctionType) exportedFunction.getType();\n    Preconditions.checkState(functionType != null,\n        \"Cannot create extern function from a function with missing return type\");\n\n    Node returnType = IR.typeName(functionType.getReturnType().toString());\n\n    IR.Function function = IR.createFunction(IR.name(functionName));\n\n    for (String parameterName : parameterNames) {\n        function.addParameter(IR.parameter(IR.name(parameterName), functionType.getParameterType(parameterName)));\n    }\n\n    function.addStatement(IR.returnStatement(returnType));\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> params = exportedFunction.get(IR.params);\n    List<Node> returnTypes = exportedFunction.get(IR.returns);\n\n    Preconditions.checkState(params != null, \"missing parameter list\");\n\n    List<Node> externParams = Lists.newArrayList();\n\n    for (Node param : params) {\n        Node paramNameNode = param.get(IR.name);\n        String paramName = (paramNameNode != null) ? paramNameNode.toString() : null;\n\n        Preconditions.checkState(paramName != null, \"missing parameter name\");\n\n        externParams.add(IR.param(IR.name(paramName)));\n    }\n\n    Preconditions.checkState(returnTypes != null, \"missing return type\");\n\n    Node externReturnType = returnTypes.get(0);\n\n    Preconditions.checkState(externReturnType != null,\n            \"missing return type\");\n\n    return IR.func(externParams, IR.returns(externReturnType), IR.block());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n\n    Node returnType = exportedFunction.getReturnType();\n    List<Node> parameterList = exportedFunction.getParameterList();\n    Node functionName = exportedFunction.getName();\n\n    Node externFunction = IR.fun(\n        IR.name(functionName),\n        parameterList.stream()\n            .map(param -> IR.param(param.getName(), param.getType()))\n            .collect(Collectors.toList()),\n        returnType.isPresent()\n            ? returnType.get()\n            : IR.PRIMITIVE_VOID,\n        IR.empty(),\n        IR.nullLiteral());\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n  FunctionNode functionNode = (FunctionNode) exportedFunction;\n\n  List<Parameter> parameters = new ArrayList<>();\n  for (Parameter parameter : functionNode.getParameters()) {\n    parameters.add(new Parameter(parameter.getName(), parameter.getType()));\n  }\n\n  List<Statement> statements = new ArrayList<>();\n\n  if (functionNode.getReturnType() != null) {\n    statements.add(IR.return_(IR.nullLiteral()));\n  }\n\n  return IR.function(functionNode.getName(), parameters, statements);\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> params = exportedFunction.get(IR.params);\n    List<Node> body = exportedFunction.get(IR.body);\n\n    Preconditions.checkArgument(params != null,\n            \"Functions to export must have parameters\");\n    Preconditions.checkArgument(body == null,\n            \"Functions to export must not have a body\");\n\n    Node returnType = exportedFunction.get(IR.returnType);\n    if (returnType == null) {\n        returnType = IR.voidType();\n\n        compiler.getDiagnostics().report(Diagnostic.Kind.WARNING,\n                \"Functions exported to externs must have a return type\");\n    }\n\n    List<Node> newParams = Lists.newArrayList();\n    for (Node param : params) {\n        newParams.add(NodeUtil.newVarNode(param.get(IR.name),\n                param.get(IR.type)));\n    }\n\n    return IR.func(IR.name(\"extern_\" + exportedFunction.get(IR.name)),\n            IR.params(newParams), returnType, IR.body());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Preconditions.checkArgument(exportedFunction.isFunction());\n    FunctionExpr functionExpr = (FunctionExpr) exportedFunction;\n\n    List<IR.Var> externParams = Lists.newArrayList();\n    for (Map.Entry<String, Node> entry : functionExpr.getParameters().entrySet()) {\n      externParams.add(IR.var(IR.name(entry.getKey())));\n    }\n\n    IR.Var returnVar;\n    if (functionExpr.getReturnType().isPresent()) {\n      returnVar = IR.var(IR.name(\"return\"));\n    } else {\n      returnVar = null;\n    }\n\n    return IR.createExternFunction(\n        compiler.getCodingConvention(),\n        functionExpr.getName(),\n        Joiner.on(\",\").join(externParams),\n        returnVar);\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    List<Node> params = exportedFunction.get(IR.params);\n    Node returnType = exportedFunction.get(IR.returnType);\n    List<Node> body = exportedFunction.get(IR.body);\n\n    List<Node> newParams = new ArrayList<>();\n    for (Node param : params) {\n        Node name = param.get(IR.name);\n        newParams.add(NodeUtil.newVarNode(name.toString(), IR.voidType()));\n    }\n\n    return IR.fun(\n        IR.name(\"extern_\" + exportedFunction.get(IR.name).toString()),\n        newParams,\n        returnType,\n        body);\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Preconditions.checkState(exportedFunction.isFunction());\n\n  FunctionDeclaration functionDeclaration = (FunctionDeclaration) exportedFunction;\n  List<Parameter> parameters = functionDeclaration.getParameters();\n\n  List<Parameter> newParameters = Lists.newArrayList();\n  for (Parameter parameter : parameters) {\n    newParameters.add(createExternParameter(parameter));\n  }\n\n  Node returnType = functionDeclaration.getReturnType();\n\n  if (returnType == null) {\n    returnType = IR.voidType();\n\n    if (functionDeclaration.hasBlockBody()) {\n      context.reportWarning(\n          \"Function '%s' doesn't have return type, defaulting to void\",\n          functionDeclaration.getName());\n    }\n  }\n\n  return IR.externFunction(\n      context.getCodingConvention(),\n      functionDeclaration.getName(),\n      createExternParameters(newParameters), returnType,\n      IR.empty(), functionDeclaration.getFlags(),\n      functionDeclaration.getSourceInfo());\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n\nPreconditions.checkArgument(exportedFunction.isFunction(), \"Not a function: %s\", exportedFunction);\n\nNode returnType = exportedFunction.getReturnType();\nNode params = exportedFunction.getParameters();\n\nNode emptyFunction = IR.fun(null, params, returnType, IR.empty(), IR.nullLiteral());\n\nif (returnType == IR.VOID) {\n  return emptyFunction;\n}\n\nif (params.isEmpty()) {\n  if (returnType.isPrimitiveType()) {\n    return createExternFunction(IR.fun(null, IR.name(\"dummyName\"), returnType, IR.nullLiteral()));\n  } else {\n    return IR.assign(IR.name(\"dummyName\"), IR.nullLiteral());\n  }\n}\n\nif (params.size() == 1) {\n  Node param = params.get(0);\n  if (param.getType().isPrimitiveType()) {\n    return createExternFunction(IR.fun(null, IR.name(\"dummyName\"), returnType, IR.nullLiteral()));\n  } else {\n    return IR.assign(IR.name(\"dummyName\"), IR.nullLiteral());\n  }\n}\n\nif (returnType.isPrimitiveType()) {\n  return createExternFunction(IR.fun(null, params, returnType, IR.nullLiteral()));\n} else {\n  return IR.assign(IR.name(\"dummyName\"), IR.nullLiteral());\n}\n\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    final double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    final double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params,\n            covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Set up the Jacobian.\n    final RealMatrix j = computeWeightedJacobian(params);\n\n    // Compute transpose(J)J.\n    final RealMatrix jTj = j.transpose().multiply(j);\n\n    // Compute the covariances matrix.\n    final DecompositionSolver solver\n        = new QRDecomposition(jTj, covarianceSingularityThreshold).getSolver();\n    final double[][] covariance = solver.getInverse().getData();\n\n    // Extract the diagonal coefficients and compute the square root.\n    final double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    double[][] covarianceMatrix = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements.\n    double[] sigma = new double[covarianceMatrix.length];\n    for (int i = 0; i < covarianceMatrix.length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    final double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    final double[] sigma = new double[covariance.length];\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Get the covariance matrix.\n    final double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Extract the diagonal elements and return their square root.\n    final double[] sigma = new double[covariance.length];\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = Math.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, covarianceSingularityThreshold).getSolver();\n        final double[][] covariance = solver.getInverse().getData();\n\n        // Compute the standard deviations.\n        final double[] sigma = new double[covariance.length];\n        for (int i = 0; i < covariance.length; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        // cyclic substitution found\n        throw new IllegalArgumentException(\n                \"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVarName : priorVariables) \n    {\n        if (priorVarName.equals(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    // Check if the variable is already in the stack\n    if (priorVariables.contains(varName)) {\n        // Throw an exception or handle the cyclic substitution as desired\n        throw new CyclicSubstitutionException(varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (final String priorVarName : priorVariables)\n    {\n        if (varName.equals(priorVarName))\n        {\n            // cyclic substitution detected\n            throw new IllegalStateException(\"Cyclic substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    // Implement logic to check for cyclic substitution.\n    // ...\n    // Throw an exception if a cycle is detected.\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVarName : priorVariables) {\n        if (priorVarName.equals(varName)) {\n            // Found a cyclic substitution\n            // Handle cyclic substitution error as needed\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CyclicVariableSubstitutionsException(varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVar : priorVariables) \n    {\n        if (varName.equals(priorVar)) \n        {\n            throw new SubstitutionException(\n                    \"Cyclic substitution detected: \" + varName);\n        }\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> all = new ArrayList<>(roots);\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : all) {\n        for (String symbol : input.getRequires()) {\n            deps.put(input, getInputProviding(symbol));\n        }\n    }\n\n    List<INPUT> cycle = findCycle(roots, deps);\n    if (cycle.size() > 1) {\n        throw new IllegalStateException(\"circular dependency: \" + cycleToString(cycle));\n    }\n\n    List<INPUT> result = new ArrayList<>(all);\n    if (sorted) {\n        Collections.sort(result, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = buildDeps();\n    List<INPUT> allInputs = new ArrayList<>(deps.keySet());\n\n    if (sorted) {\n        // Find the cycle and convert it to a string.\n        List<INPUT> cycle = findCycle(allInputs, deps);\n        String cycleString = cycleToString(cycle);\n\n        // Throw an exception if there is a cycle.\n        if (cycleString.length() > 0) {\n            throw new CyclicDependencyException(cycleString);\n        }\n    }\n\n    // Create a list to store the sorted dependencies.\n    List<INPUT> sortedDependencies = new ArrayList<>();\n\n    // Add the roots to the sorted list.\n    for (INPUT root : roots) {\n        sortedDependencies.add(root);\n    }\n\n    // Add the dependencies of the roots to the sorted list.\n    for (INPUT root : roots) {\n        for (INPUT dependency : deps.get(root)) {\n            if (!sortedDependencies.contains(dependency)) {\n                sortedDependencies.add(dependency);\n            }\n        }\n    }\n\n    // Sort the sorted dependencies if requested.\n    if (sorted) {\n        Collections.sort(sortedDependencies);\n    }\n\n    // Return the sorted dependencies.\n    return sortedDependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = createDependenciesMap(roots);\n    List<INPUT> subGraph = new ArrayList<>(roots);\n\n    List<List<INPUT>> cycles = new ArrayList<>();\n    Set<INPUT> seen = new HashSet<>();\n\n    // Find all the cycles\n    while (!seen.containsAll(subGraph)) {\n        List<INPUT> cycle = findCycle(subGraph, deps);\n        seen.addAll(cycle);\n        cycles.add(cycle);\n        subGraph.removeAll(cycle);\n    }\n\n    // Sort the cycles in topological order\n    Collections.sort(cycles, (c1, c2) -> c1.get(0).toString().compareTo(c2.get(0).toString()));\n\n    // Flatten the cycles into a single list\n    List<INPUT> dependencies = new ArrayList<>();\n    for (List<INPUT> cycle : cycles) {\n        dependencies.addAll(cycle);\n    }\n\n    // Reverse the list if necessary\n    if (!sorted) {\n        Collections.reverse(dependencies);\n    }\n\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : roots) {\n        for (INPUT require : input.getRequires()) {\n            deps.put(require, input);\n        }\n    }\n    List<INPUT> subgraph = new ArrayList<>(roots);\n    List<INPUT> cycle = findCycle(subgraph, deps);\n    if (cycle.isEmpty()) {\n        List<INPUT> sortedDeps = new ArrayList<>(roots);\n        for (INPUT input : roots) {\n            for (INPUT dep : deps.get(input)) {\n                if (!sortedDeps.contains(dep)) {\n                    sortedDeps.add(dep);\n                }\n            }\n        }\n        if (sorted) {\n            sortedDeps = topologicalSort(sortedDeps, deps);\n        }\n        return sortedDeps;\n    } else {\n        throw new CircularDependencyException(cycleToString(cycle));\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.<INPUT, INPUT>create();\n\n    // Build up the dependencies multimap\n    for (INPUT input : roots) {\n        for (String symbol : input.getRequires()) {\n            deps.put(input, getInputProviding(symbol));\n        }\n    }\n\n    // Perform a topological sort on the dependencies\n    List<INPUT> sortedDeps = topologicalSort(roots, deps);\n\n    // Add the inputs to the result list, in the correct order\n    for (INPUT input : sortedDeps) {\n        if (!result.contains(input)) {\n            result.add(input);\n        }\n    }\n\n    // Return the result list\n    if (sorted) {\n        return result;\n    } else {\n        return roots;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = Multimap.create();\n    for (INPUT input : roots) {\n        for (INPUT requires : input.getRequires()) {\n            deps.put(requires, input);\n        }\n    }\n\n    List<INPUT> subGraph = new ArrayList<>();\n    for (INPUT root : roots) {\n        if (!subGraph.contains(root)) {\n            subGraph.add(root);\n            subGraph.addAll(findDependencies(root, deps));\n        }\n    }\n\n    if (sorted) {\n        return topologicalSort(subGraph, deps);\n    } else {\n        return subGraph;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = buildDependencyGraph(roots);\n\n    // Find cycles, and report an error if we found any.\n    List<INPUT> cycle = findCycle(roots, deps);\n    if (!cycle.isEmpty()) {\n      throw new IllegalStateException(\"Cyclic dependency detected: \" + cycleToString(cycle));\n    }\n\n    // Topological sort ( Kahn's algorithm).\n    List<INPUT> sortedDeps = new ArrayList<>(roots.size());\n    Deque<INPUT> ready = new ArrayDeque<>(roots.size());\n    for (INPUT root : roots) {\n      if (deps.get(root).isEmpty()) {\n        ready.add(root);\n      }\n    }\n\n    while (!ready.isEmpty()) {\n      INPUT current = ready.poll();\n      sortedDeps.add(current);\n\n      for (INPUT dependent : deps.remove(current)) {\n        if (deps.get(dependent).isEmpty()) {\n          ready.add(dependent);\n        }\n      }\n    }\n\n    if (sortedDeps.size() != deps.keySet().size()) {\n      throw new IllegalStateException(\"Failed to find all dependencies\");\n    }\n\n    return sorted ? sortedDeps : deps.keySet().asList();\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.<INPUT, INPUT>create();\n    for (INPUT root : roots) {\n        for (String symbol : root.getRequires()) {\n            deps.put(root, getInputProviding(symbol));\n        }\n    }\n    Set<INPUT> visited = Sets.newHashSet();\n    for (INPUT root : roots) {\n        dfs(root, deps, visited, result);\n    }\n    return sorted ? result : roots;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.<INPUT, INPUT>create();\n    for (INPUT root : roots) \n    {\n        for (String symbol : root.getRequires()) \n        {\n            deps.put(root, getInputProviding(symbol));\n        }\n    }\n    for (INPUT root : roots) \n    {\n        result.add(root);\n        for (INPUT input : deps.get(root)) \n        {\n            if (!result.contains(input)) \n            {\n                result.add(input);\n            }\n        }\n    }\n    if (sorted) \n    {\n        List<INPUT> cycle = findCycle(result, deps);\n        if (cycle != null) \n        {\n            throw new IllegalStateException(\n                \"Cyclic dependency detected: \" + cycleToString(cycle));\n        }\n        result.sort(new Comparator<INPUT>() \n        {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> allInputs = new ArrayList<>(roots);\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n\n    for (INPUT input : allInputs) {\n        for (String symbol : input.getRequires()) {\n            INPUT dependency = getInputProviding(symbol);\n            deps.put(input, dependency);\n        }\n    }\n\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        dfs(root, deps, result, visited);\n    }\n\n    if (sorted) {\n        Collections.reverse(result);\n    }\n\n    return result;\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    char[] chars = str.toCharArray();\n    boolean capitalizeNext = false;\n    for (int i = 0; i < chars.length; i++) {\n        if (Character.isWhitespace(chars[i])) {\n            capitalizeNext = true;\n        } else {\n            if (capitalizeNext) {\n                chars[i] = Character.toLowerCase(chars[i]);\n                capitalizeNext = false;\n            } else {\n                chars[i] = Character.toUpperCase(chars[i]);\n            }\n        }\n    }\n    return new String(chars);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    return capitalize(str.toLowerCase(), delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    String result = \"\";\n    final char[] chars = str.toCharArray();\n    final int strLen = chars.length;\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = chars[i];\n        if (Character.isWhitespace(ch)) {\n            capitalizeNext = true;\n            result += ch;\n        } else if (delimLen == -1 || !isDelimiter(ch, delimiters)) {\n            if (capitalizeNext) {\n                result += Character.toLowerCase(ch);\n                capitalizeNext = false;\n            } else {\n                result += Character.toUpperCase(ch);\n            }\n        }\n    }\n    return result;\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder result = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (Character.isWhitespace(ch)) {\n            capitalizeNext = true;\n            result.append(ch);\n        } else {\n            if (capitalizeNext) {\n                result.append(Character.toLowerCase(ch));\n                capitalizeNext = false;\n            } else {\n                result.append(ch);\n            }\n        }\n    }\n\n    return result.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        if (Character.isWhitespace(ch)) \n        {\n            capitalizeNext = true;\n            result.append(ch);\n        } \n        else if (i == 0 || (delimLen == -1 && !Character.isWhitespace(str.charAt(i - 1)))) \n        {\n            if (capitalizeNext) \n            {\n                result.append(Character.toLowerCase(ch));\n                capitalizeNext = false;\n            } \n            else \n            {\n                result.append(ch);\n            }\n        } \n        else \n        {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    char[] chars = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < chars.length; i++) \n    {\n        if (Character.isWhitespace(chars[i])) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            chars[i] = Character.toLowerCase(chars[i]);\n            capitalizeNext = false;\n        }\n    }\n    return new String(chars);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder buf = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); ++i) {\n        char ch = str.charAt(i);\n        if (Character.isWhitespace(ch)) {\n            capitalizeNext = true;\n        } else {\n            if (capitalizeNext) {\n                ch = Character.toLowerCase(ch);\n                capitalizeNext = false;\n            }\n        }\n        buf.append(ch);\n    }\n    return buf.toString();\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    return capitalize(str.toLowerCase(), delimiters);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    DfpField.Exp exp = a.getExponent();\n    int digits = exp.getDigits();\n    int sig = exp.getSig();\n    int sp = digits - sig;\n    char[] buf = new char[digits + 2];\n    a.getDigits(buf, 0);\n\n    if (sp > 0) {\n        result[0] = field.newDfp(new String(buf, 0, sp));\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = '0';\n        }\n\n        result[1] = field.newDfp(new String(buf));\n    } else {\n        result[0] = a;\n        result[1] = field.ZERO;\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    int radixDigits = a.getField().getRadixDigits();\n    int sig = (400 - sig) % 4;\n    int sp = (int) Math.ceil((double) (sig + (radixDigits / 2)) / (double) radixDigits);\n    String num = a.toString();\n    result[0] = new Dfp(num.substring(0, sp));\n    result[1] = new Dfp(num.substring(sp));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n    \n    for (int i = 0; i < buf.length; i++)\n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '1' && buf[i] <= '9')\n        {\n            leading = false;\n        }\n        if (buf[i] == '.')\n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n        if (sig == (field.getRadixDigits() / 2) * 4)\n        {\n            sp = i;\n            break;\n        }\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading)\n        {\n            sig ++;\n        }\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for (int i = 0; i < buf.length; i++)\n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp)\n        {\n            buf[i] = '0';\n        }\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp result[] = new Dfp[2];\n    DfpField.DfpLength len = field.getFormat();\n    char[] buf = new char[len.getLength() + 1];\n    int sp = 0;\n    int sig = 0;\n    int i;\n\n    for (i = 0; i < len.getLength(); i++) {\n        buf[i] = a.getDigit(i);\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            break;\n        }\n    }\n\n    if (i == len.getLength()) {\n        buf[i] = '0';\n        result[0] = field.newDfp(buf);\n        result[1] = field.getZero();\n        return result;\n    }\n\n    for (; i < len.getLength(); i++) {\n        if (buf[i] >= '0' && buf[i] <= '9') {\n            sig++;\n        } else if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n        } else {\n            break;\n        }\n    }\n\n    sp = i;\n\n    for (; i < len.getLength(); i++) {\n        buf[i] = a.getDigit(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    result[1] = field.newDfp(new String(buf, sp, len.getLength() - sp));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    String value = a.toString();\n    int decimal = 0;\n    for (int i=0; i<value.length(); i++) \n    {\n        if (value.charAt(i) == '.') decimal++;\n    }\n    if (decimal >= 3) \n    {\n        String[] splitted = value.split(\"\\\\.\");\n        result[0] = a.getField().newDfp(splitted[0] + \".\" + splitted[1].substring(0, (splitted[1].length() / 2)));\n        result[1] = a.getField().newDfp(\"0.\" + splitted[1].substring((splitted[1].length() / 2)));\n    } \n    else \n    {\n        result[0] = a;\n        result[1] = a.getField().getZero();\n    }\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getBufferSize()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    DfpField field = a.getField();\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getPrecision()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (field.getRadixDigits() - sig) % field.getRadixDigits();\n            leading = false;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * field.getRadixDigits()) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp result[] = new Dfp[2];\n    int len = a.getBufferSize();\n    int sig = 0;\n    char[] buf = new char[len];\n    a.getBuffer().getChars(0, len, buf, 0);\n    boolean leading = true;\n    int sp = 0;\n    \n    for(int i = 0; i < len; i++) {\n    \tif(buf[i] >= '1' && buf[i] <= '9') {\n    \t\tleading = false;\n    \t}\n    \tif(buf[i] == '.') {\n    \t\tsig += (field.getRadixDigits() - sig) % field.getRadixDigits();\n    \t\tleading = false;\n    \t}\n    \tif(sig == field.getRadixDigits() / 2 * 4) {\n    \t\tsp = i;\n    \t\tbreak;\n    \t}\n    \tif(buf[i] >= '0' && buf[i] <= '9' && !leading) {\n    \t\tsig ++;\n    \t}\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for(int i = 0; i < len; i++) {\n    \tif(buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n    \t\tbuf[i] = '0';\n    \t}\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    int sig = 0;\n    int sp = 0;\n    int len = a.getBufferSize();\n\n    for (int i = 0; i < len; i++) {\n        if (a.getQuickAccess()[i] >= '1' && a.getQuickAccess()[i] <= '9') {\n            sig++;\n        }\n\n        if (a.getQuickAccess()[i] == '.') {\n            sig += (400 - sig) % 4;\n        }\n\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n    }\n\n    char[] buf = new char[len];\n    a.getQuickAccess().copyInto(buf);\n\n    result[0] = field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < len; i++) {\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = field.newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (hasAttribute(\"id\")) {\n        return \"#\" + attribute(\"id\");\n    } else {\n        String path = parent().cssSelector();\n        if (path.length() > 0) {\n            path = path + \" > \";\n        }\n        path = path + tagName();\n        String classNames = attribute(\"class\");\n        if (classNames.length() > 0) {\n            path = path + \".\" + classNames.replace(\" \", \".\");\n        }\n        int index = siblings().indexOf(this);\n        if (index > -1) {\n            path = path + \":nth-child(\" + (index + 1) + \")\";\n        }\n        return path;\n    }\n}",
      "public String cssSelector()  {\n\tif (id != null && !id.isEmpty()) {\n\t\treturn \"#\" + id;\n\t} else {\n\t\tString parentSelector = null;\n\t\tif (parent() != null) {\n\t\t\tparentSelector = parent().cssSelector();\n\t\t}\n\t\tStringBuilder uniqueSelector = new StringBuilder();\n\t\tuniqueSelector.append(tagName());\n\t\tfor (String className : classes) {\n\t\t\tuniqueSelector.append(\".\").append(className);\n\t\t}\n\t\tuniqueSelector.append(\":\");\n\t\tif (parentSelector != null) {\n\t\t\tuniqueSelector.append(\"nth-child(\").append(siblingIndex() + 1).append(\")\");\n\t\t} else {\n\t\t\tuniqueSelector.append(\"nth-of-type(\").append(siblingIndex() + 1).append(\")\");\n\t\t}\n\t\tif (parentSelector != null) {\n\t\t\treturn parentSelector + \" > \" + uniqueSelector;\n\t\t} else {\n\t\t\treturn uniqueSelector.toString();\n\t\t}\n\t}\n}",
      "public String cssSelector()  {\n    if (hasAttribute(\"id\") && !getAttribute(\"id\").isEmpty()) \n    {\n        return \"#\" + getAttribute(\"id\");\n    }\n    else \n    {\n        String parentSelector = getParent().cssSelector();\n        if (parentSelector != null) \n        {\n            return parentSelector + \" > \" + cssSelectorFromTagAndClassesAndNthChild(this);\n        }\n        else \n        {\n            return cssSelectorFromTagAndClassesAndNthChild(this);\n        }\n    }\n}",
      "public String cssSelector()  {\n  if (id() != null)\n    return \"#\" + id();\n\n  StringBuilder sb = new StringBuilder();\n  Element parent = parent();\n\n  if (parent != null)\n    sb.append(parent.cssSelector()).append(\">\");\n\n  return sb.append(tagName()).append(\".\").append(className().replace(' ', '.')).append(\":nth-child(\").append(index() + 1).append(\")\").toString();\n}",
      "public String cssSelector()  {\n    if (id() != null)\n    {\n        return \"#\" + id();\n    }\n    else if (parent() == null)\n    {\n        return tagName();\n    }\n    else\n    {\n        List<Element> sibs = parent().children().filter(e -> e.tagName().equals(tagName())).collect(Collectors.toList());\n        int idx = sibs.indexOf(this);\n        StringBuilder sb = new StringBuilder();\n        for (Element p = parent(); p != null; p = p.parent())\n        {\n            if (p.id() != null)\n            {\n                sb.insert(0, \"#\" + p.id() + \" > \");\n                break;\n            }\n            else if (p.tagName().equals(\"html\"))\n            {\n                sb.insert(0, p.tagName() + \" > \");\n                break;\n            }\n            else\n            {\n                sb.insert(0, p.tagName() + \".\");\n            }\n        }\n        sb.append(tagName());\n        for (String c : className())\n        {\n            sb.append(\".\").append(c);\n        }\n        sb.append(\":\");\n        if (idx == -1)\n        {\n            sb.append(\"nth-of-type(0)\");\n        }\n        else\n        {\n            sb.append(\"nth-child(\").append(idx+1).append(\")\");\n        }\n        return sb.toString();\n    }\n}",
      "public String cssSelector()  {\n  if (id() != null) \n  {\n    return \"#\" + id();\n  } \n  else \n  {\n    Element parent = parent();\n    if (parent != null) \n    {\n      return parent.cssSelector() + \" > \" + uniqueSelector();\n    } \n    else \n    {\n      return uniqueSelector();\n    }\n  }\n}",
      "public String cssSelector()  {\n    if (hasAttr(ID_ATTRIBUTE)) \n    {\n        return \"#\" + attr(ID_ATTRIBUTE);\n    }\n    else \n    {\n        String parentSelector = parent() != null ? parent().cssSelector() : \"\";\n        String tag = tagName();\n        String classes = classList().size() > 0 ? \".\" + classList().join(\".\") : \"\";\n        String nthChild = nthChild();\n        return parentSelector + \" > \" + tag + classes + nthChild;\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null)\n    {\n        return \"#\" + id();\n    }\n    else if (parent() != null)\n    {\n        String parentSelector = parent().cssSelector();\n        if (!parentSelector.isEmpty())\n        {\n            parentSelector += \" > \";\n        }\n        String uniqueSelector = tag();\n        if (!classNames().isEmpty())\n        {\n            uniqueSelector += \".\" + classNames().join(\".\");\n        }\n        if (siblingIndex() > 0)\n        {\n            uniqueSelector += \":nth-child(\" + (siblingIndex() + 1) + \")\";\n        }\n        return parentSelector + uniqueSelector;\n    }\n    else\n    {\n        return \"\";\n    }\n}",
      "public String cssSelector()  {\n\tString selector;\n\tif (id() != null)\n\t\tselector = \"#\" + id();\n\telse \n\t{\n\t\tif (parent() != null) \n\t\t{\n\t\t\tselector = parent().cssSelector();\n\t\t\tif (selector.length() > 0)\n\t\t\t\tselector += \" > \";\n\t\t\t}\n\t\t\telse\n\t\t\t\tselector = \"\";\n\t\t\tString tag = tagName().toLowerCase();\n\t\t\tString classNames = \"\";\n\t\t\tString nthChild = \"\";\n\t\t\tint childIndex = 0;\n\t\t\tfor (Element element : parent().childNodes())\n\t\t\t\tif (element.tagName().equalsIgnoreCase(tag))\n\t\t\t\t\tchildIndex++;\n\t\t\tfor (String className : classNames().split(\" \"))\n\t\t\t\tclassNames += \".\" + className;\n\t\t\tif (childIndex > 1)\n\t\t\t\tnthChild = \":nth-child(\" + childIndex + \")\";\n\t\t\tselector += tag + classNames + nthChild;\n\t\t}\n\treturn selector;\n}",
      "public String cssSelector()  {\n    if (hasAttribute(\"id\") && StringUtils.isNotBlank(id())) {\n        return \"#\" + id();\n    } else {\n        StringBuilder sb = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) {\n            sb.append(parent.cssSelector()).append(\">\");\n        }\n        sb.append(tagName()).append(\".\").append(className()).append(\":\");\n        if (siblings().size() > 1) {\n            sb.append(\"nth-child(\").append(siblingIndex() + 1).append(\")\");\n        }\n        return sb.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n      return 1 + estimateCostOneLevel(n.getFirstChild());\n    }\n    else if (n.getType() == Token.LPAR || n.getType() == Token.RPAR) {\n      return 2;\n    }\n    else {\n      return 0;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType())\n    {\n        case Token.HOOK:\n        case Token.OR:\n        case Token.AND:\n        case Token.XOR:\n        case Token.NOT:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            return 1;\n        case Token.LPAR:\n        case Token.RPAR:\n            return 2;\n        case Token.COND:\n            return 3;\n        case Token.COMMA:\n            return 2;\n        case Token.STAR:\n        case Token.PLUS:\n        case Token.MINUS:\n        case Token.DIV:\n        case Token.MOD:\n            return 5;\n        case Token.POW:\n            return 4;\n        default:\n            return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            result += 1;\n            break;\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n        case Token.XOR:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            result += 7; // (2 for the operator + 5 for the parentheses)\n            break;\n        case Token.LPAR:\n        case Token.RPAR:\n            result += 2;\n            break;\n        case Token.LBRACE:\n        case Token.RBRACE:\n            result += 4;\n            break;\n        case Token.STAR:\n        case Token.PLUS:\n            result += 5; // (2 for the operator + 3 for the parentheses)\n            break;\n        case Token.DOT:\n            result += 2;\n            break;\n        case Token.COMMA:\n            result += 3; // (2 for the operator + 1 for the parentheses)\n            break;\n        case Token.IDENTIFIER:\n            result += n.getText().length();\n            break;\n        case Token.INT_LIT:\n            result += 5; // (4 for the digits + 1 for the integer symbol)\n            break;\n        case Token.FLOAT_LIT:\n            result += 8; // (7 for the digits + 1 for the decimal point)\n            break;\n        case Token.CHAR_LIT:\n            result += 3; // (2 for the apostrophes + 1 for the character)\n            break;\n        case Token.STRING_LIT:\n            result += n.getText().length() + 2; // (quotes + content)\n            break;\n        case Token.EOF:\n            break;\n        default:\n            System.err.println(\"Unknown token: \" + n.getType());\n    }\n    return result;\n}\n\n    case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        Node thenSubtree = cond.getNext();\n        Node elseSubtree = thenSubtree.getNext().detachFromParent();\n\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) \n    {\n        return estimateCostOneLevel(n.getFirstChild()) + 1;\n    } \n    else \n    {\n        return 0;\n    }\n}\n\n    case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        MinimizedCondition thenSubtree =\n            computeMinimizedCondition(cond.getNext().detachFromParent());\n        MinimizedCondition elseSubtree =\n            computeMinimizedCondition(cond.getNext().getNext().detachFromParent());\n        MeasuredNode posTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.positive,\n            elseSubtree.positive);\n        MeasuredNode negTree = MeasuredNode.addNode(\n            new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n            thenSubtree.negative,\n            elseSubtree.negative);\n        return new MinimizedCondition(posTree, negTree);\n      }",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    switch (n.getType()) \n    {\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.NOT:\n            result = 1;\n            break;\n        case Token.AND:\n        case Token.OR:\n        case Token.XOR:\n        case Token.IMPLIES:\n        case Token.IFF:\n            result = 2;\n            break;\n        case Token.HOOK:\n        case Token.LAMBDA:\n        case Token.LAMBDA_EXPR:\n        case Token.LAMBDA_PARAM:\n        case Token.LAMBDA_RETURN:\n        case Token.LAMBDA_BODY:\n        case Token.LAMBDA_TYPE:\n        case Token.LAMBDA_TYPE_PARAM:\n        case Token.LAMBDA_TYPE_PARAM_BOUND:\n        case Token.LAMBDA_TYPE_BODY:\n        case Token.LAMBDA_TYPE_SIGNATURE:\n        case Token.LAMBDA_TYPE_ARGS:\n        case Token.LAMBDA_TYPE_RESULT:\n        case Token.LAMBDA_TYPE_RETURN:\n        case Token.LAMBDA_TYPE_EXTENDS:\n        case Token.LAMBDA_TYPE_EXTENDS_LIST:\n        case Token.LAMBDA_TYPE_IMPLEMENTS:\n        case Token.LAMBDA_TYPE_IMPLEMENTS_LIST:\n        case Token.LAMBDA_TYPE_SUPER:\n        case Token.LAMBDA_TYPE_SUPER_LIST:\n        case Token.LAMBDA_TYPE_TYPE:\n        case Token.LAMBDA_TYPE_TYPE_LIST:\n        case Token.LAMBDA_TYPE_VAR:\n        case Token.LAMBDA_TYPE_VAR_ARGS:\n        case Token.LAMBDA_TYPE_VAR_ARGS_LIST:\n        case Token.LAMBDA_TYPE_VAR_LIST:\n        case Token.LAMBDA_TYPE_VAR_LIST_ARGS:\n        case Token.LAMBDA_TYPE_VAR_LIST_ARGS_LIST:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int result = 0;\n    if (n.getType() == Token.NOT) \n    {\n        result += 3; // '!' + '(' + ')'\n    } \n    else\n    {\n        switch (n.getType())\n        {\n            case Token.HOOK:\n            case Token.AND:\n            case Token.OR:\n            case Token.XOR:\n            case Token.EQ:\n            case Token.NE:\n            case Token.SHEQ:\n            case Token.SHNE:\n                result += 2; // '(' + ')'\n                break;\n            case Token.LPAREN:\n            case Token.RPAREN:\n                result += 0;\n                break;\n            case Token.NUMBER:\n            case Token.STRING:\n                result += n.getText().length();\n                break;\n            case Token.ID:\n                result += n.getText().length() - 1; // minus '='\n                break;\n            case Token.VAR:\n                result += n.getText().length();\n                break;\n            case Token.DOT:\n                result += 1; // '.'\n                break;\n            case Token.CAST:\n                result += 3; // '('.length() + ')'.length() + '('.length()\n                break;\n            case Token.SRCREF:\n            case Token.LAMBDA:\n            case Token.HASH:\n            case Token.AT:\n            case Token.DOUBLE_AT:\n                result += 0;\n                break;\n            case Token.NEW:\n                result += 5; // 'new'.length() + ' '.length() + '('.length() + ')'.length()\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown token: \" + n.getType());\n        }\n    }\n    for (Node child : n.getChildren())\n    {\n        result += estimateCostOneLevel(child);\n    }\n    return result;\n}\n\n    case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        MinimizedCondition thenSubtree =\n            computeMinimizedCondition(cond.getNext().detachFromParent());\n        MinimizedCondition elseSubtree =\n            computeMinimizedCondition(cond.getNext().getNext().detachFromParent());\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n        case Token.NOT:\n            return 1;\n        case Token.HOOK:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.EQ:\n        case Token.NE:\n            return 5;\n        case Token.OR:\n        case Token.AND:\n            return 4;\n        case Token.LPAREN:\n        case Token.RPAREN:\n            return 2;\n        case Token.TIMES:\n        case Token.DIVIDE:\n        case Token.MOD:\n            return 3;\n        case Token.PLUS:\n        case Token.MINUS:\n            return 2;\n        case Token.DOT:\n        case Token.INC:\n        case Token.DEC:\n            return 1;\n        default:\n            return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            return 0;\n        case Token.NOT:\n            return 1 + estimateCostOneLevel(n.getFirstChild());\n        case Token.LPAREN:\n        case Token.RPAREN:\n            return 0;\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n        case Token.XOR:\n        case Token.COMMA:\n            int cost = 0;\n            for (Node child : n.getChildren()) {\n                cost += estimateCostOneLevel(child);\n            }\n            return 1 + cost;\n        default:\n            return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n      return 1 + estimateCostOneLevel(n.getFirstChild());\n    }\n    return 2;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) \n    {\n        return 1 + estimateCostOneLevel(n.getFirstChild());\n    } \n    else \n    {\n        return 0;\n    }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    char[] buf = buffer;\n\n    while(start <= end) {\n        char temp = buf[start];\n        buf[start] = buf[end];\n        buf[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char[] buffer = this.buffer;\n    while (left < right) \n    {\n        // Swap characters\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n\n        // Move pointers inward\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char temp;\n    while (left < right) \n    {\n        temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int from = 0;\n    int to = size - 1;\n    while (from < to) \n    {\n        char temp = buffer[from];\n        buffer[from] = buffer[to];\n        buffer[to] = temp;\n        from++;\n        to--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int from = 0;\n    int to = size - 1;\n    while (from < to)\n    {\n        char temp = buffer[from];\n        buffer[from] = buffer[to];\n        buffer[to] = temp;\n        from++;\n        to--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int from = 0;\n    int to = size - 1;\n    while (from < to) \n    {\n        char temp = buffer[from];\n        buffer[from] = buffer[to];\n        buffer[to] = temp;\n        from++;\n        to--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n    \n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    \n    return this;\n}",
      "public StrBuilder reverse()  {\n    int start = 0;\n    int end = size - 1;\n\n    while (start < end)\n    {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n\n        start++;\n        end--;\n    }\n\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Illegal offset: %d\", offset);\n    Validate.isTrue(offset <= value.length(), \"Illegal offset: %d for length %d\", offset, value.length());\n\n    String leftText = value.substring(0, offset);\n    String rightText = value.substring(offset);\n\n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n\n    parentNode.insertBefore(rightNode, this.nextSibling);\n\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Illegal offset: %d\", offset);\n    Validate.isTrue(offset <= value.length(), \"Offset too large: %d\", offset);\n\n    TextNode newTextNode = new TextNode(value.substring(offset));\n    parentNode.insertBefore(this, newTextNode);\n    parentNode.removeChild(this);\n\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Cannot split text node before offset 0\");\n    String text = getWholeText();\n\n    if (offset >= text.length()) {\n        return this;\n    }\n\n    String prefix = text.substring(0, offset);\n    String suffix = text.substring(offset);\n    TextNode newTextNode = new TextNode(suffix);\n    insertBefore(newTextNode);\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be non-negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must be less than or equal to the length of the text\");\n\n    String before = value.substring(0, offset);\n    String after = value.substring(offset);\n\n    TextNode newTextNode = new TextNode(after);\n    parentNode.insertBefore(this, newTextNode);\n\n    text(before);\n\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be non-negative\");\n    String text = getWholeText();\n    if (offset >= text.length()) {\n        return this;\n    }\n    TextNode newTextNode = new TextNode(text.substring(offset));\n    parentNode.insertBefore(newTextNode, getSiblingIndex() + 1);\n    coreValue(text.substring(0, offset));\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and the length of the text node\");\n    String before = value.substring(0, offset);\n    String after = value.substring(offset);\n    TextNode afterNode = new TextNode(after);\n    insertChildren(afterNode); // insert new node as a sibling\n    this.text(before); // update current node with text before the split point\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Illegal offset: \" + offset);\n\n    TextNode textNode = new TextNode(value.substring(offset));\n    parentNode.insertBefore(this, textNode);\n\n    coreValue(value.substring(0, offset));\n    return textNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"offset out of bounds\");\n    String leftText = value.substring(0, offset);\n    String rightText = value.substring(offset);\n\n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n\n    parentNode.insertBefore(nextSibling, rightNode);\n    parentNode.removeChild(this);\n\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"offset out of bounds\");\n    String leftText = value.substring(0, offset);\n    String rightText = value.substring(offset);\n\n    TextNode rightNode = new TextNode(rightText);\n    parentNode.insertBefore(rightNode, this.nextSibling);\n\n    value = leftText;\n\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and the length of the string\");\n    String beforeText = value.substring(0, offset);\n    String afterText = value.substring(offset);\n    TextNode afterNode = new TextNode(afterText);\n    this.after(afterNode);\n    this.value = beforeText;\n    return afterNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        final int aCount = helper.count(obj, a);\n        final int bCount = helper.count(obj, b);\n        helper.setCardinality(obj, Math.max(aCount, bCount) - Math.min(aCount, bCount));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        final int aCard = helper.cardinality(obj, a);\n        final int bCard = helper.cardinality(obj, b);\n        helper.setCardinality(obj, Math.max(aCard, bCard) - Math.min(aCard, bCard));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        final int aCard = helper.cardinality(obj, a);\n        final int bCard = helper.cardinality(obj, b);\n        helper.setCardinality(obj, Math.max(aCard, bCard) - Math.min(aCard, bCard));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++)\n    {\n        bytes[i] = (byte) (value.shiftRight(i * BYTE_2_SHIFT).longValue() & 0xFF);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n\n    int offset = 0;\n    int numBytesToCopy = Math.min(temp.length, result.length);\n\n    if (temp[0] >= LEFTMOST_BIT) {\n        offset = LEFTMOST_BIT_SHIFT - temp.length + 1;\n        numBytesToCopy = temp.length - offset;\n    }\n\n    System.arraycopy(temp, offset, result, 0, numBytesToCopy);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n\n    final long longValue = value.longValue();\n\n    if (longValue >= 0) {\n        bytes[BYTE_7] = (byte) (longValue >>> BYTE_7_SHIFT);\n        bytes[BYTE_6] = (byte) (longValue >>> BYTE_6_SHIFT);\n        bytes[BYTE_5] = (byte) (longValue >>> BYTE_5_SHIFT);\n        bytes[BYTE_4] = (byte) (longValue >>> BYTE_4_SHIFT);\n        bytes[BYTE_3] = (byte) (longValue >>> BYTE_3_SHIFT);\n        bytes[BYTE_2] = (byte) (longValue >>> BYTE_2_SHIFT);\n        bytes[BYTE_1] = (byte) longValue;\n    } else {\n        bytes[BYTE_7] = LEFTMOST_BIT;\n\n        final long leftOver = longValue + 1L << LEFTMOST_BIT_SHIFT;\n        bytes[BYTE_6] = (byte) (leftOver >>> BYTE_6_SHIFT);\n        bytes[BYTE_5] = (byte) (leftOver >>> BYTE_5_SHIFT);\n        bytes[BYTE_4] = (byte) (leftOver >>> BYTE_4_SHIFT);\n        bytes[BYTE_3] = (byte) (leftOver >>> BYTE_3_SHIFT);\n        bytes[BYTE_2] = (byte) (leftOver >>> BYTE_2_SHIFT);\n        bytes[BYTE_1] = (byte) leftOver;\n    }\n\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    final long longValue = value.longValue();\n\n    bytes[BYTE_7] = (byte) ((longValue >>> BYTE_7_SHIFT) & 0xFF);\n    bytes[BYTE_6] = (byte) ((longValue >>> BYTE_6_SHIFT) & 0xFF);\n    bytes[BYTE_5] = (byte) ((longValue >>> BYTE_5_SHIFT) & 0xFF);\n    bytes[BYTE_4] = (byte) ((longValue >>> BYTE_4_SHIFT) & 0xFF);\n    bytes[BYTE_3] = (byte) ((longValue >>> BYTE_3_SHIFT) & 0xFF);\n    bytes[BYTE_2] = (byte) ((longValue >>> BYTE_2_SHIFT) & 0xFF);\n    bytes[BYTE_1] = (byte) ((longValue >>> 0) & 0xFF);\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    long valLong = value.longValue();\n\n    bytes[BYTE_7] = (byte) valLong;\n    bytes[BYTE_6] = (byte) (valLong >>> BYTE_6_SHIFT);\n    bytes[BYTE_5] = (byte) (valLong >>> BYTE_5_SHIFT);\n    bytes[BYTE_4] = (byte) (valLong >>> BYTE_4_SHIFT);\n    bytes[BYTE_3] = (byte) (valLong >>> BYTE_3_SHIFT);\n    bytes[BYTE_2] = (byte) (valLong >>> BYTE_2_SHIFT);\n    bytes[BYTE_1] = (byte) valLong;\n\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n        value.subtract(BigInteger.ONE);\n    }\n\n    for (int i = 0; i < result.length; i++) {\n        result[result.length - i - 1] = (byte) value.shiftRight(i * BYTE_2_SHIFT).intValue();\n    }\n\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0)\n    {\n        bytes[BYTE_7] = LEFTMOST_BIT;\n    }\n\n    bytes[BYTE_6] = (byte) (value.shiftRight(BYTE_6_SHIFT).intValue() & 0xFF);\n    bytes[BYTE_5] = (byte) (value.shiftRight(BYTE_5_SHIFT).intValue() & 0xFF);\n    bytes[BYTE_4] = (byte) (value.shiftRight(BYTE_4_SHIFT).intValue() & 0xFF);\n    bytes[BYTE_3] = (byte) (value.shiftRight(BYTE_3_SHIFT).intValue() & 0xFF);\n    bytes[BYTE_2] = (byte) (value.shiftRight(BYTE_2_SHIFT).intValue() & 0xFF);\n    bytes[BYTE_1] = (byte) (value.intValue() & 0xFF);\n\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) \n    {\n        result[BYTE_7] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) \n    {\n        result[BYTE_6] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Integer.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Short.MAX_VALUE)) > 0) \n    {\n        result[BYTE_5] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Short.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) > 0) \n    {\n        result[BYTE_4] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Byte.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) > 0) \n    {\n        result[BYTE_3] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Byte.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) > 0) \n    {\n        result[BYTE_2] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Byte.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    if (value.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) > 0) \n    {\n        result[BYTE_1] = LEFTMOST_BIT;\n        value = value.subtract(BigInteger.valueOf(Byte.MAX_VALUE).add(BigInteger.ONE));\n    }\n\n    result[BYTE_1] += (byte) value.intValue();\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bigEndianValue = value.toByteArray();\n    final int shift = bigEndianValue.length - 8;\n    for (int i = 0; i < 8; i++) \n    {\n        if (i < bigEndianValue.length) \n        {\n            result[i] = bigEndianValue[i + shift];\n        } else \n        {\n            result[i] = 0;\n        }\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] bytes = new byte[8];\n    if (value.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n        long longValue = value.longValue();\n        bytes[BYTE_7] = (byte) ((longValue >> BYTE_7_SHIFT) & 0xFF);\n        bytes[BYTE_6] = (byte) ((longValue >> BYTE_6_SHIFT) & 0xFF);\n        bytes[BYTE_5] = (byte) ((longValue >> BYTE_5_SHIFT) & 0xFF);\n        bytes[BYTE_4] = (byte) ((longValue >> BYTE_4_SHIFT) & 0xFF);\n        bytes[BYTE_3] = (byte) ((longValue >> BYTE_3_SHIFT) & 0xFF);\n        bytes[BYTE_2] = (byte) ((longValue >> BYTE_2_SHIFT) & 0xFF);\n        bytes[BYTE_1] = (byte) ((longValue >> 0) & 0xFF);\n        return bytes;\n    }\n\n    final byte[] bigIntegerBytes = value.toByteArray();\n    for (int i = 0; i < bigIntegerBytes.length; i++) {\n        bytes[i] = bigIntegerBytes[bigIntegerBytes.length - i - 1];\n    }\n\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (final char ch : str.toCharArray()) {\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return \"\";\n    }\n    final StringBuilder buffer = new StringBuilder();\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char ch : str.toCharArray()) \n    {\n        if (chars.contains(ch)) \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (final char ch : str.toCharArray()) \n    {\n        if (chars.contains(ch)) \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return \"\";\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) \n        {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    StringBuilder buffer = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n\n    // Create a new RealMatrix object to store the square root\n    RealMatrix squareRoot = new Array2DRowRealMatrix(matrix.length, matrix.length);\n\n    // Compute the square root using the eigenvalue decomposition\n    for (int i = 0; i < matrix.length; i++) {\n        double sqrtValue = Math.sqrt(realEigenvalues[i]);\n        squareRoot.setEntry(i, i, sqrtValue);\n    }\n\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n        RealMatrix squareRoot = new Array2DRowRealMatrix(realEigenvalues.length, realEigenvalues.length);\n        for (int i = 0; i < realEigenvalues.length; i++) \n        {\n            squareRoot.setEntry(i, i, Math.sqrt(realEigenvalues[i]));\n        }\n        return squareRoot;\n    }",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric\");\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be positive definite\");\n    }\n\n    // Compute the square-root of the matrix using the Cholesky decomposition\n    RealMatrix choleskyDecomposition = getCholeskyDecomposition();\n    return choleskyDecomposition.getSolver().getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    // Create a new matrix to store the square root\n    RealMatrix squareRoot = new Array2DRowRealMatrix(eigenvectors.length, eigenvectors[0].getDimension());\n    // Calculate the square root of each eigenvalue and store it in the new matrix\n    for (int i = 0; i < eigenvectors.length; i++) {\n        squareRoot.setRowVector(i, eigenvectors[i].copy().scalarMultiply(Math.sqrt(realEigenvalues[i])));\n    }\n    // Return the square root matrix\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n        RealMatrix squareRootMatrix = new Array2DRowRealMatrix(eigenvectors[0].getData().length, eigenvectors[0].getData().length);\n\n        for (int i = 0; i < eigenvectors.length; i++)\n        {\n            RealVector eigenvector = eigenvectors[i];\n            for (int j = 0; j < eigenvectors.length; j++)\n            {\n                RealVector otherEigenvector = eigenvectors[j];\n                double realEigenvalue = realEigenvalues[i];\n\n                if (i == j) \n                {\n                    squareRootMatrix.setEntry(i, j, Math.sqrt(realEigenvalue));\n                }\n                else \n                {\n                    double realPart = (realEigenvalue - realEigenvalues[j]) / 2.0;\n                    double imagPart = (imagEigenvalues[i] + imagEigenvalues[j]) / 2.0;\n\n                    if (Math.abs(imagPart) < 1.0e-12)\n                    {\n                        squareRootMatrix.setEntry(i, j, Math.sqrt(realPart));\n                    }\n                    else\n                    {\n                        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n                    }\n                }\n            }\n        }\n\n        return squareRootMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric\");\n    }\n\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) \n    {\n        throw new MathUnsupportedOperationException(\"Matrix must be positive definite\");\n    }\n\n    // Compute the square-root of the matrix using the Cholesky decomposition\n    RealMatrix squareRoot = new Array2DRowRealMatrix(data.length, data.length);\n    for (int i = 0; i < data.length; i++) \n    {\n        for (int j = 0; j <= i; j++) \n        {\n            double sum = 0;\n            for (int k = 0; k < j; k++) \n            {\n                sum += squareRoot.getEntry(i, k) * squareRoot.getEntry(j, k);\n            }\n            if (i == j) \n            {\n                squareRoot.setEntry(i, j, Math.sqrt(data[i][i] - sum));\n            } \n            else \n            {\n                squareRoot.setEntry(i, j, (1 / squareRoot.getEntry(j, j)) * (data[i][j] - sum));\n            }\n        }\n    }\n\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n        RealMatrix squareRoot = new Array2DRowRealMatrix(matrix.length, matrix.length);\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix.length; j++) {\n                squareRoot.setEntry(i, j, Math.sqrt(matrix.getEntry(i, j)));\n            }\n        }\n        return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n        if (!isSymmetric() || !isPositiveDefinite())\n        {\n            throw new MathUnsupportedOperationException(\"Matrix must be symmetric and positive definite\");\n        }\n        return getRealEigenvalues().stream().map(Math::sqrt).mapToObj(RealVector::create).collect(Collectors.toList()).toArray(RealMatrix[]::new)[0];\n    }",
      "public RealMatrix getSquareRoot()  {\n        RealMatrix squareRoot = new Array2DRowRealMatrix(matrix.length, matrix.length);\n        for (int i = 0; i < matrix.length; i++)\n        {\n            for (int j = 0; j < matrix.length; j++)\n            {\n                if (i == j)\n                {\n                    squareRoot.setEntry(i, j, Math.sqrt(matrix[i][j]));\n                }\n                else\n                {\n                    squareRoot.setEntry(i, j, 0);\n                }\n            }\n        }\n        return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    // Check if the matrix is symmetric\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    // Check if the matrix is positive definite\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    // Compute the square-root of the matrix using the Cholesky decomposition\n    RealMatrix cholesky = getCholeskyDecomposition().getSolver().getMatrix();\n    // Create a new matrix with the square-root values\n    RealMatrix squareRoot = new Array2DRowRealMatrix(cholesky.getData());\n    return squareRoot;\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = ctxt.readValue(p, t, handledType());\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, t, view);\n            }\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE || t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = ctxt.handleMissingValue(t);\n        if (bean == MissingToken.ACCEPT_EMPTY_STRING) {\n            bean = \"\";\n        }\n        p.setCurrentValue(bean);\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_unwrappedPropertyHandler != null) {\n            return deserializeWithUnwrapped(p, ctxt, bean);\n        }\n        if (_externalTypeIdHandler != null) {\n            return deserializeWithExternalTypeId(p, ctxt, bean);\n        }\n        String propName;\n        if (p.isExpectedStartObjectToken()) {\n            propName = p.nextFieldName();\n            if (propName == null) {\n                return bean;\n            }\n        } else {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n                propName = p.getCurrentName();\n            } else {\n                return bean;\n            }\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        do {\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        } while ((propName = p.nextFieldName()) != null);\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (!t.isValueNull()) {\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n        return deserializeFromVanilla(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (!p.isExpectedStartObjectToken()) {\n            return _missingToken(p, ctxt);\n        }\n\n        Object bean = ctxt.getBeanInstance(handledType(), getObjectId());\n        String propName;\n\n        if (t != null) {\n            p.nextToken();\n        }\n\n        do {\n            propName = p.nextFieldName();\n            if (propName == null) { // end of object\n                break;\n            }\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop == null) { // ignore unknown properties\n                continue;\n            }\n\n            try {\n                prop.deserializeAndSet(p, ctxt, bean);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        } while (true);\n\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (!p.hasTokenId(JsonTokenId.ID_START_OBJECT)) {\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n        Object bean;\n        if (_delegate.canCreateInstance()) {\n            bean = _delegate.createInstance();\n        } else {\n            bean = _factory.constructFromObjectWithoutState(ctxt, _objectIdReader);\n        }\n        if (t.getValueAsString().equals(\"true\")) {\n            _generator.write(bean);\n        }\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromObject(p, ctxt);\n        } else {\n            return deserializeFromNumber(p, ctxt);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        } else if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        } else if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        } else if (t == JsonToken.VALUE_TRUE || t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        } else if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        } else {\n            return ctxt.handleUnexpectedToken(handledType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, t, view);\n            }\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeFromEmbedded(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE || t == JsonToken.VALUE_FALSE) {\n            return deserializeFromBoolean(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            // these only work if there's a (delegating) creator...\n            return deserializeFromArray(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(handledType(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getValueAsString();\n        } else if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getLongValue();\n        } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getDoubleValue();\n        } else if (t == JsonToken.VALUE_NULL) {\n            return null;\n        } else if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        } else if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        } else {\n        \tthrow ctxt.handleUnexpectedToken(t, p);\n        }\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"No data exists to calculate the statistic\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\n                \"Array dimensions are not compatible. First array has length \" +\n                        sample1.length + \" and second array has length \" +\n                        sample2.length);\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // Check if arrays are null or empty\n    if (sample1 == null || sample2 == null || sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Both arrays must be non-null and non-empty\");\n    }\n\n    // Check if arrays have the same length\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Both arrays must have the same length\");\n    }\n\n    // Initialize sum of differences\n    double sum = 0;\n\n    // Iterate through the arrays and calculate differences\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // Check if arrays are empty\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Cannot calculate difference with empty arrays\");\n    }\n\n    // Check if arrays have the same length\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays must have the same length\");\n    }\n\n    // Calculate the sum of differences\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Arrays must have the same length\");\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(\"Arrays cannot be empty\");\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // Check if arrays are null or empty\n    if (sample1 == null || sample2 == null || sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Input arrays cannot be null or empty.\");\n    }\n\n    // Check if arrays have the same length\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\"Input arrays must have the same length.\");\n    }\n\n    // Calculate the sum of paired differences\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\n                \"Array dimensions are not equal\");\n    } else if (sample1.length == 0) {\n        throw new NoDataException(\"Array length is zero\");\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(\n                \"Input arrays must have the same length\");\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException(\"Input arrays must have length > 0\");\n    }\n\n    double sum = 0.0;\n    for (int i=0; i<sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    // Check if arrays have the same length\n    if (sample1.length != sample2.length || sample1.length <= 0) {\n        throw new DimensionMismatchException(\"The input arrays should have the same positive length.\");\n    }\n\n    // Check if arrays are empty\n    if (sample1.length == 0) {\n        throw new NoDataException(\"The input arrays cannot be empty.\");\n    }\n\n    // Calculate the sum of differences\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>();\n            _tail = _head;\n        } else {\n            _tail.next = new LinkedNode<Object[]>();\n            _tail = _tail.next;\n        }\n\n        _tail.data = fullChunk;\n\n        _size += fullChunk.length;\n\n        if (_size >= MAX_CHUNK) {\n            // TODO: Grow array more intelligently\n            Object[] oldArray = fullChunk;\n            fullChunk = new Object[oldArray.length + 128];\n            System.arraycopy(oldArray, 0, fullChunk, 0, oldArray.length);\n        }\n\n        return fullChunk;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>();\n            _tail = _head;\n        } else {\n            _tail = _tail.next = new LinkedNode<Object[]>();\n        }\n        _tail.value = fullChunk;\n        _size += fullChunk.length;\n        if (_freeBuffer == fullChunk) {\n            _freeBuffer = null;\n        }\n        if (_size >= MAX_CHUNK) {\n            return null;\n        } else if (_size >= SMALL_CHUNK) {\n            return new Object[Math.max(12, _size - SMALL_CHUNK)];\n        } else {\n            return new Object[Math.max(12, _size * 2)];\n        }\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer != fullChunk) {\n            _append(fullChunk);\n        } else {\n            _freeBuffer = null;\n        }\n        return resetAndStart();\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Safety check: we must have a valid fullChunk\n        if (fullChunk == null) {\n            throw new IllegalArgumentException(\"fullChunk argument must be non-null\");\n        }\n\n        // Safety check: we must have at least one entry in fullChunk\n        if (fullChunk.length == 0) {\n            throw new IllegalArgumentException(\"fullChunk argument must have a length greater than 0\");\n        }\n\n        // Handle trivial case: no buffering yet\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>();\n            _tail = _head;\n            _head.set(fullChunk, 0);\n            _size = fullChunk.length;\n            return resetAndStart();\n        }\n\n        // Handle case with single entry in buffer: we need to create a new node\n        if (_tail.next == null) {\n            _tail.next = new LinkedNode<Object[]>();\n            _tail = _tail.next;\n            if (_tail.index == _tail.array.length) {\n                _tail.array = doubleCapacity(_tail.array);\n            }\n            _tail.set(fullChunk, 0);\n            _size += fullChunk.length;\n            return resetAndStart();\n        }\n\n        // Handle case with multiple entries in the buffer: we can append to existing node\n        int currentLength = _tail.index;\n        int fullChunkLength = fullChunk.length;\n        if ((currentLength + fullChunkLength) <= _tail.array.length) {\n            System.arraycopy(fullChunk, 0, _tail.array, currentLength, fullChunkLength);\n            _tail.index += fullChunkLength;\n            _size += fullChunkLength;\n            return resetAndStart();\n        }\n\n        // If we reach here, then we need to create a new node\n        _tail.next = new LinkedNode<Object[]>();\n        _tail = _tail.next;\n        if (_tail.index == _tail.array.length) {\n            _tail.array = doubleCapacity(_tail.array);\n        }\n        System.arraycopy(fullChunk, 0, _tail.array, 0, fullChunkLength);\n        _tail.index = fullChunkLength;\n}",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Avoid unnecessary allocations\n        if ((_freeBuffer != null) && (_freeBuffer.length >= fullChunk.length)) {\n            System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n            return _freeBuffer;\n        }\n\n        // Create new buffer and append\n        final int newLength = Math.min(_size + fullChunk.length, MAX_CHUNK);\n        final Object[] result = new Object[newLength];\n\n        // Append previous elements\n        if (_size > 0) {\n            final LinkedNode<Object[]> node = _head;\n            int pos = 0;\n            while (node != null) {\n                System.arraycopy(node.value, pos, result, pos,\n                        Math.min(node.value.length - pos, newLength - pos));\n                pos += node.value.length;\n                node = node.next;\n            }\n        }\n\n        // Append new chunk\n        System.arraycopy(fullChunk, 0, result, _size, fullChunk.length);\n\n        // Update internal state\n        _size = newLength;\n        _tail = new LinkedNode<Object[]>(result, _tail);\n        if (_head == null) {\n            _head = _tail;\n        }\n\n        // Return new buffer for filling\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Optimization: reuse freeBuffer if it is large enough.\n        if (_freeBuffer != null) {\n            if (_freeBuffer.length >= fullChunk.length) {\n                Object[] tmp = _freeBuffer;\n                _freeBuffer = fullChunk;\n                fullChunk = tmp;\n            } else {\n                _freeBuffer = null;\n            }\n        }\n\n        // Optimization: if there is no head or previous node,\n        // simply append to the head.\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>();\n            _tail = _head;\n        } else {\n            if (_tail._next == null) {\n                _tail._next = new LinkedNode<Object[]>();\n                _tail = _tail._next;\n            }\n        }\n\n        // Optimization: if the fullChunk is smaller than the SMALL_CHUNK,\n        // simply add it to the linked list as is.\n        if (fullChunk.length < SMALL_CHUNK) {\n            _tail._next = new LinkedNode<Object[]>();\n            _tail = _tail._next;\n            _tail._item = fullChunk;\n            _size += fullChunk.length;\n            return resetAndStart();\n        }\n\n        // Optimization: if the fullChunk is larger than the MAX_CHUNK,\n        // simply copy it to a new array and add it to the linked list.\n        if (fullChunk.length >= MAX_CHUNK) {\n            Object[] newArray = (Object[]) Array.newInstance(fullChunk.getClass().getComponentType(), fullChunk.length);\n            System.arraycopy(fullChunk, 0, newArray, 0, fullChunk.length);\n            _tail._next = new LinkedNode<Object[]>();\n            _tail = _tail._next;\n            _tail._item = newArray;\n            _size += fullChunk.length;\n            return resetAndStart();\n        }\n\n        // Optimization: if the fullChunk is larger than SMALL_CHUNK but smaller than\n        // MAX_CHUNK, find the optimal split point for the linked list.\n        int splitPoint = 0;\n        for (int i = 0; i < fullChunk.length; i++) {\n            if (i > SMALL_CHUNK) {\n}\n}\n}",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Simply append the chunk to the current buffer\n        return appendCompletedChunk(fullChunk, 0, fullChunk.length);\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_size >= MAX_CHUNK) {\n            throw new IllegalStateException(\"Buffer exceeds maximum size\");\n        }\n        _size += fullChunk.length;\n        if (_tail == null) {\n            _head = _tail = new LinkedNode<Object[]>();\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        if (_freeBuffer != null) {\n            return new Object[Math.min(SMALL_CHUNK, MAX_CHUNK - _size)];\n        } else {\n            return new Object[Math.min(SMALL_CHUNK, MAX_CHUNK - _size)];\n        }\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Validate input\n        if (fullChunk == null || fullChunk.length == 0) {\n            throw new IllegalArgumentException(\"Invalid input array\");\n        }\n\n        // Handle reuse of free buffer\n        if (_freeBuffer != null && _freeBuffer.length >= fullChunk.length) {\n            Object[] result = _freeBuffer;\n            _freeBuffer = null;\n            return result;\n        }\n\n        // Find the correct LinkedNode to append the chunk to\n        LinkedNode<Object[]> node = _head;\n        while (node != null && node.getData().length <= fullChunk.length) {\n            node = node.getNext();\n        }\n\n        // Create a new LinkedNode if necessary\n        if (node == null) {\n            node = new LinkedNode<>(fullChunk, _tail);\n            _tail = node;\n        } else {\n            node.setData(fullChunk);\n        }\n\n        // Update size and return a new buffer\n        _size += fullChunk.length;\n        return new Object[0]; // Returning an empty array indicates that the caller should allocate a new buffer\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Construct a new array to return\n        Object[] result = null;\n\n        // Check if there is anything in the linked list\n        if (_head != null) {\n\n            // Determine the size of the existing linked list\n            int existingSize = 0;\n            LinkedNode<Object[]> current = _head;\n            while (current != null) {\n                existingSize += current.getData().length;\n                current = current.getPrevious();\n            }\n\n            // Calculate the new size of the combined linked list\n            int newSize = existingSize + fullChunk.length;\n\n            // Check if the new size exceeds the maximum chunk size\n            if (newSize <= MAX_CHUNK) {\n\n                // Check if the new size exceeds the current allocated size\n                if (existingSize >= _head.getData().length - SMALL_CHUNK) {\n\n                    // Allocate a new array with double the size of the existing one\n                    result = new Object[_head.getData().length * 2];\n\n                    // Copy the existing elements in reverse order\n                    int j = result.length - 1;\n                    LinkedNode<Object[]> current = _tail;\n                    while (current != null) {\n                        Object[] currentData = current.getData();\n                        System.arraycopy(currentData, 0, result, j - currentData.length, currentData.length);\n                        j -= currentData.length;\n                        current = current.getPrevious();\n                    }\n                } else {\n\n                    // Reuse the existing array\n                    result = _head.getData();\n                }\n\n                // Add the new elements to the beginning of the linked list\n                _head.setData(fullChunk);\n                _head.prepend(result);\n\n            } else {\n\n                // Allocate a new array with the same size as the full chunk\n                result = fullChunk.clone();\n\n                // Add the new element to the linked list\n                _tail.append(result);\n            }\n\n        } else {\n\n            // If the linked list is empty, add the full chunk as the first element\n            _head = new LinkedNode<>(fullChunk);\n            _tail = _head;\n            _size = fullChunk.length;\n            result = fullChunk;\n        }\n\n        // Update the size of the linked list\n        _size += fullChunk.length;\n}"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n    appendPatternTo(buf, pattern, indexRef);\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] {0};\n    String token;\n\n    while ((token = parseToken(pattern, indexRef)) != null) {\n        if (token.isEmpty()) {\n            continue;\n        }\n\n        if (isNumericToken(token)) {\n            buf.append(\"uuuu-MM-dd\");\n        } else {\n            if (token.charAt(0) >= 'a' && token.charAt(0) <= 'z') {\n                token = token.toUpperCase();\n            }\n            buf.append(token);\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(buf.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n\n    char c;\n    int i;\n\n    while (indexRef[0] < pattern.length()) {\n        i = indexRef[0];\n        c = pattern.charAt(i);\n\n        switch (c) {\n        case 'G': // Era (text)\n            buf.append(\"G\");\n            break;\n        case 'y': // Year (number)\n            buf.append(\"yyyy\");\n            break;\n        case 'M': // Month (text and number)\n            if (i + 1 < pattern.length() && pattern.charAt(i + 1) >= '0' && pattern.charAt(i + 1) <= '9') {\n                buf.append(\"MM\");\n            } else {\n                buf.append(\"MMMM\");\n            }\n            break;\n        case 'w': // Week of year (number)\n            buf.append(\"ww\");\n            break;\n        case 'W': // Week of month (number)\n            buf.append(\"W\");\n            break;\n        case 'D': // Day of year (number)\n            buf.append(\"D\");\n            break;\n        case 'F': // Day of week in month (number)\n            buf.append(\"F\");\n            break;\n        case 'd': // Day of month (number)\n            buf.append(\"dd\");\n            break;\n        case 'E': // Day of week (text)\n            buf.append(\"EEEE\");\n            break;\n        case 'e': // Day of week (number)\n            buf.append(\"e\");\n            break;\n        case 'H': // Hour of day (number, 0..23)\n            buf.append(\"HH\");\n            break;\n        case 'k': // Hour of day (1..24)\n            buf.append(\"kk\");\n            break;\n        case 'K': // Hour of day (0..11)\n            buf.append(\"K\");\n            break;\n        case 'h': // Hour of day (number, 1..12)\n            buf.append(\"hh\");\n            break;\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n    appendPatternTo(pattern, buf, indexRef);\n\n    DateTimeFormatter formatter;\n    if (buf.length() == 0) {\n        formatter = DateTimeFormatter.ISO_DATE_TIME;\n    } else {\n        String formatString = buf.toString();\n        if (isNumericToken(formatString)) {\n            formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\");\n        } else {\n            formatter = DateTimeFormatter.ofPattern(formatString);\n        }\n    }\n\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (isNumericToken(token)) {\n            buf.append(\"yyyy-MM-dd'T'HH:mm:ss\");\n        } else {\n            if (token.equals(\"c\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"C\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"x\")) {\n                buf.append(\"w\");\n            } else if (token.equals(\"y\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"Y\")) {\n                buf.append(\"yyyy\");\n            } else if (token.equals(\"d\")) {\n                buf.append(\"d\");\n            } else if (token.equals(\"h\")) {\n                buf.append(\"hh\");\n            } else if (token.equals(\"H\")) {\n                buf.append(\"HH\");\n            } else if (token.equals(\"m\")) {\n                buf.append(\"mm\");\n            } else if (token.equals(\"s\")) {\n                buf.append(\"ss\");\n            } else if (token.equals(\"S\")) {\n                buf.append(\"SSS\");\n            } else if (token.equals(\"e\")) {\n                buf.append(\"E\");\n            } else if (token.equals(\"E\")) {\n                buf.append(\"EEEE\");\n            } else if (token.equals(\"D\")) {\n                buf.append(\"D\");\n            } else if (token.equals(\"F\")) {\n                buf.append(\"F\");\n            } else if (token.equals(\"w\")) {\n                buf.append(\"w\");\n            } else if (token.equals(\"W\")) {\n                buf.append(\"W\");\n            } else if (token.equals(\"k\")) {\n                buf.append(\"k\");\n            } else if (token.equals(\"K\")) {\n                buf.append(\"K\");\n            } else if (token.equals(\"M\")) {\n                buf.append(\"M\");\n            }\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] {0};\n    StringBuilder patternBuf = new StringBuilder();\n    boolean inLiteral = false;\n\n    int i = indexRef[0];\n    int length = pattern.length();\n\n    char c = pattern.charAt(i);\n    while (i < length) {\n        if (inLiteral) {\n            patternBuf.append(c);\n        } else if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            patternBuf.append(c);\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    patternBuf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            if (c == '\\'') {\n                if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                    // '' is treated as escaped '\n                    patternBuf.append('\\'');\n                    i++;\n                } else {\n                    inLiteral = !inLiteral;\n                }\n            } else {\n                patternBuf.append(c);\n            }\n        }\n        i++;\n    }\n\n    indexRef[0] = i;\n    pattern = patternBuf.toString();\n\n    DateTimeFormatter formatter = null;\n    String token = parseToken(pattern, indexRef);\n\n    while (indexRef[0] < pattern.length()) {\n        if (isNumericToken(token)) {\n            if (pattern.charAt(indexRef[0]) == 'c' ||\n                pattern.charAt(indexRef[0]) == 'C') {\n                formatter = DateTimeFormatter.ISO_WEEK_DATE;\n            } else {\n                formatter = DateTimeFormatter.ISO_LOCAL_DATE;\n            }\n        } else {\n            formatter = DateTimeFormatter.ISO_LOCAL_DATE;\n        }\n\n        while (indexRef[0] < pattern.length() && pattern.charAt(indexRef[0]) == 'T') {\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] {0};\n    String token = null;\n\n    while (indexRef[0] < pattern.length()) {\n        token = parseToken(pattern, indexRef);\n\n        if (token == null) {\n            break;\n        }\n\n        if (isNumericToken(token)) {\n            buf.append(token);\n        } else {\n            switch (token) {\n            case \"G\": // era (text)\n                buf.append(\"G\");\n                break;\n            case \"y\": // year (number)\n            case \"M\": // month of year (text and number)\n            case \"d\": // day of month (number)\n            case \"h\": // hour of day (number, 1..12)\n            case \"H\": // hour of day (number, 0..23)\n            case \"m\": // minute of hour (number)\n            case \"s\": // second of minute (number)\n            case \"S\": // fraction of second (number)\n            case \"E\": // day of week (text)\n            case \"c\": // century (number)\n            case \"k\": // hour of day (1..24)\n            case \"K\": // hour of day (0..11)\n                buf.append(token);\n                break;\n            case \"C\": // century of era (number)\n                buf.append(\"y\");\n                break;\n            case \"x\": // weekyear (number)\n                buf.append(\"w\");\n                break;\n            case \"Y\": // year of era (number)\n                buf.append(\"y\");\n                break;\n            case \"D\": // day of year (number)\n                buf.append(\"d\");\n                break;\n            case \"F\": // day of week in month (number)\n                buf.append(\"E\");\n                break;\n            case \"w\": // week of year (number)\n                buf.append(\"w\");\n                break;\n            case \"W\": // week of month (number)\n                buf.append(\"W\");\n                break;\n            case \"a\": // am/pm marker (text)\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] {0};\n    StringBuilder formatPattern = new StringBuilder();\n    String token;\n\n    while (indexRef[0] < pattern.length()) {\n        token = parseToken(pattern, indexRef);\n\n        if (isNumericToken(token)) {\n            formatPattern.append(\"yyyy-MM-dd\");\n            if (token.equals(\"c\") || token.equals(\"C\") || token.equals(\"y\") || token.equals(\"Y\")) {\n                formatPattern.append(\"-\");\n            }\n        } else {\n            formatPattern.append(\"['\").append(token).append(\"']\");\n        }\n    }\n\n    return DateTimeFormatter.ofPattern(formatPattern.toString());\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n\n    boolean inLiteral = false;\n    boolean inQuoteLiteral = false;\n    boolean inToken = false;\n    boolean inYear = false;\n    boolean inMonth = false;\n    boolean inDay = false;\n    boolean inHour = false;\n    boolean inMinute = false;\n    boolean inSecond = false;\n    boolean inMillis = false;\n    boolean inTimeZone = false;\n    boolean firstTokenInYear = false;\n    boolean firstTokenInMonth = false;\n    boolean firstTokenInDay = false;\n    boolean firstTokenInHour = false;\n    boolean firstTokenInMinute = false;\n    boolean firstTokenInSecond = false;\n    boolean firstTokenInMillis = false;\n    boolean firstTokenInTimeZone = false;\n\n    while (indexRef[0] < pattern.length()) {\n        char c = pattern.charAt(indexRef[0]);\n\n        if (c == '\\'') {\n            if (inQuoteLiteral) {\n                inQuoteLiteral = false;\n            } else {\n                inQuoteLiteral = true;\n            }\n        } else if (!inQuoteLiteral) {\n            switch (c) {\n            case 'c': // century (number)\n            case 'C': // century of era (number)\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (inToken) {\n                    String token = parseToken(pattern, indexRef);\n                    if (isNumericToken(token)) {\n                        if (inYear) {\n                            if (firstTokenInYear) {\n                                buf.append(\"yyyy\");\n                                firstTokenInYear = false;\n                            } else {\n                                buf.append(\"yy\");\n                            }\n                        } else if (inMonth) {\n                            if (firstTokenInMonth) {\n                                buf.append(\"MM\");\n                                firstTokenInMonth = false;\n                            } else {\n                                buf.append(\"M\");\n                            }\n                        } else if (inDay) {\n                            if (firstTokenInDay) {\n                                buf.append(\"dd\");\n}\n}\n}\n}\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n    StringBuilder buf = new StringBuilder();\n    int[] indexRef = new int[] { 0 };\n\n    while (indexRef[0] < pattern.length()) {\n        String token = parseToken(pattern, indexRef);\n        if (token.length() == 0) {\n            throw new IllegalArgumentException(\"Empty pattern\");\n        }\n\n        if (isNumericToken(token)) {\n            buf.append(token);\n        } else {\n            switch (token) {\n            case \"c\": // century (number)\n                buf.append(\"yyyy\");\n                break;\n            case \"C\": // century of era (number)\n                buf.append(\"CC\");\n                break;\n            case \"x\": // weekyear (number)\n                buf.append(\"ww\");\n                break;\n            case \"y\": // year (number)\n                buf.append(\"yyyy\");\n                break;\n            case \"Y\": // year of era (number)\n                buf.append(\"uuuu\");\n                break;\n            case \"d\": // day of month (number)\n                buf.append(\"dd\");\n                break;\n            case \"h\": // hour of day (number, 1..12)\n                buf.append(\"hh\");\n                break;\n            case \"H\": // hour of day (number, 0..23)\n                buf.append(\"HH\");\n                break;\n            case \"k\": // hour of day (1..24)\n                buf.append(\"kk\");\n                break;\n            case \"K\": // hour of day (0..11)\n                buf.append(\"KK\");\n                break;\n            case \"m\": // minute of hour (number)\n                buf.append(\"mm\");\n                break;\n            case \"s\": // second of minute (number)\n                buf.append(\"ss\");\n                break;\n            case \"S\": // fraction of second (number)\n                buf.append(\"SSS\");\n                break;\n            case \"e\": // day of week (number)\n                buf.append(\"EE\");\n                break;\n            case \"E\": // day of week (text)\n                buf.append(\"EEEE\");\n                break;\n}\n}\n}\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token)\n    {\n        case JsDocToken.STAR: return newNode(Token.STAR);\n        case JsDocToken.NULL: return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED: return newNode(Token.UNDEFINED);\n        case JsDocToken.IDENTIFIER: return parseTypeName(next());\n        case JsDocToken.LPAREN: return parseFunctionType(token);\n        case JsDocToken.UNION: return parseUnionType(token);\n        case JsDocToken.RECORD: return parseRecordType(token);\n        case JsDocToken.LBRACK: return parseArrayType(token);\n        default: return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.ID) {\n        return parseTypeName(next());\n    } else if (match(JsDocToken.LPAR)) {\n        next();\n        Node params = parseFormalParameterList(token);\n        if (params == null) {\n            return null;\n        }\n        skipEOLs();\n        if (!match(JsDocToken.RPAR)) {\n            return null;\n        }\n        next();\n        Node returnType = parseTypeExpression(token);\n        if (returnType == null) {\n            return null;\n        }\n        return IR.func(params, returnType);\n    } else if (match(JsDocToken.LBRACE)) {\n        next();\n        if (match(JsDocToken.RBRACE)) {\n            next();\n            return IR.record();\n        } else {\n            Node fields = parseRecordFields(token);\n            if (fields == null) {\n                return null;\n            }\n            if (!match(JsDocToken.RBRACE)) {\n                return null;\n            }\n            next();\n            return fields;\n        }\n    } else if (match(JsDocToken.LSQUARE)) {\n        next();\n        Node elementType = parseTypeExpression(token);\n        if (elementType == null) {\n            return null;\n        }\n        if (!match(JsDocToken.RSQUARE)) {\n            return null;\n        }\n        next();\n        return IR.array(elementType);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case JsDocToken.STAR:\n            return newNode(Token.STAR);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case JsDocToken.NAME:\n            return parseTypeName(token);\n        case JsDocToken.LPAREN:\n            return parseFunctionType(token);\n        case JsDocToken.UNION:\n            return parseUnionType(token);\n        case JsDocToken.RECORD:\n            return parseRecordType(token);\n        case JsDocToken.LBRACK:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (match(JsDocToken.NULL)) {\n      next();\n      return newNode(Token.NULL);\n    } else if (match(JsDocToken.UNDEFINED)) {\n      next();\n      return newNode(Token.UNDEFINED);\n    } else {\n      return parseTypeName(token);\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.NAME) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LPAREN) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LS) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LBRACK) {\n    return parseArrayType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (match(JsDocToken.IDENTIFIER)) {\n    Node typeName = parseTypeName(token);\n    return typeName;\n  } else if (match(JsDocToken.LPAREN)) {\n    return parseFunctionType();\n  } else if (match(JsDocToken.LBRACE)) {\n    return parseUnionTypeWithAlternate(token, null);\n  } else if (match(JsDocToken.LBRACK)) {\n    return parseArrayType(token, null);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.ASTERISK) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      next();\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      next();\n      return newNode(Token.UNDEFINED);\n    } else if (match(JsDocToken.IDENTIFIER)) {\n      String name = token.getText();\n      next();\n      if (name.equals(Token.VOID)) {\n        return newNode(Token.VOID);\n      } else if (name.equals(Token.ANY)) {\n        return newNode(Token.ANY);\n      } else {\n        return parseTypeName(name);\n      }\n    } else if (match(JsDocToken.LPAREN)) {\n      return parseFunctionType();\n    } else if (match(JsDocToken.UNION)) {\n      return parseUnionType(next());\n    } else if (match(JsDocToken.LBRACE)) {\n      return parseRecordType(next());\n    } else if (match(JsDocToken.LBRACK)) {\n      return parseArrayType(next());\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n        case JsDocToken.STAR:\n            return newNode(Token.STAR);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case JsDocToken.IDENTIFIER:\n            String name = next().getText().toLowerCase();\n            if (\"string\".equals(name)) {\n                return newNode(Token.STRING);\n            } else if (\"number\".equals(name)) {\n                return newNode(Token.NUMBER);\n            } else if (\"boolean\".equals(name)) {\n                return newNode(Token.BOOLEAN);\n            } else if (\"object\".equals(name)) {\n                return newNode(Token.OBJECT);\n            } else if (\"function\".equals(name)) {\n                return newNode(Token.FUNCTION);\n            } else if (\"symbol\".equals(name)) {\n                return newNode(Token.SYMBOL);\n            } else if (\"bigint\".equals(name)) {\n                return newNode(Token.BIGINT);\n            }\n            return newNode(Token.IDENTIFIER, name);\n        case JsDocToken.LAMBDA:\n            return parseFunctionType(token);\n        case JsDocToken.LT:\n            return parseUnionType(token);\n        case JsDocToken.LBRACE:\n            return parseRecordType(token);\n        case JsDocToken.LSquare:\n            return parseArrayType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token)\n    {\n        case JsDocToken.STAR:\n            return newNode(Token.STAR);\n        case JsDocToken.NULL:\n            return newNode(Token.NULL);\n        case JsDocToken.UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        default:\n            return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.ID) {\n    return parseTypeName(token);\n  } else if (match(JsDocToken.LPAREN)) {\n    return parseFunctionType(token);\n  } else if (match(JsDocToken.UNION)) {\n    return parseUnionType(token);\n  } else if (match(JsDocToken.LBRACE)) {\n    return parseRecordType(token);\n  } else if (match(JsDocToken.LBRACK)) {\n    return parseArrayType(token);\n  }\n  return null;\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n\n  if (stack[stackSize - 1] == NONEMPTY_OBJECT) {\n    newline();\n  } else {\n    skipValue();\n  }\n\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    int context = peek();\n    if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {\n        throw new IllegalStateException(\"name() called in the middle of an array or value\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n\n    writeDeferredName();\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (closed) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n\n  writeDeferredName();\n  this.name = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (closed) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  if (deferredName == null) {\n    deferredName = name;\n  } else {\n    writeDeferredName();\n    out.write(name);\n  }\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    if (inName) {\n        throw new IllegalStateException(\"name() called twice without intervening write()\");\n    }\n\n    writeDeferredName();\n    this.deferredName = name;\n    this.inName = true;\n\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n\n    switch (peek()) {\n        case EMPTY_OBJECT:\n        case NONEMPTY_OBJECT:\n            writeDeferredName();\n            break;\n        case EMPTY_ARRAY:\n        case NONEMPTY_ARRAY:\n            if (stackSize <= 1) {\n                throw new IllegalStateException(\"Nesting problem.\");\n            }\n            replaceTop(VALUE);\n            break;\n        default:\n            throw new IllegalStateException(\"encodeName() called in invalid state\");\n    }\n\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  if (stack[stackSize - 1] == NONEMPTY_ARRAY) {\n    throw new IllegalStateException(\"name() may not be called after beginArray()\");\n  }\n\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n\n  if (stackSize == 0) {\n    deferredName = name;\n    return this;\n  }\n\n  int context = peek();\n  if (context == EMPTY_OBJECT) {\n    newline();\n    indent();\n  } else if (context == NONEMPTY_OBJECT) {\n    out.write(',');\n    newline();\n    indent();\n  } else {\n    throw new IllegalStateException(\"name() cannot be called after endObject()\");\n  }\n\n  writeDeferredName();\n  out.write(escapeString(name));\n  deferredName = null;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n\n    writeDeferredName();\n    if (deferredName != null) {\n        throw new IllegalStateException(\"name() called twice without intervening write()\");\n    }\n    deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range range = findStackedRangeBounds(dataset, new DefaultKeyToGroupMap());\n    if (range == null) {\n        return null;\n    } else {\n        return new Double(range.getLowerBound());\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double minimum = Double.MAX_VALUE;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = Number.valueOf(minimum);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Number result = null;\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double lowest = Double.MAX_VALUE;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < lowest) {\n                        lowest = value;\n                    }\n                }\n            }\n            if (lowest < result.doubleValue()) {\n                result = new Double(lowest);\n            }\n        }\n        if (!hasValidData) {\n            result = null;\n        }\n        return result;\n    }",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tRange result = findStackedRangeBounds(dataset, null);\n\tif (result == null) {\n\t\treturn null;\n\t} else {\n\t\treturn new Double(result.getLowerBound());\n\t}\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = map.getGroupIndex(map.getGroup(\n                dataset.getRowKey(i)));\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = map.getGroupCount();\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                    = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                    = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    if (hasValidData) {\n        for (int j = 0; j < groupCount; j++) {\n            result = Math.min(result, minimum[j]);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tNumber result = null;\n\tint seriesCount = dataset.getRowCount();\n\tfor (int series = 0; series < seriesCount; series++) {\n\t\tNumber value = dataset.getValue(series, 0);\n\t\tif (value != null) {\n\t\t\tresult = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result != null) {\n\t\tdouble minValue = result.doubleValue();\n\t\tfor (int series = 0; series < seriesCount; series++) {\n\t\t\tNumber value = dataset.getValue(series, 0);\n\t\t\tif (value != null) {\n\t\t\t\tdouble valueDouble = value.doubleValue();\n\t\t\t\tif (valueDouble < minValue) {\n\t\t\t\t\tminValue = valueDouble;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = Double.valueOf(minValue);\n\t}\n\treturn result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tNumber result = null;\n\tint categoryCount = dataset.getColumnCount();\n\tfor (int item = 0; item < categoryCount; item++) {\n\t\tdouble minimum = Double.MAX_VALUE;\n\t\tint seriesCount = dataset.getRowCount();\n\t\tfor (int series = 0; series < seriesCount; series++) {\n\t\t\tNumber number = dataset.getValue(series, item);\n\t\t\tif (number != null) {\n\t\t\t\tdouble value = number.doubleValue();\n\t\t\t\tif (value < minimum) {\n\t\t\t\t\tminimum = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (result == null || minimum < result.doubleValue()) {\n\t\t\tresult = new Double(minimum);\n\t\t}\n\t}\n\treturn result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n\tif (dataset == null) {\n\t\tthrow new IllegalArgumentException(\"Null 'dataset' argument.\");\n\t}\n\tNumber result = null;\n\tdouble minimum = Double.MAX_VALUE;\n\t// Assuming that the series in one category are stacked\n\tfor (int item = 0; item < dataset.getColumnCount(); item++) {\n\t\tdouble negative = 0;\n\t\tint seriesCount = dataset.getRowCount();\n\t\tfor (int series = 0; series < seriesCount; series++) {\n\t\t\tNumber number = dataset.getValue(series, item);\n\t\t\tif (number != null) {\n\t\t\t\tdouble value = number.doubleValue();\n\t\t\t\tif (value < 0.0) {\n\t\t\t\t\tnegative = negative + value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminimum = Math.min(minimum, negative);\n\t}\n\tif (minimum != Double.MAX_VALUE) {\n\t\tresult = new Double(minimum);\n\t}\n\treturn result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    // create an array holding the group indices for each series...\n    int[] groupIndex = new int[dataset.getRowCount()];\n    for (int i = 0; i < dataset.getRowCount(); i++) {\n        groupIndex[i] = map.getGroupIndex(map.getGroup(\n                dataset.getRowKey(i)));\n    }\n\n    // minimum and maximum for each group...\n    int groupCount = map.getGroupCount();\n    double[] minimum = new double[groupCount];\n    double[] maximum = new double[groupCount];\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                            = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                            = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum[g] = Math.min(minimum[g], negative[g]);\n            maximum[g] = Math.max(maximum[g], positive[g]);\n        }\n    }\n    if (hasValidData) {\n        for (int j = 0; j < groupCount; j++) {\n            result = Number.min(result, minimum[j]);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    boolean hasValidData = false;\n    Number result = null;\n\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double minimum = Double.MAX_VALUE;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < minimum) {\n                    minimum = value;\n                }\n            }\n        }\n        result = Number.valueOf(minimum);\n    }\n    if (!hasValidData) {\n        return null;\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) \n        {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) \n        {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try \n        {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } \n        catch (final NullPointerException ex) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final Boolean element : array) {\n            if (element == null) {\n                throw new IllegalArgumentException(\"The array must not contain any null elements\");\n            }\n            if (element) {\n                return Boolean.TRUE;\n            }\n        }\n        return Boolean.FALSE;\n    }",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        try {\n            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n        } catch (final NullPointerException ex) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final Boolean element : array) {\n            if (element == null) {\n                throw new IllegalArgumentException(\"The array must not contain any null elements\");\n            }\n            if (element) {\n                return Boolean.TRUE;\n            }\n        }\n        return Boolean.FALSE;\n    }",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final Boolean element : array) {\n            if (element == null) {\n                throw new IllegalArgumentException(\"The array must not contain any null elements\");\n            }\n            if (element) {\n                return Boolean.TRUE;\n            }\n        }\n        return Boolean.FALSE;\n    }",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null)\n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0)\n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try\n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    }\n    catch (final NullPointerException ex)\n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null)\n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0)\n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try\n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    }\n    catch (final NullPointerException ex)\n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final Boolean element : array) {\n            if (element == null) {\n                throw new IllegalArgumentException(\"The array must not contain any null elements\");\n            }\n            if (element) {\n                return Boolean.TRUE;\n            }\n        }\n        return Boolean.FALSE;\n    }",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null)\n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0)\n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array)\n    {\n        if (element == null)\n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n    }\n    try\n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    }\n    catch (final NullPointerException ex)\n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            if (firstWord) {\n                initials.append(ch);\n                firstWord = false;\n            } else {\n                if (delimiters == null || !Character.isWhitespace(buffer[i - 1])) {\n                    initials.append(ch);\n                }\n            }\n        } else if (Character.isTitleCase(ch)) {\n            if (firstWord) {\n                initials.append(ch);\n                firstWord = false;\n            } else {\n                if (delimiters == null || !Character.isWhitespace(buffer[i - 1])) {\n                    initials.append(ch);\n                }\n            }\n        } else if (Character.isLowerCase(ch)) {\n            if (delimiters == null || Character.isWhitespace(buffer[i - 1])) {\n                initials.append(ch);\n            }\n        } else {\n            if (delimiters == null || Character.isWhitespace(ch)) {\n                firstWord = true;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean whitespace = true;\n    StringBuilder initials = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                if (delimiters == null || Arrays.stream(delimiters).anyMatch(ch::equals)) {\n                    initials.append(Character.toUpperCase(ch));\n                    whitespace = false;\n                } else {\n                    initials.append(ch);\n                }\n            } else {\n                initials.append(Character.toUpperCase(ch));\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean whitespace = true;\n    StringBuilder initials = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                if (delimiters == null || delimiterContains(delimiters, ch)) {\n                    initials.append(ch);\n                    whitespace = false;\n                }\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean whitespace = true;\n    StringBuilder initials = new StringBuilder();\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                initials.append(ch);\n                whitespace = false;\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch)\n                    || (delimiters != null && delimiterMatches(ch, delimiters));\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder initials = new StringBuilder();\n\n    boolean whitespace = true;\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            initials.append(Character.toLowerCase(ch));\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            initials.append(Character.toLowerCase(ch));\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace || (delimiters != null && contains(delimiters, ch))) {\n                initials.append(Character.toTitleCase(ch));\n                whitespace = false;\n            } else {\n                initials.append(Character.toUpperCase(ch));\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder initials = new StringBuilder();\n\n    boolean whitespace = true;\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            initials.append(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                initials.append(ch);\n                whitespace = false;\n            }\n        } else if (delimiters == null || delimiters.length == 0 || !Character.isWhitespace(ch)) {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final int length = buffer.length;\n    final StringBuilder sb = new StringBuilder();\n    boolean firstLetter = true;\n    for (int i = 0; i < length; i++) {\n        final char ch = buffer[i];\n        if (Character.isWhitespace(ch)) {\n            firstLetter = true;\n        } else if (delimiters == null || !WordUtils.contains(delimiters, ch)) {\n            if (firstLetter) {\n                sb.append(ch);\n                firstLetter = false;\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        final boolean whitespace = Character.isWhitespace(ch);\n        if (!whitespace) {\n            if (firstWord || (delimiters != null && Arrays.stream(delimiters).anyMatch(d -> d == ch))) {\n                initials.append(Character.toUpperCase(ch));\n                firstWord = false;\n            }\n        } else {\n            firstWord = true;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean first = true;\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = Character.toLowerCase(buffer[i]);\n        if (i > 0 && (delimiters == null || !delimiterCheck(ch, delimiters))) {\n            continue;\n        }\n        if (first || Character.isWhitespace(ch)) {\n            first = false;\n            if (Character.isWhitespace(ch)) {\n                continue;\n            }\n            buffer[i] = Character.toUpperCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n\n    boolean first = true;\n\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n\n        if (first) {\n            buffer[i] = Character.toTitleCase(ch);\n            first = false;\n        }\n        else if (Character.isWhitespace(ch) || (delimiters != null && delimiters.length > 0 && delimiters[0] == ch)) {\n            first = true;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    if (column < 0 || column >= data.getColumnCount()) {\n        throw new IllegalArgumentException(\"Column index out of bounds.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    if (column < 0 || column >= data.getColumnCount()) {\n        throw new IllegalArgumentException(\"Column index out of bounds.\");\n    }\n\n    double total = 0.0;\n    Number value;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        value = data.getValue(row, column);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    if (column < 0 || column >= data.getColumnCount()) {\n        throw new IllegalArgumentException(\"Invalid column index.\");\n    }\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    if (column < 0 || column >= data.getColumnCount()) {\n        throw new IllegalArgumentException(\"Column index out of bounds.\");\n    }\n    double total = 0.0;\n    for (int i = 0; i < data.getRowCount(); i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int i = 0; i < rowCount; i++) {\n        total += data.getValue(i, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    if (column < 0 || column >= data.getColumnCount()) {\n        throw new IllegalArgumentException(\"Column index out of bounds.\");\n    }\n\n    double total = 0;\n    for (int row = 0; row < data.getRowCount(); row++) {\n        total += data.getValue(row, column);\n    }\n\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] split = source.split(\" / \");\n        if(split.length != 2)\n        {\n            throw new MathParseException(\"Improper fraction format\");\n        }\n        BigInteger num = getNumeratorFormat().parse(split[0]).getBigInteger();\n        BigInteger denom = getDenominatorFormat().parse(split[1]).getBigInteger();\n        return new BigFraction(num, denom);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if(source.contains(\".\"))\n        {\n            return new BigFraction(new BigDecimal(source));\n        }\n        else\n        {\n            String[] parts = source.split(\"/\");\n            if (parts.length == 2) {\n                return new BigFraction(new BigInteger(parts[0]), new BigInteger(parts[1]));\n            } else {\n                throw new MathParseException(LocalizedFormats.CANNOT_PARSE_STRING_TO_FRACTION);\n            }\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if(source == null || source.isEmpty()) {\n            throw new MathParseException(source, 0, LocalizedFormats.CANNOT_PARSE_NULL_OR_EMPTY_STRING);\n        } else {\n            int startPos = 0;\n            int endPos = 0;\n            int pos = 0;\n            int numStart = 0;\n            int numEnd = 0;\n            int denStart = 0;\n            int denEnd = 0;\n            final char[] ca = source.toCharArray();\n            final int len = ca.length;\n            boolean foundSlash = false;\n            boolean foundNum = false;\n            boolean foundDen = false;\n            BigInteger num = BigInteger.ZERO;\n            BigInteger den = BigInteger.ONE;\n\n            while(pos < len) {\n                final char ch = ca[pos];\n                if(Character.isWhitespace(ch)) {\n                    pos ++;\n                    continue;\n                }\n                if(numStart == 0 && Character.isDigit(ch)) {\n                    numStart = pos;\n                    foundNum = true;\n                }\n                if(denStart == 0 && ch == '/' && !foundDen) {\n                    denStart = pos + 1;\n                    foundDen = true;\n                    foundSlash = true;\n                }\n                if(denStart != 0 && Character.isDigit(ch)) {\n                    denEnd = pos + 1;\n                }\n                pos ++;\n            }\n            if(!foundNum || (!foundSlash && !foundDen) || !foundDen) {\n                throw new MathParseException(source, pos, LocalizedFormats.CANNOT_PARSE_FRACTION);\n            } else {\n                try {\n                    num = new BigInteger(source.substring(numStart, numEnd));\n                    if(denEnd == len) {\n                        den = BigInteger.ONE;\n                    } else {\n                        den = new BigInteger(source.substring(denStart, denEnd));\n                    }\n                } catch(NumberFormatException nfe) {\n                    throw new MathParseException(source, pos, LocalizedFormats.CANNOT_PARSE_FRACTION);\n                }\n                if(den.compareTo(BigInteger.ZERO) <= 0) {\n}\n}\n}\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if(source.contains(\".\"))\n        {\n            return new BigFraction(source);\n        }\n        else\n        {\n            return new BigFraction(source, 1, source.length());\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] split = source.split(\"/\");\n        if (split.length != 2) {\n            throw new MathParseException(source, 0, source.length(),LocalizedFormats.CANNOT_PARSE_FRACTION_FROM_STRING);\n        }\n        BigFraction numerator = getNumeratorFormat().parse(split[0]);\n        BigFraction denominator = getDenominatorFormat().parse(split[1]);\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] tokens = source.split(\"[/]\");\n        if (tokens.length != 2) {\n            throw new MathParseException(source, 0, 0, LocalizedFormats.FRACTION_PARSE_ERROR);\n        }\n        return new BigFraction(new BigInteger(tokens[0]), new BigInteger(tokens[1]));\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            final int pos = source.indexOf('/');\n            if (pos == -1) {\n                return new BigFraction(new BigInteger(source));\n            } else {\n                return new BigFraction(new BigInteger(source.substring(0, pos)),\n                        new BigInteger(source.substring(pos + 1)));\n            }\n        } catch (NumberFormatException e) {\n            throw new MathParseException(LocalizedFormats.CANNOT_PARSE_FRACTION, e);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        String[] tokens = source.split(\"/\");\n        if (tokens.length != 2) {\n            throw new MathParseException(source, 0, 1, LocalizedFormats.INVALID_FRACTION_STRING);\n        }\n        BigInteger numerator = new BigInteger(tokens[0].trim());\n        BigInteger denominator = new BigInteger(tokens[1].trim());\n        return new BigFraction(numerator, denominator);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        try {\n            return new BigFraction(source);\n        } catch (final NumberFormatException nfe) {\n            throw new MathParseException(source, nfe);\n        }\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        if(source.contains(\".\"))\n        {\n            return new BigFraction(new BigDecimal(source));\n        }\n        else\n        {\n            return new BigFraction(new BigInteger(source),new BigInteger(\"1\"));\n        }\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<>(list);\n\n    if (list.size() != set.size()) {\n        // List contains duplicates, remove them\n        list.retainAll(set);\n    }\n\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    // Remove duplicates from the list\n    Set<E> set = new HashSet<>(list);\n\n    // Create a new ListOrderedSet with the set and the list\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list);\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list.size());\n    List<E> setOrder = new ArrayList<>(list.size());\n    for (E element : list) {\n        if (!set.contains(element)) {\n            set.add(element);\n            setOrder.add(element);\n        }\n    }\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    Set<E> set = new HashSet<>(list); // Use HashSet for set behaviour\n\n    // Remove duplicates from the list\n    list.clear();\n    list.addAll(set);\n\n    // Create a new ListOrderedSet with the set and list\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list.size());\n    for (E element : list) {\n        if (set.add(element)) {\n            setOrder.add(element);\n        }\n    }\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list.size());\n    for (E e : list) \n    {\n        if (set.add(e)) \n        {\n            list.remove(list.indexOf(e));\n        }\n    }\n    return new ListOrderedSet<>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list.size());\n    for (E e : list) \n    {\n        if (set.add(e)) \n        {\n            list.remove(e);\n        }\n    }\n    List<E> setOrder = new ArrayList<>(list.size());\n    for (E e : list) \n    {\n        setOrder.add(e);\n    }\n    return new ListOrderedSet<>(set, setOrder);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<>(list);\n    List<E> setOrder = new ArrayList<>(list.size());\n    for (E element : set) \n    {\n        int index = list.indexOf(element);\n        if (index != -1) \n        {\n            setOrder.add(index, element);\n        }\n    }\n    return new ListOrderedSet<>(set, setOrder);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n        Range result = null;\n        for (CategoryPlot plot : subplots) {\n            Range plotRange = plot.getDataRange(axis);\n            if (result == null) {\n                result = plotRange;\n            } else {\n                result.add(plotRange);\n            }\n        }\n        return result;\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n    Range range = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())\n    {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        if (range == null) \n        {\n            range = plot.getDataRange(axis);\n        } \n        else \n        {\n            Range tmp = plot.getDataRange(axis);\n            if (axis.isVertical()) \n            {\n                if (tmp.getUpperBound() > range.getUpperBound())\n                {\n                    range.setUpperBound(tmp.getUpperBound());\n                }\n                if (tmp.getLowerBound() < range.getLowerBound()) \n                {\n                    range.setLowerBound(tmp.getLowerBound());\n                }\n            } \n            else \n            {\n                if (tmp.getUpperBound() > range.getUpperBound()) \n                {\n                    range.setUpperBound(tmp.getUpperBound());\n                }\n                if (tmp.getLowerBound() < range.getLowerBound())\n                {\n                    range.setLowerBound(tmp.getLowerBound());\n                }\n            }\n        }\n    }\n    \n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\tRange range = axis.getRange();\n\tIterator iterator = this.subplots.iterator();\n\twhile (iterator.hasNext()) {\n\t\tCategoryPlot plot = (CategoryPlot) iterator.next();\n\t\tRange temp = plot.getDataRange(axis);\n\t\tif(temp.getLowerBound() < range.getLowerBound()) {\n\t\t\trange = new Range(temp.getLowerBound(), range.getUpperBound());\n\t\t}\n\t\tif(temp.getUpperBound() > range.getUpperBound()) {\n\t\t\trange = new Range(range.getLowerBound(), temp.getUpperBound());\n\t\t}\n\t}\n\treturn range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == getRangeAxis()) {\n        return getRangeAxis().getRange();\n    } else {\n        Range min = null;\n        Range max = null;\n        for (int i = 0; i < subplots.size(); i++) {\n            CategoryPlot plot = (CategoryPlot) subplots.get(i);\n            Range plotMin = plot.getDataRange(axis);\n            if (plotMin != null && (min == null || plotMin.getLowerBound() < min.getLowerBound())) {\n                min = plotMin;\n            }\n            Range plotMax = plot.getDataRange(axis);\n            if (plotMax != null && (max == null || plotMax.getUpperBound() > max.getUpperBound())) {\n                max = plotMax;\n            }\n        }\n        if (min != null && max != null) {\n            return new Range(min.getLowerBound(), max.getUpperBound());\n        } else {\n            return null;\n        }\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n\tRange result = null;\n\tIterator iterator = this.subplots.iterator();\n\twhile (iterator.hasNext()) {\n\t    CategoryPlot plot = (CategoryPlot) iterator.next();\n\t    Range range = plot.getDataRange(axis);\n\t    if (result == null) {\n\t        result = range;\n\t    } else {\n\t        result = result.combine(range);\n\t    }\n\t}\n\treturn result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n        Range result = null;\n        for (CategoryPlot plot : subplots) {\n            Range plotRange = plot.getDataRange(axis);\n            if (result == null) {\n                result = plotRange;\n            } else {\n                result = result.combine(plotRange);\n            }\n        }\n        return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n        Range result = null;\n        Iterator iterator = subplots.iterator();\n        while (iterator.hasNext())\n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subRange = plot.getDataRange(axis);\n            result = Range.combine(result, subRange);\n        }\n        return result;\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n    Range dataRange = axis.getRange();\n\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range plotRange = plot.getDataRange(axis);\n        if (plotRange.getLowerBound() < dataRange.getLowerBound()) {\n            dataRange = new Range(plotRange.getLowerBound(), dataRange.getUpperBound());\n        }\n        if (plotRange.getUpperBound() > dataRange.getUpperBound()) {\n            dataRange = new Range(dataRange.getLowerBound(), plotRange.getUpperBound());\n        }\n    }\n    return dataRange;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == getRangeAxis()) {\n        return getRangeAxis().getRange();\n    } else {\n        Iterator iterator = this.subplots.iterator();\n        Range result = null;\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subResult = plot.getDataRange(axis);\n            if (result == null) {\n                result = subResult;\n            } else if (!result.equals(subResult)) {\n                result = null;\n                break;\n            }\n        }\n        return result;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null)\n    {\n        throw new IllegalArgumentException(\"Null axis\");\n    }\n    double lowerBound = Double.NaN;\n    double upperBound = Double.NaN;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (!Double.isNaN(range.getLowerBound())) {\n            lowerBound = Math.min(lowerBound, range.getLowerBound());\n        }\n        if (!Double.isNaN(range.getUpperBound())) {\n            upperBound = Math.max(upperBound, range.getUpperBound());\n        }\n    }\n    if (Double.isNaN(lowerBound) || Double.isNaN(upperBound)) {\n        return null;\n    } else {\n        return new Range(lowerBound, upperBound);\n    }\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        return Math.log10(val) + Math.log10(10.0);\n    } else {\n        return Math.log10(val);\n    }\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        return -adjustedLog10(-val);\n    }\n    if (val < 1) {\n        double factor = Math.log(10) / LOG10_VALUE / 8;\n        return factor * (int) (8 * Math.log(val) / LOG10_VALUE) +\n                (Math.log(val) / LOG10_VALUE - factor * (int) (8 * Math.log(val) / LOG10_VALUE));\n    }\n    return Math.log(val) / LOG10_VALUE;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val >= 10) {\n        return Math.log10(val);\n    }\n    return Math.log10(10.0 + (val - 1) / (double) 10);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10.0) {\n        val += Math.log10(1.0 / val);\n    }\n    return -Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        return -adjustedLog10(-val);\n    } else {\n        if (val < 10) {\n            return Math.log10(val) + Math.log10(10.0 / 10);\n        } else {\n            return Math.log10(val);\n        }\n    }\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val >= 10) {\n        return Math.log10(val);\n    }\n    final double factor = (10.0 / val) - 1;\n    return Math.log10(val) + factor * LOG10_VALUE;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        return Math.log10(val) + (1 - val) / val;\n    }\n    return Math.log10(val);\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val >= 10) {\n        return Math.log10(val);\n    }\n    val = Math.log10(val + 1e-10); // adjust for log(0) -> log(1e-10)\n    return val;\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        val = -val;\n    }\n    if (val < 10) {\n        double scale = Math.log(val) / Math.log(10);\n        return scale * LOG10_VALUE;\n    } else {\n        return Math.log10(val);\n    }\n}",
      "public double adjustedLog10(double val)  {\n    if (val < 0) {\n        return -adjustedLog10(-val);\n    } else if (val < 1) {\n        final double scale = Math.min(9.0 / val, 1.0);\n        return Math.log10(val) + Math.log10(scale);\n    } else {\n        return Math.log10(val);\n    }\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  List<DiGraphEdge<Node, ControlFlowGraph.Branch>> edges = cfg.getEdges();\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : edges) \n  {\n    if (edge.getValue() != Branch.ON_EX) \n    {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraph<Node, DiGraphEdge<Node, ControlFlowGraph.Branch>> cfgGraph = cfg.getGraph();\n    DiGraphEdge<Node, ControlFlowGraph.Branch> start = cfgGraph.getEdge(cfg.getEntry(), cfg.getImplicitReturn());\n    return cfgGraph.allPathsSatisfy(start, IS_RETURN);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node implicitReturn = cfg.getImplicitReturn();\n  if (implicitReturn == null) {\n    return false;\n  }\n\n  Node traversalRoot = cfg.getEntry();\n  Queue<Node> worklist = new LinkedList<>();\n  worklist.add(traversalRoot);\n\n  Set<Node> visited = new HashSet<>();\n  visited.add(traversalRoot);\n\n  while (!worklist.isEmpty()) {\n    Node current = worklist.poll();\n\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getSuccessors(current)) {\n      Node successor = edge.getSource().getValue();\n\n      if (!visited.contains(successor)) {\n        if (cfg.isReachable(successor)) {\n          if (successor.equals(implicitReturn)) {\n            return true;\n          } else {\n            worklist.add(successor);\n            visited.add(successor);\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraph<Node, ControlFlowGraph.Branch> graph = cfg.getGraph();\n    Set<Node> reachable = graph.reachableNodes(graph.getEntry(), IS_RETURN);\n    return cfg.getImplicitReturn().equals(reachable);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraph<Node, ControlFlowGraph.Branch> graph = cfg.getGraph();\n    boolean allPathsReturn = true;\n\n    graph.forEachEdge(new AbstractGraphEdgeVisitor<Node, ControlFlowGraph.Branch>() {\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  boolean allPathsReturn = true;\n\n  if (cfg.getEntry().getSuccessors().size() == 1) {\n    Node next = cfg.getEntry().getSuccessors().iterator().next().getTarget();\n\n    if (next.isReturn() || (next.getSuccessors().size() == 1)) {\n      return true;\n    }\n  }\n\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getEdges()) {\n    if (edge.getValue() != Branch.ON_EX && edge.getValue().isConditional()) {\n      Node condition = NodeUtil.getConditionExpression(edge.getSource().getValue());\n\n      if (condition != null) {\n        TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n\n        if (val != TernaryValue.UNKNOWN) {\n          allPathsReturn = val.toBoolean(true) == (Branch.ON_TRUE == edge.getValue());\n        }\n      }\n    }\n  }\n\n  return allPathsReturn;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraph<Node, ControlFlowGraph.Branch> graph = cfg.getGraph();\n    List<DiGraphEdge<Node, ControlFlowGraph.Branch>> incomingEdges =\n        graph.getIncomingEdges(graph.getImplicitReturn());\n    return incomingEdges.stream().allMatch(\n        edge -> edge.getSource().getValue().isReturn()\n    );\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Map<Node, Boolean> visitedNodes = new HashMap<>();\n    List<Node> nodesToVisit = new ArrayList<>();\n    nodesToVisit.add(cfg.getEntry());\n\n    while(!nodesToVisit.isEmpty()) {\n        Node node = nodesToVisit.remove(nodesToVisit.size() - 1);\n        visitedNodes.put(node, true);\n\n        for(DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getIncomingEdges(node)) {\n            Branch branch = edge.getValue();\n\n            if (branch == Branch.ON_EX) {\n                return false;\n            } else if (branch.isConditional()) {\n                Node condition = NodeUtil.getConditionExpression(edge.getSource().getValue());\n                if (condition != null) {\n                    TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n                    if (val != TernaryValue.UNKNOWN) {\n                        if (val.toBoolean(true)) {\n                            nodesToVisit.add(edge.getSource().getValue());\n                        } else {\n                            nodesToVisit.add(edge.getTarget().getValue());\n                        }\n                    } else {\n                        nodesToVisit.add(edge.getSource().getValue());\n                        nodesToVisit.add(edge.getTarget().getValue());\n                    }\n                }\n            } else {\n                nodesToVisit.add(edge.getTarget().getValue());\n            }\n        }\n\n        if (visitedNodes.containsKey(cfg.getImplicitReturn())) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node exit = cfg.getImplicitReturn();\n    if (!cfg.mayHaveSideEffects(entry)) \n    {\n        return true;\n    }\n    if (!cfg.mayHaveSideEffects(exit))\n    {\n        return true;\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Node root = cfg.getEntry();\n  Node implicitReturn = cfg.getImplicitReturn();\n  if (implicitReturn == null) {\n    return false;\n  }\n  return cfg.mayReach(root, implicitReturn);\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0].add(a[1]);\n    if (!x.greaterThan(a.newInstance(\"2\"))) \n    {\n        return split(a[0].log10K());\n    }\n\n    x = x.divide(pow(a.newInstance(10000), x.log10K()));  /* This puts x in the range 0-10000 */\n    int ix = x.floor().intValue();\n\n    int p2 = 0;\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = split(x);\n\n    spx[0] = a.newInstance(new StringBuilder().append(p2+4*x.log10K()).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    spx[0] = a.newInstance(new StringBuilder().append(4*x.log10K()).toString());\n    spx[1] = a.getZero();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    x[0] = a[0].subtract(a.getTwo());\n    x[1] = a[1];\n\n    int p2 = -1;\n    if (x[0].greaterThan(a.getZero()))\n    {\n        lr = x[0].log10K();\n\n        x[0] = x[0].divide(pow(a.newInstance(10000), lr));  /* This puts x in the range 0-10000 */\n        ix = x[0].floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n\n        Dfp[] spx = split(x);\n        Dfp[] spy = new Dfp[2];\n        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        Dfp[] spz = logInternal(spx);\n\n        spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a.clone();\n    Dfp[] spy = new Dfp[2];\n\n    double p2 = 0;\n    int ix = (int) spx[0].floor().intValue();\n\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n\n    spx[0] = spx[0].divide(pow(a.newInstance(10000), ix));  /* This puts x in the range 0-10000 */\n\n    Dfp[] spz = split(spx);\n\n    spx[0] = a.newInstance(new StringBuilder().append(p2+4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    return a.newInstance(spz[0].add(spz[1]));\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x = a[0], y = a[1];\n        Dfp[] spx, spy;\n        int ix, p2 = 0;\n        Dfp[] spz = new Dfp[2];\n\n\n        spz[0] = x.log10K();\n\n        x = x.divide(pow(a.newInstance(10000), spz[0]));  /* This puts x in the range 0-10000 */\n        ix = x.floor().intValue();\n\n        while (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n\n        spx = split(x);\n        spy = new Dfp[2];\n        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n        spz[0] = x.log2K();\n\n        spx[0] = a.newInstance(new StringBuilder().append(p2+4*spz[0]).toString());\n        spx[1] = a.getZero();\n        spy = splitMult(a.getField().getLn2Split(), spx);\n\n        spz[0] = spz[0].add(spy[0]);\n        spz[1] = spz[1].add(spy[1]);\n\n        spx[0] = a.newInstance(new StringBuilder().append(4*spz[0]).toString());\n        spx[1] = a.getZero();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] spx = a.clone();\n        Dfp[] spy = new Dfp[2];\n\n        final int k = spx[0].getSign();\n        if (k == 0) {\n            spx[0] = a.getZero();\n            spx[1] = a.getZero();\n            return spx;\n        }\n        if (k == -1) {\n            spx[0] = spx[0].negate();\n        }\n\n        int ix = spx[0].floor().intValue();\n\n        if (ix >= 0x3ff + 26) { /* if x >= 2**26 + 2 */\n            ix -= 0x3ff + 26;\n            p2 += 26;\n            spx[0] = spx[0].subtract(new Dfp(0x3ff + 26));\n        } else if (ix <= -0x3ff - 26) { /* if x <= -2**26 - 2 */\n            ix += 0x3ff + 26;\n            p2 -= 26;\n            spx[0] = spx[0].add(new Dfp(0x3ff + 26));\n        }\n\n        if (ix > 2) {\n            ix >>= 1;\n            p2++;\n        }\n\n\n        spy[0] = pow(a.getTwo(), p2);          // use spy[0] temporarily as a divisor\n        spx[0] = spx[0].divide(spy[0]);\n        spx[1] = spx[1].divide(spy[0]);\n\n        spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n        while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n            spx[0] = spx[0].divide(2);\n            spx[1] = spx[1].divide(2);\n            p2++;\n        }\n\n        // X is now in the range of 2/3 < x < 4/3\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x = a[0];\n    final Dfp y = a[1];\n\n    final Dfp[] spx = split(x);\n    final Dfp[] spy = split(y);\n    final int ix = spx[0].floor().intValue();\n    final int iy = spy[0].floor().intValue();\n\n    final int p2 = (ix+iy-2)>>>1;\n    final int p1 = ix+iy-2-2*p2;\n\n    spx[0] = spx[0].shiftLeft(p2);\n    spx[1] = spx[1].shiftLeft(p2);\n\n    spy[0] = spy[0].shiftLeft(p2);\n    spy[1] = spy[1].shiftLeft(p2);\n\n    Dfp[] spz = new Dfp[2];\n\n    spz[0] = spx[0].add(spy[0]);\n    spz[1] = spx[1].add(spy[1]);\n\n    spz = splitAdd(a.getField().getLn2Split(), spz);\n    spz = splitAdd(a.getField().getLn5Split(), spz);\n\n    spz[0] = spz[0].shiftRight(p1);\n    spz[1] = spz[1].shiftRight(p1);\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x = new Dfp(\"0.5\");\n    final Dfp[] spx = split(x);\n    final Dfp[] spy = new Dfp[2];\n\n    spy[0] = a.newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n\n    spx[0] = a.newInstance(new StringBuilder().append(4*lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a.clone();\n    Dfp[] spy = new Dfp[2];\n\n    spx[0] = spx[0].add(spx[0]);\n    spx[0] = spx[0].add(spx[0]);\n    spx[0] = spx[0].add(spx[0]);\n    spx[0] = spx[0].add(spx[0]);\n\n    spy[0] = a.newInstance(\"0.5\");\n    spy[1] = a.getZero();\n    spx = splitMult(spy, spx);\n\n    spx[0] = spx[0].subtract(spx[0]);\n    spx[0] = spx[0].subtract(spx[0]);\n    spx[0] = spx[0].subtract(spx[0]);\n\n    spy[0] = a.newInstance(\"0.25\");\n    spy[1] = a.getZero();\n    spx = splitMult(spy, spx);\n\n    spy[0] = a.newInstance(\"0.125\");\n    spy[1] = a.getZero();\n    spx = splitMult(spy, spx);\n\n    return spx;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a.clone();\n    Dfp[] spy = new Dfp[2];\n    int p2 = 0;\n\n    // X is now in the range of 2/3 < x < 4/3\n    spx[0] = spx[0].subtract(a.newInstance(new StringBuilder().append(4).toString()));\n    spx[0] = spx[0].divide(a.newInstance(new StringBuilder().append(3).toString()));\n\n    // Split into 2 parts, so we can use the series\n    spy[0] = a.newInstance(new StringBuilder().append(3).toString());\n    spy[1] = a.newInstance(new StringBuilder().append(5).toString());\n\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].multiply(spy[0]);\n    spz[1] = spx[1].multiply(spy[0]);\n\n    for (int i=1; ; i++) {\n        spy[0] = spy[0].add(a.newInstance(new StringBuilder().append(2).toString()));\n        spz[0] = spz[0].add(spx[0]);\n        spz[1] = spz[1].add(spx[1]);\n\n        if (spz[1].greaterThanOrEqual(a.getHalf())) {\n            spz[0] = spz[0].subtract(a.getHalf());\n            spz[1] = spz[1].subtract(a.getHalf());\n            p2--;\n        }\n\n        if (i >= 10) {\n            break;\n        }\n    }\n\n    spz[0] = spz[0].divide(a.newInstance(new StringBuilder().append(p2+4).toString()));\n    spz[1] = spz[1].divide(a.newInstance(new StringBuilder().append(p2+4).toString()));\n\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = a.clone();\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n\n    // Find p2, the number of times to divide by 2\n    int p2 = 0;\n    for (int ix = spx[0].floor().intValue(); ix > 2; ix >>= 1) {\n        p2++;\n    }\n\n    // Split x into the form 2^p2 * x'\n    spx[0] = spx[0].shiftRight(p2);\n    spx[1] = spx[1].shiftRight(p2);\n\n    // Scale x' to the range 2/3 < x' < 4/3\n    spy[0] = a.newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].shiftRight(1);\n        spx[1] = spx[1].shiftRight(1);\n        p2++;\n    }\n\n    // Calculate log(x')\n    spy = splitMult(a.getField().getLn2Split(), spx);\n    spz[0] = spy[0];\n    spz[1] = spy[1];\n\n    // Adjust for the scaling factor\n    spz[0] = spz[0].add(new Dfp(p2));\n\n    // Calculate the remaining log terms\n    spy = splitMult(a.getField().getLn5Split(), new Dfp[]{new Dfp(4)});\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n\n    // Recombine the log terms and return\n    return spz;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  { \n        Collection<Object> values = decorated().get(key);\n        if (values == null) {\n            return false;\n        }\n        boolean result = values.remove(value);\n        if (result && values.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n    if(key == null || value == null) {\n        return false;\n    }\n    Collection<Object> coll = decorated().get(key);\n    if(coll == null) {\n        return false;\n    }\n    boolean result = coll.remove(value);\n    if(coll.isEmpty()) {\n        decorated().remove(key);\n    }\n    return result;\n}",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  { \n        Collection<Object> values = this.get(key);\n        if (values == null || !values.contains(value)) { \n            return false; \n        } \n        return values.remove(value); \n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  { \n        Collection<Object> values = get(key); \n        if (values == null) \n            return false; \n        return values.remove(value); \n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  { \n        if (!decorated().containsKey(key)) \n        { \n            return false; \n        }\n        \n        Collection<Object> coll = decorated().get(key);\n        boolean removed = coll.remove(value);\n\n        if(coll.size() == 0)\n        {\n            decorated().remove(key);\n        }\n\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  { \n        if (!decorated().containsKey(key)) {\n            return false;\n        }\n        Collection<Object> values = decorated().get(key);\n        for (Object v : values) {\n            if (value.equals(v)) {\n                values.remove(v);\n                if (values.size() == 0) {\n                    decorated().remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n    Collection<Object> values = (Collection<Object>) decorated().get(key);\n    if (values != null && values.remove(value)) {\n        if (values.isEmpty()) {\n            decorated().remove(key);\n        }\n        return true;\n    }\n\n    return false;\n}",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n    if(key == null || value == null) {\n        return false;\n    }\n    Map<K, Object> decoratedMap = decorated();\n    Collection<V> values = (Collection<V>) decoratedMap.get(key);\n    if(values == null || values.size() == 0) {\n        return false;\n    }\n    boolean removeFlag = values.remove(value);\n    if(values.size() == 0) {\n        decoratedMap.remove(key);\n    }\n    return removeFlag;\n}",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n    Collection<Object> coll = get(key);\n    if (coll == null) {\n        return false;\n    }\n    return coll.remove(value);\n}",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if(key==null || value==null)\n        {\n            throw new NullPointerException(\"key and/or value cannot be null\");\n        }\n        if(!map.containsKey(key))\n        {\n            return false;\n        }\n        Collection<V> collection = (Collection<V>) map.get(key);\n        return collection.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(Token.STRING);\n   node.setValue(n.getValue());\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(transformTokenType(n.getType()));\n   for (com.google.javascript.rhino.head.Node child : n) \n   {\n      node.addChildToBack(transform((AstNode) child));\n   }\n   if (node.getType() == Token.NAME) \n   {\n      node = new Token(Token.STRING, node.getValue());\n   }\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(Token.STRING);\n    node.setStringValue(n.getStringValue());\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(Token.STRING);\n   String str = n.getValue();\n   node.setStringValue(str);\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(transformTokenType(n.getType()));\n   for (com.google.javascript.rhino.head.Node child : n) {\n      node.addChildToBack(transform((AstNode) child));\n   }\n   if (node.getType() == Token.NAME) {\n      node.setType(Token.STRING);\n      node.setStringValue(node.getStringValue().quote());\n   }\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (com.google.javascript.rhino.head.Node child : n) {\n        node.addChildToBack(transform((AstNode) child));\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(Token.STRING);\n   node.setValue(n.getValue());\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n   Node node = newNode(transformTokenType(n.getType()));\n   for (com.google.javascript.rhino.head.Node child : n) {\n      node.addChildToBack(transform((AstNode) child));\n   }\n   if (node.getType() == Token.NAME) {\n      node = newNode(Token.STRING);\n      node.setStringValue(n.getStringValue());\n   } else if (node.getType() == Token.STRING) {\n      if (n.getStringValue().length() > 0) {\n         node.setStringValue(n.getStringValue());\n      } else {\n         node.setStringValue(\"\");\n      }\n   }\n   return node;\n}",
      "private Node transformAsString(AstNode n)  {\n\tNode node = newNode(transformTokenType(n.getType()));\n\tfor (com.google.javascript.rhino.head.Node child : n) {\n\t\tnode.addChildToBack(transform((AstNode) child));\n\t}\n\tif (node.getType() == Token.NAME) {\n\t\tnode.setType(Token.STRING);\n\t\tnode.setStringValue(n.getStringValue());\n\t} else if (node.getType() == Token.STRING) {\n\t\tString string = n.getStringValue();\n\t\tif (string.startsWith(\"\\\"\") || string.startsWith(\"'\")) {\n\t\t\tstring = string.substring(1, string.length() - 1);\n\t\t}\n\t\tnode.setStringValue(\"\\\"\" + string + \"\\\"\");\n\t}\n\treturn node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(transformTokenType(n.getType()));\n    for (com.google.javascript.rhino.head.Node child : n) \n    {\n        node.addChildToBack(transform((AstNode) child));\n    }\n    if (node.getType() == Token.NAME) {\n        return newNode(Token.STRING, \"\\\"\" + node.getStringValue() + \"\\\"\");\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset must be specified.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Category key must be specified.\");\n    }\n    List result = new ArrayList();\n\n    double total = 0.0;\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category);\n        if (Double.isNaN(value)) {\n            value = 0;\n        }\n        total += value;\n    }\n\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category);\n        if (Double.isNaN(value)) {\n            value = 0;\n        }\n        result.add(asPercentages ? (value / total) : value);\n    }\n\n    result.add(asPercentages ? (base / total) : base);\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset must be specified.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Category key must be specified.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Included rows must be specified.\");\n    }\n\n    List result = new ArrayList();\n\n    Number value = dataset.getEndValue(category, includedRows[0]);\n    if (value != null) {\n        result.add(value.doubleValue() + base);\n    }\n\n    for (int row = 1; row < includedRows.length; row++) {\n        Number delta = dataset.getEndValue(category, includedRows[row])\n                - dataset.getEndValue(category, includedRows[row - 1]);\n        if (delta != null) {\n            result.add(delta.doubleValue() + result.get(result.size() - 1));\n        }\n    }\n\n    if (asPercentages) {\n        Number total = dataset.getEndValue(category, includedRows[includedRows.length - 1]);\n        if (total != null) {\n            double denom = total.doubleValue();\n            if (denom > 0) {\n                for (int i = 0; i < result.size(); i++) {\n                    result.set(i, result.get(i) / denom);\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    if (dataset == null) {\n        return result;\n    }\n    Comparable rowKey;\n    double total = 0.0;\n    for (int row : includedRows) {\n        rowKey = dataset.getRowKey(row);\n        total += dataset.getValue(rowKey, category);\n    }\n    for (int row : includedRows) {\n        rowKey = dataset.getRowKey(row);\n        double value = dataset.getValue(rowKey, category);\n        if (asPercentages) {\n            result.add(100.0 * (value + base) / total);\n        }\n        else {\n            result.add(value + base);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n\n    if (dataset == null) {\n        return values;\n    }\n\n    Number value = dataset.getEndValue(category, includedRows[0]);\n    values.add(asPercentages ? (value == null ? 0.0 : value.doubleValue() / dataset.getSum(includedRows)) : (value == null ? 0.0 : value.doubleValue()));\n\n    for (int row = 1; row < includedRows.length; row++) {\n        value = dataset.getEndValue(category, includedRows[row]);\n        Number previousValue = dataset.getEndValue(category, includedRows[row - 1]);\n        double previous = (previousValue == null ? 0.0 : previousValue.doubleValue());\n        double current = (value == null ? 0.0 : value.doubleValue());\n        if (asPercentages) {\n            values.add(current / dataset.getSum(includedRows));\n        } else {\n            values.add(current - previous);\n        }\n    }\n\n    values.add(asPercentages ? 1.0 : base);\n\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null || category == null) {\n        throw new IllegalArgumentException(\"Dataset and category must be non-null.\");\n    }\n\n    List result = new ArrayList();\n    result.add(base);\n\n    double total = 0.0;\n\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category);\n        if (Double.isNaN(value) || value == 0) {\n            if (ignoreZeroValues) {\n                continue;\n            }\n        }\n        total += value;\n        result.add(value);\n    }\n\n    if (asPercentages && total != 0) {\n        for (int i = 0; i < result.size(); i++) {\n            result.set(i, ((Number) result.get(i)).doubleValue() / total);\n        }\n    }\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset may not be null\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Category key may not be null\");\n    }\n\n    Number value = dataset.getEndValue(category, includedRows[0]);\n    if (value == null) {\n        return Collections.emptyList();\n    }\n    List result = new ArrayList();\n\n    // add the base value\n    result.add(new Double(base));\n\n    // add the stacked values\n    for (int row : includedRows) {\n        if (row == 0) {\n            continue;\n        }\n        Number nextValue = dataset.getEndValue(category, row);\n        if (nextValue != null) {\n            value = new Double(value.doubleValue() + nextValue.doubleValue());\n            result.add(value);\n        }\n    }\n\n    if (asPercentages) {\n        Number total = dataset.getEndValue(category,\n            DatasetUtilities.calculateRangeBounds(dataset).getUpperBound());\n        if (total != null) {\n            double factor = 100.0 / total.doubleValue();\n            for (int i = 0; i < result.size(); ++i) {\n                result.set(i, new Double(((Number) result.get(i)).doubleValue() * factor));\n            }\n        }\n    }\n\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null || category == null) {\n        throw new IllegalArgumentException(\"Dataset and category must not be null.\");\n    }\n\n    List result = new ArrayList();\n\n    // add base value\n    result.add(new Double(base));\n\n    // calculate stacked values\n    Number previousValue = base;\n    for (int row : includedRows) {\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            previousValue = new Double(value.doubleValue() + previousValue.doubleValue());\n            result.add(previousValue);\n        }\n    }\n\n    // convert to percentages if requested\n    if (asPercentages) {\n        double total = ((Number) result.get(result.size() - 1)).doubleValue();\n        for (int i = result.size() - 1; i >= 0; i--) {\n            result.set(i, new Double(((Number) result.get(i)).doubleValue() / total));\n        }\n    }\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List<Double> list = new ArrayList<>();\n    list.add(base);\n    if (dataset == null || category == null) {\n        return list;\n    }\n\n    Number value = dataset.getValue(category, includedRows[0]);\n    if (value != null) {\n        list.add(value.doubleValue());\n    }\n    for (int i = 1; i < includedRows.length; i++) {\n        value = dataset.getValue(category, includedRows[i]);\n        if (value != null) {\n            list.add(list.get(i) + value.doubleValue());\n        }\n        else {\n            list.add(list.get(i));\n        }\n    }\n    if (asPercentages) {\n        double total = list.get(list.size() - 1);\n        for (int i = 0; i < list.size() - 1; i++) {\n            list.set(i, list.get(i) / total);\n        }\n    }\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List list = new ArrayList();\n    if (dataset == null || category == null) {\n        return list;\n    }\n\n    double total = 0.0;\n    for (int row : includedRows) {\n        total += dataset.getValue(row, category);\n    }\n\n    list.add(base);\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category);\n        if (asPercentages) {\n            list.add((value / total) * 100.0);\n        }\n        else {\n            list.add(value);\n        }\n    }\n\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset may not be null\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Category may not be null\");\n    }\n\n    List list = new ArrayList();\n    list.add(new Double(base));\n\n    Number total = 0;\n    for (int row : includedRows) {\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            total = total == null ? value : new Double(total.doubleValue() + value.doubleValue());\n        }\n    }\n\n    for (int row : includedRows) {\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            list.add(asPercentages ? new Double(value.doubleValue() / total.doubleValue()) : value);\n        }\n    }\n\n    return list;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (childNodesList == null) {\n        childNodesList = new ArrayList<>();\n        for (Node childNode : childNodes()) {\n            if (childNode instanceof Element) {\n                childNodesList.add((Element) childNode);\n            }\n        }\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null)\n    {\n        childNodesList = new ArrayList<>();\n        for (Node node : childNodes())\n        {\n            if (node instanceof Element)\n            {\n                childNodesList.add((Element) node);\n            }\n        }\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null)\n    {\n        childNodesList = new ArrayList<>();\n        for (Node node : childNodes())\n        {\n            if (node instanceof Element)\n            {\n                childNodesList.add((Element) node);\n            }\n        }\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        List<Node> nodeList = new ArrayList<>();\n        for (Node child : nodelist())\n        {\n            if (child instanceof Element)\n            {\n                nodeList.add((Element) child);\n            }\n        }\n        childElements = nodeList;\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        List<Node> nodeList = childNodes();\n        childElements = new ArrayList<>(nodeList.size());\n        for (Node node : nodeList)\n        {\n            if (node instanceof Element) \n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null)\n    {\n        childNodesList = new ArrayList<>();\n        for (int i = 0; i < childNodes().size(); i++) \n        {\n            Node node = childNodes().get(i);\n            if (node instanceof Element)\n                childNodesList.add((Element) node);\n        }\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : nodeList()) \n        {\n            if (node instanceof Element)\n            {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : nodeList) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (childNodesList == null)\n    {\n        childNodesList = new ArrayList<>();\n        for (int i = 0; i < childNodes().size(); i++) \n        {\n            Node childNode = childNodes().get(i);\n            if (childNode instanceof Element)\n            {\n                childNodesList.add((Element) childNode);\n            }\n        }\n    }\n    return childNodesList;\n}",
      "private List<Element> childElementsList()  {\n    if (childElements == null)\n    {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes())\n        {\n            if (node instanceof Element)\n            {\n                childElements.add((Element)node);\n            }\n        }\n    }\n    return childElements;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length - 1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length-1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length - 1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length-1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length - 1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & (buckets.length - 1));\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() & 0x7FFFFFFF) % buckets.length;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k == 0) {\n        return m;\n    }\n    RealMatrix result = m.copy();\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = r + k; c < m.getColumnDimension(); c++) {\n            result.setEntry(r, c, 0);\n        }\n    }\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    int r = 0;\n    int c = 0;\n    while (r < m.getRowDimension())\n    {\n        c = r + k;\n        if (c < m.getColumnDimension())\n        {\n            d[r][c] = m.getEntry(r, c);\n        }\n        r++;\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    int r = 0;\n    for (int c = Math.max(0, k); c < m.getColumnDimension(); c++)\n    {\n        for (int r1 = 0; r1 <= c - k; r1++)\n        {\n            d[r++][c] = m.getEntry(r1, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k == 0) {\n        return m;\n    }\n\n    RealMatrix result = new Array2DRowRealMatrix(m.getRowDimension(), m.getColumnDimension());\n\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = Math.max(0, r - k); c < m.getColumnDimension(); c++) {\n            result.setEntry(r, c, m.getEntry(r, c));\n        }\n    }\n\n    return result;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            for (int c = 0; c < m.getColumnDimension(); c++) \n            {\n                if (r >= c - k) {\n                    d[r][c] = m.getEntry(r, c);\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    int rStart = Math.max(0, k);\n    int rEnd = Math.min(m.getRowDimension(), m.getColumnDimension() - k);\n    int cEnd = Math.min(m.getColumnDimension(), m.getRowDimension() + k);\n    for (int r = rStart; r < rEnd; r++) {\n        for (int c = Math.max(0, r - k); c < cEnd; c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    if (k < 0) {\n        for (int r = 0; r < m.getRowDimension() - Math.abs(k); r++) {\n            for (int c = Math.abs(k); c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension() - k; c++) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = Math.max(0, r-k); c < m.getColumnDimension(); c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    int rStart = Math.max(0, k);\n    for (int r = rStart; r < m.getRowDimension(); r++) {\n        for (int c = Math.max(0, r - k); c < m.getColumnDimension(); c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    if (k == 0) {\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = r; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    if (k > 0) {\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = r + k; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    if (k < 0) {\n        for (int r = 0; r < m.getRowDimension() + k; r++) {\n            for (int c = r; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) \n        {\n            rotateCCW();\n            skew = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } \n        else if (right.skew == Skew.BALANCED) \n        {\n            rotateCCW();\n            skew = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n        }\n        else \n        {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) \n            {\n            case LEFT_HIGH:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return false;\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) \n        {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } \n        else if (right.skew == Skew.BALANCED) \n        {\n            rotateRight();\n            skew      = Skew.RIGHT_HIGH;\n            left.skew = Skew.BALANCED;\n        } \n        else \n        {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) \n            {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return true;\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            right.rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return false;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.RIGHT_HIGH;\n            left.skew = Skew.LEFT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return false;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.RIGHT_HIGH;\n            left.skew = Skew.LEFT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.RIGHT_LOW;\n            left.skew = Skew.BALANCED;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return false;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) \n        {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } \n        else if (right.skew == Skew.BALANCED) \n        {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n        } \n        else \n        {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) \n            {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n        return false;\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return false;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            right.rotateCCW();\n            skew = Skew.BALANCED;\n            right.skew = Skew.BALANCED;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return false;\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n\n    for (int iu = startIdx; iu >= 0; iu--) {\n        final double tNorm = Math.abs(matrixT[iu][iu]) + Math.abs(matrixT[iu][iu - 1]) / 2.0;\n\n        // return the first element that satisfies the condition\n        if (tNorm / norm < 1.0) {\n            return iu;\n        }\n    }\n\n    // no small sub-diagonal element found\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = 0.00000001 * norm;\n    for (int i = startIdx; i < n - 1; i++) {\n        if (FastMath.abs(matrixT[i][i + 1]) <= threshold) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = 0.00000001 * norm;\n    for (int i = startIdx; i >= 0; i--) {\n        for (int j = i - 1; j >= 0; j--) {\n            if (FastMath.abs(matrixT[i][j]) < threshold) {\n                return j;\n            }\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int iu = startIdx; iu >= 0; iu--) {\n        for (int il = iu - 1; il >= 0; il--) {\n            if (FastMath.abs(matrixT[iu][il]) <= norm / 2 / (iu - il + 1)) {\n                return il;\n            }\n        }\n    }\n    return -1; // No small sub-diagonal element found\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double smallest = Double.MAX_VALUE;\n    int idx = startIdx;\n\n    for (int i = startIdx; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < i; j++) {\n            final double absT = FastMath.abs(matrixT[i][j]);\n            if (absT < smallest) {\n                smallest = absT;\n                idx = i;\n            }\n        }\n    }\n\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int iu = startIdx; iu >= 0; iu--) {\n        final double sum = matrixT[iu][iu] + matrixT[iu][iu - 1];\n        if (FastMath.abs(sum) <= 2.0 * NORM_EPSILON * norm) {\n            return iu;\n        }\n    }\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double maxSubDiagonalValue = Double.MAX_VALUE;\n    int maxIdx = startIdx;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        final double subDiagonalValue = matrixT[i][i];\n        if (Math.abs(subDiagonalValue) <= maxSubDiagonalValue && Math.abs(subDiagonalValue / norm) < 1e-14) {\n            maxSubDiagonalValue = subDiagonalValue;\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double minElement = Double.MAX_VALUE;\n    int minIndex = 0;\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (matrixT[i][i] <= minElement) {\n            minElement = matrixT[i][i];\n            minIndex = i;\n        }\n    }\n    if (Math.abs(minElement) > (0.5 / norm)) {\n        return minIndex;\n    } else {\n        return -1;\n    }\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n\n    for (int iu = startIdx; iu >= 0; iu--) {\n        final double t = matrixT[iu][iu];\n        final double s = norm / (FastMath.abs(t) + FAST_MATH_DOUBLE_EPSILON);\n        for (int i = iu + 1; i < n; i++) {\n            matrixT[iu][i] *= s;\n        }\n        if (FastMath.abs(matrixT[iu][iu]) < FAST_MATH_DOUBLE_EPSILON) {\n            return iu;\n        }\n    }\n\n    return -1; // No small sub-diagonal element found\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int iu = startIdx; iu >= 0; iu--) {\n        for (int j = iu - 1; j >= 0; j--) {\n            // Small sub-diagonal element found\n            if (FastMath.abs(matrixT[iu][j]) <= 4.0 * PRECISION * norm / (FastMath.abs(matrixT[iu][iu]) + FastMath.abs(matrixT[j][j]))) {\n                return iu;\n            }\n        }\n    }\n\n    return 0;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    if (top == null || reference.compareTo(top.element) < 0) \n    {\n        return null;\n    }\n    return getNotSmaller(top, reference);\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        int comparison = node.element.compareTo(reference);\n        if (comparison >= 0) {\n            break;\n        } else {\n            node = node.getNext();\n        }\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    Node previous = null;\n    while (current != null)\n    {\n        int comparison = reference.compareTo(current.element);\n        if (comparison > 0)\n        {\n            // reference is bigger than current node, go right\n            previous = current;\n            current = current.right;\n        }\n        else if (comparison < 0)\n        {\n            // reference is smaller than current node, go left\n            current = current.left;\n        }\n        else\n        {\n            // reference is equal to current node, return current\n            return current;\n        }\n    }\n    // No element in the tree is not smaller than reference\n    return previous;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    if (node == null) \n    {\n        return null;\n    }\n    if (reference == null) \n    {\n        return node;\n    }\n    if (reference.compareTo(node.getElement()) < 0) \n    {\n        return null;\n    }\n    while (node.getNext() != null) \n    {\n        if (reference.compareTo(node.getNext().getElement()) < 0) \n        {\n            return node;\n        }\n        node = node.getNext();\n    }\n    return node;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (top == null || reference.compareTo(top.element) < 0)\n        return null;\n    return top.getNotSmaller(reference);\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node result = top;\n\n    if (reference == null)\n    {\n        return null;\n    }\n\n    while (result != null)\n    {\n        int compareToValue = reference.compareTo(result.element);\n        if (compareToValue == 0)\n        {\n            return result;\n        }\n        else if (compareToValue < 0)\n        {\n            if (result.left != null)\n            {\n                result = result.left;\n            }\n            else\n            {\n                return result;\n            }\n        }\n        else\n        {\n            if (result.right != null)\n            {\n                result = result.right;\n            }\n            else\n            {\n                return result;\n            }\n        }\n    }\n\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node current = top;\n    while (current != null) \n    {\n        int comparison = current.element.compareTo(reference);\n        if (comparison == 0) \n        {\n            return current;\n        } else if (comparison < 0) \n        {\n            current = current.getNext();\n        } else \n        {\n            return current;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node result = top;\n    while (result != null) \n    {\n        if (reference.compareTo(result.element) <= 0) \n        {\n            if (result.left != null) \n            {\n                result = result.left;\n            } \n            else \n            {\n                return result;\n            }\n        } \n        else \n        {\n            if (result.right != null) \n            {\n                result = result.right;\n            } \n            else \n            {\n                return result;\n            }\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node result = top;\n    while (result != null) \n    {\n        if (reference == null) \n        {\n            return null;\n        }\n        else if (result.element.compareTo(reference) < 0) \n        {\n            result = result.getNext();\n        }\n        else\n        {\n            return result;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    if (reference != null) {\n        for (Node node = getSmallest(); node != null; node = node.getNext()) \n        {\n            // loop over all elements from smallest to largest\n            if (node.element.compareTo(reference) >= 0) \n            {\n                return node;\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int strLen = str.length();\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(0)) {\n            int j;\n            for (j = 0; j < strLen; j++) {\n                if (i + j >= size || buffer[i + j] != str.charAt(j)) {\n                    break;\n                }\n            }\n            if (j == strLen) {\n                final int start = i;\n                final int len = strLen;\n                deleteImpl(start, start + len, len);\n                i -= len;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n\n    for (int i = 0; i < size; i++) {\n        if (str.charAt(0) == buffer[i]) {\n            final int start = i;\n            boolean found = true;\n            for (int j = 1; j < str.length(); j++) {\n                if (str.charAt(j) != buffer[(i + j) % size]) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) {\n                final int len = str.length();\n                deleteImpl(start, start + len, len);\n                i -= len;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int start = 0;\n    int end = 0;\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(start)) {\n            end++;\n            if (end == str.length()) {\n                deleteImpl(i - str.length() + 1, i + 1, str.length());\n                i -= str.length() - 1;\n                start = 0;\n                end = 0;\n            }\n        } else {\n            if (start < end) {\n                deleteImpl(i, i + 1, 1);\n                i--;\n            }\n            start = 0;\n            end = 0;\n        }\n    }\n    if (start < end) {\n        deleteImpl(size - end, size, end);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int start = 0;\n    int end = 0;\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(start)) {\n            end++;\n            if (end == str.length()) {\n                deleteImpl(i - end + 1, i + 1, end);\n                i -= end - 1;\n                start = 0;\n                end = 0;\n            }\n        } else {\n            if (start != end) {\n                deleteImpl(i - end, i, end);\n                i -= end;\n                start = 0;\n                end = 0;\n            }\n            start = 0;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int start = 0;\n    int end = 0;\n    while (end < size) {\n        while (end < size && buffer[end] == str.charAt(start)) {\n            end++;\n        }\n        if (end - start == str.length()) {\n            deleteImpl(start, end, str.length());\n        } else {\n            start = end;\n            end++;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n\n    int start = 0;\n    int pos = 0;\n    while ((pos = indexOf(str, start)) != -1) {\n        deleteImpl(pos, pos + str.length(), str.length());\n        start = pos;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n\n    final char[] strChars = str.toCharArray();\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == strChars[0]) {\n            int start = i;\n            int j = 1;\n            while (j < strChars.length && i + j < size && buffer[i + j] == strChars[j]) {\n                j++;\n            }\n\n            if (j == strChars.length) {\n                final int len = j;\n                deleteImpl(start, start + len, len);\n                i -= len - 1;\n            }\n        }\n    }\n\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(0)) {\n            int matchIndex = i;\n            for (int j = 0; j < str.length(); j++) {\n                if (matchIndex >= size || buffer[matchIndex] != str.charAt(j)) {\n                    break;\n                }\n                matchIndex++;\n            }\n            if (matchIndex - i == str.length()) {\n                deleteImpl(i, matchIndex, str.length());\n                i -= (matchIndex - i - 1);\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final char[] delete = str.toCharArray();\n\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == delete[0]) {\n            boolean match = true;\n            for (int j = 1; j < delete.length; j++) {\n                if (i + j >= size || buffer[i + j] != delete[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                final int start = i;\n                while (++i < size) {\n                    if (buffer[i] != delete[delete.length - 1]) {\n                        break;\n                    }\n                }\n                final int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int start = 0;\n    int end = 0;\n    for (int i = 0; i < size; i++) {\n        if (buffer[i] == str.charAt(start)) {\n            start++;\n            if (start == str.length()) {\n                end = i + 1;\n                break;\n            }\n        } else {\n            start = 0;\n        }\n    }\n    if (end > start) {\n        deleteImpl(start, end, end - start);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = getJSDocInfo(node);\n  if (info == null) {\n    return null;\n  }\n\n  if (info.hasType()) {\n    boolean valid = false;\n    switch (node.getType()) {\n      // Casts are valid\n      case com.google.javascript.rhino.head.Token.LP:\n        valid = node instanceof ParenthesizedExpression;\n        break;\n      // Variable declarations are valid\n      case com.google.javascript.rhino.head.Token.VAR:\n        valid = true;\n        break;\n      // Function declarations are valid\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        FunctionNode fnNode = (FunctionNode) node;\n        valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n        break;\n      // Object literal properties, catch declarations and variable\n      // initializers are valid.\n      case com.google.javascript.rhino.head.Token.NAME:\n        AstNode parent = node.getParent();\n        valid = parent instanceof ObjectProperty\n            || parent instanceof CatchClause\n            || parent instanceof FunctionNode\n            || (parent instanceof VariableInitializer &&\n                node == ((VariableInitializer) parent).getTarget());\n        break;\n      // Object literal properties are valid\n      case com.google.javascript.rhino.head.Token.GET:\n      case com.google.javascript.rhino.head.Token.SET:\n      case com.google.javascript.rhino.head.Token.NUMBER:\n      case com.google.javascript.rhino.head.Token.STRING:\n        valid = node.getParent() instanceof ObjectProperty;\n        break;\n\n      // Property assignments are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        if (node instanceof Assignment) {\n          valid = isExprStmt(node.getParent())\n              && isPropAccess(((Assignment) node).getLeft());\n        }\n        break;\n\n      // Property definitions are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.GETPROP:\n      case com.google.javascript.rhino.head.Token.GETELEM:\n}\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (info.hasType()) {\n    boolean valid = false;\n    switch (node.getType()) {\n      // Casts are valid\n      case com.google.javascript.rhino.head.Token.LP:\n        valid = node instanceof ParenthesizedExpression;\n        break;\n      // Variable declarations are valid\n      case com.google.javascript.rhino.head.Token.VAR:\n        valid = true;\n        break;\n      // Function declarations are valid\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        FunctionNode fnNode = (FunctionNode) node;\n        valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n        break;\n      // Object literal properties, catch declarations and variable\n      // initializers are valid.\n      case com.google.javascript.rhino.head.Token.NAME:\n        AstNode parent = node.getParent();\n        valid = parent instanceof ObjectProperty\n            || parent instanceof CatchClause\n            || parent instanceof VariableInitializer &&\n                node == ((VariableInitializer) parent).getTarget();\n        break;\n      // Object literal properties are valid\n      case com.google.javascript.rhino.head.Token.GET:\n      case com.google.javascript.rhino.head.Token.SET:\n      case com.google.javascript.rhino.head.Token.NUMBER:\n      case com.google.javascript.rhino.head.Token.STRING:\n        valid = node.getParent() instanceof ObjectProperty;\n        break;\n\n        // Property assignments are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        if (node instanceof Assignment) {\n          valid = isExprStmt(node.getParent())\n              && isPropAccess(((Assignment) node).getLeft());\n        }\n        break;\n\n        // Property definitions are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.GETPROP:\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        valid = isExprStmt(node.getParent());\n        break;\n\n      case com.google.javascript.rhino.head.Token.CALL:\n        valid = info.isDefine();\n        break;\n    }\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = jsDocParser.parse(node);\n  if (info.hasType()) \n  {\n    boolean valid = false;\n    switch (node.getType()) \n    {\n      // Casts are valid\n      case com.google.javascript.rhino.head.Token.LP:\n        valid = node instanceof ParenthesizedExpression;\n        break;\n      // Variable declarations are valid\n      case com.google.javascript.rhino.head.Token.VAR:\n        valid = true;\n        break;\n      // Function declarations are valid\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        FunctionNode fnNode = (FunctionNode) node;\n        valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n        break;\n      // Object literal properties, catch declarations and variable\n      // initializers are valid.\n      case com.google.javascript.rhino.head.Token.NAME:\n        AstNode parent = node.getParent();\n        valid = parent instanceof ObjectProperty\n            || parent instanceof CatchClause\n            || parent instanceof FunctionNode\n            || (parent instanceof VariableInitializer &&\n                node == ((VariableInitializer) parent).getTarget());\n        break;\n      // Object literal properties are valid\n      case com.google.javascript.rhino.head.Token.GET:\n      case com.google.javascript.rhino.head.Token.SET:\n      case com.google.javascript.rhino.head.Token.NUMBER:\n      case com.google.javascript.rhino.head.Token.STRING:\n        valid = node.getParent() instanceof ObjectProperty;\n        break;\n\n      // Property assignments are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        if (node instanceof Assignment) {\n          valid = isExprStmt(node.getParent())\n              && isPropAccess(((Assignment) node).getLeft());\n        }\n        break;\n\n      // Property definitions are valid, if at the root of an expression.\n      case com.google.javascript.rhino.head.Token.GETPROP:\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        valid = isExprStmt(node.getParent());\n        break;\n\n}\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME\n        && (node.getParent() instanceof FunctionNode.Param\n        || node.getParent() instanceof VariableInitializer)) {\n      irNode = maybeInjectVarAnnotation(node, jsDocInfo, irNode);\n    }\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = jsDocParser.parse(node);\n  if (info.hasType()) {\n    boolean valid = false;\n    switch (node.getType()) {\n      // Casts are valid\n      case com.google.javascript.rhino.head.Token.LP:\n        valid = node instanceof ParenthesizedExpression;\n        break;\n      // Variable declarations are valid\n      case com.google.javascript.rhino.head.Token.VAR:\n        valid = true;\n        break;\n      // Function declarations are valid\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        FunctionNode fnNode = (FunctionNode) node;\n        valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n        break;\n      // Object literal properties, catch declarations and variable\n      // initializers are valid.\n      case com.google.javascript.rhino.head.Token.NAME:\n        AstNode parent = node.getParent();\n        valid = parent instanceof ObjectProperty\n            || parent instanceof CatchClause\n            || parent instanceof FunctionNode\n            || (parent instanceof VariableInitializer &&\n                node == ((VariableInitializer) parent).getTarget());\n        break;\n      // Object literal properties are valid\n      case com.google.javascript.rhino.head.Token.GET:\n      case com.google.javascript.rhino.head.Token.SET:\n      case com.google.javascript.rhino.head.Token.NUMBER:\n      case com.google.javascript.rhino.head.Token.STRING:\n        valid = node.getParent() instanceof ObjectProperty;\n        break;\n\n        // Property assignments are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.ASSIGN:\n          if (node instanceof Assignment) {\n            valid = isExprStmt(node.getParent())\n                && isPropAccess(((Assignment) node).getLeft());\n          }\n          break;\n\n        // Property definitions are valid, if at the root of an expression.\n        case com.google.javascript.rhino.head.Token.GETPROP:\n        case com.google.javascript.rhino.head.Token.GETELEM:\n          valid = isExprStmt(node.getParent());\n          break;\n\n}\n}\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (!info.hasType()) {\n    return transform(node);\n  }\n\n  Node irNode = transform(node);\n\n  if (node.getType() == com.google.javascript.rhino.head.Token.VAR\n      || node.getType() == com.google.javascript.rhino.head.Token.PARAM) {\n    irNode = maybeInjectCastNode(node, info, irNode);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo info = getJSDocInfo(node);\n  if (!info.hasType()) {\n    return null;\n  }\n  Node irNode = transform(node);\n  irNode = maybeInjectCastNode(node, info, irNode);\n  irNode.setJSDocInfo(info);\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    final Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<>(new ArrayList<>(list));\n    setUniqueList.set = new HashSet<>(list);\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    SetUniqueList<E> setUniqueList = new SetUniqueList<E>(list, new HashSet<E>());\n    return setUniqueList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    SetUniqueList<E> setList = new SetUniqueList<>(list);\n    return setList;\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"List cannot be null\");\n    }\n    Set<E> set;\n    if (list.size() > 0) {\n        set = new HashSet<>(list);\n    } else {\n        set = new HashSet<>();\n    }\n    return new SetUniqueList<>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    return new SetUniqueList<>(list, new HashSet<>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    return new SetUniqueList<>(list, new HashSet<>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  throws NullPointerException {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    List<E> decorated = list;\n    Set<E> set;\n    if (list instanceof SetUniqueList) {\n        set = ((SetUniqueList<E>) list).set;\n    } else {\n        set = new HashSet<>(list);\n        decorated = new ArrayList<>(set);\n    }\n    return new SetUniqueList<>(decorated, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    // Remove duplicates and create a SetList\n    Set<E> set = new HashSet<>(list);\n    List<E> uniqueList = new ArrayList<>(set);\n\n    // Create and return the SetUniqueList\n    return new SetUniqueList<>(uniqueList, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"list cannot be null\");\n    }\n    SetUniqueList<E> setList = new SetUniqueList<>(new ArrayList<>(list), new HashSet<>(list));\n    return setList;\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  if (!match(JsDocToken.LBRACK)) \n  {\n    return null;\n  }\n  next();\n  Node elementTypeList = parseElementTypeList(null);\n  if (elementTypeList == null) \n  {\n    return null;\n  }\n  if (!match(JsDocToken.RBRACK)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.ls\");\n    }\n\n    skipEOLs();\n    Node elementType = parseElementTypeList(next(), false);\n\n    if (elementType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementtype\");\n    }\n\n    if (!match(JsDocToken.RS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n\n    next();\n    return newNode(Token.ARRAY, elementType);\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  skipEOLs();\n  if (!match(JsDocToken.LBRACK)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n\n  Node elementType = parseTypeExpression(token);\n  if (elementType == null) \n  {\n    return null;\n  }\n\n  boolean isVarArgs = false;\n  if (match(JsDocToken.ELLIPSIS)) \n  {\n    isVarArgs = true;\n    next();\n    skipEOLs();\n    elementType = parseTypeExpression(next());\n    if (elementType == null) \n    {\n      return null;\n    }\n  }\n\n  if (!match(JsDocToken.RBRACK)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  return new ArrayType(elementType, isVarArgs);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LBRACK)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lbracket\");\n    }\n    next();\n\n    List<Node> paramsType = new ArrayList<>();\n\n    while (true) {\n        if (!match(JsDocToken.RBRACK)) {\n            boolean isVarArgs = false;\n            Node paramType = parseTypeExpression(next());\n            if (paramType == null) {\n                return null;\n            }\n            if (match(JsDocToken.ELLIPSIS)) {\n                isVarArgs = true;\n                paramType = new NodeImpl(Token.ELLIPSIS);\n                paramType.addChildToFront(parseTypeExpression(next()));\n            }\n            paramsType.add(paramType);\n            if (isVarArgs) {\n                break;\n            }\n        } else {\n            next();\n            break;\n        }\n    }\n\n    return new NodeImpl(Token.LBRACK, paramsType);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LBRACK)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lbracket\");\n    }\n    next();\n\n    Node elementType = parseTypeExpression(token);\n\n    if (elementType == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementtype\");\n    }\n\n    if (match(JsDocToken.ELLIPSIS)) \n    {\n        next();\n        if (elementType == null) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.elementtype\");\n        }\n        elementType.addChildToBack(new Node(Token.ELLIPSIS));\n    }\n\n    if (!match(JsDocToken.RBRACK)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n    }\n    next();\n\n    return elementType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (!match(JsDocToken.LS)) {\n        return null;\n    }\n    next();\n\n    Node elementTypes = newNode(Token.ARRAY_LIST);\n    boolean isVarArgs = false;\n\n    skipEOLs();\n    while (true) {\n        if (match(JsDocToken.ELLIPSIS)) {\n            isVarArgs = true;\n            next();\n            if (match(JsDocToken.LS)) {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.array.varargs.missing.type\");\n            }\n            break;\n        } else if (match(JsDocToken.LS)) {\n            break;\n        }\n\n        Node paramType = parseTypeExpression(next());\n        if (paramType == null) {\n            return null;\n        }\n\n        elementTypes.addChildToBack(paramType);\n        if (isVarArgs) {\n            break;\n        }\n\n        if (!match(JsDocToken.COMMA)) {\n            break;\n        }\n        next();\n        skipEOLs();\n    }\n\n    if (isVarArgs && match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n    }\n\n    if (!match(JsDocToken.RS)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rs\");\n    }\n    next();\n\n    return new ArrayType(elementTypes, isVarArgs);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LBRACK)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lbracket\");\n    }\n    next();\n\n    Node elementType = null;\n    boolean isVarArgs = false;\n    while (true) \n    {\n        if (elementType != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                if (isVarArgs) \n                {\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs.multiple\");\n                }\n                elementType = newNode(Token.ELLIPSIS);\n                isVarArgs = true;\n            } \n            else \n            {\n                if (!match(JsDocToken.RBRACK)) \n                {\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n                }\n                next();\n                break;\n            }\n        }\n        elementType = parseTypeExpression(token);\n        if (elementType == null) \n        {\n            return null;\n        }\n    }\n    Node arrayType = newNode(Token.LBRACK, elementType, Token.RBRACK);\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (!match(JsDocToken.LBRACK)) {\n    return null;\n  }\n  next();\n  skipEOLs();\n\n  Node elementType = parseTypeExpression(token);\n  if (elementType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.array.element\");\n  }\n\n  boolean isVarArgs = false;\n  if (match(JsDocToken.ELLIPSIS)) {\n    next();\n    isVarArgs = true;\n  }\n\n  if (match(JsDocToken.RBRACK)) {\n    next();\n    return new ArrayType(elementType, isVarArgs);\n  }\n\n  while (match(JsDocToken.COMMA)) {\n    next();\n    skipEOLs();\n    elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.array.element\");\n    }\n    if (isVarArgs) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.array.varargs.duplicate\");\n    }\n    isVarArgs = true;\n  }\n\n  return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LBRACK)) \n    {\n        return null;\n    }\n    next();\n    skipEOLs();\n    Node elementTypes = newNode(Token.EMPTY);\n    boolean isVarArgs = false;\n    do \n    {\n        Node elementType = null;\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            isVarArgs = true;\n            elementType = newNode(Token.ELLIPSIS);\n            next();\n        } else \n        {\n            elementType = parseTypeExpression(next());\n        }\n\n        if (elementType == null) \n        {\n            return null;\n        }\n        elementTypes.addChildToBack(elementType);\n        skipEOLs();\n    } while (match(JsDocToken.ELLIPSIS, JsDocToken.COMMA));\n\n    if (isVarArgs && match(JsDocToken.RBRACK)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.array.varargs\");\n    }\n\n    if (!match(JsDocToken.RBRACK)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    return new ArrayType(elementTypes, isVarArgs);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  skipEOLs();\n  if (!match(JsDocToken.LBRACK)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n\n  Node elementType = parseTypeExpression(token);\n  if (elementType == null) \n  {\n    return null;\n  }\n\n  boolean isVarArgs = false;\n  while (true) \n  {\n    if (match(JsDocToken.ELLIPSIS)) \n    {\n      next();\n      skipEOLs();\n      isVarArgs = true;\n      break;\n    }\n    if (!match(JsDocToken.RBRACK)) \n    {\n      if (!match(JsDocToken.COMMA)) \n      {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.array.missing.comma\");\n      }\n      next();\n      skipEOLs();\n    } else \n    {\n      next();\n      break;\n    }\n    elementType = parseTypeExpression(next());\n    if (elementType == null) \n    {\n      return null;\n    }\n  }\n\n  if (isVarArgs) \n  {\n    if (elementType.getType() == Type.UNION) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.array.varargs.union.element\");\n    }\n  }\n  return newNode(Token.ARRAY, elementType, isVarArgs);\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    Vector3D axis = new Vector3D(q1, q2, q3);\n    axis.normalize();\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    double lengthSq = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3;\n    if (lengthSq > 0) \n    {\n        double length = FastMath.sqrt(lengthSq);\n        return new Vector3D(q1 / length, q2 / length, q3 / length);\n    }\n\n    return new Vector3D(0.0, 0.0, 1.0);\n}",
      "public Vector3D getAxis()  {\n    final double lenSq = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3;\n    final double len = FastMath.sqrt(lenSq);\n    if (len == 0.0) {\n        return new Vector3D(1.0, 0.0, 0.0);\n    }\n    final double invlen = 1.0 / len;\n    return new Vector3D(q1 * invlen, q2 * invlen, q3 * invlen);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    Vector3D axis = new Vector3D(q1, q2, q3);\n    double length = axis.length();\n    if (length == 0) \n    {\n        return new Vector3D(0, 0, 1);\n    } else \n    {\n        axis.scale(1.0 / length);\n        return axis;\n    }\n}",
      "public Vector3D getAxis()  {\n    final double len = getLength();\n    return new Vector3D(q1 / len, q2 / len, q3 / len);\n}",
      "public Vector3D getAxis()  {\n    Vector3D axis = new Vector3D(q1, q2, q3);\n    axis.normalize();\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0, n = bytes.length;\n    while (i < n) {\n        final byte c = bytes[i++];\n\n        if (c == ESCAPE_CHAR) {\n            final byte h1 = bytes[i++];\n            final byte h2 = bytes[i++];\n            if (h1 >= '0' && h1 <= '9') {\n                h1 -= '0';\n            } else if (h1 >= 'A' && h1 <= 'F') {\n                h1 -= 'A' - 10;\n            } else if (h1 >= 'a' && h1 <= 'f') {\n                h1 -= 'a' - 10;\n            } else {\n                throw new DecoderException(\"Invalid hex character: \" + h1);\n            }\n\n            if (h2 >= '0' && h2 <= '9') {\n                h2 -= '0';\n            } else if (h2 >= 'A' && h2 <= 'F') {\n                h2 -= 'A' - 10;\n            } else if (h2 >= 'a' && h2 <= 'f') {\n                h2 -= 'a' - 10;\n            } else {\n                throw new DecoderException(\"Invalid hex character: \" + h2);\n            }\n\n            buffer.write((h1 << 4) | h2);\n        } else {\n            int b = c;\n            if (b < 0) {\n                b = 256 + b;\n            }\n            if (b == '+') {\n                b = ' ';\n            } else if (!WWW_FORM_URL_SAFE.get(b)) {\n                throw new DecoderException(\"Invalid character: \" + c);\n            }\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final byte c = bytes[i++];\n        if (c == ESCAPE_CHAR) {\n            if (i >= bytes.length) {\n                throw new DecoderException(\"Unexpected end of encoded string\");\n            }\n            final byte b1 = Character.toLowerCase(bytes[i++]);\n            final byte b2 = Character.toLowerCase(bytes[i++]);\n\n            if ((b1 > 'f') || (b2 > 'f')) {\n                throw new DecoderException(\"Invalid hex character in encoded string\");\n            }\n\n            final int b = ((b1 - '0') << 4) | (b2 - '0');\n            baos.write(b);\n        } else if (c == '+') {\n            baos.write(' ');\n        } else {\n            baos.write(c);\n        }\n    }\n    return baos.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (b == '+') {\n            b = ' ';\n        }\n        if (b >= ESCAPE_CHAR) {\n            if (b <= 'z') {\n                b = (b - ESCAPE_CHAR) + ('A' - 'a');\n            } else {\n                b -= ESCAPE_CHAR;\n            }\n            if (b > 127) {\n                throw new DecoderException(\"Invalid URL character: \" + (char) b);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int position = 0;\n    while (position < bytes.length) {\n        final byte c = bytes[position++];\n        if (c == ESCAPE_CHAR) {\n            if (position >= bytes.length) {\n                throw new DecoderException(\"Unexpected end of URL-encoded content\");\n            }\n            final byte b1 = Character.toLowerCase(bytes[position++]);\n            final byte b2 = Character.toLowerCase(bytes[position++]);\n            final int b = (Character.digit(b1, RADIX) << 4) | Character.digit(b2, RADIX);\n            buffer.write(b);\n        } else {\n            if (c == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(c);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final byte b = bytes[i++];\n        if (b == ESCAPE_CHAR) {\n            final char hex1 = Character.toLowerCase((char) bytes[i++]);\n            final char hex2 = Character.toLowerCase((char) bytes[i++]);\n            final int value = Character.digit(hex1, RADIX) << 4 | Character.digit(hex2, RADIX);\n            buffer.write((byte) value);\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    int i = 0, end = bytes.length;\n\n    while (i < end) {\n        final byte c = bytes[i++];\n        if (c == ESCAPE_CHAR) {\n            final byte h = bytes[i++];\n            final byte l = bytes[i++];\n            final char hex1 = (char) ((h - '0') & 0xF);\n            final char hex2 = (char) ((l - '0') & 0xF);\n            final int b = (hex1 << 4) + hex2;\n            baos.write(b);\n        } else {\n            baos.write(c);\n        }\n    }\n\n    return baos.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            if (buffer.size() == buffer.capacity()) {\n                buffer.grow(buffer.size() * 2);\n            }\n            final int nextIndex = buffer.size();\n            buffer.write(b);\n            if (buffer.size() - nextIndex >= 2) {\n                final int c1 = Character.digit((char)buffer.buf[nextIndex], RADIX);\n                final int c2 = Character.digit((char)buffer.buf[nextIndex + 1], RADIX);\n                if (c1 >= 0 && c2 >= 0) {\n                    final int b2 = (c1 << 4) | c2;\n                    buffer.write(b2);\n                } else {\n                    throw new DecoderException(\"Invalid URL encoding\");\n                }\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            if (bytes.length < (buffer.size() + 2)) {\n                throw new DecoderException(\"Unexpected end of encoded stream\");\n            }\n            int u = (bytes[++buffer.size()] - '0') << 4;\n            if (bytes[++buffer.size()] < '0' || bytes[buffer.size()] > '9') {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            u |= (bytes[buffer.size()] - '0');\n            buffer.write(u);\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final byte c = bytes[i++];\n        if (c == ESCAPE_CHAR) {\n            final byte hex1 = Character.toLowerCase(bytes[i++]);\n            final byte hex2 = Character.toLowerCase(bytes[i++]);\n            final int b = ((hex1 - '0') << 4) + (hex2 - '0');\n            if (b < 0 || b >= 256) {\n                throw new DecoderException(\"Invalid hex character sequence.\");\n            }\n            buffer.write(b);\n        } else {\n            if (c == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(c);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int position = 0;\n    while (position < bytes.length) {\n        final byte currentByte = bytes[position++];\n        if (currentByte == ESCAPE_CHAR) {\n            if (position == bytes.length) {\n                throw new DecoderException(\"Invalid URL encoding: escape character at the end of the string\");\n            }\n            final byte hex1 = bytes[position++];\n            final byte hex2 = bytes[position++];\n            if (!isHex(hex1) || !isHex(hex2)) {\n                throw new DecoderException(\"Invalid URL encoding: illegal hexadecimal character\");\n            }\n            final int b = (Character.digit(hex1, RADIX) << 4) | Character.digit(hex2, RADIX);\n            buffer.write(b);\n        } else {\n            if (currentByte == '+') {\n                currentByte = ' ';\n            }\n            buffer.write(currentByte);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n    \n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    // Check if the partial is null.\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n\n    // Get the units of the partial.\n    Set<TemporalUnit> units = partial.getUnits();\n\n    // Iterate through the units of the partial.\n    for (TemporalUnit unit : units) {\n        // Get the range of the current unit.\n        long range = unit.getRange();\n\n        // Get the unit of the next field.\n        TemporalUnit nextUnit = unit.plus(1);\n\n        // Get the range of the next unit.\n        long nextRange = nextUnit.getRange();\n\n        // Check if the two ranges are equal.\n        if (range != nextRange) {\n            // The partial is not contiguous.\n            return false;\n        }\n    }\n\n    // The partial is contiguous.\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    // Check if the partial is null.\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null.\");\n    }\n\n    // Get the fields from the partial.\n    TemporalField[] fields = partial.getFields();\n\n    // Iterate through the fields.\n    for (int i = 0; i < fields.length - 1; i++) {\n        TemporalField field = fields[i];\n        TemporalField nextField = fields[i + 1];\n\n        // Check if the range of the field is the same as the next field.\n        if (!field.range().equals(nextField.range())) {\n            return false;\n        }\n    }\n\n    // The partial is contiguous.\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    // Check if the partial is null\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n\n    // Get the range unit of the partial\n    Class<? extends TemporalAmount> rangeUnit = partial.rangeUnit();\n\n    // Get the unit of the next field in the partial\n    Class<? extends TemporalAmount> nextUnit = partial.nextUnit();\n\n    // Check if the range unit and the next unit are the same\n    return rangeUnit.equals(nextUnit);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n    { \n        throw new IllegalArgumentException(\"partial must not be null\"); \n    } \n    \n    Class<? extends ReadablePartial> type = partial.getClass(); \n    \n    if (type == LocalDate.class) \n    { \n        return true; \n    } \n    if (type == LocalTime.class) \n    { \n        return true; \n    } \n    \n    if (type == LocalDateTime.class) \n    { \n        return true; \n    } \n    \n    if (type == YearMonth.class) \n    { \n        return true; \n    } \n    \n    if (type == Year.class) \n    { \n        return true; \n    } \n    \n    if (type == Month.class) \n    { \n        return true; \n    } \n    \n    if (type == DayOfWeek.class) \n    { \n        return true; \n    } \n    \n    if (type == DayOfMonth.class) \n    { \n        return true; \n    } \n    \n    if (type == HourOfDay.class) \n    { \n        return true; \n    } \n    \n    if (type == MinuteOfHour.class) \n    { \n        return true; \n    } \n    \n    if (type == SecondOfMinute.class) \n    { \n        return true; \n    } \n    \n    if (type == MillisOfSecond.class) \n    { \n        return true; \n    } \n    \n    if (type == MonthOfYear.class) \n    { \n        return true; \n    } \n    \n    if (type == WeekOfWeekBased.class) \n    { \n        return true; \n    } \n    \n    if (type == WeekFields.class) \n    { \n        return true; \n    } \n    \n    if (type == IsoFields.class) \n    { \n        return true; \n    } \n    \n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    // Check for null value\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    // Get the chronology\n    Chronology chrono = getChronology(partial.getChronology());\n    // Get the next field from the partial\n    ReadablePartial next = partial.next();\n    // Check if the range field of the partial is equal to the unit field of the next field\n    if (next == null || chrono.getRangeUnit(partial.getRangeField()) != chrono.getUnit(next.getUnit())) {\n        return false;\n    }\n    // If we reach here, the partial is contiguous\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    // Get the fields of the partial.\n    List<TemporalField> fields = partial.getFields();\n\n    // Iterate over the fields.\n    for (int i = 0; i < fields.size() - 1; i++) {\n        // Get the range of the current field.\n        TemporalAmount range = fields.get(i).range();\n\n        // Get the unit of the next field.\n        TemporalUnit unit = fields.get(i + 1).rangeUnit();\n\n        // Check if the range and unit are compatible.\n        if (!range.equals(unit)) {\n            return false;\n        }\n    }\n\n    // All fields are contiguous.\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    // Check if the partial is null\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    // Get the fields of the partial\n    TemporalField[] fields = partial.range().getFields();\n    // Iterate through the fields and check if they are contiguous\n    for (int i = 0; i < fields.length - 1; i++) {\n        TemporalField field = fields[i];\n        TemporalField nextField = fields[i + 1];\n        // Check if the range of the field is equal to the range of the next field\n        if (!field.range().equals(nextField.range())) {\n            return false;\n        }\n    }\n    // If all fields are contiguous, return true\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    \n    Class<? extends ReadablePartial> type = partial.getClass();\n    \n    if (type == LocalDate.class) {\n        return true;\n    } else if (type == LocalTime.class) {\n        return true;\n    } else if (type == LocalDateTime.class) {\n        return true;\n    } else if (type == Year.class) {\n        return false;\n    } else if (type == Month.class) {\n        return false;\n    } else if (type == DayOfMonth.class) {\n        return false;\n    } else if (type == DayOfWeek.class) {\n        return false;\n    } else if (type == HourOfDay.class) {\n        return false;\n    } else if (type == MinuteOfHour.class) {\n        return false;\n    } else if (type == SecondOfMinute.class) {\n        return false;\n    } else if (type == MillisOfSecond.class) {\n        return false;\n    } else if (type == YearMonth.class) {\n        return true;\n    } else if (type == MonthOfYear.class) {\n        return true;\n    } else {\n        return false;\n    }\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial cannot be null\");\n    }\n    \n    ReadablePartial next = partial.plus(1, partial.range());\n    return partial.range().equals(next.range());\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n    { \n        throw new IllegalArgumentException(\"partial is null\");\n    }\n    \n    List<TemporalUnit> units = partial.range().getUnits(); \n    List<TemporalUnit> nextUnits = new ArrayList<>(); \n    \n    for (TemporalUnit unit : units) \n    { \n        nextUnits.add(unit.getRangeUnit()); \n    }\n    \n    return nextUnits.equals(units); \n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> setOperationCardinalityHelper = new SetOperationCardinalityHelper<>(a, b);\n    for (O obj : a) \n    {\n        int count = 0;\n        if (b.iterator().hasNext()) \n        {\n            count++;\n        }\n        setOperationCardinalityHelper.setCardinality(obj, count);\n    }\n    return setOperationCardinalityHelper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> result = new SetOperationCardinalityHelper<>(a, b);\n\n    Map<O, Integer> map = new HashMap<>();\n    for (O o : a) {\n        int count = 0;\n        if (b.contains(o)) {\n            count = Math.max(count, 2);\n        } else {\n            count++;\n        }\n        map.put(o, count);\n    }\n\n    for (O o : b) {\n        if (!map.containsKey(o)) {\n            map.put(o, 1);\n        }\n    }\n\n    for (O o : map.keySet()) {\n        result.setCardinality(o, map.get(o));\n    }\n\n    return result.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n\n    for (O element : a) {\n        helper.setCardinality(element, Math.max(helper.getCardinality(element), helper.getCardinalityFromB(element)));\n    }\n\n    for (O element : b) {\n        helper.setCardinality(element, Math.max(helper.getCardinality(element), helper.getCardinalityFromA(element)));\n    }\n\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (O element : a) {\n            helper.setCardinality(element, Math.max(helper.getCount(element), helper.getMax(element)));\n        }\n        for (O element : b) {\n            helper.setCardinality(element, Math.max(helper.getCount(element), helper.getMax(element)));\n        }\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n    helper.computeMaximalCardinality();\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n\n    // iterate through both collections and record the maximum cardinality for each element\n    for (O element : a) {\n        helper.setCardinality(element, Math.max(helper.getCardinality(element), helper.getUpperBound(element)));\n    }\n\n    for (O element : b) {\n        helper.setCardinality(element, Math.max(helper.getCardinality(element), helper.getUpperBound(element)));\n    }\n\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> setOperationCardinalityHelper = new SetOperationCardinalityHelper<O>(a, b);\n    return setOperationCardinalityHelper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (O element : a) \n        {\n            helper.setCardinality(element, Math.max(1, helper.get(element)));\n        }\n        for (O element : b) \n        {\n            helper.setCardinality(element, Math.max(1, helper.get(element)));\n        }\n        return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n\n        // Calculate the maximum cardinality for each element\n        for (O element : a) \n        {\n            int cardinality = 1;\n            for (O otherElement : b) \n            {\n                if (element.equals(otherElement)) \n                {\n                    cardinality = Math.max(cardinality, helper.getCardinality(element));\n                }\n            }\n            helper.setCardinality(element, cardinality);\n        }\n\n        // Return the resulting collection\n        return helper.list();\n    }",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (O element : a) {\n            helper.setCardinality(element, Math.max(helper.getCount(element), helper.maxCount(element, b)));\n        }\n        for (O element : b) {\n            helper.setCardinality(element, Math.max(helper.getCount(element), helper.maxCount(element, a)));\n        }\n        return helper.list();\n    }"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : NodeUtil.getFunctionParameterList(params)) {\n        if (param.getType() == NodeType.PARAM) {\n            Node name = NodeUtil.getFunctionName(param);\n            if (name != null && name.getType() == NodeType.NAME) {\n                result.add(IR.string(name.getValue()));\n            }\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param : NodeUtil.getFunctionParameters(params)) {\n    if (param.isIdentifier()) {\n      strings.add(IR.string(param.asIdentifier().getName()));\n    } else {\n      throw new IllegalStateException(\"Unexpected parameter node:\" + param);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node param : NodeUtil.getFunctionParameters(params)) {\n        result.add(IR.string(param.getFirstToken().getText()));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> dependencies = Lists.newArrayList();\n    for (int i = 0; i < params.getChildCount(); ++i) \n    {\n        Node param = params.getChild(i);\n        if (param.isIdentifier()) \n        {\n            dependencies.add(IR.string(param.toString()));\n        } \n        else \n        {\n            Diagnostic diagnostic = new Diagnostic(\n                INJECT_NON_FUNCTION_ERROR,\n                params.getPosition(),\n                params.getPosition() + params.getLength(),\n                params);\n            diagnostic.setMessage(\"Expected identifier\");\n            diagnostic.setContext(params);\n            throw new RuntimeException(diagnostic.getMessage());\n        }\n    }\n    return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> dependencies = Lists.newArrayList();\n    if (params.isBlockItemList()) {\n        for (Node param : params.getStatements()) {\n            if (param.isVariableDeclaration()) {\n                Node declarator = param.getFirstChild();\n                if (declarator.isVariableDeclarator()) {\n                    dependencies.add(IR.string(\n                        declarator.getLastChild().getName()));\n                }\n            }\n        }\n    } else {\n        for (Node param : params.getExpressions()) {\n            if (param.isName()) {\n                dependencies.add(IR.string(param.getName()));\n            }\n        }\n    }\n    return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<Node>();\n    for (Node param : NodeUtil.getFunctionParameters(params)) {\n        result.add(IR.string(NodeUtil.getFunctionName(param)));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : NodeUtil.getFunctionParams(params)) {\n    strings.add(IR.string(param.getName()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  if (!params.isParamList()) {\n    return result;\n  }\n  List<Node> children = params.getChildren();\n  for (int i = 0; i < children.size(); ++i) {\n    Node param = children.get(i);\n    if (param.isVariable()) {\n      String name = ((Variable) param).getIdentifier().name;\n      result.add(IR.string(name));\n    } else {\n      throw new RuntimeException(\n          \"Invalid parameter: expected Variable, found \" + param + \".\");\n    }\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> dependencies = Lists.newArrayList();\n    for (Node param : NodeUtil.getFunctionParameters(params)) {\n        if (param.isString()) {\n            dependencies.add(param);\n        }\n    }\n    return dependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> dependencies = Lists.newArrayList();\n    if (params.isParamList()) {\n        for (Node param : NodeUtil.getFunctionParameterList(params)) {\n            dependencies.add(IR.string(param.toSource()));\n        }\n    }\n    return dependencies;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size - padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        final int padLen = width - strLen;\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size++] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size - padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        final int padLen = width - strLen;\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        final int padLen = width - strLen;\n        if (padLen > 0) {\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        } else {\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size + padLen);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, strLen, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = false;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    for (int i = 0; i < str.length(); i++) \n    {\n        char c = str.charAt(i);\n        if (Character.isLowerCase(c)) \n        {\n            str = str.substring(0, i) + Character.toUpperCase(c) + str.substring(i + 1);\n        }\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    return capitalize(str, delimiters).toLowerCase();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return capitalize(str, delimiters);\n    }\n\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null)\n    {\n        return null;\n    }\n\n    if (delimiters == null || delimiters.length == 0)\n    {\n        delimiters = new char[] { ' ' };\n    }\n\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++)\n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters))\n        {\n            capitalizeNext = true;\n            sb.append(ch);\n        }\n        else\n        {\n            if (capitalizeNext)\n            {\n                sb.append(Character.toTitleCase(ch));\n            }\n            else\n            {\n                sb.append(Character.toLowerCase(ch));\n            }\n            capitalizeNext = false;\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = str.toLowerCase();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (cConverter == null) {\n        cConverter = new IdConverter();\n    }\n    \n    return cConverter.convert(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cConvertedIds.get(id);\n    if (convertedId == null) {\n        for (Map.Entry<String, String> entry : cOldStyleIds.entrySet()) {\n            if (entry.getKey().equalsIgnoreCase(id)) {\n                convertedId = entry.getValue();\n                cConvertedIds.put(id, convertedId);\n                break;\n            }\n        }\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cIdsMap == null) \n    {\n        cIdsMap = new HashMap<>();\n        cIdsMap.put(\"America/New_York\", \"America/New_York\");\n        cIdsMap.put(\"America/Chicago\", \"America/Chicago\");\n        // ... add more mappings here ...\n    }\n    return cIdsMap.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // TODO: Implement logic to convert an old style id to a new style id.\n\n    // If no conversion is found, return null.\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cIdsMap == null) {\n        cIdsMap = new HashMap<>(256);\n\n        // Add mappings here, e.g.,\n        cIdsMap.put(\"America/Los_Angeles\", \"America/Los_Angeles\");\n        cIdsMap.put(\"Etc/GMT+5\", \"Etc/GMT+5\");\n        // ...\n    }\n\n    return cIdsMap.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    // Use the provider to convert the old style id to a new style id\n    String newId = getNameProvider().getID(id);\n    if (newId != null) {\n        return newId;\n    }\n\n    // If the provider failed, use the default name provider\n    return getDefaultNameProvider().getID(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cOldStyleIdMap == null)\n    {\n        cOldStyleIdMap = new HashMap<>(300);\n        cOldStyleIdMap.put(\"GMT\", \"Etc/GMT+0\");\n        cOldStyleIdMap.put(\"GMT+0100\", \"Etc/GMT+1\");\n        cOldStyleIdMap.put(\"GMT+0200\", \"Etc/GMT+2\");\n        cOldStyleIdMap.put(\"GMT+0300\", \"Etc/GMT+3\");\n        cOldStyleIdMap.put(\"GMT+0330\", \"Asia/Tehran\");\n        cOldStyleIdMap.put(\"GMT+0400\", \"Etc/GMT+4\");\n        cOldStyleIdMap.put(\"GMT+0500\", \"Etc/GMT+5\");\n        cOldStyleIdMap.put(\"GMT+0530\", \"Asia/Calcutta\");\n        cOldStyleIdMap.put(\"GMT+0545\", \"Asia/Katmandu\");\n        cOldStyleIdMap.put(\"GMT+0600\", \"Etc/GMT+6\");\n        cOldStyleIdMap.put(\"GMT+0630\", \"Asia/Novosibirsk\");\n        cOldStyleIdMap.put(\"GMT+0700\", \"Etc/GMT+7\");\n        cOldStyleIdMap.put(\"GMT+0800\", \"Etc/GMT+8\");\n        cOldStyleIdMap.put(\"GMT+0845\", \"Asia/Ulaanbaatar\");\n        cOldStyleIdMap.put(\"GMT+0900\", \"Etc/GMT+9\");\n        cOldStyleIdMap.put(\"GMT+0930\", \"Asia/Tokyo\");\n        cOldStyleIdMap.put(\"GMT+1000\", \"Etc/GMT+10\");\n        cOldStyleIdMap.put(\"GMT+1030\", \"Pacific/Honolulu\");\n        cOldStyleIdMap.put(\"GMT+1100\", \"Etc/GMT+11\");\n        cOldStyleIdMap.put(\"GMT+1200\", \"Etc/GMT+12\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String result = null;\n    if (cIdMap.containsKey(id)) {\n        result = cIdMap.get(id);\n    } else {\n        for (Map.Entry<String, String> entry : cIdMap.entrySet()) {\n            if (entry.getValue().equals(id)) {\n                result = entry.getKey();\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cConvertedIds.get(id);\n    if (convertedId == null) {\n        convertedId = convertId(id);\n        if (convertedId != null) {\n            cConvertedIds.put(id, convertedId);\n        }\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = idMap.get(id);\n    if (convertedId == null) \n    {\n        for (Map.Entry<String, String> entry : idMap.entrySet()) \n        {\n            if (id.startsWith(entry.getKey())) \n            {\n                convertedId = entry.getValue() + id.substring(entry.getKey().length());\n                break;\n            }\n        }\n        if (convertedId == null)\n            convertedId = id;\n        idMap.put(id, convertedId);\n    }\n    return convertedId;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix jacobian = jF.value(params).jacobian();\n    return weightMatrixSqrt.operate(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int numParams = params.length;\n\n    // Initialize weightedResidualJacobian if necessary\n    if (weightedResidualJacobian == null || weightedResidualJacobian.length != numParams) {\n        weightedResidualJacobian = new double[numParams];\n    }\n\n    // Calculate weighted residuals\n    for (int i = 0; i < numParams; i++) {\n        weightedResiduals[i] = objective[i] - weightedResidualJacobian[i];\n    }\n\n    // Compute Jacobian using jF\n    MultivariateRealVector j = jF.value(params);\n\n    // Calculate weighted Jacobian\n    for (int i = 0; i < numParams; i++) {\n        weightedResidualJacobian[i] = j.getEntry(i) * weightMatrixSqrt.getEntry(i, i);\n    }\n\n    // Return weighted Jacobian\n    return new Array2DRowRealMatrix(weightedResidualJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix weightedJacobian = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            weightedJacobian.setEntry(i, j, weightedResidualJacobian[i][j]);\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    if (cols != params.length) {\n        throw new DimensionMismatchException(\"Jacobian dimension (\" + cols\n                + \") must match problem dimension (\" + params.length + \")\");\n    }\n    RealMatrix jacobian = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            jacobian.setEntry(i, j, computeWeightedResidualJacobianEntry(params, i, j));\n        }\n    }\n    return jacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix jacobian = jF.valueJacobian(params);\n    return weightMatrixSqrt.operate(jacobian);\n}\n\n@Override\nprotected void updateJacobian() throws DimensionMismatchException {\n    weightedResidualJacobian = computeWeightedJacobian(point).scalarMultiply(-1).getData();\n    jacobianEvaluations++;\n}\n\n@Override\nprotected void setPoint(double[] point) {\n    this.point = point;\n    objective = jF.value(point);\n    weightedResiduals = weightedResidual.copy();\n    cost = weightedResiduals.dotProduct(weightedResidual);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        if (weightedResidualJacobian == null) {\n            weightedResidualJacobian = new double[rows][cols];\n        }\n        jF.valueJacobian(params, weightedResidualJacobian);\n        return weightMatrixSqrt.operate(new Array2DRowRealMatrix(weightedResidualJacobian));\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    RealMatrix jacobian = jF.value(params);\n    if (jacobian.getColumnDimension() != cols) {\n        throw new DimensionMismatchException(\n                \"Jacobian dimension (\" + jacobian.getColumnDimension() + \") does not match problem dimension (\" + cols + \")\");\n    }\n    return weightMatrixSqrt.operate(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Handle the case where the Jacobian is not yet initialized.\n        if (jF == null) {\n            throw new IllegalStateException(\"Jacobian not initialized.\");\n        }\n        // Calculate the Jacobian using the given function.\n        RealMatrix jacobian = jF.value(params);\n        // Multiply the Jacobian by the square root of the weight matrix.\n        return jacobian.scalarMultiply(weightMatrixSqrt);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Implement Jacobian computation logic here.\n        // Utilize the provided context if possible.\n        // ...\n        // Return the weighted Jacobian matrix.\n        return weightedJacobianMatrix;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n  // Use the provided jF function to compute the Jacobian\n  RealMatrix jacobian = jF.value(new ArrayRealVector(params)).getJacobian();\n  \n  // Multiply by the square root of the weight matrix\n  if (weightMatrixSqrt != null) {\n    jacobian = weightMatrixSqrt.operate(jacobian);\n  }\n  \n  // Return the weighted Jacobian\n  return jacobian;\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n\n    if (leastIndex == -1) {\n        for (int i = 0; i < values.size(); i++) {\n            if (valueSet.get(i)) {\n                leastIndex = i;\n                break;\n            }\n        }\n\n        if (leastIndex == -1) {\n            for (int i = 0; i < values.size(); i++) {\n                if (set(i)) {\n                    leastIndex = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    if (valueSet.nextSetBit(leastIndex + 1) >= 0) {\n        return valueSet.nextSetBit(leastIndex + 1);\n    }\n    return -1;\n}",
      "private int least()  {\n    if (leastIndex == -1)\n    {\n        throw new NoSuchElementException();\n    }\n    final E val = values.get(leastIndex);\n    clear(leastIndex);\n    lastReturned = leastIndex;\n    return val;\n}",
      "private int least()  {\n    if (comparator == null)\n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < iterators.size(); i++)\n    {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex),values.get(i)) > 0)\n        {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator is set\");\n    }\n\n    int leastIndex = -1;\n    E least = null;\n\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            final E current = values.get(i);\n            final int comparison = comparator.compare(current, least);\n            if (comparison < 0) {\n                leastIndex = i;\n                least = current;\n            }\n        } else {\n            if (set(i)) {\n                final E current = values.get(i);\n                final int comparison = comparator.compare(current, least);\n                if (comparison < 0) {\n                    leastIndex = i;\n                    least = current;\n                }\n            }\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    if (valueSet.nextSetBit(leastIndex + 1) == -1) {\n        return -1;\n    }\n\n    int leastIndex = this.leastIndex;\n    for (int i = leastIndex + 1; i < iterators.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n\n    return leastIndex;\n}",
      "private int least()  {\n    start();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator is set\");\n    }\n\n    if (leastIndex >= 0 && valueSet.get(leastIndex)) {\n        return leastIndex;\n    }\n\n    leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            continue;\n        }\n        if (!set(i)) {\n            continue;\n        }\n        if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (values == null)\n    {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    start();\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++)\n    {\n        if (valueSet.get(i))\n        {\n            continue;\n        }\n        if (leastIndex == -1)\n        {\n            leastIndex = i;\n        }\n        else \n        {\n            if (comparator.compare(values.get(i), values.get(leastIndex)) < 0)\n            {\n                leastIndex = i;\n            }\n        }\n        if (!set(i))\n        {\n            clear(leastIndex);\n            leastIndex = -1;\n        }\n    }\n    if (leastIndex == -1)\n    {\n        throw new NoSuchElementException();\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (set(i)) {\n                leastIndex = i;\n            }\n        }\n        else if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (values == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    leastIndex = -1;\n    int leastValue = Integer.MAX_VALUE;\n    for (int i = 0; i < values.size(); i++) {\n        final E val = values.get(i);\n        if (val == null) {\n            if (!set(i)) {\n                continue;\n            }\n        }\n        final int current = comparator.compare(val, leastValue);\n        if (current < 0) {\n            leastValue = val;\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return parentPointer.getPropertyPointer(step.getPropertyName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return parentPointer.getPropertyPointer(step.getPropertyName());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression[] predicates = step.getPredicates();\n    if (predicates.length > 0) {\n        // Property exists - return a child pointer to the first predicate\n        return new NodePointer(predicates[0]);\n    }\n    return parentPointer.childPointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String propertyName = step.getPropertyName();\n    return parentPointer.getPropertyValue(propertyName);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    }\n    return parentPointer.createChildPointerForStep(step);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String propertyName = step.getProperty();\n    return parentPointer.getPropertyValueAsPointer(propertyName);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression[] predicates = step.getPredicates();\n    if (predicates.length > 0) {\n        return predicates[0].evaluate(parentPointer);\n    }\n    return parentPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    }\n    return parentPointer.getProperty(step.getProperty());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    return parentPointer.getProperty(step.getProperty())\n        .orElseThrow(() -> new RuntimeException(\"Invalid step\"));\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    String propertyName = step.getPropertyName();\n    return parentPointer.createChildPointer(propertyName);\n}"
    ],
    [
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return (getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getEntry(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        if(((Boolean) getTree(false).getAttribute()) == true) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    } else {\n        OrientedPoint lowerCut = (OrientedPoint) getTree(false).getCut().getHyperplane();\n        return lowerCut.getLocation().getCoordinate(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return (Double.isInfinite((Boolean) getTree(false).getAttribute()) ? \n                Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n    } else {\n        for (final Interval interval : asList()) {\n            if (interval.getLowerBound() > Double.NEGATIVE_INFINITY) {\n                return interval.getLowerBound();\n            }\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        if(((Boolean) getTree(false).getAttribute()))\n            return Double.NEGATIVE_INFINITY;\n        else\n            return Double.POSITIVE_INFINITY;\n    } else {\n        for (final Interval interval : asList()) {\n            if(interval.getLower() <= getInf())\n                return interval.getLower();\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return (getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    return getTree(false).getCut().getHyperplane().getMin();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        // the instance is unbounded on the low side\n        if (((Boolean) getTree(false).getAttribute())) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n    // the instance is bounded on the low side\n    return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getEntry(0);\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return (Boolean) getTree(false).getAttribute() ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getEntry(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return ((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation().getCoordinate(0);\n    }\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        if(((Boolean) getTree(false).getAttribute())) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    }\n    return getTree(false).getCut().getHyperplane().getMin();\n}",
      "public double getInf()  {\n    if (getTree(false).getCut() == null) {\n        if(((Boolean) getTree(false).getAttribute()) == true) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return Double.POSITIVE_INFINITY;\n        }\n    } else {\n        OrientedPoint hyperplane = (OrientedPoint) getTree(false).getCut().getHyperplane();\n        if(hyperplane.isPositive()) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return Double.NEGATIVE_INFINITY;\n        }\n    }\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(),\n            locale -> createLocaleSpecificStrategy(field, locale, definingCalendar));\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.get(Calendar.LOCALE);\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.get(Calendar.LOCALE);\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy result = cache.get(locale);\n    if (result == null) {\n        String shortText = definingCalendar.getDisplayName(field, Calendar.SHORT, locale);\n        String longText = definingCalendar.getDisplayName(field, Calendar.LONG, locale);\n        result = new TextStrategy(field, shortText, longText);\n        cache.putIfAbsent(locale, result);\n    }\n    return result;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(), \n    new Supplier<Strategy>() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(), new Function<Locale, Strategy>() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(), new Function<Locale, Strategy>() \n    {\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(), \n        locale -> new TextStrategy(field, definingCalendar.getDisplayName(field, Calendar.SHORT, locale),\n                                      definingCalendar.getDisplayName(field, Calendar.LONG, locale)));\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return getCache(field).computeIfAbsent(definingCalendar.getLocale(),\n            new Function<Locale, Strategy>() {\n\n}\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.get(Calendar.LOCALE);\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy==null) {\n        final StringBuilder regex = new StringBuilder();\n        addLocaleSpecificRegex(locale, regex, definingCalendar);\n        strategy = new TextStrategy(field, regex.toString());\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = definingCalendar.get(Calendar.LOCALE);\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    do {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n    } while (!predicate.test(nextObject));\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        return false;\n    }\n    E next = iterator.next();\n    if (predicate.test(next)) {\n        nextObject = next;\n        nextObjectSet = true;\n        return true;\n    }\n    return setNextObject();\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.test(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    do {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n    } while (!predicate.test(nextObject));\n    \n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        final E object = iterator.next();\n        if (predicate.test(object)) \n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    nextObject = null;\n    return false;\n}",
      "private boolean setNextObject()  {\n    nextObject = null;\n    while (iterator.hasNext()) \n    {\n        final E next = iterator.next();\n        if (predicate.test(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    nextObject = null;\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.test(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    do {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n    } while (!predicate.test(nextObject));\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext())\n    {\n        final E next = iterator.next();\n        if (predicate.test(next))\n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    nextObject = null;\n    while (iterator.hasNext()) {\n        E next = iterator.next();\n        if (predicate.test(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] fixed = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (Double.isNaN(x[i])) {\n            fixed[i] = Double.NaN;\n        } else if (x[i] < lB[i]) {\n            fixed[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            fixed[i] = uB[i];\n        } else {\n            fixed[i] = x[i];\n        }\n    }\n    return fixed;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    final double[] result = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            result[i] = lB[i];\n        }\n        else if (x[i] > uB[i]) \n        {\n            result[i] = uB[i];\n        }\n        else \n        {\n            result[i] = x[i];\n        }\n    }\n\n    return result;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] fixed = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            fixed[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            fixed[i] = uB[i];\n        } else {\n            fixed[i] = x[i];\n        }\n    }\n    return fixed;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] result = x.clone();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            result[i] = lB[i];\n        }\n        else if (x[i] > uB[i]) \n        {\n            result[i] = uB[i];\n        }\n    }\n    return result;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] result = x.clone();\n\n    for (int i = 0; i < x.length; i++) {\n        if (result[i] < lB[i]) {\n            result[i] = lB[i];\n        }\n        if (result[i] > uB[i]) {\n            result[i] = uB[i];\n        }\n    }\n\n    return result;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] xRepaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            xRepaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            xRepaired[i] = uB[i];\n        } else {\n            xRepaired[i] = x[i];\n        }\n    }\n    return xRepaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(Math.min(x[i], uB[i]), lB[i]);\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    if (matrix.getRowDimension() != matrix.getColumnDimension()) {\n        throw new IllegalArgumentException(\"Matrix must be square\");\n    }\n    final int n = matrix.getColumnDimension();\n    final double[][] z = matrix.getData();\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    for (int j = 0; j < n; j++) {\n        realEigenvalues[j] = z[j][j];\n        for (int i = 0; i < j; i++) {\n            e[i] = z[i][j];\n        }\n        for (int m = j + 1; m < n; m++) {\n            double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (realEigenvalues[j] + e[j]);\n            if (q == 0.0) {\n                continue;\n            }\n            double u = 0.0;\n            double s = 1.0;\n            double c = 1.0;\n            int i;\n            for (i = m - 1; i >= j; i--) {\n                double p = s * e[i];\n                double h = c * e[i];\n                if (FastMath.abs(p) >= FastMath.abs(q)) {\n                    c = q / p;\n                    t = FastMath.sqrt(c * c + 1.0);\n                    e[i + 1] = p * t;\n                    s = 1.0 / t;\n                    c = c * s;\n                } else {\n                    s = p / q;\n                    t = FastMath.sqrt(s * s + 1.0);\n                    e[i + 1] = q * t;\n                    c = 1.0 / t;\n                    s = s * c;\n                }\n                if (e[i + 1] == 0.0) {\n                    realEigenvalues[i + 1] -= u;\n                    e[m] = 0.0;\n                    break;\n                }\n                q = realEigenvalues[i + 1] - u;\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getRowDimension();\n    double[][] z = matrix.getData();\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    for (int j = 0; j < n - 1; j++) {\n        double t, q;\n        int m;\n        for (m = j + 1; m < n; m++) {\n            t = realEigenvalues[j] - realEigenvalues[m];\n            q = e[m] - t;\n            if (FastMath.abs(q) <= FastMath.abs(t)) {\n                break;\n            }\n        }\n        if (m == n) {\n            continue;\n        }\n        do {\n            q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n            t = (realEigenvalues[j] - q) / (realEigenvalues[m] - q) + 1.0;\n            for (int i = j; i <= m; i++) {\n                e[i] = t * e[i];\n            }\n            realEigenvalues[m] -= t * q;\n            realEigenvalues[j] = q;\n        } while (FastMath.abs(e[m]) >= FastMath.abs(e[j]));\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        for (int i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getColumnDimension();\n\n    // Initialize the transformation matrix\n    RealMatrix z = matrix.copy();\n    if (z.getRowDimension() != z.getColumnDimension())\n        throw new RuntimeException(\"Matrix must be square\");\n\n    // Initialize the eigenvalue and eigenvector arrays\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    RealVector[] eigenvectors = new ArrayRealVector[n];\n\n    // Initialize the transformation matrix z\n    for (int j = 0; j < n - 1; j++) {\n        int m = j;\n        for (int i = j + 1; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > FastMath.abs(realEigenvalues[m])) {\n                m = i;\n            }\n        }\n        if (m == j) {\n            continue;\n        }\n        double q;\n        if (FastMath.abs(realEigenvalues[m]) > FastMath.abs(realEigenvalues[j])) {\n            q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (realEigenvalues[m] + e[j]);\n        } else {\n            q = realEigenvalues[j] - realEigenvalues[m] + e[m] / (realEigenvalues[j] + e[m]);\n        }\n        double t;\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        for (int i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    RealMatrix z = matrix.copy();\n    final int n = matrix.getColumnDimension();\n    RealMatrix e = new ArrayRealMatrix(n, 1);\n    RealMatrix realEigenvalues = new ArrayRealMatrix(n, 1);\n    e.setEntry(0, 0, 1.0);\n    realEigenvalues.setEntry(0, 0, z.getEntry(0, 0));\n\n    for (int m = 1; m < n; m++) {\n        realEigenvalues.setEntry(m, m, z.getEntry(m, m));\n        for (int j = 0; j < m; j++) {\n            realEigenvalues.setEntry(m, j, z.getEntry(m, j));\n            z.setEntry(m, j, 0.0);\n        }\n        if (m < n - 1) {\n            for (int j = m + 1; j < n; j++) {\n                z.setEntry(j, m, z.getEntry(j, m) - z.getEntry(m, m) * z.getEntry(j, j));\n            }\n        }\n        double max = 0.0;\n        int k = m;\n        for (int j = m; j < n; j++) {\n            if (FastMath.abs(z.getEntry(j, m)) > max) {\n                k = j;\n                max = FastMath.abs(z.getEntry(j, m));\n            }\n        }\n        if (max == 0.0) {\n            continue;\n        }\n        if (k != m) {\n            for (int j = 0; j < n; j++) {\n                double p = z.getEntry(j, m);\n                z.setEntry(j, m, z.getEntry(j, k));\n                z.setEntry(j, k, p);\n            }\n            double p = realEigenvalues.getEntry(m, m);\n            realEigenvalues.setEntry(m, m, realEigenvalues.getEntry(k, k));\n            realEigenvalues.setEntry(k, k, p);\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    RealMatrix z = matrix.copy();\n    int n = matrix.getRowDimension();\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    for (int j = 0; j < n - 1; j++) {\n        int m = j;\n        for (int i = j + 1; i < n; i++) {\n            if (realEigenvalues[i] < realEigenvalues[m]) {\n                m = i;\n            }\n        }\n        if (m != j) {\n            double temp = realEigenvalues[j];\n            realEigenvalues[j] = realEigenvalues[m];\n            realEigenvalues[m] = temp;\n            for (int i = 0; i < n; i++) {\n                temp = z.getEntry(i, j);\n                z.setEntry(i, j, z.getEntry(i, m));\n                z.setEntry(i, m, temp);\n            }\n        }\n        double t;\n        if (e[j] != 0.0) {\n            q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n        }\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    if (matrix == null) {\n        throw new IllegalArgumentException(\"matrix cannot be null\");\n    }\n\n    int n = matrix.getRowDimension();\n    if (n != matrix.getColumnDimension()) {\n        throw new IllegalArgumentException(\"matrix must be square\");\n    }\n\n    // Create a copy of the matrix to avoid modifying the original\n    RealMatrix m = matrix.copy();\n\n    // Initialize the eigenvalue vector\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = m.getEntry(i, i);\n        e[i] = 0.0;\n    }\n\n    // Initialize the eigenvector matrix\n    double[][] z = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = m.getEntry(i, j);\n        }\n    }\n\n    // Perform the QR iterations\n    for (int j = 0; j < n; j++) {\n        int m = j;\n        while (m < n - 1) {\n            double t;\n            double q;\n            if (FastMath.abs(e[m]) >= FastMath.abs(realEigenvalues[m] - realEigenvalues[m + 1])) {\n                q = realEigenvalues[m] - realEigenvalues[m + 1] + e[m] / (q + t);\n            } else {\n                q = realEigenvalues[m] - realEigenvalues[m + 1] + e[m + 1] / (q + t);\n            }\n            double u = 0.0;\n            double s = 1.0;\n            double c = 1.0;\n            for (int i = m - 1; i >= j; i--) {\n                double p = s * e[i];\n                double h = c * e[i];\n                if (FastMath.abs(p) >= FastMath.abs(q)) {\n                    c = q / p;\n}\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getColumnDimension();\n\n    // Initialize the result arrays.\n    double[][] z = new double[n][n];\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n\n    // Copy the matrix to the work array.\n    for (int i = 0; i < n; i++) {\n        System.arraycopy(matrix.getRowVector(i).toArray(), 0, z[i], 0, n);\n    }\n\n    // Initialize the eigenvalues array.\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrix.getEntry(i, i);\n    }\n\n    // Apply the Givens rotations.\n    for (int m = 0; m < n - 1; m++) {\n        for (int j = m + 1; j < n; j++) {\n            double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n            for (int i = m - 1; i >= j; i--) {\n                double p = s * e[i];\n                double h = c * e[i];\n                if (FastMath.abs(p) >= FastMath.abs(q)) {\n                    c = q / p;\n                    t = FastMath.sqrt(c * c + 1.0);\n                    e[i + 1] = p * t;\n                    s = 1.0 / t;\n                    c = c * s;\n                } else {\n                    s = p / q;\n                    t = FastMath.sqrt(s * s + 1.0);\n                    e[i + 1] = q * t;\n                    c = 1.0 / t;\n                    s = s * c;\n                }\n                if (e[i + 1] == 0.0) {\n                    realEigenvalues[i + 1] -= u;\n                    e[m] = 0.0;\n                    break;\n                }\n                q = realEigenvalues[i + 1] - u;\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    if (!matrix.isSquare())\n        throw new IllegalArgumentException(\"Matrix must be square\");\n\n    final int n = matrix.getColumnDimension();\n    final RealMatrix z = matrix.copy();\n    final double[] e = new double[n];\n    final double[] realEigenvalues = new double[n];\n\n    for (int j = 0; j < n; j++) {\n        e[j] = 0.0;\n    }\n    int m = 0;\n\n    do {\n        m++;\n        for (int i = m; i < n; i++) {\n            double q = realEigenvalues[m] - realEigenvalues[i] + e[i] / (q + t);\n            e[i] = q;\n        }\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n            if (e[i + 1] == 0.0) {\n                realEigenvalues[i + 1] -= u;\n                e[m] = 0.0;\n                break;\n            }\n            q = realEigenvalues[i + 1] - u;\n            t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n            u = s * t;\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    int n = matrix.getColumnDimension();\n    double[][] z = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            z[i][j] = matrix.getEntry(i, j);\n        }\n    }\n\n    double[] realEigenvalues = new double[n];\n    double[] e = new double[n];\n\n    for (int j = 0; j < n; j++) {\n        e[j] = 0.0;\n    }\n    e[0] = 1.0;\n\n    for (int m = 0; m < n - 1; m++) {\n        realEigenvalues[m] = z[m][m];\n        for (int j = m + 1; j < n; j++) {\n            realEigenvalues[j] = z[j][j];\n        }\n        double q = realEigenvalues[m];\n        for (int j = m + 1; j < n; j++) {\n            q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n        }\n        double u = 0.0;\n        double s = 1.0;\n        double c = 1.0;\n        int i;\n        for (i = m - 1; i >= j; i--) {\n            double p = s * e[i];\n            double h = c * e[i];\n            if (FastMath.abs(p) >= FastMath.abs(q)) {\n                c = q / p;\n                t = FastMath.sqrt(c * c + 1.0);\n                e[i + 1] = p * t;\n                s = 1.0 / t;\n                c = c * s;\n            } else {\n                s = p / q;\n                t = FastMath.sqrt(s * s + 1.0);\n                e[i + 1] = q * t;\n                c = 1.0 / t;\n                s = s * c;\n            }\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final int n = matrix.getColumnDimension();\n    final double[][] z = matrix.getData();\n    final double[] e = new double[n];\n    final double[] realEigenvalues = new double[n];\n    for (int m = 0; m < n; m++) {\n        e[m] = 0.0;\n    }\n    double maxAbsoluteValue;\n\n    for (int m = 0; m < n; m++) {\n        e[m] = 0.0;\n    }\n\n    //Transform to Hessenberg form\n    for (int j = 0; j < n - 1; j++) {\n        int m = j;\n        for (int i = j + 1; i < n; i++) {\n            if (Math.abs(realEigenvalues[i]) > Math.abs(realEigenvalues[m])) {\n                m = i;\n            }\n        }\n        if (m == j) {\n            continue;\n        }\n        for (int i = 0; i < m; i++) {\n            double p = z[i][m];\n            double h = z[i][j];\n            z[i][m] = p - h;\n            z[i][j] = p + h;\n        }\n        double q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n    }\n\n    //Sort the eigen values (and vectors) in increase order\n    for (int i = 0; i < n; i++) {\n        int k = i;\n        double p = realEigenvalues[i];\n        for (int j = i + 1; j < n; j++) {\n            if (realEigenvalues[j] > p) {\n                k = j;\n                p = realEigenvalues[j];\n            }\n        }\n        if (k != i) {\n            realEigenvalues[k] = realEigenvalues[i];\n            realEigenvalues[i] = p;\n            for (int j = 0; j < n; j++) {\n                p = z[j][i];\n                z[j][i] = z[j][k];\n}\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        EnumSet<E> bitset = processBitVector(enumClass, value);\n        result.addAll(bitset);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        result.addAll(processBitVector(enumClass, value));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) \n    {\n        for (int i = 0; i < Long.SIZE; i++) \n        {\n            if ((value & (1L << i)) != 0L) \n            {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        EnumSet<E> bitSet = processBitVector(enumClass, value);\n        result.addAll(bitFieldSet);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (E constant : enumClass.getEnumConstants()) {\n            if ((value & (1L << constant.ordinal())) != 0L) {\n                condensed.add(constant);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long bitvector : values) {\n        while (bitvector != 0) {\n            long leastSignificantBit = bitvector & -bitvector;\n            result.add(enumClass.getEnumConstants()[(int) (Long.numberOfTrailingZeros(leastSignificantBit) / Long.SIZE)]);\n            bitvector ^= leastSignificantBit;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if ((value & (1L << i)) != 0) {\n                result.add(EnumUtils.<E>checkBitVectorable(enumClass).getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values)\n    {\n        for (int i = 0; i < Long.SIZE; i++)\n        {\n            if ((value & (1L << i)) != 0L)\n            {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((value & (1L << e.ordinal())) != 0) {\n                condensed.add(e);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values)\n    {\n        result.addAll(processBitVector(enumClass, value));\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) newZone = DateTimeZone.getDefault();\n    \n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    \n    if (oldInstant == Long.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    }\n    \n    long localInstant = convertUTCToLocal(oldInstant);\n    long newInstant = convertLocalToUTC(localInstant, false, oldInstant);\n    \n    if (newInstant == Long.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    }\n    \n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) newZone = DateTimeZone.getDefault();\n    \n    Instant old = Instant.ofEpochMilli(oldInstant, ZoneOffset.UTC);\n    ZonedDateTime oldZdt = old.atZone(ZoneOffset.UTC);\n    ZonedDateTime newZdt = oldZdt.withZoneSameInstant(newZone);\n    return newZdt.toInstant().toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) newZone = DateTimeZone.getDefault();\n    \n    Instant oldInstantUTC = Instant.ofEpochMilli(oldInstant);\n    Instant localInstant = oldInstantUTC.withZone(newZone).toInstant();\n    return localInstant.toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    \n    DateTimeZone currentZone = DateTimeZone.getDefault();\n    \n    if (!currentZone.getID().equals(newZone.getID())) \n    {\n        int currentOffset = currentZone.getOffset(oldInstant);\n        int newOffset = newZone.getOffset(oldInstant);\n        if (currentOffset != newOffset) \n        {\n            long newInstant = oldInstant + (newOffset - currentOffset);\n            return newInstant;\n        }\n    }\n    return oldInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant, newZone);\n    return convertLocalToUTC(localMillis, true);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) newZone = DateTimeZone.getDefault();\n    \n    Instant old = Instant.ofEpochMilli(oldInstant);\n    Instant newInstant = old.atZone(newZone).toInstant();\n    \n    return newInstant.toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant, true);\n    long newInstant = convertLocalToUTC(localMillis, true, oldInstant);\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) newZone = DateTimeZone.getDefault();\n    \n    Instant old = Instant.ofEpochMilli(oldInstant).atZone(ZoneOffset.UTC).toInstant();\n    Instant newInstant = old.atZone(newZone).toInstant();\n    \n    return newInstant.toEpochMilli();\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    \n    long localInstant = convertUTCToLocal(oldInstant, newZone);\n    return convertLocalToUTC(localInstant, false, newZone);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    \n    int offset = getOffset(oldInstant);\n    int newOffset = newZone.getOffset(oldInstant);\n    \n    long millisLocal = oldInstant - offset;\n    long millisNew = millisLocal + (newOffset - offset);\n    \n    // Ensure the result is in the new zone\n    if (newZone.getID().equals(\"Etc/UTC\")) \n    {\n        return millisNew;\n    }\n    else \n    {\n        return convertLocalToUTC(millisNew, false);\n    }\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.HOUR)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        if (hours >= 23) {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n            calendar.add(Calendar.DATE, 1);\n        }\n        else {\n            calendar.set(Calendar.HOUR_OF_DAY, hours + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        int days = calendar.get(Calendar.DATE);\n        if (days >= calendar.getActualMaximum(Calendar.DATE)) {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n            calendar.add(Calendar.MONTH, 1);\n        }\n        else {\n            calendar.set(Calendar.DATE, days + 1);\n        }\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.set(Calendar.MILLISECOND, 0);\n        int month = calendar.get(Calendar.MONTH);\n        if (month >= 11) {\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    if (unit.equals(DateTickUnitType.HOUR)) {\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        int minutes = calendar.get(Calendar.MINUTE);\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DATE), hours + 1, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.HOUR_OF_DAY, hours);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        int minutes = calendar.get(Calendar.MINUTE);\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DATE), calendar.get(Calendar.HOUR_OF_DAY), minutes + 1, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.MINUTE, minutes);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DATE), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), seconds + 1);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.SECOND, seconds);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else {\n        return null;\n    }\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        int years = calendar.get(Calendar.YEAR);\n        int months = calendar.get(Calendar.MONTH);\n        int value = calendar.get(Calendar.DATE);\n        int hours = 0;\n        int minutes = 0;\n        int seconds = 0;\n        if (value == calendar.getActualMaximum(Calendar.DATE)) {\n            value = 1;\n            if (months == calendar.getActualMaximum(Calendar.MONTH)) {\n                months = 0;\n                years++;\n            } else {\n                months++;\n            }\n        } else {\n            value++;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.DATE, value - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    } else if (unit.equals(DateTickUnitType.MONTH)) {\n        int years = calendar.get(Calendar.YEAR);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, value, 1, 0, 0, 0);\n        Month month = new Month(calendar.getTime(), this.timeZone,\n                this.locale);\n        Date standardDate = calculateDateForPosition(\n                month, this.tickMarkPosition);\n        long millis = standardDate.getTime();\n        if (millis >= date.getTime()) {\n            month = (Month) month.previous();\n            // need to peg the month in case the time zone isn't the\n            // default - see bug 2078057\n            month.peg(Calendar.getInstance(this.timeZone));\n            standardDate = calculateDateForPosition(\n                    month, this.tickMarkPosition);\n        }\n        return standardDate;\n    } else if (unit.equals(DateTickUnitType.YEAR)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    Calendar calendar = Calendar.getInstance(this.timeZone);\n    calendar.setTime(date);\n\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        int seconds = calendar.get(Calendar.SECOND);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, seconds + 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        int minutes = calendar.get(Calendar.MINUTE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, minutes + 1);\n        calendar.set(Calendar.SECOND, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, hours + 1);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) {\n        int days = calendar.get(Calendar.DATE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.DATE, days + 1);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.WEEK)) {\n        int days = calendar.get(Calendar.DATE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.DATE, days + 7);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n    int years, months, days, hours, minutes, seconds;\n    if (t.equals(DateTickUnitType.DAY)) {\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, minutes, seconds);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.DATE, value - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (t.equals(DateTickUnitType.MONTH)) {\n        years = calendar.get(Calendar.YEAR);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, value, 1, 0, 0, 0);\n        Month month = new Month(calendar.getTime(), this.timeZone,\n                this.locale);\n        Date standardDate = calculateDateForPosition(\n                month, this.tickMarkPosition);\n        long millis = standardDate.getTime();\n        if (millis >= date.getTime()) {\n            month = (Month) month.previous();\n            // need to peg the month in case the time zone isn't the\n            // default - see bug 2078057\n            month.peg(Calendar.getInstance(this.timeZone));\n            standardDate = calculateDateForPosition(\n                    month, this.tickMarkPosition);\n        }\n        return standardDate;\n    }\n    else if (t.equals(DateTickUnitType.YEAR)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            months = 0;\n            days = 1;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            months = 6;\n            days = 1;\n        }\n        else {\n            months = 11;\n            days = 31;\n        }\n        calendar.clear(Calendar.MILLISECOND);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.HOUR)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n                calendar.get(Calendar.DATE), hours + 1, 0, 0);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            return d1;\n        }\n        else {\n            calendar.set(Calendar.HOUR_OF_DAY, hours - 23);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int minutes = calendar.get(Calendar.MINUTE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n                calendar.get(Calendar.DATE), calendar.get(Calendar.HOUR_OF_DAY),\n                minutes + 1, 0);\n        Date d1 = calendar.getTime();\n        if (d1.getTime() >= date.getTime()) {\n            return d1;\n        }\n        else {\n            calendar.set(Calendar.MINUTE, minutes - 59);\n            d1 = calendar.getTime();\n        }\n        return d1;\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int value = calendar.get(Calendar.DATE);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),\n                value + 1, 0, 0, 0);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            return d2;\n        }\n        else {\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int years = calendar.get(Calendar.YEAR);\n        int months = calendar.get(Calendar.MONTH);\n        int value = calendar.get(Calendar.DATE);\n        int hours = 23;\n        int minutes = 59;\n        int seconds = 59;\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, months, value, hours, 0, 0);\n        Date d2 = calendar.getTime();\n        if (d2.getTime() >= date.getTime()) {\n            calendar.set(Calendar.DATE, value - 1);\n            d2 = calendar.getTime();\n        }\n        return d2;\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        int years = calendar.get(Calendar.YEAR);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(years, value, 1, 0, 0, 0);\n        Month month = new Month(calendar.getTime(), this.timeZone,\n                this.locale);\n        Date standardDate = calculateDateForPosition(\n                month, this.tickMarkPosition);\n        long millis = standardDate.getTime();\n        if (millis >= date.getTime()) {\n            month = (Month) month.previous();\n            // need to peg the month in case the time zone isn't the\n            // default - see bug 2078057\n            month.peg(Calendar.getInstance(this.timeZone));\n            standardDate = calculateDateForPosition(\n                    month, this.tickMarkPosition);\n        }\n        return standardDate;\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            months = 0;\n            days = 1;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            months = 6;\n}\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTime(date);\n\n    if (unit.equals(DateTickUnitType.HOUR)) {\n        hours++;\n        if (hours > 23) {\n            hours = 0;\n            minutes++;\n            if (minutes > 59) {\n                minutes = 0;\n                seconds++;\n                if (seconds > 59) {\n                    seconds = 0;\n                    calendar.add(Calendar.DATE, 1);\n                }\n            }\n        }\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(hours, minutes, seconds, 0, 0, 0);\n        return calendar.getTime();\n    }\n\n    if (unit.equals(DateTickUnitType.DAY)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.DATE, 1);\n        return calendar.getTime();\n    }\n\n    if (unit.equals(DateTickUnitType.WEEK)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.DATE, 7);\n        return calendar.getTime();\n    }\n\n    if (unit.equals(DateTickUnitType.MONTH)) {\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.add(Calendar.MONTH, 1);\n        return calendar.getTime();\n    }\n\n    if (unit.equals(DateTickUnitType.YEAR)) {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.DAY)) {\n        int years = calendar.get(Calendar.YEAR);\n        int months = calendar.get(Calendar.MONTH);\n        int value = calendar.get(Calendar.DATE);\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        years = calendar.get(Calendar.YEAR);\n        months = calendar.get(Calendar.MONTH);\n        value = 1;\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        if (this.tickMarkPosition == DateTickMarkPosition.START) {\n            months = 0;\n            days = 1;\n        }\n        else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) {\n            months = 6;\n            days = 1;\n        }\n        else {\n            months = 11;\n            days = 31;\n        }\n        value = calendar.get(Calendar.YEAR);\n        hours = 0;\n        minutes = 0;\n        seconds = 0;\n    }\n    else {\n        return null;\n    }\n\n    calendar.clear(Calendar.MILLISECOND);\n    calendar.set(years, months, value, hours, 0, 0);\n    Date d2 = calendar.getTime();\n    if (d2.getTime() >= date.getTime()) {\n        calendar.set(Calendar.DATE, value - 1);\n        d2 = calendar.getTime();\n    }\n    return d2;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.SECOND)) {\n        int seconds = calendar.get(Calendar.SECOND) + 1;\n        int minutes = calendar.get(Calendar.MINUTE);\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.clear(Calendar.MILLISECOND);\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        Date d = calendar.getTime();\n        if (d.getTime() >= date.getTime()) {\n            return d;\n        }\n        else {\n            calendar.set(Calendar.SECOND, 0);\n            d = calendar.getTime();\n            if (d.getTime() >= date.getTime()) {\n                return d;\n            }\n            else {\n                calendar.set(Calendar.MINUTE, 0);\n                d = calendar.getTime();\n                if (d.getTime() >= date.getTime()) {\n                    return d;\n                }\n                else {\n                    calendar.set(Calendar.HOUR_OF_DAY, 0);\n                    d = calendar.getTime();\n                    if (d.getTime() >= date.getTime()) {\n                        return d;\n                    }\n                    else {\n                        calendar.set(Calendar.HOUR_OF_DAY, hours - 1);\n                        d = calendar.getTime();\n                        if (d.getTime() >= date.getTime()) {\n                            return d;\n                        }\n                        else {\n                            calendar.set(Calendar.HOUR_OF_DAY, 23);\n                            d = calendar.getTime();\n                            if (d.getTime() >= date.getTime()) {\n                                return d;\n                            }\n                            else {\n                                calendar.set(Calendar.HOUR_OF_DAY, 23);\n                                calendar.set(Calendar.MINUTE, 59);\n                                d = calendar.getTime();\n                                if (d.getTime() >= date.getTime()) {\n                                    return d;\n                                }\n                                else {\n                                    calendar.set(Calendar.HOUR_OF_DAY, 23);\n                                    calendar.set(Calendar.MINUTE, 59);\n}\n}\n}\n}\n}\n}\n}\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName, buf, startPos, endPos);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    //TODO: Implement logic to resolve the variable value based on the provided arguments.\n    //For example, you could use a variable resolver map or a database connection.\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final VariableResolver resolver = getVariableResolver();\n    final Object result = resolver.resolve(variableName);\n    if (result == null) {\n        return null;\n    }\n    final String variableValue = result.toString();\n    return variableValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final Map<String, String> resolver = getVariableResolver();\n    if (resolver != null) {\n        final String value = resolver.get(variableName);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName, buf, startPos, endPos);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName, buf, startPos, endPos);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final String var = getVariableResolver().resolve(variableName);\n    if (var == null) {\n        return null;\n    }\n    return var;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().resolve(variableName, buf, startPos, endPos);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // Resolve the variable name using the variable resolver\n    Object resolvedValue = getVariableResolver().resolve(variableName);\n    \n    // If the resolved value is not null, convert it to a string\n    if (resolvedValue != null) \n    {\n        return resolvedValue.toString();\n    }\n    \n    // If the resolved value is null, return null\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    // Remove non-alphabetic characters and convert to uppercase\n    str = str.replaceAll(\"[^A-Z]\", \"\").toUpperCase();\n\n    // Initialize soundex code\n    String soundexCode = \"\";\n\n    // Add first letter\n    if (!str.isEmpty()) {\n        soundexCode += str.charAt(0);\n    }\n\n    // Process remaining characters\n    for (int i = 1; i < str.length(); i++) {\n        char currentChar = str.charAt(i);\n        char previousChar = str.charAt(i - 1);\n\n        // Ignore consecutive identical letters\n        if (currentChar == previousChar) {\n            continue;\n        }\n\n        // Map current character to Soundex code\n        char soundexCodeChar = map(currentChar);\n\n        // Append code if it's different from the previous one\n        if (soundexCodeChar != soundexCode.charAt(soundexCode.length() - 1)) {\n            soundexCode += soundexCodeChar;\n        }\n    }\n\n    // Pad or truncate soundex code to the fixed length\n    while (soundexCode.length() < 4) {\n        soundexCode += \"0\";\n    }\n    if (soundexCode.length() > 4) {\n        soundexCode = soundexCode.substring(0, 4);\n    }\n\n    return soundexCode;\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return \"\";\n    }\n\n    final StringBuilder result = new StringBuilder(str.charAt(0));\n    final char[] soundexMapping = getSoundexMapping();\n\n    for (int i = 1; i < str.length(); i++) {\n        final char ch = Character.toUpperCase(str.charAt(i));\n        final char soundexCode = map(ch);\n\n        if (soundexCode != result.charAt(result.length() - 1)) {\n            result.append(soundexCode);\n        }\n    }\n\n    if (result.length() < 4) {\n        for (int i = result.length(); i < 4; i++) {\n            result.append(\"0\");\n        }\n    }\n\n    return result.toString();\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    StringBuilder builder = new StringBuilder(str.length());\n\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        char mapped = map(ch);\n        if ((i == 0) || (mapped != builder.charAt(builder.length() - 1))) {\n            builder.append(mapped);\n        }\n    }\n    return builder.toString();\n}",
      "public String soundex(String str)  {\n    // Implement the logic to calculate the Soundex code for the given String.\n    // Refer to the original code and the context provided.\n    // ...\n\n    // Return the calculated Soundex code.\n    return soundexCode;\n}",
      "public String soundex(String str)  {\n    // Convert to uppercase and trim leading spaces\n    str = str.toUpperCase().trim();\n    \n    // Create a new StringBuilder to hold the soundex code\n    StringBuilder soundexCode = new StringBuilder(4);\n    \n    // Add the first letter of the string\n    soundexCode.append(str.charAt(0));\n    \n    // Iterate through the remaining letters in the string\n    for (int i = 1; i < str.length(); i++)\n    {\n        // Get the current letter and the previous letter\n        char currentLetter = str.charAt(i);\n        char previousLetter = str.charAt(i - 1);\n        \n        // Ignore letters that are the same as the previous letter\n        if (currentLetter == previousLetter)\n        {\n            continue;\n        }\n        \n        // Map the current letter to its Soundex code\n        char soundexCodeLetter = map(currentLetter);\n        \n        // Ignore letters that are '0'\n        if (soundexCodeLetter == '0')\n        {\n            continue;\n        }\n        \n        // Add the Soundex code letter to the soundex code\n        soundexCode.append(soundexCodeLetter);\n    }\n    \n    // Pad the soundex code to a length of 4 with '0's\n    while (soundexCode.length() < 4)\n    {\n        soundexCode.append('0');\n    }\n    \n    // Return the soundex code\n    return soundexCode.toString();\n}",
      "public String soundex(String str)  {\n    // Convert to uppercase and remove non-alphabetic characters.\n    str = str.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n\n    // Initialize the soundex code.\n    StringBuilder soundexCode = new StringBuilder(str.substring(0, 1));\n\n    // Iterate through the remaining characters.\n    for (int i = 1; i < str.length(); i++) {\n        char currentLetter = str.charAt(i);\n        char previousLetter = soundexCode.charAt(soundexCode.length() - 1);\n\n        // Get the Soundex code for the current letter.\n        char currentSoundexCode = map(currentLetter);\n\n        // If the current letter is the same as the previous letter, skip it.\n        if (currentLetter == previousLetter) {\n            continue;\n        }\n\n        // Add the current Soundex code to the code.\n        soundexCode.append(currentSoundexCode);\n    }\n\n    // Pad the code with '9' until it reaches the maximum length.\n    while (soundexCode.length() < 4) {\n        soundexCode.append('9');\n    }\n\n    // Return the final soundex code.\n    return soundexCode.toString();\n}",
      "public String soundex(String str)  {\n    // Add '0' to the end of the string if it is shorter than 4 characters\n    if (str.length() < 4) \n    {\n        str += \"0\".repeat(4 - str.length());\n    }\n\n    // Initialize the soundex code to the first character of the input string\n    String soundexCode = Character.toString(str.charAt(0));\n\n    // Iterate through the remaining characters in the input string\n    for (int i = 1; i < str.length(); i++) \n    {\n        // Get the current character from the input string\n        char currentChar = str.charAt(i);\n\n        // Get the previous character from the soundex code\n        char previousChar = soundexCode.charAt(soundexCode.length() - 1);\n\n        // Map the current character to its Soundex code\n        char mappedChar = map(currentChar);\n\n        // If the current character is the same as the previous character, skip it\n        if (mappedChar == previousChar) \n        {\n            continue;\n        }\n\n        // If the current character is different from the previous character, add it to the soundex code\n        soundexCode += mappedChar;\n\n        // If the soundex code is now 4 characters long, stop iterating\n        if (soundexCode.length() == 4) \n        {\n            break;\n        }\n    }\n\n    // Return the soundex code\n    return soundexCode;\n}",
      "public String soundex(String str)  {\n    // Set the default soundex code to \"0000\"\n    String soundexCode = \"0000\";\n    \n    // Ensure the input string is not null\n    if (str != null) {\n        // Convert the string to uppercase to maintain consistency\n        str = str.toUpperCase();\n        \n        // Initialize the soundex code with the first character\n        soundexCode = str.substring(0, 1);\n        \n        // Iterate through the remaining characters\n        for (int i = 1; i < str.length(); i++) {\n            // Get the current character\n            char ch = str.charAt(i);\n            \n            // Map the character to its Soundex code\n            char code = map(ch);\n            \n            // Handle duplicate codes\n            if (code != soundexCode.charAt(soundexCode.length() - 1)) {\n                soundexCode += code;\n            }\n        }\n    }\n    \n    // Trim the soundex code to the maximum length (4 characters)\n    return soundexCode.substring(0, Math.min(soundexCode.length(), 4));\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    StringBuilder builder = new StringBuilder(str.charAt(0));\n    for (int i = 1; i < str.length(); i++)\n    {\n        char ch = str.charAt(i);\n        if (!Character.isAlphabetic(ch))\n        {\n            continue;\n        }\n        ch = map(ch);\n        if (builder.charAt(builder.length() - 1) != ch)\n        {\n            builder.append(ch);\n        }\n    }\n    if (builder.length() < 4)\n    {\n        while (builder.length() < 4)\n        {\n            builder.append('0');\n        }\n    }\n    return builder.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return \"\";\n    }\n\n    char[] result = new char[4];\n    result[0] = str.charAt(0);\n\n    int count = 1;\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        char code = map(ch);\n\n        if (code != result[count - 1]) {\n            result[count++] = code;\n        }\n    }\n\n    while (count < 4) {\n        result[count++] = '0';\n    }\n\n    return new String(result);\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    }\n    if (clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == byte[].class) {\n        return CORE_TYPE_BYTE_ARRAY;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INTEGER;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == int.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Collection.class) {\n        return CORE_TYPE_COLLECTION;\n    } else if (clz == Map.class) {\n        return CORE_TYPE_MAP;\n    } else if (clz == Reference.class) {\n        return CORE_TYPE_REFERENCE;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) \n    {\n        return CORE_TYPE_STRING;\n    } \n    else if (clz == Integer.class) \n    {\n        return CORE_TYPE_INT;\n    } \n    else if (clz == Double.class) \n    {\n        return CORE_TYPE_DOUBLE;\n    } \n    else if (clz == Boolean.class) \n    {\n        return CORE_TYPE_BOOLEAN;\n    } \n    else if (clz == Byte.class) \n    {\n        return CORE_TYPE_BYTE;\n    } \n    else if (clz == Short.class) \n    {\n        return CORE_TYPE_SHORT;\n    } \n    else if (clz == Long.class) \n    {\n        return CORE_TYPE_LONG;\n    } \n    else if (clz == Float.class) \n    {\n        return CORE_TYPE_FLOAT;\n    } \n    else if (clz == Object.class) \n    {\n        return CORE_TYPE_OBJECT;\n    } \n    else if (clz == void.class) \n    {\n        return CORE_TYPE_VOID;\n    } \n    else \n    {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == void.class) {\n        return CORE_TYPE_VOID;\n    } else if (clz == int.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == char.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz.isArray()) {\n        return CORE_TYPE_ARRAY;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == Byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == Character.class) {\n        return CORE_TYPE_CHAR;\n    } else if (clz == Short.class) {\n        return CORE_TYPE_SHORT;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == Double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == Void.class) {\n        return CORE_TYPE_VOID;\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) \n    {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class) \n    {\n        return CORE_TYPE_BOOLEAN;\n    }\n    if (clz == Byte.class) \n    {\n        return CORE_TYPE_BYTE;\n    }\n    if (clz == Short.class) \n    {\n        return CORE_TYPE_SHORT;\n    }\n    if (clz == Integer.class) \n    {\n        return CORE_TYPE_INTEGER;\n    }\n    if (clz == Long.class) \n    {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Float.class) \n    {\n        return CORE_TYPE_FLOAT;\n    }\n    if (clz == Double.class) \n    {\n        return CORE_TYPE_DOUBLE;\n    }\n    if (clz == Void.class) \n    {\n        return CORE_TYPE_VOID;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == boolean.class) {\n        return CORE_TYPE_BOOLEAN;\n    } else if (clz == int.class) {\n        return CORE_TYPE_INTEGER;\n    } else if (clz == double.class) {\n        return CORE_TYPE_DOUBLE;\n    } else if (clz == float.class) {\n        return CORE_TYPE_FLOAT;\n    } else if (clz == long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == byte.class) {\n        return CORE_TYPE_BYTE;\n    } else if (clz == short.class) {\n        return CORE_TYPE_SHORT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) \n    {\n        return CORE_TYPE_STRING;\n    } \n    else if (clz == Integer.class) \n    {\n        return CORE_TYPE_INT;\n    } \n    else if (clz == Double.class) \n    {\n        return CORE_TYPE_DOUBLE;\n    } \n    else if (clz == Boolean.class) \n    {\n        return CORE_TYPE_BOOLEAN;\n    } \n    else if (clz == Byte.class) \n    {\n        return CORE_TYPE_BYTE;\n    } \n    else if (clz == Character.class) \n    {\n        return CORE_TYPE_CHAR;\n    } \n    else if (clz == Short.class) \n    {\n        return CORE_TYPE_SHORT;\n    } \n    else if (clz == Long.class) \n    {\n        return CORE_TYPE_LONG;\n    } \n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        PrototypeMemberDeclaration prototypeMember = new PrototypeMemberDeclaration(n.getLhs(), n);\n        if (prototypeMember.memberName.equals(PATTERN_NAME)) {\n            return prototypeMember;\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof VariableInitializer) {\n      VariableInitializer initializer = (VariableInitializer) n;\n      if (initializer.getInitializer().getKind() == SyntaxKind.PROTOTYPE_MEMBER_DECLARATION) {\n        return new PrototypeMemberDeclaration(initializer.getInitializer(), initializer);\n      }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isPrototypeMemberDeclaration()) {\n    Node lhs = n.getPrototypeMemberDeclaration().getLHS();\n    return new PrototypeMemberDeclaration(lhs, n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        Node lhs = n.getLhs();\n        return new PrototypeMemberDeclaration(lhs, n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n instanceof VariableInitializer) {\n      VariableInitializer initializer = (VariableInitializer) n;\n      if (InitializerKind.ASSIGNMENT.is(initializer.getKind())\n          && initializer.getInitializer() != null\n          && initializer.getInitializer().isPrototypeMember()) {\n        return new PrototypeMemberDeclaration(initializer.getVariable(), initializer.getInitializer());\n      }\n    } else if (n instanceof ExpressionStatement) {\n      ExpressionStatement statement = (ExpressionStatement) n;\n      Expression expression = statement.getExpression();\n      if (expression.isPrototypeMember() && !expression.isFunction()) {\n        return new PrototypeMemberDeclaration(expression, expression);\n      }\n    } else if (n instanceof MethodCall) {\n      MethodCall methodCall = (MethodCall) n;\n      if (methodCall.isPrototypeMember()) {\n        return new PrototypeMemberDeclaration(methodCall.getReceiver(), methodCall);\n      }\n    }\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        Node lhs = n.getPrototypeMemberDeclaration().getLHS();\n        PrototypeMemberDeclaration prototypeMemberDeclaration =\n            new PrototypeMemberDeclaration(lhs, n);\n        return prototypeMemberDeclaration;\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n instanceof PrototypeMemberDeclaration) {\n    return (PrototypeMemberDeclaration) n;\n  }\n\n  if (n instanceof MethodDeclaration) {\n    MethodDeclaration method = (MethodDeclaration) n;\n    if (method.isConstructor()) {\n      return new PrototypeMemberDeclaration(method.getLhs(), method);\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isVariable()) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(n, n.getInitializer());\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n instanceof VariableInitializer) {\n    VariableInitializer initializer = (VariableInitializer) n;\n    if (initializer.getInitializer() instanceof MemberRef) {\n      MemberRef ref = (MemberRef) initializer.getInitializer();\n      if (ref.getName().equals(\"prototype\")\n          && ref.getQualifier() instanceof Name) {\n        Name name = (Name) ref.getQualifier();\n        return new PrototypeMemberDeclaration(initializer, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n instanceof PrototypeMemberDeclaration) \n  {\n    return (PrototypeMemberDeclaration) n;\n  }\n\n  if (n instanceof VariableInitializer) \n  {\n    VariableInitializer initializer = (VariableInitializer) n;\n    if (initializer.isPrototypeDeclaration()) \n    {\n      return new PrototypeMemberDeclaration(initializer.getVariable(), initializer.getNode());\n    }\n  }\n\n  if (n instanceof ExpressionStatement) \n  {\n    ExpressionStatement statement = (ExpressionStatement) n;\n    if (statement.isPrototypeDeclaration()) \n    {\n      return new PrototypeMemberDeclaration(statement.getExpression(), statement.getNode());\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int r = mat.getRowDimension();\n    final int c = mat.getColumnDimension();\n    final double[][] d = new double[n * r][m * c];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, new Array2DRowRealMatrix(d, false), j * c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension()*n][mat.getColumnDimension()*m];\n    for(int i=0; i<n;i++) {\n        for(int j=0; j<m;j++) {\n            copyColumn(mat, 0, new Array2DRowRealMatrix(d, false), j*mat.getColumnDimension()+i);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r += mat.getRowDimension()) {\n        for (int c = 0; c < cols; c += mat.getColumnDimension()) {\n            copyColumn(mat, 0, new Array2DRowRealMatrix(d, false), c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension()*n][mat.getColumnDimension()*m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int rr = 0; rr < n; rr++) {\n                for (int cc = 0; cc < m; cc++) {\n                    d[r*n+rr][c*m+cc] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int row = 0; row < n; row++) {\n        for (int col = 0; col < m; col++) {\n            copyColumn(mat, 0, d, col + row * mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int r = mat.getRowDimension();\n    final int c = mat.getColumnDimension();\n    final double[][] d = new double[r*n][c*m];\n    for (int j = 0; j < r*n; j++) {\n        for (int i = 0; i < c*m; i++) {\n            d[j][i] = mat.getEntry(j/n, i/m);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++) \n    {\n        for (int c = 0; c < cols; c++) \n        {\n            d[r][c] = mat.getEntry(r / n, c / m);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int j = 0; j < m; j++) {\n        for (int i = 0; i < n; i++) {\n            copyColumn(mat, 0, new Array2DRowRealMatrix(d, false), j * mat.getColumnDimension() + i);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension() * n; r++) {\n        for (int c = 0; c < mat.getColumnDimension() * m; c++) {\n            d[r][c] = mat.getEntry(r / n, c / m);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] result = new double[rows * n][cols * m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, new Array2DRowRealMatrix(result, false), j * rows + i);\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) <= 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    final int diff = current.bytesReadFromStream - (int) current.bytesRead;\n    return current.bytesRead > current.bytesReadFromStream ?\n           current.bytesRead + diff : current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  {\n    final int bytesRead = (int) current.bytesRead;\n    final int bytesReadFromStream = (int) current.bytesReadFromStream;\n    if (bytesReadFromStream >= bytesRead) {\n        return bytesRead;\n    }\n\n    final long diff = bytesRead - bytesReadFromStream;\n    if (diff >= Integer.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    }\n\n    return bytesReadFromStream + (int) inf.getBytesInflated();\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = in.getBytesInflated();\n    if (bytesInflated >= current.bytesReadFromStream)\n    {\n        return bytesInflated;\n    }\n\n    final long diff = current.bytesReadFromStream - bytesInflated;\n    if (diff >= Integer.MAX_VALUE)\n    {\n        return current.bytesReadFromStream;\n    }\n\n    final int diffAsInt = (int) diff;\n    final int read = in.read(buf.array(), 0, diffAsInt);\n    if (read != diffAsInt)\n    {\n        throw new EOFException(\"Truncated ZIP entry: \"\n                + ArchiveUtils.sanitize(current.entry.getName()));\n    }\n    count(read);\n    bytesInflated = in.getBytesInflated();\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n            ? getBytesInflatedFromInflater() : current.bytesRead;\n\n    final long diff = current.bytesReadFromStream - inB;\n\n    // Pushback any required bytes\n    if (diff > 0) \n    {\n        pushback(buf.array(), buf.limit() - diff, diff);\n        current.bytesReadFromStream -= diff;\n    }\n\n    return inB;\n}",
      "private long getBytesInflated()  {\n    final int bytesRead = (int) current.bytesReadFromStream;\n    if (bytesRead < 0) {\n        throw new IllegalStateException(\"negative bytesRead\");\n    }\n    if (bytesRead >= 0x7FFFFFFF) {\n        final long total = current.bytesRead;\n        final int lastRead = current.bytesReadFromStream - bytesRead;\n        if (lastRead >= 0 && lastRead < 0x7FFFFFFF) {\n            return total - lastRead;\n        } else {\n            // we can't assume that the total number of bytes read is\n            // smaller than 2^32.  Just return the number of bytes\n            // read so far.\n            return bytesRead;\n        }\n    } else {\n        // we can assume that the number of bytes consumed is smaller\n        // than or equal to the number of bytes read but not smaller\n        // by more than 2^32.\n        return bytesRead;\n    }\n}",
      "private long getBytesInflated()  {\n    final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED ? getBytesInflated() : current.bytesRead;\n    final long diff = (current.bytesReadFromStream - inB);\n    return current.bytesReadFromStream - Math.max(diff, 0);\n}",
      "private long getBytesInflated()  {\n    long ret = current.bytesReadFromStream;\n    final long diff = current.bytesReadFromStream - current.bytesRead;\n    if (diff > Integer.MAX_VALUE) {\n        ret = current.bytesRead;\n    } else {\n        ret += inf.getBytesInflated() - diff;\n    }\n    return ret;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = in.getBytesInflated();\n    if (bytesInflated >= current.bytesReadFromStream) \n    {\n        return bytesInflated;\n    }\n    long diff = current.bytesReadFromStream - bytesInflated;\n    if (diff > Integer.MAX_VALUE) \n    {\n        return Long.MAX_VALUE;\n    }\n    if (diff >= 0) \n    {\n        bytesInflated += diff;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final int totalRead = (int) current.bytesReadFromStream;\n    final long bytesRead = current.bytesRead;\n    final int diff = totalRead - bytesRead;\n\n    // Java 7 and later\n    if (bytesRead >= 2L << 32) {\n        return bytesRead - diff;\n    }\n\n    // Java 6 and earlier\n    if (bytesRead >= 4L << 24) {\n        final int bytesInflated = Math.max(0, inf.getBytesInflated() - diff);\n        final long totalBytesRead = current.bytesReadFromStream - bytesInflated;\n        if (totalBytesRead >= 4L << 24) {\n            return bytesRead - diff;\n        }\n    }\n\n    final int bytesInflated = Math.max(0, inf.getBytesInflated() - diff);\n\n    return bytesInflated >= totalRead ? bytesRead : bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long ret = current.bytesReadFromStream;\n    long bytesRead = current.bytesRead;\n\n    if (bytesRead > ret && bytesRead - ret >= 0x100000000L)\n    {\n        ret = bytesRead - 0x100000000L;\n    }\n    return ret;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return IterableUtils.isEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            return !it.hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) \n        {\n            return true;\n        }\n        if (object instanceof Map<?, ?>) \n        {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) \n        {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Object[]) \n        {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) \n        {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) \n        {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else \n        {\n            try \n            {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) \n            {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return IterableUtils.isEmpty((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return !it.hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return !((Iterable<?>) object).iterator().hasNext();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Map<?,?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        } else if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        } else if (object instanceof Iterable<?>) {\n            return !((Iterable<?>) object).iterator().hasNext();\n        } else if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        } else if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        } else if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        } else {\n            try {\n                return Array.getLength(object) == 0;\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n    }",
      "public static boolean sizeIsEmpty(final Object object)  {\n\tif (object == null) \n\t{\n\t\treturn true;\n\t}\n\tif (object instanceof Map<?, ?>) \n\t{\n\t\treturn ((Map<?, ?>) object).isEmpty();\n\t} \n\telse if (object instanceof Collection<?>) \n\t{\n\t\treturn ((Collection<?>) object).isEmpty();\n\t} \n\telse if (object instanceof Object[]) \n\t{\n\t\treturn ((Object[]) object).length == 0;\n\t} \n\telse if (object instanceof Iterator<?>) \n\t{\n\t\treturn !((Iterator<?>) object).hasNext();\n\t} \n\telse if (object instanceof Enumeration<?>) \n\t{\n\t\treturn !((Enumeration<?>) object).hasMoreElements();\n\t} \n\telse \n\t{\n\t\ttry \n\t\t{\n\t\t\treturn Array.getLength(object) == 0;\n\t\t} \n\t\tcatch (final IllegalArgumentException ex) \n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n\t\t}\n\t}\n\treturn false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        return !it.hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isQualifiedName(name) &&\n      TokenStream.isIdentifier(name.substring(0, name.lastIndexOf(\".\"))) &&\n      isValidSimpleName(name.substring(name.lastIndexOf(\".\")+1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  // Check that the name is in the correct format for qualified names.\n  return !name.contains(\".\") || (name.indexOf(\".\") == name.lastIndexOf(\".\") && name.endsWith(\".\"));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This logic is duplicated from\n    // Language.isValidQualifiedName. Decide if we need both.\n    return TokenStream.isQualifiedName(name) &&\n           !TokenStream.isKeyword(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!name.contains(\".\")) {\n        return isValidSimpleName(name);\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null) {\n    return false;\n  }\n  int len = name.length();\n  for (int index = 0; index < len; index++) {\n    char c = name.charAt(index);\n    if (c == '.') {\n      continue;\n    }\n    if (c > LARGEST_BASIC_LATIN) {\n      return false;\n    }\n  }\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isJSIdentifier(name) &&\n      !TokenStream.isKeyword(name) &&\n      // no Unicode escaped characters - some browsers are less tolerant\n      // of Unicode characters that might be valid according to the\n      // language spec.\n      // Note that by this point, Unicode escapes have been converted\n      // to UTF-16 characters, so we're only searching for character\n      // values, not escapes.\n      isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!TokenStream.isQualifiedName(name)) {\n        return false;\n    }\n    return TokenStream.isIdentifier(name) && !TokenStream.isKeyword(name) &&\n           isLatin(name);\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    hVec[il] = -1.0;\n    for (int i = il + 1; i <= iu; i++) {\n        hVec[i] = matrixT[i][il];\n    }\n\n    double t = -2.0 * matrixT[il][il + 1];\n    hVec[il + 1] += t;\n\n    for (int i = il + 2; i <= iu; i++) {\n        hVec[i] += t * matrixT[il][i];\n    }\n\n    return il + 1;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int k = iu - il + 2;\n    if (k == 0) {\n        k = matrixT.length - iu - 1;\n    }\n    hVec[0] = matrixT[iu][iu] - matrixT[iu + 1][iu + 1];\n    hVec[1] = matrixT[iu + 1][iu];\n\n    if (il < iu) {\n        hVec[2] = matrixT[il][iu];\n        hVec[3] = matrixT[il + 1][iu];\n        hVec[4] = matrixT[il + 1][il];\n    } else {\n        hVec[2] = hVec[3] = hVec[4] = 0.0;\n    }\n\n    hVec[5] = hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2] + hVec[3] * hVec[3] + hVec[4] * hVec[4];\n\n    if (hVec[5] == 0.0) {\n        hVec[5] = 1.0;\n        hVec[0] = 1.0;\n        hVec[1] = hVec[2] = hVec[3] = hVec[4] = 0.0;\n    } else {\n        hVec[5] = FastMath.sqrt(hVec[5]);\n        hVec[0] /= hVec[5];\n        hVec[1] /= hVec[5];\n        hVec[2] /= hVec[5];\n        hVec[3] /= hVec[5];\n        hVec[4] /= hVec[5];\n    }\n\n    return iu - k + 1;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double sx = shift.x;\n    double sy = shift.y;\n    double sw = shift.w;\n    boolean isShiftInv = (iu >= il && iu - il < 4);\n    int j = iu - 1;\n    for (int i = iu - 2; i >= il; i--) {\n        double t;\n        if (isShiftInv) {\n            t = sy / sx;\n        } else {\n            t = sy / (sx - matrixT[i + 1][i]);\n        }\n        double s = FastMath.abs(t) + 1.0;\n        s = 2.0 / s;\n        t *= s;\n        hVec[j] = t;\n        j--;\n        if (i > il) {\n            matrixT[i][i] -= t * matrixT[i + 1][i];\n        }\n        sy = sx;\n        sx = matrixT[i][i] - t * matrixT[i + 1][i + 1];\n    }\n    hVec[j] = sy / sx;\n    return j;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        int l = il;\n\n        // Initialize hVec\n        for (int j = iu; j <= il; j++) {\n            hVec[j] = matrixT[j][l];\n        }\n        hVec[l] += shift.x;\n\n        // Perform QR factorization\n        for (int m = iu; m < il; m++) {\n            final double h = -hVec[m + 1] / hVec[m];\n            for (int j = iu; j <= m; j++) {\n                hVec[j] += h * matrixT[j][m];\n            }\n            for (int j = m + 1; j <= il; j++) {\n                matrixT[j][m] += h * matrixT[j][m + 1];\n            }\n        }\n\n        return iu;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int is = iu + 1;\n    if (il < iu) {\n        hVec[iu] = matrixT[iu][il];\n        hVec[iu + 1] = matrixT[iu + 1][il];\n        is = il;\n    } else {\n        hVec[iu] = matrixT[iu][iu];\n        hVec[iu + 1] = 0.0;\n    }\n    return is;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int startIdx = iu - il + il;\n    double s = FastMath.abs(matrixT[iu][iu - 1]) + FastMath.abs(matrixT[iu - 1][iu - 2]);\n    for (int j = iu - 2; j > il; j--) {\n        hVec[j] = matrixT[iu][j];\n        hVec[j - 1] = matrixT[iu - 1][j - 1];\n    }\n    hVec[il] = matrixT[iu][il] - shift.x;\n    hVec[il - 1] = matrixT[iu - 1][il - 1] - shift.y;\n    hVec[iu] = -hVec[il];\n    hVec[iu - 1] = -hVec[il - 1];\n    s = s * 2.0;\n    for (int j = iu - 2; j >= il; j--) {\n        hVec[j] /= s;\n        hVec[j - 1] /= s;\n    }\n\n    return startIdx;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    hVec[iu] = matrixT[iu][iu] - shift.x;\n    hVec[il] = matrixT[il][il] - shift.x;\n    if (il < iu) {\n        hVec[iu - 1] = matrixT[iu - 1][iu - 1] - shift.x;\n        hVec[il + 1] = matrixT[il + 1][il + 1] - shift.x;\n        hVec[iu] += matrixT[iu][iu - 1] * matrixT[iu - 1][iu - 1] - matrixT[iu][il] * matrixT[il][il];\n        hVec[il] += matrixT[iu][il + 1] * matrixT[il + 1][il + 1] - matrixT[iu - 1][il] * matrixT[il][il];\n        hVec[iu - 1] += matrixT[iu - 1][iu] * matrixT[iu][iu - 1] - matrixT[iu - 1][il] * matrixT[il][il];\n        hVec[il + 1] += matrixT[il + 1][iu] * matrixT[iu][il + 1] - matrixT[il][il + 1] * matrixT[il + 1][il];\n    }\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double x, y, w;\n    hVec[iu] = 1.0;\n    if (il < iu) {\n        x = matrixT[iu - 1][iu - 1];\n        y = matrixT[iu][iu - 1];\n        w = y * y + x * x;\n        hVec[iu - 1] = y / FastMath.sqrt(w);\n        hVec[iu] = -x / FastMath.sqrt(w);\n    }\n    return iu - il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        // compute the shift and apply it to the matrix\n        computeShift(il, iu, 0, shift);\n\n        // adjust shift for subsequent iteration\n        if (il < iu) {\n            shift.y *= 0.5;\n            shift.w *= 0.25;\n        }\n\n        // compute the first element of the first house holder vector\n        hVec[0] = -shift.x - shift.y;\n        if (hVec[0] != 0.0) {\n            hVec[0] = 1.0 / FastMath.sqrt(hVec[0] * hVec[0] + shift.w * shift.w);\n        } else {\n            hVec[0] = 1.0;\n            shift.w = 0.0;\n        }\n\n        // compute the rest of the house holder vector\n        for (int i = 1; i < iu - il + 1; i++) {\n            hVec[i] = matrixT[iu - i][iu - il];\n            if (hVec[i] != 0.0) {\n                hVec[i] = -hVec[i];\n            }\n            hVec[i] -= shift.w;\n        }\n\n        return iu - il + 1;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    if (il < iu) {\n        hVec[iu] = shift.x;\n        hVec[iu - 1] = -shift.y;\n    } else {\n        hVec[il] = shift.x;\n    }\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n        {\n            textNodes.add((TextNode)node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return childNodes.stream()\n        .filter(node -> node instanceof TextNode)\n        .map(node -> (TextNode) node)\n        .collect(Collectors.toList());\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes)\n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes)\n    {\n        if (child instanceof TextNode)\n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    \n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node childNode : childNodes) \n    {\n        if (childNode instanceof TextNode) \n        {\n            textNodes.add((TextNode) childNode);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return childNodes.stream()\n        .filter(node -> node instanceof TextNode)\n        .map(node -> (TextNode) node)\n        .collect(Collectors.toList());\n}",
      "public List<TextNode> textNodes()  {\n    return textNodesList().stream().filter(TextNode.class::isInstance).map(TextNode.class::cast).toList();\n}",
      "public List<TextNode> textNodes()  {\n    return childNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .toList();\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n  long segmentNumber = this.segmentNumber;\n  long start = this.segmentStart;\n  long end = this.segmentEnd;\n\n  for (long i = 0; i < this.segmentCount; i++) {\n    Segment segment = getSegment(segmentNumber);\n    segmentNumber++;\n    if (!segment.isInIncludeSegment()) {\n      return false;\n    }\n  }\n  return true;\n}",
      "public boolean inIncludeSegments()  {\n\tfor(long i = segmentNumber; i <= segmentNumber + segmentCount; i++)\n\t{\n\t\tif(!isIncludedSegment(i))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
      "public boolean inIncludeSegments()  {\n\tfor(int i = calculateSegmentNumber(this.segmentStart); i <= calculateSegmentNumber(this.segmentEnd); i++)\n\t{\n\t\tSegment seg = getSegment(i);\n\t\tif (!seg.inIncludeSegment()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
      "public boolean inIncludeSegments()  {\n\treturn (this.segmentCount == (this.segmentEnd - this.segmentStart + 1));\n}",
      "public boolean inIncludeSegments()  {\n\tif (this.segmentCount == 0) \n\t{\n\t\treturn true;\n\t}\n\treturn (this.segmentStart == this.segmentEnd);\n}",
      "public boolean inIncludeSegments()  {\n\tfor(int i=0;i<segmentCount;i++) \n\t{\n\t\tSegment seg = getSegment(millisecond+i*segmentLength);\n\t\tif(seg.isException() || seg.isIncluded()==false) \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
      "public boolean inIncludeSegments()  {\n    return (this.segmentNumber >= this.segmentStart) \n        && (this.segmentNumber <= this.segmentEnd)\n        && (this.segmentNumber == this.millisecond);\n}",
      "public boolean inIncludeSegments()  {\n\tfor(long i = segmentNumber; i < segmentNumber + segmentCount; i++) {\n\t\tif(!segmentsMap.containsKey(i) || segmentsMap.get(i).getSegmentType() != SegmentType.INCLUDED) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
      "public boolean inIncludeSegments()  {\n    if (this.segmentCount <= 0) {\n        return false;\n    }\n    return this.millisecond >= this.segmentStart\n        && this.millisecond <= this.segmentEnd;\n}",
      "public boolean inIncludeSegments()  {\n  long start = this.segmentStart;\n  long end = this.segmentEnd;\n  for(long i = start; i<=end;i++) {\n     Segment seg = getSegment(i);\n     if (seg.isException()) {\n        return false;\n     }\n     if (!seg.isInSegment()) {\n        return false;\n     }\n  }\n  return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    PeriodType type = zeroInstance.getPeriodType();\n    MutablePeriod result = type.getZero().toMutablePeriod();\n    for (int i = 0; i < type.size(); i++) {\n        DurationField field = type.getField(i);\n        int amount = field.getDifference(end, start);\n        result.set(i, amount);\n    }\n    return result.toPeriod().get(zeroInstance.getFieldType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    if (!zeroInstance.getClass().isInstance(start)) {\n        throw new IllegalArgumentException(\"Start and zero instance must be of same type\");\n    }\n    if (!zeroInstance.getClass().isInstance(end)) {\n        throw new IllegalArgumentException(\"End and zero instance must be of same type\");\n    }\n\n    MutablePeriod mutablePeriod = zeroInstance.toMutablePeriod();\n    mutablePeriod.add(start);\n    mutablePeriod.minus(end);\n    return mutablePeriod.get(zeroInstance.getPeriodType().getField(field));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"Both arguments must have the same number of fields\");\n    }\n    PeriodType type = zeroInstance.getPeriodType();\n    MutablePeriod result = type.zero();\n    for (int i = 0; i < start.size(); i++) {\n        DurationField field = type.getField(i);\n        int startValue = start.get(field);\n        int endValue = end.get(field);\n        long durationMillis = field.getDifferenceAsLong(endValue, startValue);\n        if (durationMillis > Integer.MAX_VALUE || durationMillis < Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Duration value too large for an int: \" + durationMillis);\n        }\n        result.set(field, (int) durationMillis);\n    }\n    return result.get(field);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getPartialChronology(start);\n    MutablePeriod mutablePeriod = zeroInstance.toMutablePeriod();\n    for (DurationField field : zeroInstance.getFields()) {\n        long amount = field.getField(chrono).getDifference(end.getValue(field), start.getValue(field));\n        mutablePeriod.set(field, (int) amount);\n    }\n    return mutablePeriod.toPeriod().get(zeroInstance.getDurationFieldType());\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    PeriodType type = zeroInstance.getPeriodType();\n    if (!type.equals(start.getPeriodType()) || !type.equals(end.getPeriodType())) {\n        throw new IllegalArgumentException(\"Both partial objects must have the same type\");\n    }\n    MutablePeriod mutablePeriod = new MutablePeriod(zeroInstance);\n    mutablePeriod.add(start);\n    mutablePeriod.subtract(end);\n    return mutablePeriod.get(type.getField(0));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getPartialChronology(start);\n    MutablePeriod mutablePeriod = new MutablePeriod(zeroInstance.getPeriodType(), chrono);\n    mutablePeriod.add(start);\n    mutablePeriod.subtract(end);\n    int amount = mutablePeriod.get(getDurationField());\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    if (zeroInstance.getClass() != start.getClass()) {\n        throw new IllegalArgumentException(\"Zero instance constant must be of the same type as the start\");\n    }\n    MutablePeriod result = new MutablePeriod(zeroInstance);\n    for (int i = 0; i < start.size(); i++) {\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        if (startValue > endValue) {\n            result.set(i, startValue - endValue);\n        } else {\n            result.set(i, endValue - startValue);\n        }\n    }\n    return result.toPeriod().get(zeroInstance.getPeriodType().getField(0));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    MutablePeriod result = zeroInstance.toMutablePeriod();\n    for (int i = 0; i < start.size(); ++i) {\n        int startValue = start.get(i);\n        int endValue = end.get(i);\n        if (startValue != endValue) {\n            if (startValue > endValue) {\n                result.set(i, startValue - endValue);\n            } else {\n                result.set(i, endValue - startValue);\n            }\n        }\n    }\n    return result.toPeriod().get(zeroInstance.getFieldType(0));\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance constant must not be null\");\n    }\n    PeriodType type = zeroInstance.getPeriodType();\n    int amount = type.getField(0).getDifference(end.get(0), start.get(0));\n    for (int i = 1; i < type.size(); i++) {\n        amount = amount * 60 + type.getField(i).getDifference(end.get(i), start.get(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    PeriodType periodType = zeroInstance.getPeriodType();\n    MutablePeriod mutablePeriod = new MutablePeriod(periodType);\n    for (DurationField field : periodType.getFields()) {\n        mutablePeriod.set(field, between(start, end, field));\n    }\n    return mutablePeriod.toPeriod().compareTo(zeroInstance) >= 0 ? mutablePeriod.toPeriod().get(periodType.getField(iFieldIndex)) : -mutablePeriod.toPeriod().get(periodType.getField(iFieldIndex));\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubTitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (subtitles.isEmpty())\n    {\n        return null;\n    }\n    if (index >= subtitles.size())\n    {\n        throw new IndexOutOfBoundsException(\"No legend exists for index: \"+index);\n    }\n    return (LegendTitle)subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < getSubtitleCount()) {\n        Title title = getSubtitle(index);\n        if (title instanceof LegendTitle) {\n            return (LegendTitle) title;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subplots.isEmpty()) {\n        return null;\n    }\n    return this.subplots.get(index).getLegend();\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < legends.size()) {\n        return legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < legends.size())\n    {\n        return legends.get(index);\n    }\n    else\n    {\n        return null;\n    }\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else if (token == JsDocToken.LC) {\n    if (!match(JsDocToken.ELLIPSIS)) {\n      reportTypeSyntaxWarning(\"msg.jsdoc.invalid.ellipsis.in.param\");\n    } else {\n      next();\n      skipEOLs();\n    }\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return null;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n\n      if (match(JsDocToken.ELLIPSIS)) {\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n\n        return typeNode;\n      } else {\n        Node optionalParameter = parseOptionalParameterType(token);\n        if (optionalParameter != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n\n        return optionalParameter;\n      }\n    } else {\n      Node typeNode = parseTopLevelTypeExpression(token);\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n\n    if (match(JsDocToken.ELLIPSIS)) \n    {\n      JsDocToken nextToken = next();\n      Node typeNode = parseTopLevelTypeExpression(nextToken);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else \n        {\n          next();\n        }\n\n        return typeNode;\n      }\n    } \n    else \n    {\n      Node typeNode = parseOptionalParameterType(token);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else \n        {\n          next();\n        }\n\n        return typeNode;\n      }\n    }\n  }\n\n  return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else \n                {\n                    next();\n                }\n            }\n            return new Annotation(Kind.ELLIPSIS, null, typeNode);\n        } \n        else \n        {\n            Node node = parseOptionalParameterType();\n            if (node != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else \n                {\n                    next();\n                }\n            }\n            return node;\n        }\n    } else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      Node optParamNode = parseOptionalParameterType(next());\n      if (optParamNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return optParamNode;\n    }\n  } else {\n    Node typeNode = parseTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            next();\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else \n            {\n                next();\n            }\n            return Node.create(Node.ELLIPSIS_TOKEN, \"...\");\n        } else \n        {\n            Node typeNode = parseOptionalParameterType(next());\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else \n                {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else if (token == JsDocToken.LC) {\n    skipEOLs();\n    typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n    }\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      reportTypeSyntaxError(\"msg.jsdoc.expected.top.level.type\");\n      return null;\n    }\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    if (match(JsDocToken.ELLIPSIS)) {\n      next();\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      Node typeNode = parseOptionalParameterType(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    }\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(next());\n\n            skipEOLs();\n\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n\n            return new Annotation(TypeExpressionAnnotation.ELLIPSIS_PARAMETER_TYPE, null, typeNode);\n        } \n        else \n        {\n            Node optionalParameterType = null;\n\n            if (match(JsDocToken.EQ)) \n            {\n                next();\n                optionalParameterType = parseTopLevelTypeExpression(next());\n            } \n            else \n            {\n                optionalParameterType = parseTopLevelTypeExpression(token);\n            }\n\n            skipEOLs();\n\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n\n            return new Annotation(TypeExpressionAnnotation.OPTIONAL_PARAMETER_TYPE, optionalParameterType, null);\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n\n    if (match(JsDocToken.ELLIPSIS)) \n    {\n      token = next();\n      Node typeNode = parseTopLevelTypeExpression(token);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else \n        {\n          next();\n        }\n\n        return new Annotation(Annotation.ELLIPSIS, typeNode);\n      }\n\n      return reportTypeSyntaxError(\"msg.jsdoc.invalid.ellipsis.param.type\");\n    } else \n    {\n      Node optionalParameterType = parseOptionalParameterType(token);\n      if (optionalParameterType != null) \n      {\n        return optionalParameterType;\n      }\n\n      Node typeNode = parseTopLevelTypeExpression(token);\n      if (typeNode != null) \n      {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) \n        {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else \n        {\n          next();\n        }\n\n        return typeNode;\n      }\n    }\n\n    return reportTypeSyntaxError(\"msg.jsdoc.missing.param.type\");\n  }\n\n  return null;\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> lines = Arrays.asList(getStackFrames(t));\n    List<String> result = new ArrayList<String>();\n\n    for (String line : lines) {\n        if (!line.startsWith(\"at \")) {\n            result.add(line);\n        }\n    }\n\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = getStackFrames(t);\n    List<String> result = new ArrayList<>(stackFrames.size());\n    for (int i = stackFrames.size() - 1; i >= 0; i--) \n    {\n        result.add(stackFrames.get(i));\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = getStackFrames(t);\n    List<String> result = new ArrayList<>(stackFrames.size());\n    for (int i = 0; i < stackFrames.size(); i++) \n    {\n        String line = stackFrames.get(i);\n        if (line.startsWith(\"at \")) \n        {\n            result.add(line);\n        }\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> lines = new ArrayList<String>();\n    List<String> frames = getStackFrames(t);\n    for (String frame : frames) \n    {\n        if (!frame.startsWith(\"at \"))\n        {\n            lines.add(frame);\n        }\n    }\n    return lines;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<>();\n    for (StackTraceElement frame : t.getStackTrace()) {\n        frames.add(frame.toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFramesList = new ArrayList<>();\n    String stackTrace = getStackTrace(t);\n    String[] stackFramesArray = getStackFrames(stackTrace);\n    for (int i = 0; i < stackFramesArray.length; i++)\n    {\n        String currentLine = stackFramesArray[i];\n        if (!currentLine.startsWith(\"Caused by:\") && !currentLine.startsWith(\"at \"))\n        {\n            stackFramesList.add(currentLine);\n        }\n    }\n    return stackFramesList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> lines = Arrays.asList(getStackFrames(t));\n    List<String> result = new ArrayList<>();\n    for (String line : lines) \n    {\n        if (!line.trim().startsWith(\"at\"))\n        {\n            result.add(line);\n        }\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frameList = new ArrayList<>();\n    if (t != null) \n    {\n        String exceptionTrace = getStackTrace(t);\n        String[] stackFrames = getStackFrames(exceptionTrace);\n        for (String frame : stackFrames) \n        {\n            if (!frame.startsWith(\"Caused by\"))\n            {\n                frameList.add(frame);\n            }\n        }\n    }\n    return frameList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> traceList = new ArrayList<>();\n    String[] stackFrames = getStackFrames(t);\n    for (int i = 0; i < stackFrames.length; i++) \n    {\n        if (i != 0) \n        {\n            traceList.add(stackFrames[i]);\n        }\n    }\n    return traceList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFramesList = new ArrayList<>();\n    List<String> causeFramesList = new ArrayList<>();\n    List<String> causeStackTraceList = new ArrayList<>();\n    List<String> wrapperFramesList = new ArrayList<>();\n    List<String> wrapperStackTraceList = new ArrayList<>();\n    List<String> resultFramesList = new ArrayList<>();\n    \n    if (t != null) \n    {\n        String[] frames = getStackFrames(t);\n        for (String frame : frames) \n        {\n            stackFramesList.add(frame);\n        }\n    }\n    \n    if (t.getCause() != null) \n    {\n        String[] causeFrames = getStackFrames(t.getCause());\n        for (String causeFrame : causeFrames) \n        {\n            causeFramesList.add(causeFrame);\n        }\n    }\n    \n    if (t.getCause() != null) \n    {\n        String[] causeStackTrace = getStackTrace(t.getCause()).split(\"\\n\");\n        for (String causeStackTraceLine : causeStackTrace) \n        {\n            causeStackTraceList.add(causeStackTraceLine);\n        }\n    }\n    \n    if (t.getStackTrace() != null) \n    {\n        String[] wrapperFrames = getStackFrames(t);\n        for (String wrapperFrame : wrapperFrames) \n        {\n            wrapperFramesList.add(wrapperFrame);\n        }\n    }\n    \n    if (t.getStackTrace() != null) \n    {\n        String[] wrapperStackTrace = getStackTrace(t).split(\"\\n\");\n        for (String wrapperStackTraceLine : wrapperStackTrace) \n        {\n            wrapperStackTraceList.add(wrapperStackTraceLine);\n        }\n    }\n    \n    removeCommonFrames(causeFramesList, wrapperFramesList);\n    \n    for (int i = wrapperStackTraceList.size() - 1; i >= 0; i--) \n    {\n        String line = wrapperStackTraceList.get(i);\n        if (line.contains(\"at\")) \n        {\n            resultFramesList.add(line);\n        }\n        else \n        {\n            break;\n        }\n    }\n    \n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    boolean result;\n    if (p == PEEKED_TRUE) {\n        result = true;\n    } else if (p == PEEKED_FALSE) {\n        result = false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE)\n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE)\n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  boolean result;\n  if (p == PEEKED_TRUE) {\n    result = true;\n  } else if (p == PEEKED_FALSE) {\n    result = false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) \n    {\n        result = true;\n    } else if (p == PEEKED_FALSE) \n    {\n        result = false;\n    } else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n  {\n    p = doPeek();\n  }\n  boolean result;\n  if (p == PEEKED_TRUE)\n  {\n    result = true;\n  }\n  else if (p == PEEKED_FALSE)\n  {\n    result = false;\n  }\n  else\n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    boolean result;\n    if (p == PEEKED_TRUE) {\n      result = true;\n      nextTrue();\n    } else if (p == PEEKED_FALSE) {\n      result = false;\n      nextFalse();\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE)\n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    }\n    else if (p == PEEKED_FALSE)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) \n    {\n        return null;\n    }\n    \n    if (size < 0) \n    {\n        size = 0;\n    }\n\n    int strLen = length(str);\n    \n    if (strLen >= size) \n    {\n        return str;\n    }\n    \n    int padLen = size - strLen;\n    \n    if (padLen <= 0) \n    {\n        return str;\n    }\n    \n    char[] padding = new char[padLen];\n    \n    for (int i = 0; i < padLen; i++) \n    {\n        padding[i] = padChar;\n    }\n    \n    return new String(padding) + str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int strLen = str.length();\n\n    if (size <= strLen) {\n        return str;\n    }\n\n    final int padLen = size - strLen;\n\n    if (padLen % 2 == 0) {\n        final String leftPad = new StringBuilder(padLen / 2).append(padChar).toString();\n        final String rightPad = leftPad;\n        return leftPad + str + rightPad;\n    } else {\n        final String leftPad = new StringBuilder(padLen / 2).append(padChar).toString();\n        final String rightPad = leftPad;\n        return leftPad + str + rightPad + padChar;\n    }\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) \n    {\n        return null;\n    }\n    int strLen = str.length();\n    if (size <= strLen) \n    {\n        return str;\n    }\n    int padLength = size - strLen;\n    StringBuilder paddedStr = new StringBuilder(size);\n    for (int i = 0; i < padLength / 2; i++) \n    {\n        paddedStr.append(padChar);\n    }\n    paddedStr.append(str);\n    for (int i = padLength / 2; i < padLength; i++) \n    {\n        paddedStr.append(padChar);\n    }\n    return paddedStr.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) \n    {\n        return null;\n    }\n    int strLen = length(str);\n    if (size < 0) \n    {\n        size = 0;\n    }\n    if (strLen >= size) \n    {\n        return str;\n    }\n    int padLen = size - strLen;\n    char[] padding = new char[padLen];\n    for (int i = 0; i < padLen; i++) \n    {\n        padding[i] = padChar;\n    }\n    return new String(padding).concat(str);\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n\n    int strLen = str.length();\n\n    if (size <= strLen) {\n        return str;\n    }\n\n    int padLen = size - strLen;\n    char[] padding = new char[padLen];\n\n    for (int i = 0; i < padLen; i++) {\n        padding[i] = padChar;\n    }\n\n    return new StringBuilder(padding).append(str).toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size < 0) {\n        size = 0;\n    }\n    if (size <= str.length()) {\n        return str;\n    }\n    int padLen = size - str.length();\n    if (padLen <= 0) {\n        return str;\n    }\n    StringBuilder buf = new StringBuilder(size);\n    for (int i = 0; i < padLen / 2; i++) {\n        buf.append(padChar);\n    }\n    buf.append(str);\n    for (int i = padLen / 2; i < padLen; i++) {\n        buf.append(padChar);\n    }\n    return buf.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n\n    int strLen = length(str);\n\n    if (size <= strLen) {\n        return str;\n    }\n\n    int padLen = size - strLen;\n    char[] padding = new char[padLen];\n\n    for (int i = 0; i < padLen; i++) {\n        padding[i] = padChar;\n    }\n\n    return new String(padding) + str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (size <= 0) \n    {\n        return str;\n    }\n    if (str.length() >= size) \n    {\n        return str;\n    }\n    int padLength = (size - str.length()) / 2;\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < padLength; i++) \n    {\n        builder.append(padChar);\n    }\n    builder.append(str);\n    for (int i = 0; i < padLength + (size - str.length()) % 2; i++) \n    {\n        builder.append(padChar);\n    }\n    return builder.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n    if (size <= 0) {\n        size = 0;\n    }\n    if (size >= str.length()) {\n        return str;\n    }\n    int padLength = size - str.length();\n    StringBuilder sb = new StringBuilder(size);\n    for (int i = 0; i < (padLength / 2); i++) {\n        sb.append(padChar);\n    }\n    sb.append(str);\n    for (int i = 0; i < (padLength / 2) + (padLength % 2); i++) {\n        sb.append(padChar);\n    }\n    return sb.toString();\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int strLen = str.length();\n\n    if (size <= strLen) {\n        return str;\n    }\n\n    int padLen = size - strLen;\n\n    char[] padding = new char[padLen];\n\n    for (int i = 0; i < padLen; i++) {\n        padding[i] = padChar;\n    }\n\n    return new String(padding) + str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node obj = call.getFirstChild();\n  if (!obj.isVarRef()) {\n    return true; // Function calls have side effects if the object is not a varref\n  }\n\n  // Check if the object is used elsewhere in the method\n  if (NodeUtil.isExprCall(call.getParent())) {\n    return true;\n  }\n\n  // Check if the object is a local variable\n  VarSymbol sym = SymbolTable.lookupVariable(call.getSourceInfo(), call.getFirstChild().getName());\n  if (sym instanceof LocalSymbol && sym.isLocal()) {\n    return true;\n  }\n\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg : call.getArgs()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node[] arguments = call.getLastChild().getChildren();\n  for (Node argument : arguments)\n  {\n    if (!NodeUtil.argsMayHaveSideEffects(argument))\n    {\n      return false;\n    }\n  }\n  return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  if (!call.isCall()) {\n    return false;\n  }\n\n  List<Node> args = call.getChildren().subList(1, call.getChildCount());\n  for (Node arg : args) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  List<Node> children = call.getChildren();\n  for(int i = 1; i < children.size(); i++) {\n    if(NodeUtil.mayHaveSideEffects(children.get(i))) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  return compiler.mayHaveSideEffects(call.getChildren().get(1));\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  if (!call.isCall()) \n  {\n    return false;\n  }\n\n  Node callee = call.getSecondChild();\n  if (callee.isGetProp()) \n  {\n    return true;\n  }\n\n  List<Node> args = call.getChildNodes(1);\n  for (Node arg : args) \n  {\n    if (compiler.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node[] args = call.getChildren().toArray(new Node[call.getChildCount()]);\n  for (Node arg : args) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg))\n      return true;\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  List<Node> args = call.getLastChild().getChildren();\n  for(Node arg:args)\n  {\n    if(NodeUtil.isVar(arg))\n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node fn = call.getFirstChild();\n\n  // Check if the method is empty, if so, return false.\n  if (isEmptyMethod(fn)) {\n    return false;\n  }\n\n  // Check if the method block is null, if so, return true.\n  Node expectedBlock = getMethodBlock(fn);\n  if (expectedBlock == null) {\n    return true;\n  }\n\n  // Check if the block is empty, if so, return true.\n  if (NodeUtil.isEmptyBlock(expectedBlock)) {\n    return true;\n  }\n\n  // Check if the method arguments have side effects.\n  for (Node arg : call.getLastChild().getChildren()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedP.setEntry(i, j, field.getZero());\n            }\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int row = 0; row < m; row++) \n        {\n            for (int col = 0; col < m; col++) \n            {\n                if (col == pivot[row]) \n                {\n                    cachedP.setEntry(row, col, field.getOne());\n                }\n                else \n                {\n                    cachedP.setEntry(row, col, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final int p = pivot[i];\n            cachedP.setEntry(i, p, field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final T[] luI = lu[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedP.setEntry(i, j, field.getZero());\n            }\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n\n        for (int i = 0; i < m; ++i) {\n            final T[] luI = lu[i];\n            int j = i;\n            if (luI[j].equals(field.getZero())) {\n                j = getPivot()[i] + j;\n            }\n            cachedP.setEntry(i, j, field.getOne());\n        }\n    }\n\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int j = 0; j < m; ++j) \n        {\n            cachedP.setEntry(j, pivot[j], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if (cachedP == null) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cachedP.setEntry(i, j, field.getZero());\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final List<Byte> mergedLocalFileData = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        if (ze.getCentralDirectoryLength() == -1) {\n            mergedLocalFileData.addAll(Arrays.asList(ze.getLocalFileData()));\n        }\n    }\n    final byte[] result = new byte[mergedLocalFileData.size()];\n    int i = 0;\n    for (final byte b : mergedLocalFileData) {\n        result[i++] = b;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final List<Byte> result = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            if (ze instanceof LocalFileDataExtraField) {\n                final LocalFileDataExtraField lfe = (LocalFileDataExtraField) ze;\n                result.addAll(Arrays.asList(lfe.getLocalFileData()));\n            } else {\n                throw new ZipException(\"only local file data extra fields\"\n                        + \" are supported\");\n            }\n        }\n        final byte[] bytes = new byte[result.size()];\n        for (int i = 0; i < result.size(); i++) {\n            bytes[i] = result.get(i);\n        }\n        return bytes;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    if (data == null) {\n        return null;\n    }\n    List<byte[]> fieldData = new ArrayList<>();\n    for (ZipExtraField zef : data) {\n        if (zef instanceof LocalFileDataExtraField) {\n            fieldData.add(((LocalFileDataExtraField)zef).getData());\n        }\n    }\n    if (fieldData.isEmpty()) {\n        return null;\n    }\n    byte[] result = new byte[0];\n    for (byte[] b : fieldData) {\n        byte[] newResult = new byte[result.length + b.length];\n        System.arraycopy(result, 0, newResult, 0, result.length);\n        System.arraycopy(b, 0, newResult, result.length, b.length);\n        result = newResult;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final List<Byte> out = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            if (ze instanceof LocalFileDataExtraField) {\n                final LocalFileDataExtraField lfe = (LocalFileDataExtraField) ze;\n                final byte[] bytes = lfe.getLocalFileData();\n                out.addAll(Arrays.asList(bytes));\n            }\n        }\n        final byte[] result = new byte[out.size()];\n        int i = 0;\n        for (final byte b : out) {\n            result[i++] = b;\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws IOException {\n    List<Byte> merged = new ArrayList<>();\n    for (final ZipExtraField f : data) {\n        if (f instanceof UnparseableExtraField) {\n            final UnparseableExtraField u = (UnparseableExtraField) f;\n            u.parseFromLocalFileData(merged.toByteArray(), 0, merged.size());\n        }\n    }\n    return merged.toByteArray();\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    if (data == null || data.length == 0) {\n        return new byte[0];\n    }\n    int totalLength = 0;\n    for (int i = 0; i < data.length; ++i) {\n        totalLength += data[i].getLocalFileDataLength();\n    }\n    final byte[] result = new byte[totalLength];\n    int offset = 0;\n    for (final ZipExtraField ze : data) {\n        final byte[] fieldData = ze.getLocalFileData();\n        if (fieldData != null && fieldData.length > 0) {\n            System.arraycopy(fieldData, 0, result, offset, fieldData.length);\n            offset += fieldData.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final List<Byte> list = new ArrayList<>();\n    for (final ZipExtraField f : data) {\n        if (f instanceof LocalFileDataExtraField) {\n            list.add(((LocalFileDataExtraField) f).getLocalFileDataData().getData(0));\n        }\n    }\n    final byte[] result = new byte[list.size()];\n    int pos = 0;\n    for (final byte b : list) {\n        result[pos++] = b;\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    if (data == null || data.length == 0) {\n        return new byte[0];\n    }\n    final List<byte[]> localData = new ArrayList<>();\n    for (final ZipExtraField ze : data) {\n        if (ze instanceof UnparseableExtraField) {\n            final UnparseableExtraField uze = (UnparseableExtraField) ze;\n            localData.add(uze.getLocalFileData());\n        } else {\n            final ZipLocalFileData ze2 = (ZipLocalFileData) ze;\n            localData.add(ze2.getData());\n        }\n    }\n    byte[] mergedData = new byte[0];\n    for (final byte[] bytes : localData) {\n        mergedData = ArrayUtils.addAll(mergedData, bytes);\n    }\n    return mergedData;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n        final List<Byte> v = new ArrayList<>();\n        for (final ZipExtraField ze : data) {\n            if (ze instanceof LocalFileDataExtraField) {\n                final LocalFileDataExtraField lfe = (LocalFileDataExtraField) ze;\n                final byte[] lfd = lfe.getLocalFileData();\n                if (lfd != null) {\n                    v.addAll(Arrays.asList(lfd));\n                }\n            } else {\n                final UnparseableExtraFieldData field = new UnparseableExtraFieldData();\n                field.parseFromCentralDirectoryData(ze.getHeaderId().getBytes(), 0, 2)\n                     .parseFromCentralDirectoryData(ze.getData(), 0, ze.getData().length);\n                final byte[] lfd = field.getLocalFileData();\n                if (lfd != null) {\n                    v.addAll(Arrays.asList(lfd));\n                }\n            }\n        }\n        final byte[] result = new byte[v.size()];\n        return v.toArray(result);\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  throws ZipException {\n    final List<Byte> bytes = new ArrayList<>();\n    for (final ZipExtraField f : data) {\n        if (f instanceof LocalFileDataExtraField) {\n            final LocalFileDataExtraField l = (LocalFileDataExtraField) f;\n            for (final byte b : l.getData()) {\n                bytes.add(b);\n            }\n        }\n    }\n    final byte[] result = new byte[bytes.size()];\n    int i = 0;\n    for (final byte b : bytes) {\n        result[i++] = b;\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? sup : Double.POSITIVE_INFINITY;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.isReady = true;\n    StringBuilder content = token.content;\n\n    boolean escape = false;\n    boolean endReached = false;\n\n    while (!endReached) {\n        switch (ch) {\n            case '\\n':\n                content.append('\\n');\n                endReached = true;\n                break;\n            case '\\r':\n                if (reader.read() == '\\n') {\n                    content.append('\\r');\n                    content.append('\\n');\n                } else {\n                    content.append('\\r');\n                }\n                endReached = true;\n                break;\n            case '\\\\':\n                escape = true;\n                break;\n            case '\"':\n            case '\\'':\n                if (escape) {\n                    content.append(ch);\n                    escape = false;\n                } else {\n                    endReached = true;\n                    break;\n                }\n            default:\n                if (isDelimiter(ch)) {\n                    if (escape) {\n                        content.append('\\\\');\n                        escape = false;\n                    }\n                    endReached = true;\n                    break;\n                } else {\n                    content.append((char) ch);\n                }\n        }\n        ch = reader.read();\n    }\n\n    token.type = TOKEN;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    StringBuilder content = token.content;\n\n    boolean escapeNext = false;\n\n    while (true) {\n        if (escapeNext) {\n            content.append((char) ch);\n            escapeNext = false;\n        } else if (ch == ESCAPE_CHAR) {\n            escapeNext = true;\n        } else if (isDelimiter(ch)) {\n            if (isEndOfLine(ch)) {\n                // end of line reached\n                token.type = EORECORD;\n            } else {\n                // unescaped delimiter reached\n                token.type = TOKEN;\n            }\n            break;\n        } else if (isEndOfFile(ch)) {\n            // end of stream reached\n            token.type = EOF;\n            token.isReady = true;\n            break;\n        } else {\n            content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean escapeNext = false;\n\n    while (true) {\n        if (escapeNext) {\n            token.content.append((char) ch);\n            escapeNext = false;\n        } else if (ch == ESCAPE_CHAR) {\n            escapeNext = true;\n        } else if (isEndOfLine(ch)) {\n            // end of record\n            token.type = EORECORD;\n            break;\n        } else if (isEndOfFile(ch)) {\n            // end of file\n            token.type = EOF;\n            break;\n        } else if (isDelimiter(ch) && ch != ESCAPE_CHAR) {\n            // end of token\n            token.type = TOKEN;\n            break;\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    StringBuilder content = token.content;\n\n    boolean escaped = false;\n    while (true) {\n        if (ch == '\\r' || ch == '\\n' || isDelimiter(ch) || isEndOfFile(ch)) {\n            if (escaped) {\n                content.append((char) ch);\n                escaped = false;\n            } else if (ch == '\\r') {\n                if (reader.peek() == '\\n') {\n                    reader.read(); // skip '\\n'\n                }\n                // end of line reached\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                // end of stream reached\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else {\n                // unescaped delimiter reached\n                token.type = TOKEN;\n                return token;\n            }\n        } else if (ch == '\\\\') {\n            escaped = true;\n        } else {\n            content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    StringBuilder content = token.content;\n    boolean escaped = false;\n    while (true) {\n        if (isEndOfFile(ch)) {\n            break;\n        }\n        if (eol) {\n            token.type = EORECORD;\n            break;\n        }\n        if (isDelimiter(ch) && !escaped) {\n            token.type = TOKEN;\n            break;\n        }\n        content.append((char) ch);\n        escaped = ch == ESCAPE;\n        ch = reader.read();\n        eol = readEndOfLine(ch);\n    }\n    token.isReady = true;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) {\n        if (isEndOfLine(ch)) \n        {\n            // empty token return EORECORD(\"\")\n            token.type = EORECORD;\n        }\n        else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF()\n            token.type = EOF;\n            token.isReady = true;\n        }\n        else if (isDelimiter(ch)) \n        {\n            // unescaped delimiter found, return TOKEN\n            if (ch != '\\\\' || (reader.read() != ch)) \n            {\n                token.type = TOKEN;\n                break;\n            }\n        }\n        else \n        {\n            // add the current char to the token\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    StringBuilder content = token.content;\n\n    while (true) {\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true;\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            token.isReady = true;\n            return token;\n        } else {\n            if (isDelimiter(ch) && token.content.toString().contains(String.valueOf((char) ch))) {\n                token.type = TOKEN;\n                token.isReady = true;\n                return token;\n            } else {\n                content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean escape = false;\n    boolean finished = false;\n    final StringBuilder content = token.content;\n\n    // we need to check for escape chars before we check for finished tokens\n    while (!finished) {\n        if (escape) {\n            escape = false;\n        } else if (isDelimiter(ch)) {\n            // end of token reached, return the token if it's not at the beginning of the line\n            if (!isStartOfLine(token.content.toString())) {\n                finished = true;\n            } else {\n                // token is at the beginning of the line, ignore it\n                content.deleteCharAt(content.length() - 1);\n                token.type = INVALID;\n            }\n        } else if (isEndOfLine(ch)) {\n            finished = true;\n        } else if (isEndOfFile(ch)) {\n            finished = true;\n            token.isReady = true; // there is data at EOF\n        } else if (isQuoteChar(ch)) {\n            finished = true;\n            token.type = INVALID;\n        } else if (ch == ESCAPE_CHAR) {\n            escape = true;\n        } else {\n            // normal char, add it to the token\n            content.append((char) ch);\n        }\n\n        // read the next char\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    boolean eol = false;\n    while (!eol) {\n        if (isEndOfLine(ch)) {\n            eol = true;\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        } else if (isDelimiter(ch)) {\n            // unescaped delimiter found: token finished\n            if (!isEscaped(token)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n                token.isReady = true;\n                return token;\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    // empty token return EORECORD(\"\")\n    // noop: token.content.append(\"\");\n    token.type = EORECORD;\n    token.isReady = true;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.isReady = false; // token is not finished yet\n    StringBuilder sb = token.content;\n\n    // check if first character of token is a blank\n    boolean firstCharIsBlank = Character.isWhitespace((char) ch);\n\n    while (true) {\n        boolean eol = readEndOfLine(ch);\n        if (eol) {\n            // end of line reached: add blank if first char was blank and token is not finished yet\n            if (firstCharIsBlank && sb.length() > 0) {\n                token.content.append(' ');\n            }\n            token.type = EORECORD;\n            return token;\n        }\n\n        char nextChar = (char) reader.read();\n\n        // end of file reached\n        if (isEndOfFile(nextChar)) {\n            // add blank if first char was blank and token is not finished yet\n            if (firstCharIsBlank && sb.length() > 0) {\n                token.content.append(' ');\n            }\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            return token;\n        }\n\n        // escaped delimiter case: add current char (escaped delimiter) to token\n        if (nextChar == ESCAPE) {\n            final String nextNextChar = reader.readNextChar();\n            if (nextNextChar.isEmpty()) {\n                throw new IOException(\"Illegal escape at the end of stream\");\n            }\n            sb.append(nextNextChar);\n        } else {\n            // unescaped delimiter case: finish token and return\n            if (isDelimiter(nextChar)) {\n                if (firstCharIsBlank && sb.length() > 0) {\n                    token.content.append(' ');\n                }\n                token.type = TOKEN;\n                return token;\n            } else {\n                // normal character: add to token\n                sb.append(nextChar);\n            }\n        }\n\n        // update current character\n        ch = nextChar;\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) \n    {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n    int[] result = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        result[i] = index / uniCounterOffset[dimension - i - 1] % size[dimension - i - 1];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n\n    int[] ret = new int[dimension];\n    int temp = index;\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        ret[i] = temp / uniCounterOffset[i];\n        temp %= uniCounterOffset[i];\n    }\n    return ret;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) \n    {\n        throw new OutOfRangeException(\"Index: \" + index + \", Size: \" + getSize());\n    }\n\n    int[] counts = new int[dimension];\n\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = counter[i] + uniCounterOffset[i] * (index / uniCounterOffset[dimension - i - 1]);\n        index %= uniCounterOffset[dimension - i - 1];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n\n    int[] counts = new int[dimension];\n    int i = last;\n    counts[i] = index % size[last];\n    int tmpIndex = index / size[last];\n    while (i > 0) {\n        counts[i - 1] = tmpIndex % size[i - 1];\n        tmpIndex /= size[i - 1];\n        i--;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize())\n    {\n        throw new OutOfRangeException(\"index must be between 0 and \" + getSize());\n    }\n    \n    int[] result = new int[dimension];\n    \n    for (int i = dimension - 1; i >= 0; i--)\n    {\n        result[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    \n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n    for (int i = last; i >= 0; i--) {\n        counts[i] = tIndex % size[i];\n        tIndex /= size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) \n    {\n        throw new OutOfRangeException();\n    }\n\n    int[] counts = new int[dimension];\n    counts[last] = index;\n\n    for (int i = last - 1; i >= 0; i--) \n    {\n        counts[i] = (index - uniCounterOffset[i]) / size[i + 1];\n        index -= counts[i] * size[i + 1];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n    \n    int[] counts = new int[dimension];\n    int offset = uniCounterOffset[last];\n    for (int i = last - 1; i >= 0; i--) {\n        counts[i] = (index / offset) % size[i];\n        offset /= size[i];\n    }\n    counts[last] = index % size[last];\n    \n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n\n    int[] counts = new int[dimension];\n    int tIndex = index;\n\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = tIndex / uniCounterOffset[i];\n        tIndex %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize());\n    }\n    \n    int[] result = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        result[i] = index / uniCounterOffset[i];\n        index -= result[i] * uniCounterOffset[i];\n    }\n    return result;\n}"
    ],
    [
      "public JsonPointer last()  {\n    if (_nextSegment == null) { return EMPTY; }\n    if (_nextSegment.inObject()) {\n        String seg = _nextSegment.getCurrentName();\n        if (seg == null) { // is this legal?\n            seg = \"\";\n        }\n        return new JsonPointer(_fullPath(null, seg), seg, last());\n    }\n    if (_nextSegment.inArray()) {\n        int ix = _nextSegment.getCurrentIndex();\n        String ixStr = String.valueOf(ix);\n        return new JsonPointer(_fullPath(null, ixStr), ixStr, ix, last());\n    }\n    return EMPTY;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current != null) {\n        if (current.inObject()) {\n            return current;\n        }\n        current = current.getParent();\n    }\n    return null;\n}",
      "public JsonPointer last()  {\n    return _lastSegment;\n}",
      "public JsonPointer last()  {\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return EMPTY;\n    }\n    return _nextSegment.last();\n}\n\n/* Factory method that composes a pointer instance, given a set\n * of 'raw' segments: raw meaning that no processing will be done,\n * no escaping may is present.\n * \n * @param segments\n * \n * @return Constructed path instance",
      "public JsonPointer last()  {\n    JsonPointer leaf = null;\n    for (JsonPointer segment = this; segment != null; segment = segment.getParent()) {\n        if (segment.inObject() || segment.inArray()) {\n            if (segment.getCurrentName() != null) {\n                leaf = segment;\n            } else if (segment.getCurrentIndex() >= 0) {\n                leaf = segment;\n            }\n        }\n    }\n    return leaf;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = null;\n\n        for (JsonPointer context = this; context != null; context = context.getParent()) {\n            if (context.inObject()) {\n                String seg = context.getCurrentName();\n                if (seg == null) { // is this legal?\n                    seg = \"\";\n                }\n                tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n            } else if (context.inArray() || includeRoot) {\n                int ix = context.getCurrentIndex();\n                String ixStr = String.valueOf(ix);\n                tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n            }\n            // NOTE: this effectively drops ROOT node(s); should have 1 such node,\n            // as the last one, but we don't have to care (probably some paths have\n            // no root, for example)\n        }\n        if (tail == null) {\n            return EMPTY;\n        }\n        return tail;\n}",
      "public JsonPointer last()  {\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            return new JsonPointer(_fullPath(null, seg), seg);\n        } else if (context.inArray()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            return new JsonPointer(_fullPath(null, ixStr), ixStr, ix);\n        }\n    }\n    return EMPTY;\n}",
      "public JsonPointer last()  {\n    return _tail;\n}",
      "public JsonPointer last()  {\n    for (JsonPointer context = this; context != null; context = context.getParent()) {\n        if (context.inObject()) {\n            String seg = context.getCurrentName();\n            if (seg == null) { // is this legal?\n                seg = \"\";\n            }\n            tail = new JsonPointer(_fullPath(tail, seg), seg, tail);\n        } else if (context.inArray()) {\n            int ix = context.getCurrentIndex();\n            String ixStr = String.valueOf(ix);\n            tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);\n        }\n    }\n    if (tail == null) {\n        return EMPTY;\n    }\n    return tail;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    try (final BufferedInputStream stream = new BufferedInputStream(data)) {\n        return updateDigest(digest, stream);\n    }\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[4096];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[4096];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[4096];\n    int bytesRead;\n\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[4096];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    try (final BufferedInputStream stream = new BufferedInputStream(data)) {\n        return updateDigest(digest, stream);\n    }\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[2048];\n    int bytesRead = data.read(buffer);\n    while (bytesRead != -1) {\n        digest.update(buffer, 0, bytesRead);\n        bytesRead = data.read(buffer);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) > -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    try (final BufferedInputStream bufferedInputStream = new BufferedInputStream(data)) {\n        final byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = bufferedInputStream.read(buffer)) > -1) {\n            updateDigest(digest, buffer, bytesRead);\n        }\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(e.getMessage(), e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T) ((Cloneable<?>) obj).clone();\n                return result;\n            } catch (CloneNotSupportedException c) {\n                throw new CloneFailedException(c);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(e.getMessage(), e);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) ((Cloneable) obj).clone();\n            return result;\n        } catch (final CloneNotSupportedException c) {\n            throw new CloneFailedException(c);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) ((Cloneable) obj).clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(e.getMessage(), e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) ((Cloneable) obj).clone();\n            return clone;\n        } catch (CloneNotSupportedException ex) {\n            throw new CloneFailedException(ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) ((Cloneable) obj).clone();\n            } catch (CloneNotSupportedException e) {\n                throw new CloneFailedException(e);\n            }\n        }\n\n        return null;\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n\n        if (obj instanceof Cloneable) {\n            try {\n                return ((Cloneable<T>) obj).clone();\n            } catch (Exception e) {\n                throw new CloneFailedException(e);\n            }\n        }\n\n        return null;\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getSymbolType() != SymbolType.FUNCTION) \n    {\n        return null;\n    }\n    FunctionSymbol function = (FunctionSymbol) sym;\n    SymbolScope functionScope = function.getScope();\n\n    // Find the first parameter in the function scope with the given name.\n    for (Symbol parameter : functionScope) \n    {\n        if (parameter.getName().equals(paramName)) \n        {\n            return parameter;\n        }\n    }\n\n    // No parameter found with the given name.\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // TODO: Implement logic to find the parameter symbol.\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // If symbol is not a function, return null\n    if (!sym.is(SymbolKind.Function)) {\n        return null;\n    }\n    \n    // Get the function node\n    FunctionNode funcNode = sym.getNode(FunctionNode.class);\n    \n    // Find the parameter list\n    ExpressionStatement exprStmt = funcNode.getBody();\n    if (exprStmt.isVariableDeclaration()) {\n        VariableDeclaration decl = exprStmt.asVariableDeclaration();\n        if (decl.getKind() != VariableKind.Function) {\n            return null;\n        }\n        \n        // Get the parameters from the function declaration\n        List<VariableDeclarator> params = decl.getDeclarations();\n        for (VariableDeclarator param : params) {\n            if (param.getId().getName().equals(paramName)) {\n                return Symbol.create(param);\n            }\n        }\n    }\n    \n    // No parameter found with that name\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.is(Symbol.KIND_FUNCTION)) {\n    return null;\n  }\n\n  FunctionSymbol fs = (FunctionSymbol) sym;\n  for (Symbol param : fs.params) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.isNative())\n    {\n        return null;\n    }\n\n    if (sym.getKind() != SymbolKind.FUNCTION)\n    {\n        return null;\n    }\n\n    List<Symbol> params = sym.getParameterList();\n\n    if (params != null)\n    {\n        for (Symbol param : params)\n        {\n            if (param.getName().equals(paramName))\n            {\n                return param;\n            }\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // Check if the symbol is a function\n    if (sym.getType().is(JSType.Function)) \n    {\n        // Get the function symbol\n        FunctionSymbol funcSymbol = (FunctionSymbol) sym;\n        \n        // Get the parameters of the function\n        List<Symbol> params = funcSymbol.getParameters();\n        \n        // Iterate through the parameters to find the one with the matching name\n        for (Symbol param : params)\n        {\n            if (param.getName().equals(paramName)) \n            {\n                return param;\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // TODO: Implement logic to search for the parameter in the function's scope.\n  // For instance, you could use the symbol's references to find the corresponding function.\n  // Remember to handle cases where the function has multiple parameters with the same name.\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  // Ensure we're dealing with a function symbol\n  if (!sym.is(Symbol.Kind.FUNCTION)) {\n    return null;\n  }\n\n  // Get the function symbol\n  FunctionSymbol funcSym = (FunctionSymbol) sym;\n\n  // Loop through the function's parameters\n  for (Symbol param : funcSym.getParameters()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  // Parameter not found\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getSymbolType() != SymbolType.FUNCTION) {\n    return null;\n  }\n\n  // Get the function's symbol table.\n  SymbolTable funcSymTable = sym.getSymbolTable();\n\n  // Get the list of parameters.\n  List<Symbol> params = funcSymTable.getAllSymbolsSorted();\n\n  // Search for the parameter with the given name.\n  for (Symbol param : params) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  // Parameter not found.\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    // If not a function, return null\n    if (!sym.is(Symbol.Kind.FUNCTION)) {\n        return null;\n    }\n    \n    // Get the function's scope\n    SymbolScope scope = sym.getScope();\n    \n    // Iterate over the function's parameters\n    for (Map.Entry<String, Symbol> entry : scope.getParameters().entrySet()) {\n        Symbol parameter = entry.getValue();\n        \n        // Check if the parameter's name matches\n        if (parameter.getName().equals(paramName)) {\n            return parameter;\n        }\n    }\n    \n    // Parameter not found\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix columnMeans = matrix.getColumnVector(0).copy();\n    for (int i=1; i<matrix.getColumnDimension(); i++) {\n        RealMatrix column = matrix.getColumnVector(i).copy();\n        for (int j=0; j<column.getColumnDimension(); j++) {\n            columnMeans.setEntry(j, columnMeans.getEntry(j) + column.getEntry(j));\n        }\n    }\n    columnMeans.scalarMultiply(1./matrix.getColumnDimension());\n    RealMatrix columnMeansMatrix = columnMeans.copy();\n    columnMeansMatrix.transpose();\n    RealMatrix scaledMatrix = matrix.subtract(columnMeansMatrix).copy();\n    RealMatrix cov = scaledMatrix.transpose().multiply(scaledMatrix);\n    if (biasCorrected) {\n        cov.scalarMultiply(1.0/(matrix.getColumnDimension()-1));\n    } else {\n        cov.scalarMultiply(1.0/matrix.getColumnDimension());\n    }\n    return cov;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    if (matrix.getColumnDimension() < 2 || matrix.getRowDimension() < 1) {\n        throw new MathIllegalArgumentException(\"Input data must have at least two rows and one column\");\n    }\n    if (matrix.getColumnDimension() != matrix.getRowDimension()) {\n        throw new MathIllegalArgumentException(\"Input matrix must be square\");\n    }\n    if (biasCorrected) {\n        RealMatrix inv = new LUDecomposition(matrix).getSolver().getInverse();\n        return matrix.transpose().multiply(inv.multiply(matrix)).scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n    } else {\n        return matrix.transpose().multiply(matrix).scalarMultiply(1.0 / (matrix.getRowDimension() - 1));\n    }\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix columnMeans = computeColumnMeans(matrix);\n    RealMatrix demeanedMatrix = demean(matrix, columnMeans);\n    RealMatrix covarianceMatrix = demeanedMatrix.transpose().multiply(demeanedMatrix);\n\n    // Calculate the number of observations (n)\n    int n = matrix.getRowDimension();\n\n    // Calculate the variance-covariance matrix\n    if (biasCorrected)\n        covarianceMatrix.scalarMultiply(n / (n - 1));\n\n    // Return the variance-covariance matrix\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Get the number of columns and rows from the input matrix\n    int numCols = matrix.getColumnDimension();\n    int numRows = matrix.getRowDimension();\n\n    // Check if the matrix has at least two rows and one column\n    if (numRows < 2 || numCols < 1) {\n        throw new MathIllegalArgumentException(\"The input matrix must have at least one column and two rows.\");\n    }\n\n    // Calculate the sample covariance matrix\n    RealMatrix covarianceMatrix = matrix.createCopy();\n    for (int i = 0; i < numCols; i++) {\n        for (int j = 0; j < i; j++) {\n            covarianceMatrix.setEntry(i, j, covarianceMatrix.getEntry(j, i));\n        }\n    }\n    for (int i = 0; i < numCols; i++) {\n        covarianceMatrix.setEntry(i, i, covarianceMatrix.getEntry(i, i) / (numRows - 1));\n    }\n\n    // If biasCorrected is true, correct for bias\n    if (biasCorrected) {\n        for (int i = 0; i < numCols; i++) {\n            covarianceMatrix.setEntry(i, i, covarianceMatrix.getEntry(i, i) + (1 / numRows));\n        }\n    }\n\n    // Return the covariance matrix\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    if (matrix.getColumnDimension() < 2 || matrix.getRowDimension() < 2) {\n        throw new MathIllegalArgumentException(\"Input matrix does not contain sufficient data\");\n    }\n\n    RealMatrix result = new LUDecomposition(matrix).getSolver().getInverse();\n\n    if (biasCorrected) {\n        result.scalarMultiply(1 / (n - 1));\n    } else {\n        result.scalarMultiply(1 / n);\n    }\n\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix cov = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < cov.getColumnDimension(); i++) {\n        for (int j = 0; j <= i; j++) {\n            cov.setEntry(i, j, computeCovariance(matrix, i, j, biasCorrected));\n            if (i != j) {\n                cov.setEntry(j, i, cov.getEntry(i, j));\n            }\n        }\n    }\n    return cov;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix columnMeans = computeColumnMeans(matrix);\n    RealMatrix demeans = subtractMatrix(matrix, columnMeans);\n    RealMatrix covarianceMatrix = computeCovarianceMatrix(demeans, biasCorrected);\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix covMatrix = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    double[][] data = matrix.getData();\n    for (int i = 0; i < data.length; i++) {\n        for (int j = i + 1; j < data.length; j++) {\n            for (int k = 0; k < data[i].length; k++) {\n                covMatrix.setEntry(i, j, covMatrix.getEntry(i, j) + (data[i][k] - matrix.getColumnVector(k).getMean())\n                        * (data[j][k] - matrix.getColumnVector(k).getMean()));\n            }\n        }\n    }\n    if (biasCorrected) {\n        for (int i = 0; i < data.length; i++) {\n            for (int j = i + 1; j < data.length; j++) {\n                covMatrix.setEntry(i, j, covMatrix.getEntry(i, j) / (data.length - 1));\n            }\n        }\n    } else {\n        for (int i = 0; i < data.length; i++) {\n            for (int j = i + 1; j < data.length; j++) {\n                covMatrix.setEntry(i, j, covMatrix.getEntry(i, j) / data.length);\n            }\n        }\n    }\n    for (int i = 0; i < data.length; i++) {\n        for (int j = i + 1; j < data.length; j++) {\n            covMatrix.setEntry(j, i, covMatrix.getEntry(i, j));\n        }\n    }\n    return covMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Ensure the matrix has enough data\n    checkSufficientData(matrix);\n    \n    // Get the number of rows and columns\n    int numRows = matrix.getRowDimension();\n    int numCols = matrix.getColumnDimension();\n\n    // Calculate the covariance matrix\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(numCols, numCols);\n    for (int i = 0; i < numCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double covariance = 0.0;\n            for (int k = 0; k < numRows; k++) {\n                covariance += (matrix.getRowVector(k).getEntry(i) - matrix.getColumnVector(i).getEntry(0))\n                        * (matrix.getRowVector(k).getEntry(j) - matrix.getColumnVector(j).getEntry(0));\n            }\n\n            // Bias correction\n            if (biasCorrected && i != j) {\n                covariance /= (numRows - 1.0);\n            } else {\n                covariance /= numRows;\n            }\n\n            covarianceMatrix.setEntry(i, j, covariance);\n            if (i != j) {\n                covarianceMatrix.setEntry(j, i, covariance);\n            }\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    RealMatrix columnMeans = matrix.getColumnVector(0).copy();\n\n    for (int i = 1; i < matrix.getColumnDimension(); i++) {\n        RealVector vector = matrix.getColumnVector(i);\n        columnMeans.addToEntry(i, vector.getEntry(0));\n    }\n    columnMeans.scalarDivide(n);\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        RealVector vector = matrix.getColumnVector(i);\n        for (int j = i; j < matrix.getColumnDimension(); j++) {\n            RealVector vector2 = matrix.getColumnVector(j);\n            covarianceMatrix.addToEntry(i, j, computeCovariance(vector, vector2, columnMeans, biasCorrected));\n            if (i != j) {\n                covarianceMatrix.addToEntry(j, i, covarianceMatrix.getEntry(i, j));\n            }\n        }\n    }\n    return covarianceMatrix;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        final int numReads = count / MAXIMUM_CACHE_SIZE + ((count % MAXIMUM_CACHE_SIZE) > 0 ? 1 : 0);\n        long result = 0;\n        for (int i = 0; i < numReads - 1; i++) \n        {\n            result = (result << MAXIMUM_CACHE_SIZE) | readBits(MAXIMUM_CACHE_SIZE);\n        }\n        return (result << count % MAXIMUM_CACHE_SIZE) | readBits(count % MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize >= count) \n    {\n        final long mask = MASKS[count];\n        final long result;\n        if (byteOrder == ByteOrder.BIG_ENDIAN) \n        {\n            result = (bitsCached & (mask << bitsCachedSize - count)) >> (bitsCachedSize - count);\n        } else \n        {\n            result = (bitsCached & (mask << bitsCachedSize - count));\n        }\n\n        bitsCachedSize -= count;\n        bitsCached &= ~(mask << bitsCachedSize);\n        return result;\n    } else \n    {\n        final long bitsToCache = Math.min(MAXIMUM_CACHE_SIZE, count - bitsCachedSize);\n        final long bitsLeftInBuffer = MAXIMUM_CACHE_SIZE - bitsToCache;\n        final long maskForCachedBits = MASKS[bitsToCache];\n        final long maskForBitsLeftInBuffer = MASKS[bitsLeftInBuffer];\n\n        final long result;\n        if (byteOrder == ByteOrder.BIG_ENDIAN) \n        {\n            result = (bitsCached & (maskForCachedBits << bitsCachedSize - bitsToCache)) >> (bitsCachedSize - bitsToCache);\n        } else \n        {\n            result = (bitsCached & (maskForCachedBits << bitsCachedSize - bitsToCache));\n        }\n\n        final int readBytes = (int) Math.ceil((bitsToCache - bitsLeftInBuffer) / 8.0);\n        final long remainingBitsToCache = (bitsToCache - bitsLeftInBuffer) & 7;\n        final long bytesReadAsLong = in.readNBytes(readBytes);\n}\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        long result = 0;\n        for (int i = 0; i < count; i += MAXIMUM_CACHE_SIZE) \n        {\n            final int bitsLeft = count - i;\n            final int toRead = bitsLeft > MAXIMUM_CACHE_SIZE ? MAXIMUM_CACHE_SIZE : bitsLeft;\n            result = (result << toRead) | readBits(toRead);\n            if (result == -1) \n            {\n                return -1;\n            }\n        }\n        return result;\n    }\n\n    if (bitsCachedSize >= count) \n    {\n        final long result = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    final int bitsNeeded = count - bitsCachedSize;\n    final long newBits = readBits(bitsNeeded);\n    if (newBits == -1) \n    {\n        return -1;\n    }\n\n    final long result = (bitsCached << bitsNeeded) | (newBits & MASKS[bitsNeeded]);\n    bitsCachedSize = MAXIMUM_CACHE_SIZE;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsToExtract = count > bitsCachedSize ? bitsCachedSize : count;\n        final long extractedBits = bitsCached & MASKS[(int) bitsToExtract];\n        bitsCachedSize -= bitsToExtract;\n        bitsCached >>>= bitsToExtract;\n        return extractedBits;\n    }\n    final int bitsNeededToFillCache = count - bitsCachedSize;\n    final int bytesNeeded = (bitsNeededToFillCache + 7) >>> 3;\n    final long bitsToExtractFromCache = bitsCachedSize;\n    final long extractedBitsFromCache = bitsCached & MASKS[(int) bitsToExtractFromCache];\n    final byte[] b = new byte[bytesNeeded];\n    final int bytesRead = in.read(b, 0, bytesNeeded);\n    if (bytesRead == -1) {\n        return bytesNeeded == 0 ? extractedBitsFromCache : -1;\n    }\n    final long bitsFromBuffer = (((long) (byteOrder == ByteOrder.BIG_ENDIAN ? b[bytesRead - 1] : b[0])) & MASKS[bytesNeeded * 8 - bitsNeededToFillCache]) << bitsCachedSize;\n    final long result = extractedBitsFromCache | bitsFromBuffer;\n    bitsCachedSize = bytesNeeded * 8 - bitsNeededToFillCache;\n    bitsCached = b[(bytesRead - 1) ^ (byteOrder == ByteOrder.BIG_ENDIAN ? 0 : 1)];\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        final long[] result = new long[2];\n        final int resultSize = readBitsArray(result, 0, count);\n        if (resultSize == count) \n        {\n            return resultSize == 1 ? result[0] : (byteOrder == ByteOrder.LITTLE_ENDIAN ? result[1] << 32 | result[0] : result[0] << 32 | result[1]);\n        }\n        return -1;\n    }\n    if (bitsCachedSize >= count) \n    {\n        final long result = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    final int remainingInCache = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n    final long valueInCache = bitsCached & MASKS[remainingInCache];\n    final int numberOfBytesNeeded = (count - remainingInCache + 7) >>> 3;\n    final int bytesRead = in.read(new byte[numberOfBytesNeeded]);\n    if (bytesRead == -1) \n    {\n        final long result = valueInCache << (count - remainingInCache);\n        bitsCachedSize = 0;\n        return result;\n    }\n    final long result = ((valueInCache << remainingInCache) | ((long) in.read() << (remainingInCache - 8)) | (bytesRead == numberOfBytesNeeded ? 0 : (long) in.read() >>> (8 - (count - remainingInCache))));\n    bitsCached = result;\n    bitsCachedSize = count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be >= 1 and <= \" + MAXIMUM_CACHE_SIZE + \", but was: \" + count);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long result = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    final int bitsLeftInCache = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n    final int numReadsNeeded = (count - bitsLeftInCache) >>> 6;\n    final int numLowBitsNeeded = (count - bitsLeftInCache) & 0x3F;\n\n    long result = bitsCached & MASKS[bitsLeftInCache];\n\n    for (int i = 0; i < numReadsNeeded; i++) {\n        result = (result << 8) | (in.read() & 0xFF);\n    }\n\n    int b = in.read();\n    if (b < 0) {\n        return -1;\n    }\n    b = (byteOrder == ByteOrder.BIG_ENDIAN) ? b : Integer.reverseBytes(b) >>> 24;\n    result = (result << numLowBitsNeeded) | (b & MASKS[numLowBitsNeeded]);\n    bitsCachedSize += count;\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long bits = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bits;\n    }\n\n    final long bits = (bitsCached << (count - bitsCachedSize)) & MASKS[count];\n    final int bytesNeeded = count - bitsCachedSize;\n\n    if (bytesNeeded > in.available()) {\n        return -1L;\n    }\n\n    final byte[] b = new byte[bytesNeeded];\n    final int bytesRead = in.read(b);\n\n    if (bytesRead == bytesNeeded) {\n        bitsCached = bytesToLong(b, byteOrder) << bitsCachedSize;\n        bitsCachedSize += 8 * bytesNeeded;\n        bitsCached &= MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bits;\n    }\n\n    bitsCached = bytesToLong(b, 0, bytesRead, byteOrder) << bitsCachedSize;\n    bitsCachedSize += 8 * bytesRead;\n    bitsCached >>>= count - bytesRead * 8;\n    bitsCached &= MASKS[count];\n    bitsCachedSize -= count;\n    bitsCached >>>= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Cannot read more than \" + MAXIMUM_CACHE_SIZE + \" bits at once\");\n    }\n\n    if (count <= bitsCachedSize) {\n        final long result = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    final long result = bitsCached & MASKS[bitsCachedSize];\n    final int remaining = count - bitsCachedSize;\n\n    final byte[] b = new byte[4]; // 4 bytes is enough for 32 bits\n    int byteCount = 0;\n    while (byteCount < b.length && byteCount < remaining / 8) {\n        if (in.read(b, byteCount, b.length - byteCount) == -1) {\n            return result | (MASKS[remaining] << (remaining - bitsCachedSize));\n        }\n        byteCount += b.length - byteCount;\n    }\n\n    switch (byteOrder) {\n        case BIG_ENDIAN:\n            if (byteCount >= 4) {\n                bitsCached = (((long) b[0] & 0xFF) << 24) | (((long) b[1] & 0xFF) << 16)\n                        | (((long) b[2] & 0xFF) << 8) | ((long) b[3] & 0xFF);\n                bitsCachedSize = 32;\n            } else if (byteCount >= 2) {\n                bitsCached = (((long) b[0] & 0xFF) << 8) | ((long) b[1] & 0xFF);\n                bitsCachedSize = 16;\n            } else if (byteCount >= 1) {\n                bitsCached = (long) (b[0] & 0xFF);\n                bitsCachedSize = 8;\n            }\n            break;\n        case LITTLE_ENDIAN:\n            if (byteCount >= 4) {\n                bitsCached = (((long) b[3] & 0xFF) << 24) | (((long) b[2] & 0xFF) << 16)\n}\n}\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        long result = 0;\n        for (int i = 0; i < count / MAXIMUM_CACHE_SIZE; i++) \n        {\n            result = (result << MAXIMUM_CACHE_SIZE) | readBits(MAXIMUM_CACHE_SIZE);\n        }\n        if (count % MAXIMUM_CACHE_SIZE != 0) \n        {\n            result = (result << count % MAXIMUM_CACHE_SIZE) | readBits(count % MAXIMUM_CACHE_SIZE);\n        }\n        return result;\n    }\n\n    if (bitsCachedSize >= count) \n    {\n        final long bitmask = MASKS[count];\n        long result;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) \n        {\n            result = (bitsCached & (bitmask << bitsCachedSize - count)) >>> (bitsCachedSize - count);\n        } else \n        {\n            result = (bitsCached & (bitmask << count)) >>> count;\n        }\n        bitsCachedSize -= count;\n        bitsCached &= ~bitmask << bitsCachedSize;\n        return result;\n    }\n\n    final int remainingCached = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n    final long bitmask;\n    if (count <= remainingCached) \n    {\n        bitmask = MASKS[count];\n    } else \n    {\n        bitmask = MASKS[remainingCached];\n    }\n\n    final int bytesNeeded = (int) Math.ceil((double) (bitsCachedSize + count) / 8D);\n    final byte[] buffer = new byte[bytesNeeded];\n    int bytesRead = in.read(buffer, 0, bytesNeeded);\n    if (bytesRead == -1) \n    {\n        return -1;\n    }\n\n    if (bytesRead < bytesNeeded) \n    {\n        final byte[] tmpBuffer = new byte[bytesNeeded - bytesRead];\n        final int tmpBytesRead = in.read(tmpBuffer, 0, tmpBuffer.length);\n        if (tmpBytesRead == -1) \n        {\n            throw new EOFException();\n        }\n}\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        final long[] buffer = new long[count / MAXIMUM_CACHE_SIZE + 1];\n        final int bytesRead = readBytesInto(buffer);\n        if (bytesRead == -1) \n        {\n            return -1;\n        }\n        long value = 0;\n        for (int i = 0; i < bytesRead; i++) \n        {\n            value = (value << MAXIMUM_CACHE_SIZE) | readBitsInternal(MAXIMUM_CACHE_SIZE);\n        }\n        return value;\n    }\n    return readBitsInternal(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Trying to read too many bits (\" + count + \") at once!\");\n    }\n    if (bitsCachedSize < count) {\n        final int remaining = count - bitsCachedSize;\n        final byte[] b = new byte[remaining > 4 ? 4 : remaining / 8 + 1];\n        final int bytesRead = in.read(b, 0, b.length);\n        if (bytesRead == -1) {\n            return -1;\n        }\n        if (bytesRead < b.length) {\n            for (int i = bytesRead * 8; i < remaining; i++) {\n                b[bytesRead] |= (in.read() << (i % 8));\n            }\n        }\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            for (final byte bi : b) {\n                bitsCached = (bitsCached << 8) | (bi & 0xFF);\n            }\n        } else {\n            for (int i = b.length - 1; i >= 0; i--) {\n                bitsCached = (bitsCached << 8) | (b[i] & 0xFF);\n            }\n        }\n        bitsCachedSize += 8 * b.length;\n    }\n    final long bitsToExtract = bitsCached & MASKS[count];\n    bitsCachedSize -= count;\n    bitsCached >>>= count;\n    return bitsToExtract;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.getData().length);\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getData()[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n        checkVectorDimensions(v.data.length);\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    checkVectorDimensions(v.data.length);\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target == null) {\n        return false;\n    }\n    if (target.getType() == Token.LABEL) {\n        return label.equals(target.getText());\n    }\n    Node labeled = getNextSiblingOfType(target, Token.LABEL);\n    if (labeled == null) {\n        return false;\n    }\n    return label.equals(labeled.getText());\n}\n\nstatic Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      case Token.GOTO:\n        return ((GotoNode) n).getTarget();\n      default:\n        return n;\n    }\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  while (target.getType() != Token.LABEL) \n  {\n    target = target.getParent();\n    if (target == null) \n    {\n      return false;\n    }\n  }\n  return label.equals(target.getText());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    return NodeUtil.getLabel(target) != null &&\n        NodeUtil.getLabel(target).equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  while (target != null) {\n    if (target.getType() == Token.LABEL && target.getText().equals(label)) {\n      return true;\n    }\n    target = target.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  return label.equals(NodeUtil.getLabel(target));\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  while (target != null) {\n    if (target.getType() == Token.LABEL && target.getText().equals(label)) {\n      return true;\n    }\n    target = target.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getPreviousSibling();\n    if (labelNode == null || labelNode.getType() != Token.LABEL) {\n      return false;\n    }\n    return labelNode.getText().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getLabel().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.getType() == Token.LABEL) {\n      return target.getName().equals(label);\n    }\n    if (target.getType() == Token.DO) {\n      Node labelNode = getNextSiblingOfType(target.getFirstChild(), Token.LABEL);\n      return labelNode != null && labelNode.getName().equals(label);\n    }\n    if (target.getType() == Token.FOR) {\n      Node labelNode = getNextSiblingOfType(target.getFirstChild(), Token.LABEL);\n      return labelNode != null && labelNode.getName().equals(label);\n    }\n    if (target.getType() == Token.WHILE) {\n      Node labelNode = getNextSiblingOfType(target.getFirstChild(), Token.LABEL);\n      return labelNode != null && labelNode.getName().equals(label);\n    }\n    if (target.getType() == Token.TRY) {\n      Node labelNode = getNextSiblingOfType(target.getFirstChild(), Token.LABEL);\n      return labelNode != null && labelNode.getName().equals(label);\n    }\n    if (target.getType() == Token.SWITCH) {\n      Node labelNode = getNextSiblingOfType(target.getFirstChild(), Token.LABEL);\n      return labelNode != null && labelNode.getName().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  for (Label labelNode : target.getLabels()) \n  {\n    if (labelNode.getName().equals(label)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      case Token.BREAK:\n        return computeFallThrough(getNextSiblingOfType(n, Token.LABEL));\n      case Token.CONTINUE:\n        return computeFallThrough(getNextSiblingOfType(n, Token.LABEL));\n      default:\n        return n;\n    }\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls == null || item < 0 || item >= urls.size()) {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        String url = (String) urls.get(item);\n        if (url != null) {\n            url = url.replaceAll(\"\\\\s\", \"%20\");\n        }\n        return url;\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls == null) \n    {\n        return null;\n    }\n    if (item >= urls.size()) \n    {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null)\n    {\n        String url = (String) urls.get(item);\n        return url;\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null)\n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null)\n    {\n        if (item >= 0 && item < urls.size())\n        {\n            return (String) urls.get(item);\n        }\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls == null) \n    {\n        return null;\n    }\n    if (item >= urls.size()) \n    {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls == null || urls.isEmpty()) {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls == null || item < 0 || item >= urls.size()) {\n        return null;\n    }\n    return (String) urls.get(item);\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item >= 0 && item < urls.size()) \n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    if ((str == null) || (str.isEmpty())) \n    {\n        return -1;\n    }\n    int idx = 0;\n    while (idx < str.length()) \n    {\n        if (!Character.isDigit(str.charAt(idx))) \n        {\n            break;\n        }\n        idx++;\n    }\n    if (idx == 0) \n    {\n        return -1;\n    }\n    if (idx == str.length()) \n    {\n        return Integer.parseInt(str);\n    }\n    if (str.charAt(idx) == ']') \n    {\n        return Integer.parseInt(str.substring(0, idx));\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int value = 0;\n    boolean negative = false;\n    if (str.charAt(0) == '-') {\n        negative = true;\n        str = str.substring(1);\n    }\n    for (int i = 0; i < str.length(); ++i) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            value *= 10;\n            value += c - '0';\n        } else {\n            throw new IllegalArgumentException(\"Illegal character in integer representation: \" + str);\n        }\n    }\n    if (negative) value = -value;\n    return value;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() > 1 && str.charAt(0) == '0' && !Character.isDigit(str.charAt(1))) {\n        return -1;\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException ex) {\n        return -1;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int idx = -1;\n    final int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        if (Character.isDigit(ch)) {\n            idx = idx * 10 + Character.digit(ch, 10);\n        } else {\n            if (idx >= 0) {\n                break;\n            }\n        }\n    }\n    return idx;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        throw new RuntimeException(\"Invalid index\");\n    }\n    int start = 0;\n    if (str.charAt(0) == '+') {\n        start++;\n    }\n    int end = str.length();\n    if (str.charAt(end - 1) == ']') {\n        end--;\n    }\n    return Integer.parseInt(str.substring(start, end));\n}",
      "private final static int _parseIndex(String str)  {\n    if ((str.length() == 0) || (str.charAt(0) != '#')) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer: \" + str);\n    }\n\n    if (str.length() == 1) {\n        return 0;\n    }\n\n    int start = 1;\n    int end = 0;\n    int depth = 0;\n    while (end < str.length()) {\n        char ch = str.charAt(end);\n        if ((ch == '/') && (depth == 0)) {\n            try {\n                return Integer.parseInt(str.substring(start, end));\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid JSON Pointer: \" + str);\n            }\n        } else if (ch == '[') {\n            depth++;\n        } else if (ch == ']') {\n            depth--;\n        }\n        end++;\n    }\n\n    throw new IllegalArgumentException(\"Invalid JSON Pointer: \" + str);\n}",
      "private final static int _parseIndex(String str)  {\n    if ((str == null) || (str.isEmpty())) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int result = 0;\n    boolean negative = false;\n    if (str.charAt(0) == '-') {\n        negative = true;\n        str = str.substring(1);\n    }\n    for (int i = 0; i < str.length(); i++) {\n        int ch = str.charAt(i);\n        if ((ch < '0') || (ch > '9')) {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        result = (result * 10) + (ch - '0');\n    }\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int number = 0;\n    boolean negative = false;\n    boolean parsingNumber = false;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (i == 0 && c == '-') {\n            negative = true;\n        } else if (c >= '0' && c <= '9') {\n            number = number * 10 + (c - '0');\n            parsingNumber = true;\n        } else if (parsingNumber) {\n            break;\n        }\n    }\n    return (negative) ? -number : number;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() == 0) {\n        throw new JsonPointerException(\"Empty string\");\n    }\n    int index = 0;\n    for (int c : str.toCharArray()) {\n        if (!Character.isDigit(c)) {\n            break;\n        }\n        index = index*10 + (c - '0');\n    }\n    if (index == 0 && !str.equals(\"0\")) {\n        throw new JsonPointerException(\"Invalid number\");\n    }\n    if (str.length() > index) {\n        throw new JsonPointerException(\"Invalid number\");\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    for (int i=str.length()-1; i>=0; --i) {\n        if (!Character.isDigit(str.charAt(i))) {\n            if (i < str.length() - 1) {\n                throw new RuntimeException(String.format(\"Cannot parse index '%s' in '%s'.\", str.substring(i+1), str));\n            } else {\n                throw new RuntimeException(String.format(\"Cannot parse index '%s'.\", str));\n            }\n        }\n        result = result*10 + str.charAt(i) - '0';\n    }\n    return result;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(i -> c.toArray()[i]).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(i -> c.toArray()[i]).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::get).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::get).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(i -> c.toArray()[(int) i]).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::toArray).toArray(Object[]::new);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::toArray).toArray(Object[]::new);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::toArray).toArray(Object[]::new);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(i -> c.toArray() [i]).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k).stream().map(c::toArray).toArray(Object[]::new);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  return new ExpressionStatement(\n      new MethodCall(\n          new MemberExpression(\n              new ThisExpression(),\n              new Identifier(methodName)),\n          Collections.singletonList(argumentNode))\n  ).setLoc(srcref.getLoc());\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n   if (methodName == null || methodName.isEmpty()) {\n      throw new IllegalArgumentException(\"Method name must not be null or empty.\");\n   }\n\n   List<Node> args = new ArrayList<>();\n   args.add(methodName);\n   if (srcref != null) {\n      args.add(srcref);\n   }\n   args.add(argumentNode);\n\n   // Build the method call node.\n   return new Node(NodeUtil.getFunction(methodName), NodeType.METHOD_CALL, args);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  List<Node> args = new ArrayList<>();\n  args.add(argumentNode);\n  if (srcref != null) {\n    args.add(srcref);\n  }\n\n  ExpressionStatement exprStatement = new ExpressionStatement(\n      new CallExpression(new MemberExpression(historyName, methodName), args));\n  return exprStatement.toSource();\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    return new Node(Token.NAME, methodName).addChildren(\n        new Node(Token.LPAREN),\n        argumentNode,\n        new Node(Token.RPAREN),\n        new Node(Token.SEMI)\n    );\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  if (methodName.equals(\"toString\")\n      && argumentNode instanceof ASTLiteral\n      && ((ASTLiteral) argumentNode).isString())\n  {\n    return argumentNode;\n  }\n  return new ASTCall(srcref, methodName, argumentNode);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    if (methodName.equals(\"Array.prototype.concat\")) {\n        return buildConcatNode(argumentNode);\n    } else if (methodName.equals(\"Array.prototype.filter\")) {\n        return buildFilterNode(argumentNode, srcref);\n    } else if (methodName.equals(\"Array.prototype.map\")) {\n        return buildMapNode(argumentNode, srcref);\n    } else if (methodName.equals(\"Array.prototype.reduce\")) {\n        return buildReduceNode(argumentNode, srcref);\n    } else if (methodName.equals(\"Object.keys\")) {\n        return buildObjectKeysNode(argumentNode);\n    } else if (methodName.equals(\"Object.entries\")) {\n        return buildObjectEntriesNode(argumentNode);\n    } else {\n        return null;\n    }\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    NodeUtil.assertNode(argumentNode, \"argumentNode\");\n    if (methodName.equals(\"callee\")) {\n        return argumentNode;\n    } else {\n        List<Node> arguments = new ArrayList<>();\n        arguments.add(argumentNode);\n        return new CallNode(srcref, methodName, arguments);\n    }\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    return new Node(methodName, argumentNode);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  if (methodName.equals(\"reduce\")) {\n    List<Node> arguments = new ArrayList<>();\n    arguments.add(argumentNode);\n    if (srcref != null) {\n      arguments.add(srcref);\n    }\n    return buildMethodCall(\"reduce\", arguments);\n  } else if (methodName.equals(\"replace\")) {\n    List<Node> arguments = new ArrayList<>();\n    arguments.add(argumentNode);\n    if (srcref != null) {\n      arguments.add(srcref);\n    }\n    return buildMethodCall(\"replace\", arguments);\n  } else if (methodName.equals(\"copy\")) {\n    List<Node> arguments = new ArrayList<>();\n    arguments.add(argumentNode);\n    if (srcref != null) {\n      arguments.add(srcref);\n    }\n    return buildMethodCall(\"copy\", arguments);\n  } else {\n    throw new RuntimeException(\"Unknown method name: \" + methodName);\n  }\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  List<Node> args = new ArrayList<>();\n  args.add(methodName);\n  args.add(argumentNode);\n  args.add(srcref);\n  return new Node(Token.NAME, null, methodName);\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for(int i = 0; i < indices.length; i++)\n        indices[i] = i;\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = i;\n    }\n\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = new int[doubles.length];\n    for(int i = 0; i < indices.length; i++)\n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        int m = main.length;\n        RealMatrix result = new Array2DRowRealMatrix(m, m);\n        double[] r = result.getData();\n        for (int i = 0; i < m; i++) {\n            r[i + i * m] = 1.0;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 0; j < i; j++) {\n                r[j + i * m] = -householderVectors[i][j];\n            }\n        }\n        cachedQt = result;\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        double data[][];\n        if (FastMath.equals(0, secondary[m - 2])) \n        {\n            data = new double[m][m];\n            for (int i = 0; i < m; ++i) \n            {\n                data[i][i] = 1.0;\n            }\n            data[0][0] = householderVectors[0][0];\n            for (int i = 1; i < m - 1; ++i) \n            {\n                data[i][i] = householderVectors[i][i] - householderVectors[i][i - 1] * secondary[i - 1];\n                data[i][i - 1] = -householderVectors[i][i - 1];\n                data[i - 1][i] = -householderVectors[i][i - 1];\n            }\n            data[m - 1][m - 1] = householderVectors[m - 1][m - 1] - householderVectors[m - 1][m - 2] * secondary[m - 2];\n        } \n        else \n        {\n            data = new double[m][m];\n            data[0][0] = 1.0;\n            for (int i = 1; i < m; ++i) \n            {\n                data[i][i] = householderVectors[i][i] - householderVectors[i][i - 1] * secondary[i - 1];\n                data[i][i - 1] = -householderVectors[i][i - 1];\n            }\n            for (int i = m - 2; i >= 0; --i) \n            {\n                data[i][i] = householderVectors[i][i] - householderVectors[i + 1][i] * secondary[i];\n                data[i][i + 1] = -householderVectors[i + 1][i];\n            }\n        }\n        cachedQt = new Array2DRowRealMatrix(data);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null)\n    {\n        final int m = householderVectors.length;\n        final double qt[][] = new double[m][m];\n        for (int j = 0; j < m; ++j)\n        {\n            for (int i = 0; i <= j; ++i)\n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = new Array2DRowRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = main.length;\n        double[][] qt = new double[m][m];\n\n        for (int j = 0; j < m; j++) \n        {\n            for (int i = 0; i <= j; i++) \n            {\n                qt[i][j] = 0.0;\n            }\n            qt[j][j] = 1.0;\n        }\n\n        for (int k = m - 1; k >= 0; k--) \n        {\n            double hk = FastMath.sqrt(householderVectors[k][k] * householderVectors[k][k]\n                                      + secondary[k] * secondary[k]);\n            for (int j = k; j < m; j++) \n            {\n                double qkj = (householderVectors[k][j] + secondary[k] / hk);\n                qt[k][j] = qkj;\n                qt[j][k] = qkj;\n            }\n        }\n\n        cachedQt = new Array2DRowRealMatrix(qt);\n    }\n\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null)\n    {\n        final int m = main.length;\n\n        // create the QT matrix\n        final double qt[][] = new double[m][m];\n\n        // initialize the first column of QT\n        for (int j = 0; j < m; j++) {\n            qt[j][0] = householderVectors[j][0];\n        }\n\n        // iterate over the remaining columns of QT\n        for (int k = 1; k < m; k++) {\n            for (int j = 0; j <= k; j++) {\n                double qtElement = 0.0;\n                for (int i = 0; i <= k - 1; i++) {\n                    qtElement += qt[j][i] * householderVectors[i][k];\n                }\n                qt[j][k] = qtElement;\n            }\n        }\n\n        // cache the QT matrix\n        cachedQt = new Array2DRowRealMatrix(qt);\n    }\n\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        double[][] qh = new double[m][m];\n        for (int j = 0; j < m; j++) \n        {\n            for (int i = 0; i <= j; i++) \n            {\n                double c = 0.0;\n                if (i == j) \n                {\n                    c = 1.0;\n                }\n                else if (i == j - 1) \n                {\n                    c = secondary[j - 1];\n                }\n                else if (i > j - 1) \n                {\n                    c = householderVectors[i][j];\n                }\n                for (int k = 0; k <= i; k++) \n                {\n                    qh[i][k] += c * householderVectors[j][k];\n                }\n            }\n        }\n        cachedQt = new Array2DRowRealMatrix(qh);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        double[][] qt = new double[m][m];\n        for (int i = 0; i < m - 1; ++i) \n        {\n            for (int j = 0; j <= i; ++j) \n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n            qt[i][i + 1] = -householderVectors[i][i + 1];\n            qt[i + 1][i] = qt[i][i + 1];\n            for (int j = i + 2; j < m; ++j) \n            {\n                qt[i][j] = 0.0;\n                qt[j][i] = 0.0;\n            }\n        }\n        for (int i = 0; i < m; ++i) \n        {\n            qt[i][i] = FastMath.sqrt(1.0 + qt[i][i]);\n        }\n        cachedQt = new Array2DRowRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = new Array2DRowRealMatrix(householderVectors.length, householderVectors.length);\n\n        for (int i = 0; i < householderVectors.length; i++) {\n            for (int j = 0; j < householderVectors.length; j++) {\n                if (j >= i) {\n                    cachedQt.setEntry(i, j, householderVectors[i][j]);\n                }\n            }\n        }\n\n        for (int j = 0; j < householderVectors.length - 1; j++) {\n            cachedQt.setEntry(j + 1, j, secondary[j]);\n        }\n    }\n\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = new Array2DRowRealMatrix(householderVectors.length, householderVectors.length);\n\n        for (int k = 0; k < householderVectors.length; k++) {\n            for (int i = k; i < householderVectors.length; i++) {\n                cachedQt.setEntry(i, k, householderVectors[i][k]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] q = new double[m][m];\n        for (int i = 0; i < m; i++) \n        {\n            final double norm = FastMath.sqrt(householderVectors[i][i] * householderVectors[i][i] + secondary[i - 1] * secondary[i - 1]);\n            q[i][i] = householderVectors[i][i] / norm;\n            q[i][i - 1] = secondary[i - 1] / norm;\n\n        for (int j = i + 1; j < m; j++) \n        {\n            q[i][j] = 0.0;\n        }\n        }\n        cachedQt = new Array2DRowRealMatrix(q);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(element);\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"set cannot be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer cannot be null\");\n    }\n    TransformedSet<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"set cannot be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"transformer cannot be null\");\n    }\n\n    TransformedSet<E> decorated = new TransformedSet<>(set, transformer);\n\n    for (E element : set) {\n        decorated.add(transformer.transform(element));\n    }\n\n    return decorated;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) \n    {\n        transformedSet.add(element);\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    TransformedSet<E> transformedSet = new TransformedSet<E>(set, transformer);\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) {\n        return this;\n    }\n    final char[] newBuffer = new char[Math.max(buffer.length * 2, capacity)];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        buffer = Arrays.copyOf(buffer, Math.max(buffer.length << 1, capacity));\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = Math.max(buffer.length << 1, capacity);\n        final char[] newBuffer = new char[newCapacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) \n    {\n        return this;\n    }\n    final char[] newBuffer = new char[Math.max(capacity, 2 * buffer.length)];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) \n    {\n        return this;\n    }\n    final int newLength = Math.max(Math.min(capacity, 2 * buffer.length), 64);\n    final char[] newBuffer = new char[newLength];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[Math.max(capacity, buffer.length * 2)];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) {\n        return this;\n    }\n    char[] newBuffer = new char[Math.max(capacity, buffer.length << 1)];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) {\n        return this;\n    }\n    final char[] newBuffer = new char[Math.max(buffer.length << 1, capacity)];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) \n    {\n        return this;\n    }\n    final int newCapacity = capacity * 3 / 2 + 1;\n    char[] newBuffer = new char[newCapacity];\n    System.arraycopy(buffer, 0, newBuffer, 0, size);\n    buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        buffer = Arrays.copyOf(buffer, Math.max(capacity, buffer.length * 2));\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getSeriesCount(); itemNo++) {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo <= itemNo; seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n            }\n        }\n        maximum = Math.max(maximum, total);\n        minimum = Math.min(minimum, total);\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.MAX_VALUE;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int itemNo = 0; itemNo < dataset.getSeriesCount(); itemNo++) {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo <= itemNo; seriesNo++) {\n            total += dataset.getYValue(seriesNo, itemNo);\n        }\n        maximum = Math.max(maximum, total);\n        minimum = Math.min(minimum, total);\n    }\n    if (minimum <= maximum) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    for (int itemNo = 0; itemNo < dataset.getSeriesCount(); itemNo++) {\n        double total = 0.0;\n        for (int seriesNo = 0; seriesNo <= itemNo; seriesNo++) {\n            total += dataset.getYValue(seriesNo, itemNo);\n        }\n        if (!Double.isNaN(minimum) && total < minimum) {\n            minimum = total;\n        }\n        else {\n            minimum = total;\n        }\n        if (!Double.isNaN(maximum) && total > maximum) {\n            maximum = total;\n        }\n        else {\n            maximum = total;\n        }\n    }\n    if (!Double.isNaN(minimum) && !Double.isNaN(maximum)) {\n        return new Range(minimum, maximum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n    {\n        double total = 0.0;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(seriesNo); itemNo++) \n        {\n            total += dataset.getYValue(seriesNo, itemNo);\n            if (Double.isNaN(minimum)) \n            {\n                minimum = total;\n            }\n            maximum = Math.max(maximum, total);\n        }\n    }\n    if (!Double.isNaN(minimum) && !Double.isNaN(maximum)) \n    {\n        return new Range(minimum, maximum);\n    }\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            total += dataset.getYValue(s, i);\n            if (Double.isNaN(minimum) || total < minimum) \n            {\n                minimum = total;\n            }\n            if (Double.isNaN(maximum) || total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    if (Double.isNaN(minimum) || Double.isNaN(maximum)) \n    {\n        return null;\n    }\n    else \n    {\n        return new Range(minimum, maximum);\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n    {\n        double runningTotal = 0.0;\n        for (int itemNo = dataset.getStartIndex(seriesNo); itemNo \n                <= dataset.getEndIndex(seriesNo); itemNo++) \n        {\n            double value = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(value)) \n            {\n                runningTotal += value;\n                if (Double.isNaN(minimum) || runningTotal < minimum) \n                {\n                    minimum = runningTotal;\n                }\n                if (Double.isNaN(maximum) || runningTotal > maximum) \n                {\n                    maximum = runningTotal;\n                }\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    for (int seriesNo = 0; seriesNo < dataset.getSeriesCount(); seriesNo++) \n    {\n        double positive = 0.0;\n        double negative = 0.0;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(seriesNo); itemNo++) \n        {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) \n            {\n                if (y > 0.0) \n                {\n                    positive += y;\n                }\n                else \n                {\n                    negative += y;\n                }\n            }\n        }\n        if (!Double.isNaN(maximum) && positive < minimum) \n        {\n            minimum = positive;\n        }\n        if (!Double.isNaN(minimum) && negative > maximum) \n        {\n            maximum = negative;\n        }\n        if (Double.isNaN(minimum)) \n        {\n            minimum = positive;\n        }\n        if (Double.isNaN(maximum)) \n        {\n            maximum = negative;\n        }\n    }\n    if (!Double.isNaN(minimum) && !Double.isNaN(maximum)) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double runningTotal = 0.0;\n        for (int i = 0; i < dataset.getItemCount(s); i++) \n        {\n            double value = dataset.getYValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                runningTotal += value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n    if (minimum <= maximum) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.NaN;\n    double maximum = Double.NaN;\n    int seriesCount = dataset.getSeriesCount();\n    for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) \n    {\n        for (int itemNo = 0; itemNo < dataset.getItemCount(seriesNo); itemNo++) \n        {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) \n            {\n                if (itemNo == 0) \n                {\n                    minimum = y;\n                    maximum = y;\n                }\n                else \n                {\n                    minimum = Math.min(minimum, y);\n                    maximum = Math.max(maximum, y);\n                }\n            }\n        }\n    }\n    if (!Double.isNaN(minimum) && !Double.isNaN(maximum)) \n    {\n        return new Range(minimum, maximum);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = 0.0;\n    double maximum = 0.0;\n    boolean hasValidData = false;\n    for (int itemNo = 0; itemNo < dataset.getSeriesCount(); itemNo++) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n            double y = dataset.getYValue(seriesNo, itemNo);\n            if (!Double.isNaN(y)) {\n                total += y;\n                if (seriesNo == itemNo) {\n                    hasValidData = true;\n                }\n                if (total > maximum) {\n                    maximum = total;\n                }\n                if (total < minimum) {\n                    minimum = total;\n                }\n            }\n        }\n    }\n    if (hasValidData) {\n        return new Range(minimum, maximum);\n    } else {\n        return null;\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        // Check if the hour offset is in range.\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours offset must be between -23 and 23\");\n        }\n\n        // Check if the minute offset is in range.\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes offset must be between -59 and 59\");\n        }\n\n        // Check if the minutes are positive when the hours are positive.\n        if (hoursOffset > 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"Minutes offset must be positive when hours offset is positive\");\n        }\n\n        // Calculate the total offset in milliseconds.\n        long offsetMillis = hoursOffset * 3600000L + minutesOffset * 60000L;\n\n        // Check if the offset is within the allowed range.\n        if (offsetMillis > 86400000L || offsetMillis < -86400000L) {\n            throw new IllegalArgumentException(\"Offset must be between +/- 23:59:59.000\");\n        }\n\n        // Create and return a new DateTimeZone object with the specified offset.\n        return new DateTimeZone(\"Etc/GMT\" + (hoursOffset > 0 ? \"+\" : \"\") + hoursOffset + \":\" + minutesOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > +23) {\n        throw new IllegalArgumentException(\"Hours offset must be between -23 and +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > +59) {\n        throw new IllegalArgumentException(\"Minutes offset must be between -59 and +59\");\n    }\n    if ((hoursOffset > 0 && minutesOffset < 0) || (hoursOffset < 0 && minutesOffset > 0)) {\n        throw new IllegalArgumentException(\"Cannot specify negative minutes when hour is positive\");\n    }\n    long millis = hoursOffset * 60 * 60 * 1000L + minutesOffset * 60 * 1000L;\n    if (millis > Integer.MAX_VALUE) {\n        throw new IllegalArgumentException(\"The resulting offset cannot exceed +/- 23:59:59.000\");\n    }\n    return new DateTimeZone(hoursOffset, minutesOffset, \"Zone\", millis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > +23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > +59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59: \" + minutesOffset);\n    }\n    if ((hoursOffset >= 0 && minutesOffset < 0) || (hoursOffset < 0 && minutesOffset > 0)) {\n        throw new IllegalArgumentException(\"Minutes may not be negative when hours are positive, or vice versa\");\n    }\n\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return getDefault();\n    } else if (hoursOffset == 0 && minutesOffset != 0) {\n        return fixedOffsetZone(printOffset(minutesOffset), minutesOffset * 60000L);\n    } else {\n        long millisOffset = (hoursOffset * 60 + minutesOffset) * 60000L;\n        if (millisOffset > 24 * 60 * 60 * 1000L || millisOffset < -24 * 60 * 60 * 1000L) {\n            throw new IllegalArgumentException(\"Offset must be within +/- 24 hours: \" + millisOffset);\n        }\n        return fixedOffsetZone(printOffset(millisOffset), millisOffset);\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) \n        {\n            throw new IllegalArgumentException(\"Hours offset must be between -23 and +23\");\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) \n        {\n            throw new IllegalArgumentException(\"Minutes offset must be between -59 and +59\");\n        }\n        if (minutesOffset < 0 && hoursOffset >= 0) \n        {\n            throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n        }\n        if ((hoursOffset == 23 && minutesOffset > 59) || (hoursOffset == -23 && minutesOffset < -59)) \n        {\n            throw new IllegalArgumentException(\"Offset must be between +/- 23:59:59.000\");\n        }\n        return fixedOffsetZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        // Validate input parameters\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours offset must be between -23 and 23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes offset must be between -59 and 59\");\n        }\n\n        // Calculate the offset in milliseconds\n        long offsetMillis = hoursOffset * 3600000L + minutesOffset * 60000L;\n\n        // Create and return the DateTimeZone object\n        return new DateTimeZone(offsetMillis, DateTimeZone.UTC);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"hours offset is out of range\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"minutes offset is out of range\");\n    }\n    if ((hoursOffset >= 0 && minutesOffset < 0) || (hoursOffset > 0 && minutesOffset > 0)) \n    {\n        throw new IllegalArgumentException(\"negative minutes are not allowed when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return getDefault();\n    }\n    if (hoursOffset == 0) \n    {\n        return DateTimeZone.forOffsetMinutes(minutesOffset);\n    }\n    if (minutesOffset == 0) \n    {\n        return DateTimeZone.forOffsetHours(hoursOffset);\n    }\n    return DateTimeZone.forOffsetHoursMinutes(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset > 23 || hoursOffset < -23) {\n            throw new IllegalArgumentException(\"hours offset must be between -23 and 23\");\n        }\n        if (minutesOffset > 59 || minutesOffset < -59) {\n            throw new IllegalArgumentException(\"minutes offset must be between -59 and 59\");\n        }\n        if ((hoursOffset >= 0 && minutesOffset < 0) || (hoursOffset < 0 && minutesOffset > 0)) {\n            throw new IllegalArgumentException(\"minutes must be zero when hours are not\");\n        }\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        }\n        if (Math.abs(hoursOffset) > 23 || Math.abs(hoursOffset) * 60 + Math.abs(minutesOffset) > 59) {\n            throw new IllegalArgumentException(\"time offset too large\");\n        }\n        if (hoursOffset > 0) {\n            hoursOffset += minutesOffset / 60;\n            minutesOffset %= 60;\n        } else {\n            hoursOffset -= minutesOffset / 60;\n            minutesOffset %= 60;\n        }\n        if (hoursOffset == 0 && minutesOffset == 0) {\n            return DateTimeZone.UTC;\n        } else {\n            return fixedOffsetZone(printOffset(hoursOffset * 60 + minutesOffset), hoursOffset * 60 + minutesOffset);\n        }\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > +23) {\n        throw new IllegalArgumentException(\"hours offset must be between -23 and +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > +59) {\n        throw new IllegalArgumentException(\"minutes offset must be between -59 and +59\");\n    }\n    if ((hoursOffset == +0) && (minutesOffset > +0)) {\n        throw new IllegalArgumentException(\"minutes offset cannot be positive when hours offset is zero\");\n    }\n    if (hoursOffset > +0) {\n        minutesOffset *= -1;\n    }\n    int millisOffset = ((hoursOffset * 60) + minutesOffset) * 60 * 1000;\n    if (millisOffset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"hours offset too large\");\n    }\n    if (millisOffset < -23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"hours offset too small\");\n    }\n    return fixedOffsetZone(\"+\" + printOffset(millisOffset), millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        int absHoursOffset = Math.abs(hoursOffset);\n        if (absHoursOffset > 23) {\n            throw new IllegalArgumentException(\"hoursOffset must be in the range -23 to +23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"minutesOffset must be in the range -59 to +59\");\n        }\n        if (hoursOffset >= 0 && minutesOffset < 0) {\n            throw new IllegalArgumentException(\"minutesOffset must be zero or positive\");\n        }\n        if (hoursOffset <= 0 && minutesOffset > 0) {\n            throw new IllegalArgumentException(\"minutesOffset must be negative\");\n        }\n        if (absHoursOffset == 23 && minutesOffset > 0) {\n            throw new IllegalArgumentException(\"minutesOffset must be zero or negative\");\n        }\n        long millisOffset = hoursOffset * 60L * 60L * 1000L + minutesOffset * 60L * 1000L;\n        if (millisOffset > 24L * 60L * 60L * 1000L) {\n            throw new IllegalArgumentException(\"Offset too large\");\n        } else if (millisOffset < -24L * 60L * 60L * 1000L) {\n            throw new IllegalArgumentException(\"Offset too small\");\n        }\n        return fixedOffsetZone(printOffset(millisOffset), millisOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        // Check if the offset is valid\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Invalid hours offset: must be between -23 and 23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Invalid minutes offset: must be between -59 and 59\");\n        }\n        \n        // Calculate the offset in milliseconds\n        long millisOffset = ((hoursOffset * 60L) + minutesOffset) * 60000L;\n        \n        // Create the DateTimeZone object using the offset\n        return DateTimeZone.forOffsetMillis(millisOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        if (c == '\\\\') \n        {\n            pos++;\n            char next = queue.charAt(pos);\n            sb.append(next);\n        }\n        else if (c == open) \n        {\n            depth++;\n            sb.append(c);\n            pos++;\n        }\n        else if (c == close) \n        {\n            depth--;\n            if (depth >= 0) \n            {\n                sb.append(c);\n                pos++;\n                if (depth == 0)\n                    return sb.toString();\n            }\n            else \n            {\n                pos++; // skip the closer\n            }\n        }\n        else \n        {\n            sb.append(c);\n            pos++;\n        }\n    }\n    \n    throw new IllegalStateException(\"Unbalanced string, missing closer: \" + open + \"/\" + close);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    boolean balanced = false;\n    int depth = 0;\n    while (!isEmpty() && !balanced) {\n        char c = queue.charAt(pos);\n        if (c == '\\\\') {\n            pos += 2; // skip escaped character\n        } else if (c == open) {\n            depth++;\n            pos++;\n        } else if (c == close) {\n            depth--;\n            pos++;\n        } else {\n            pos++;\n        }\n        balanced = (depth == 0);\n    }\n\n    if (depth > 0) {\n        return null; // unbalanced\n    }\n\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int nesting = 0;\n    while (!isEmpty()) \n    {\n        char ch = queue.charAt(pos);\n        pos++;\n        switch (ch) \n        {\n            case open:\n                nesting++;\n                break;\n            case close:\n                nesting--;\n                break;\n            case '\\\\':\n                pos++;\n                break;\n        }\n        if (nesting == 0) \n        {\n            return queue.substring(start, pos - 1);\n        }\n    }\n    throw new IllegalStateException(\"Unbalanced opening\");\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    boolean balanced = false;\n    boolean escaped = false;\n    char last = 0;\n    \n    while (!isEmpty()) \n    {\n        if (escaped)\n        {\n            sb.append(next());\n            escaped = false;\n        }\n        else\n        {\n            char c = next();\n            if (c == '\\\\')\n            {\n                escaped = true;\n                sb.append(c);\n            }\n            else if (c == open)\n            {\n                balanced = true;\n                sb.append(c);\n            }\n            else if (c == close && balanced)\n            {\n                balanced = false;\n                sb.append(c);\n            }\n            else\n            {\n                sb.append(c);\n                if (last == close)\n                    balanced = false;\n                last = c;\n            }\n        }\n    }\n    \n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    boolean matched = false;\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        if (pos >= queue.length())\n            throw new IllegalStateException(\"Queue ran out before matching balanced terminator\");\n        \n        char c = queue.charAt(pos);\n        if (c == open)\n            depth++;\n        else if (c == close)\n            depth--;\n        \n        pos++;\n        matched = true;\n        if (depth == 0)\n            break;\n    }\n    \n    if (!matched)\n        return null;\n    \n    String data = queue.substring(start, pos);\n    matchChomp(open, close);\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    char match = 0;\n    int depth = 0;\n    while (!isEmpty()) {\n        char ch = queue.charAt(pos);\n        pos++;\n        switch (ch) {\n            case '\\\\':\n                pos++; // skip escaped character\n                break;\n            case '\\'':\n            case '\"':\n                if (match == 0)\n                    match = ch;\n                else if (ch == match)\n                    match = 0;\n                break;\n            case open:\n                depth++;\n                break;\n            case close:\n                depth--;\n                if (depth < 0)\n                    throw new IllegalStateException(\"Unbalanced closer\");\n                else if (depth == 0) {\n                    String data = queue.substring(start, pos - 1); // -1 to not include closing char\n                    matchChomp(String.valueOf(close));\n                    return data;\n                }\n                break;\n        }\n    }\n    throw new IllegalStateException(\"Reached end of queue without finding a balanced terminator\");\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 0;\n    int start = pos;\n    while (!isEmpty()) \n    {\n        if (queue.charAt(pos) == open)\n            depth++;\n        else if (queue.charAt(pos) == close)\n            depth--;\n        if (depth >= 0)\n            pos++;\n        else\n            break;\n    }\n    if (depth != 0)\n        throw new IllegalStateException(\"Unbalanced matchers\");\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    boolean quoted = false;\n    boolean escaped = false;\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = queue.charAt(pos);\n        pos++;\n        if (escaped) \n        {\n            escaped = false;\n            continue;\n        }\n        if (quoted && c == '\\\\')\n        {\n            escaped = true;\n            continue;\n        }\n        if (c == '\\\\')\n        {\n            quoted = !quoted;\n            continue;\n        }\n        if (c == open) \n        {\n            depth++;\n            continue;\n        }\n        if (c == close) \n        {\n            if (depth == 0)\n                break;\n            else\n                depth--;\n            continue;\n        }\n    }\n    \n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    int startPos = pos;\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = queue.charAt(pos++);\n        if (c == open)\n            depth++;\n        else if (c == close)\n            depth--;\n        else if (c == '\\\\')\n            pos++; // ignore escapes\n        if (depth == 0)\n            return queue.substring(startPos, pos);\n    }\n    throw new IllegalStateException(\"Unmatched close character ('\" + close + \"') encountered\");\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    char lastChar = '\\u0000';\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = next();\n        if (c == '\\\\') \n        {\n            if (lastChar == '\\\\') \n            {\n                sb.append(c);\n            }\n            else \n            {\n                c = next();\n                if (c == '\\n' || c == '\\r')\n                    continue;\n                sb.append('\\\\');\n            }\n        }\n        else if (c == open)\n        {\n            depth++;\n        }\n        else if (c == close)\n        {\n            depth--;\n        }\n        else\n        {\n            sb.append(c);\n        }\n        lastChar = c;\n        if (depth < 0)\n            throw new IllegalStateException(\"Unbalanced close encountered\");\n        else if (depth == 0 && c == close)\n            return sb.toString();\n    }\n    throw new IllegalStateException(\"Unbalanced close encountered\");\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xT = getX().transpose();\n        final RealMatrix xTX = xT.operate(getX());\n        final RealMatrix invXTX = xTX.inverse();\n        final RealMatrix R = qr.getR();\n\n        final int p = getBeta().getDimension();\n        final RealMatrix topR = R.getSubMatrix(0, p - 1, 0, p - 1);\n        final RealMatrix topRT = topR.transpose();\n\n        return topRT.operate(invXTX).operate(topR);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (qr == null) {\n            throw new NullPointerException(\"Data must be loaded before calculating the beta variance\");\n        }\n        RealMatrix rSquared = qr.getR().transpose().multiply(qr.getR());\n        RealMatrix rSquaredInverse = rSquared.inverse();\n        RealMatrix xTransposedX = getX().transpose().multiply(getX());\n        RealMatrix xTransposedXInverse = xTransposedX.inverse();\n        RealMatrix betaVariance = xTransposedXInverse.multiply(rSquaredInverse).multiply(xTransposedXInverse);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix rTransposeR = qr.getR().transpose().operate(qr.getR());\n        final RealMatrix invRTransposeR = new LUDecomposition(rTransposeR).getSolver().getInverse();\n        final RealMatrix xtx = getX().transpose().operate(getX());\n        \n        return invRTransposeR.scalarMultiply(xtx);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix rrt = qr.getR().transpose().operate(qr.getR()).scalarDivide(getX().getColumnDimension() - 1);\n        return rrt.operate(new LUDecomposition(rrt).getSolver().getInverse()).scalarMultiply(getX().getColumnDimension() - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (qr == null) {\n            throw new NullPointerException(\"QR decomposition not initialized\");\n        }\n        RealMatrix xT = getX().transpose();\n        RealMatrix xTx = xT.operate(getX());\n        RealMatrix rTR = qr.getR().transpose().operate(qr.getR());\n        RealMatrix inv = rTR.scalarDivide(rTR.getNormDouble());\n        return inv.multiply(xTx);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (qr == null) {\n            throw new NullPointerException(\"QR decomposition not initialized.\");\n        }\n        final RealMatrix rTranspose = qr.getR().getRowMatrix(0, qr.getR().getRowDimension() - 1).transpose();\n        final RealMatrix rTransposeR = rTranspose.operate(qr.getR().getRowMatrix(0, qr.getR().getRowDimension() - 1));\n        final RealMatrix inverse = rTransposeR.inverse();\n        return inverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (qr == null) {\n            throw new NullPointerException(\"Data must be set before calculating the variance-covariance matrix\");\n        }\n        RealMatrix xTx = qr.getR().transpose().operate(qr.getR()).scalarMultiply(1.0 / getX().getRowDimension());\n        return xTx.inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix rSquared = new SecondMoment().evaluate(qr.getR().getData());\n        final RealMatrix inv = new LUDecomposition(rSquared).getSolver().getInverse();\n        return inv.scalarMultiply(1 / qr.getR().getColumnDimension());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (qr == null) {\n            throw new NullPointerException(\"Data must be set before calculating the variance-covariance matrix\");\n        }\n        RealMatrix XtX = qr.getR().transpose().operate(getX());\n        int p = qr.getR().getColumnDimension();\n        return XtX.getSubMatrix(0, p, 0, p).getSolver().getInverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix xTrans = getX().transpose();\n        final RealMatrix xTransX = xTrans.multiply(getX());\n        final RealMatrix xTransXInverse = xTransX.inverse();\n        final RealMatrix rTransR = qr.getR().transpose().multiply(qr.getR());\n        final int betaLength = qr.getR().getColumnDimension();\n        return xTransXInverse.multiply(rTransR.getSubMatrix(0, betaLength - 1, 0, betaLength - 1));\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    } else {\n        int absOffset = Math.abs(offset);\n        int hours = absOffset / (60 * 60 * 1000);\n        int minutes = (absOffset / (60 * 1000)) % 60;\n        StringBuffer sb = new StringBuffer(2 + 2 + 2);\n        sb.append(hours < 10 ? '0' + hours : hours);\n        sb.append(minutes < 10 ? '0' + minutes : minutes);\n        if (offset > 0) {\n            sb.insert(0, '+');\n        } else {\n            sb.insert(0, '-');\n        }\n        return sb.toString();\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hours = offset / 3600000;\n    int minutes = offset / 60000 % 60;\n    StringBuilder buf = new StringBuilder(hours >= 0 ? \"+\" : \"-\");\n    appendNumber(buf, Math.abs(hours), 2);\n    appendNumber(buf, minutes, 2);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return \"+\" + (offset / 3600000) + \":\" + ((offset / 60000) % 60);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    } else {\n        int absOffset = Math.abs(offset);\n        int hours = absOffset / 3600000;\n        int minutes = (absOffset / 60000) % 60;\n        StringBuilder buf = new StringBuilder(hours < 10 ? \"0\" + hours : hours);\n        if (minutes < 10) {\n            buf.append(\":0\");\n        } else {\n            buf.append(\":\");\n        }\n        buf.append(minutes);\n        if (offset < 0) {\n            buf.insert(0, '-');\n        } else {\n            buf.insert(0, '+');\n        }\n        return buf.toString();\n    }\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / (1000 * 60 * 60);\n    int minutes = (absOffset / (1000 * 60)) % 60;\n    StringBuffer buf = new StringBuffer();\n    if (offset > 0) {\n        buf.append(\"+\");\n    } else {\n        buf.append(\"-\");\n    }\n    if (hours < 10) {\n        buf.append(\"0\");\n    }\n    buf.append(hours);\n    if (minutes < 10) {\n        buf.append(\"0\");\n    }\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset formatter doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    } else {\n        int absOffset = Math.abs(offset);\n        int hours = absOffset / 3600000;\n        int minutes = (absOffset / 60000) % 60;\n        StringBuilder buf = new StringBuilder(hours < 10 ? \"0\" : \"\");\n        buf.append(hours);\n        buf.append(\":\");\n        buf.append(minutes < 10 ? \"0\" : \"\");\n        buf.append(minutes);\n        if (offset < 0) {\n            buf.insert(0, \"-\");\n        } else {\n            buf.insert(0, \"+\");\n        }\n        return buf.toString();\n    }\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    } else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    \n    if (this.indexMap.containsKey(key)) {\n        return ((Integer) this.indexMap.get(key)).intValue();\n    }\n    else {\n        return -1;\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    \n    Integer index = (Integer)this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    \n    return index.intValue();\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return ((Integer) this.indexMap.get(key)).intValue();\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    Integer i = (Integer) this.indexMap.get(key);\n    if (i == null) {\n        return -1;\n    } else {\n        return i.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key.\");\n    }\n    Integer result = (Integer) this.indexMap.get(key);\n    if (result == null) {\n        return -1;\n    } else {\n        return result.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key.\");\n    }\n    Integer index = (Integer) this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    } else {\n        return index.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    Integer result = (Integer) this.indexMap.get(key);\n    if (result == null) {\n        return -1;\n    } else {\n        return result.intValue();\n    }\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key.\");\n    }\n    Integer result = (Integer) this.indexMap.get(key);\n    if (result == null) {\n        return -1;\n    }\n    return result.intValue();\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    \n    if (this.indexMap.containsKey(key)) {\n        return ((Integer) this.indexMap.get(key)).intValue();\n    }\n    \n    return -1;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (String name : cache.usedSymbols) {\n    result.put(name, getSlot(name));\n  }\n  for (String name : cache.definedSymbols) {\n    result.put(name, getSlot(name));\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (String name : cache.usedSymbols) {\n        if (cache.isDirty(name)) {\n            result.put(name, getSlot(name));\n        }\n    }\n    return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet()) \n  {\n    StaticSlot<JSType> slot = entry.getValue();\n    if (slot.isLive()) \n    {\n      result.put(slot.getName(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet())\n  {\n    if (!entry.getValue().isFresh())\n    {\n      result.put(entry.getKey(), entry.getValue());\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (String name : cache.flowSlotNames) {\n        result.put(name, getSlot(name));\n    }\n    return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet()) \n  {\n    StaticSlot<JSType> slot = entry.getValue();\n    if (!slot.isFrozen()) \n    {\n      result.put(entry.getKey(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (String name : cache.flowSlots.keySet()) \n  {\n    result.put(name, getSlot(name));\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet()) \n  {\n    StaticSlot<JSType> slot = entry.getValue();\n    if (!slot.equals(cache.getEntryLattice())) \n    {\n      result.put(entry.getKey(), slot);\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> result = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet())\n  {\n    if (!entry.getValue().isConstant() && entry.getValue().isDefinedHere())\n    {\n      result.put(entry.getKey(), entry.getValue());\n    }\n  }\n  return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.flowSlots.entrySet()) \n    {\n        if (entry.getValue().isLive()) \n        {\n            result.put(entry.getKey(), entry.getValue());\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.439) {\n        result = acosh(2.0 / (a + 1));\n    } else if (a > 0.239) {\n        result = log1p(a / (1.0 - a));\n    } else if (a > -0.239) {\n        result = a;\n    } else if (a > -0.439) {\n        result = log1p((1.0 + a) / (1.0 - a));\n    } else {\n        result = asinh(a);\n    }\n\n    return negative ? -result : result;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    if (a > 0.5) {\n        return acosh((a + 1) / (a - 1));\n    } else if (a < -0.5) {\n        return -acosh((a + 1) / (a - 1));\n    } else {\n        return asinh(a);\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.439) {\n        result = acosh(2.0 / (a + 1));\n    } else if (a > 0.239) {\n        result = 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    } else {\n        double x = a * a;\n        result = x * (F_1_3 - x * (F_1_5 - x * (F_1_7 - x * (F_1_9 - x * (F_1_11 - x * (F_1_13 - x * F_1_15)))));\n    }\n\n    return negative ? -result : result;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    if (a > 1) {\n        return acosh(a) - LN2;\n    } else if (a < -1) {\n        return -acosh(a) - LN2;\n    } else {\n        double x = a * a;\n        double value = x / (1 - x);\n        if(negative) {\n            return -value;\n        } else {\n            return value;\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.439) \n    {\n        result = acosh(a + 1.0 / (FastMath.sqrt(a * a + 1) + a));\n    } \n    else if (a > 0.286) \n    {\n        result = asinh(2.0 * a / (1.0 + FastMath.sqrt(1.0 + a * a)));\n    } \n    else if (a > 0.1416) \n    {\n        final double a2 = a * a;\n        result = a * (1.0 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    } \n    else \n    {\n        final double a2 = a * a;\n        result = a * (1.0 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * F_1_11 * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    }\n\n    return negative ? -result : result;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.439) {\n        absAtanh = acosh(a + FastMath.sqrt(1 + a * a)) - acosh(a - FastMath.sqrt(1 + a * a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.238) {\n            absAtanh = asinh((2 * a) / (1 + Math.sqrt(1 - a2)));\n        } else if (a > 0.125) {\n            absAtanh = 0.5 * asinh((4 * a) / (3 + Math.sqrt(7 - 4 * a2)));\n        } else if (a > 0.0625) {\n            absAtanh = 0.75 * asinh((8 * a) / (7 + Math.sqrt(1 + 16 * a2)));\n        } else {\n            absAtanh = 1.5 * asinh((16 * a) / (15 + Math.sqrt(23 + 192 * a2)));\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.4343) {\n        absAtanh = acosh((a + 1.0) / (1.0 - a));\n    } else {\n        if (a > 0.2389) {\n            absAtanh = asinh(FastMath.sqrt((a + 1.0) / (1.0 - a)));\n        } else if (a > 0.1414) {\n            absAtanh = 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n        } else {\n            absAtanh = a;\n        }\n    }\n\n    return negative ? -absAtanh : absAtanh;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    if (a > 0.43429448170309202010) {\n        return acosh(a + 1.0) - acosh(1.0 / (a + 1.0));\n    } else if (a < -0.43429448170309202010) {\n        return -acosh(a + 1.0) + acosh(1.0 / (a + 1.0));\n    } else {\n        final double t = asinh(a);\n        return t - a * t * t;\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    if (a > 0.5) {\n        return acosh((a + 1.0) / (1.0 - a));\n    } else if (a > 0.4342944819032518) {\n        return FastMath.log(a + FastMath.sqrt(a * a + 1)) - FastMath.log(1.0 - a);\n    } else if (a > 0.23999622841870918) {\n        return FastMath.log(2.0 * a / (1.0 - a));\n    } else if (a > 0.13626794896736235) {\n        return asinh(a);\n    } else if (a > -0.13626794896736235) {\n        return -asinh(a);\n    } else {\n        return a - a * a * (F_1_3 - a * a * (F_1_5 - a * a * (F_1_7 - a * a * (F_1_9 - a * a * (F_1_11 - a * a * F_1_13)))));\n    }\n\n    if (negative) {\n        return -absAsinh;\n    }\n\n    return absAsinh;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.434) {\n        result = acosh(a + 1 / (a - 1));\n    } else if (a < -0.434) {\n        result = -acosh(a - 1 / (a + 1));\n    } else {\n        final double a2 = a * a;\n        final double a4 = a2 * a2;\n\n        result = a * (1 + a4 / 3 - a4 / 5 + a4 / 7);\n    }\n\n    return negative ? -result : result;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check if normalizedSum is infinite or NaN\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new IllegalArgumentException(\"Invalid normalized sum: \" + normalizedSum);\n    }\n\n    // Check if the input array contains any infinite elements\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Infinite element in input array\");\n        }\n    }\n\n    // Calculate the sum of the non-NaN elements\n    double sum = 0;\n    int count = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            count++;\n        }\n    }\n\n    // Check if the sum is zero\n    if (sum == 0) {\n        throw new ArithmeticException(\"Sum of input array is zero\");\n    }\n\n    // Normalize the elements\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs.\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum cannot be infinite.\");\n    }\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Input array sums to zero.\");\n    }\n\n    // Normalize the array.\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; ++i) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n\n    // Return the normalized array.\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (normalizedSum == Double.POSITIVE_INFINITY || normalizedSum == Double.NEGATIVE_INFINITY) {\n        throw new MathIllegalArgumentException(\"Infinite normalizedSum argument.\");\n    }\n\n    int numNonNaN = 0;\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            numNonNaN++;\n            sum += value;\n        }\n    }\n\n    if (numNonNaN == 0) {\n        throw new ArithmeticException(\"Cannot normalize an array with no non-NaN elements.\");\n    }\n\n    if (sum == 0.0) {\n        throw new ArithmeticException(\"Cannot normalize an array with a sum of zero.\");\n    }\n\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new IllegalArgumentException(\"Invalid normalizedSum: \" + normalizedSum);\n    }\n    int numNonNaNs = 0;\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            numNonNaNs++;\n            sum += value;\n        }\n    }\n    if (numNonNaNs == 0) {\n        throw new ArithmeticException(\"Array contains no non-NaN elements\");\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Array contains infinite elements\");\n    }\n\n    // Normalize the array\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check if the target sum is infinite or NaN\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new IllegalArgumentException(\"Target sum cannot be infinite or NaN\");\n    }\n\n    // Check if the input array contains any infinite elements\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n    }\n\n    // Calculate the sum of the non-NaN elements in the input array\n    double sum = 0.0;\n    int count = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            count++;\n        }\n    }\n\n    // Check if the input array sums to 0\n    if (count == 0) {\n        throw new ArithmeticException(\"Input array sums to 0\");\n    }\n\n    // Normalize the input array\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = Double.NaN;\n        }\n    }\n\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum: \" + normalizedSum);\n    }\n\n    // Calculate the sum of non-NaN elements\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    // Check for invalid sum\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n\n    // Normalize the elements\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    // Return the normalized array\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs.\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum cannot be infinite or NaN\");\n    }\n\n    // Check if the array contains any infinite elements.\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite elements\");\n        }\n    }\n\n    // Calculate the sum of non-NaN elements.\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    // Check if the sum is zero.\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n\n    // Normalize the array.\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs.\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalized sum: \" + normalizedSum);\n    }\n\n    // Calculate the sum of non-NaN elements.\n    double sum = 0.0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n\n    // Throw an exception if the sum is zero or infinite.\n    if (Double.isNaN(sum) || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Invalid array sum: \" + sum);\n    } else if (sum == 0.0) {\n        throw new MathArithmeticException(\"Array sum is zero, cannot normalize\");\n    }\n\n    // Normalize the elements.\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = (values[i] * normalizedSum) / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check if the target sum is valid\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalized sum: \" + normalizedSum);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new IllegalArgumentException(\"Invalid normalized sum: \" + normalizedSum);\n    }\n\n    // Check if the input array contains infinite elements or sums to zero\n    double sum = 0.0;\n    for (double value : values) {\n        if (Double.isNaN(value) || Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Infinite element in input array: \" + value);\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isNaN(sum) || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Invalid input array sum: \" + sum);\n    }\n    if (sum == 0.0) {\n        throw new ArithmeticException(\"Input array sum is zero\");\n    }\n\n    // Normalize the array\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (!Double.isFinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"The target sum is infinite or NaN\");\n    }\n\n    int validCount = 0;\n    double sum = 0.0;\n    for (double element : values) {\n        if (Double.isNaN(element)) {\n            continue;\n        }\n        validCount++;\n        sum += element;\n    }\n\n    if (validCount == 0) {\n        throw new IllegalArgumentException(\"No valid elements found in the array\");\n    }\n\n    if (Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"The input array contains infinite elements\");\n    }\n\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"The input array sums to zero\");\n    }\n\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = Double.NaN;\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final StringBuilder wrappedLine = new StringBuilder(str.length() + 32);\n    final int wrapLength = 60; // Set the desired line length\n\n    int offset = 0;\n\n    while (offset < str.length()) {\n        if (str.charAt(offset) == ' ') {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(offset, spaceToWrapAt));\n            wrappedLine.append(\"\\n\"); // Use newline character to wrap\n            offset = spaceToWrapAt + 1;\n\n        } else {\n            // really long word or URL\n            if (delimiters.length == 0) {\n                // wrap really long word one line at a time\n                wrappedLine.append(str.substring(offset, wrapLength + offset));\n                wrappedLine.append(\"\\n\"); // Use newline character to wrap\n                offset += wrapLength;\n            } else {\n                // do not wrap really long word, just extend beyond limit\n                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n                if (spaceToWrapAt >= 0) {\n                    wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                    wrappedLine.append(\"\\n\"); // Use newline character to wrap\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    wrappedLine.append(str.substring(offset));\n                    offset = str.length();\n                }\n            }\n        }\n    }\n\n    // Whatever is left in line is short enough to just pass through\n    wrappedLine.append(str.substring(offset));\n\n    return wrappedLine.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    if (delimiters == null || delimiters.length == 0) {\n        delimiters = new char[]{' '};\n    }\n\n    final StringBuilder wrappedLine = new StringBuilder(str.length() + 32);\n    wrappedLine.append(Character.toUpperCase(str.charAt(0)));\n\n    for (int i = 1; i < str.length(); i++) {\n        if (str.charAt(i) == ' ') {\n            continue;\n        }\n\n        final boolean isDelimiter = false;\n        for (final char delimiter : delimiters) {\n            if (str.charAt(i) == delimiter) {\n                isDelimiter = true;\n                break;\n            }\n        }\n\n        if (isDelimiter) {\n            wrappedLine.append(Character.toUpperCase(str.charAt(i)));\n        } else {\n            wrappedLine.append(str.charAt(i));\n        }\n    }\n    \n    return wrappedLine.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final char[] array = str.toCharArray();\n    final int len = array.length;\n\n    final boolean[] capitalizeNext = new boolean[len + 1];\n    for (int i = 0; i < len + 1; i++) {\n        capitalizeNext[i] = true;\n    }\n\n    for (int i = 0; i < len; i++) {\n        final char ch = array[i];\n        final boolean capitalizeThis = capitalizeNext[i];\n\n        if (Character.isWhitespace(ch)) {\n            capitalizeNext[i + 1] = true;\n        } else {\n            if (capitalizeThis) {\n                array[i] = Character.toTitleCase(ch);\n            } else {\n                array[i] = Character.toLowerCase(ch);\n            }\n            capitalizeNext[i + 1] = false;\n        }\n\n        for (final char delimiter : delimiters) {\n            if (ch == delimiter) {\n                capitalizeNext[i + 1] = true;\n                break;\n            }\n        }\n    }\n\n    return new String(array);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder wrappedLine = new StringBuilder(str.length());\n    final int len = delimiters.length;\n    int offset = 0;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (len != 0) {\n            boolean isDelimiter = false;\n            for (int j = 0; j < len; j++) {\n                if (delimiters[j] == ch) {\n                    isDelimiter = true;\n                    break;\n                }\n            }\n            if (isDelimiter) {\n                if (offset != i) {\n                    wrappedLine.append(str.substring(offset, i).toUpperCase());\n                }\n                wrappedLine.append(ch);\n                offset = i + 1;\n            }\n        } else {\n            if (Character.isWhitespace(ch)) {\n                if (offset != i) {\n                    wrappedLine.append(str.substring(offset, i).toUpperCase());\n                }\n                wrappedLine.append(ch);\n                offset = i + 1;\n            }\n        }\n    }\n    if (offset != str.length()) {\n        wrappedLine.append(str.substring(offset).toUpperCase());\n    }\n    return wrappedLine.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder wrappedLine = new StringBuilder(str.length() + 32);\n    int offset = 0;\n    final int inputLineLength = str.length();\n    final int wrapLength = 64;\n    final boolean wrapLongWords = true;\n    final String newLineStr = \"\\n\";\n\n    while (inputLineLength - offset > wrapLength) {\n        if (str.charAt(offset) == ' ') {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(offset, spaceToWrapAt));\n            wrappedLine.append(newLineStr);\n            offset = spaceToWrapAt + 1;\n\n        } else {\n            // really long word or URL\n            if (wrapLongWords) {\n                // wrap really long word one line at a time\n                wrappedLine.append(str.substring(offset, wrapLength + offset));\n                wrappedLine.append(newLineStr);\n                offset += wrapLength;\n            } else {\n                // do not wrap really long word, just extend beyond limit\n                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n                if (spaceToWrapAt >= 0) {\n                    wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                    wrappedLine.append(newLineStr);\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    wrappedLine.append(str.substring(offset));\n                    offset = inputLineLength;\n                }\n            }\n        }\n    }\n\n    // Whatever is left in line is short enough to just pass through\n    wrappedLine.append(str.substring(offset));\n\n    return wrappedLine.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final StringBuilder wrappedLine = new StringBuilder(str.length());\n    final char[] chars = str.toCharArray();\n    int offset = 0;\n\n    while (offset < chars.length) {\n        if (Character.isWhitespace(chars[offset])) {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = -1;\n\n        for (int i = offset; i < chars.length; i++) {\n            if (Character.isWhitespace(chars[i])) {\n                spaceToWrapAt = i;\n                break;\n            }\n            \n            for (char delimiter : delimiters) {\n                if (chars[i] == delimiter) {\n                    spaceToWrapAt = i;\n                    break;\n                }\n            }\n        }\n\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(offset, spaceToWrapAt));\n            wrappedLine.append(str.substring(spaceToWrapAt, spaceToWrapAt + 1).toUpperCase());\n            offset = spaceToWrapAt + 1;\n            \n        } else {\n            // really long word or URL\n            wrappedLine.append(str.substring(offset));\n            offset = chars.length;\n        }\n    }\n\n    return wrappedLine.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return \"\";\n    }\n\n    final StringBuilder result = new StringBuilder(strLen);\n\n    int lastIndex = -1;\n\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (Character.isWhitespace(ch) || (delimiters != null && Arrays.binarySearch(delimiters, ch) >= 0)) {\n            if (i != lastIndex + 1) {\n                result.append(Character.toTitleCase(ch));\n                lastIndex = i;\n            }\n        } else {\n            result.append(ch);\n        }\n    }\n\n    return result.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    final int len = str.length();\n    final StringBuilder buffer = new StringBuilder(len);\n    char c, p = 0;\n    for (int i = 0; i < len; i++) {\n        c = Character.toLowerCase(str.charAt(i));\n        if (i == 0) {\n            buffer.append(Character.toTitleCase(c));\n        } else if (i > 0 && str.charAt(i - 1) == ' ') {\n            for (final char delimiter: delimiters) {\n                if (c == delimiter) {\n                    buffer.append(str.substring(p, i)).append(c);\n                    p = i + 1;\n                }\n            }\n            buffer.append(Character.toTitleCase(c));\n        } else {\n            buffer.append(c);\n        }\n    }\n    buffer.append(str.substring(p));\n    return buffer.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        delimiters = new char[]{' '};\n    }\n\n    final StringBuilder wrappedLine = new StringBuilder(str.length() + 32);\n    int lastIndex = 0;\n    int offset = 0;\n    while (offset < str.length()) {\n        if (str.charAt(offset) == ' ') {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = -1;\n        for (int i = 0; i < delimiters.length; ++i) {\n            if (str.indexOf(delimiters[i], offset) >= 0) {\n                spaceToWrapAt = str.indexOf(delimiters[i], offset);\n                break;\n            }\n        }\n\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(lastIndex, spaceToWrapAt));\n            wrappedLine.append(Character.toTitleCase(str.charAt(spaceToWrapAt + 1)));\n            lastIndex = spaceToWrapAt + 2;\n            offset = lastIndex;\n            \n        } else {\n            // really long word or URL\n            if (wrapLongWords) {\n                // wrap really long word one line at a time\n                wrappedLine.append(str.substring(offset, wrapLength + offset));\n                wrappedLine.append(newLineStr);\n                offset += wrapLength;\n            } else {\n                // do not wrap really long word, just extend beyond limit\n                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n                if (spaceToWrapAt >= 0) {\n                    wrappedLine.append(str.substring(offset, spaceToWrapAt));\n                    wrappedLine.append(newLineStr);\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    wrappedLine.append(str.substring(offset));\n                    offset = str.length();\n                }\n            }\n        }\n    }\n\n    // Whatever is left in line is short enough to just pass through\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null || str.isBlank())\n    {\n        return str;\n    }\n\n    StringBuilder wrappedLine = new StringBuilder(str.length() + 32);\n    wrappedLine.append(str.substring(0, 1).toUpperCase());\n    wrappedLine.append(str.substring(1).toLowerCase());\n    return wrappedLine.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null).withUTC(); // always use UTC, avoiding DST gaps\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) \n            { // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            }\n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            return mutableDateTime;\n        }\n    }\n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                mutableDateTime = mutableDateTime.withZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null).withUTC();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mutableDateTime.setZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            return mutableDateTime.toImmutable();\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null).withUTC();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mutableDateTime.withZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null).withUTC();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime md = new MutableDateTime(millis, chrono);\n            return md;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n        \n    Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) \n            {  // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mutableDateTime.setZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTXInverse = getOmegaInverse().operate(getX().transpose()).operate(getX());\n        RealMatrix XTY = getOmegaInverse().operate(getX().transpose()).operate(getY());\n        RealVector beta = XTXInverse.operate(XTY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYSampleData();\n        RealMatrix inverseOmega = getOmegaInverse();\n        RealMatrix inverseXTX = new LUDecomposition(X.transpose().scalarMultiply(inverseOmega).multiply(X)).getSolver().getInverse();\n        return inverseXTX.multiply(X.transpose().scalarMultiply(inverseOmega).operate(y));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTX = X.transpose().multiply(getOmegaInverse()).multiply(X);\n        RealMatrix XTInvX = XTX.getSolver().getInverse();\n        RealMatrix XTInvY = X.transpose().multiply(getOmegaInverse()).operate(y);\n        return XTInvX.operate(XTInvY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealMatrix Xt = X.transpose();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XtOmegaInverseX = Xt.operate(OmegaInverse).operate(X);\n        RealMatrix XtOmegaInverseY = Xt.operate(OmegaInverse).operate(getYSampleData());\n        RealMatrix XtOmegaInverseXInverse = new LUDecomposition(XtOmegaInverseX).getSolver().getInverse();\n        return XtOmegaInverseXInverse.operate(XtOmegaInverseY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYSampleData();\n        RealMatrix xt = X.transpose();\n        RealMatrix xtOmegaInverse = xt.scalarMultiply(getOmegaInverse());\n        RealMatrix xtOmegaInverseX = xtOmegaInverse.operate(X);\n        RealMatrix xtOmegaInverseXInverse = xtOmegaInverseX.scalarMultiply(1.0 / xtOmegaInverseX.getEntry(0,0));\n        return xtOmegaInverseXInverse.operate(xtOmegaInverse).operate(y);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTXInverse = getOmegaInverse().operate(getX().transpose()).operate(getX());\n        RealMatrix XTY = getOmegaInverse().operate(getX().transpose()).operate(getY());\n        return XTXInverse.operate(XTY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealMatrix Xt = X.transpose();\n        RealMatrix XTXinverse = Xt.operate(getOmegaInverse()).operate(X).inverse();\n        RealVector Xty = Xt.operate(getYSampleData());\n        return XTXinverse.operate(Xty);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYSample();\n        RealMatrix Xt = X.transpose();\n        RealMatrix XtOmegaInverseX = Xt.operate(getOmegaInverse()).operate(X);\n        RealMatrix XtOmegaInverseXInverse = XtOmegaInverseX.getSolver().getInverse();\n        RealVector beta = XtOmegaInverseXInverse.operate(Xt).operate(getOmegaInverse()).operate(y);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTX = getXT().transpose().multiply(getOmegaInverse()).multiply(getXT());\n        RealMatrix XTinvX = new LUDecomposition(XTX).getSolver().getInverse();\n        RealMatrix XTinvY = getXT().transpose().multiply(getOmegaInverse()).multiply(getY());\n        RealVector beta = XTinvX.operate(XTinvY);\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getXMatrix();\n        RealVector y = getYSampleData();\n        RealMatrix inverseOmega = getOmegaInverse();\n        RealMatrix inverseXTX = new LUDecomposition(X.transpose().scalarMultiply(inverseOmega).multiply(X)).getSolver().getInverse();\n        return inverseXTX.multiply(X.transpose().scalarMultiply(inverseOmega).operate(y));\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    return getElementByAttribute(\"id\", id);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    List<Element> elements = parent().childElementsList();\n    for (Element element : elements) {\n        if (element.getAttribute(Tags.ID).equalsIgnoreCase(id)) {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    List<Element> elements = Collector.collect(new Evaluator.Attr(\"id\", id), this);\n    if (elements.size() > 0)\n        return elements.get(0);\n    else\n        return null;\n}",
      "public Element getElementById(String id)  {\n    Elements elements = getElementsByTag(\"element\");\n    for (Element element : elements)\n    {\n        if (element.attribute(\"id\").equals(id))\n        {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Elements elements = getElementsByTag(\"id\"); //get all elements with id as the tag\n    for (Element element : elements) {\n        if (element.getId().equals(id)) { //compare the id of the element to the given id\n            return element; //return the element if found\n        }\n    }\n    return null; //return null if id not found\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    List<Element> elements = parent().childElementsList();\n    for (Element element : elements) {\n        if (element.id().equals(id)) {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Elements elements = getElementsByTag(\"element\");\n    for (Element element : elements)\n    {\n        String elementId = element.attr(\"id\");\n        if (elementId.equals(id))\n        {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).firstElement();\n}",
      "public Element getElementById(String id)  {\n    return getElementByAttribute(\"id\", id);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    StringBuilder result = new StringBuilder(pattern);\n    int pos = 0;\n    for (final String custom : customPatterns) {\n        int start = pattern.indexOf(START_FMT, pos);\n        if (start < 0) {\n            return pattern;\n        }\n        int end = pattern.indexOf(END_FE, start + 1);\n        if (end < 0) {\n            return pattern;\n        }\n        result.replace(start, end + 1, custom);\n        pos = end + 1;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    ParsePosition pos = new ParsePosition(0, 0);\n    for (; pos.getIndex() < pattern.length(); next(pos)) {\n        switch (pattern.charAt(pos.getIndex())) {\n        case START_FE:\n            pos.setIndex(pos.getIndex() + 1);\n            final int index = readArgumentIndex(pattern, pos);\n            final Format format = getFormat(pattern);\n            final String text = parseFormatDescription(pattern, pos);\n            result.append(pattern.substring(start, pos.getIndex()));\n            if (customPatterns != null && customPatterns.size() > index) {\n                result.append(customPatterns.get(index));\n            } else if (format != null) {\n                result.append(format.format(pattern));\n            }\n            start = pos.getIndex();\n            break;\n        case END_FE:\n            pos.setIndex(pos.getIndex() + 1);\n            break;\n        case QUOTE:\n            result.append(pattern.substring(start, pos.getIndex()));\n            result.append(getQuotedString(pattern, pos, false));\n            start = pos.getIndex();\n            break;\n        default:\n            break;\n        }\n    }\n    result.append(pattern.substring(start));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    final int end = pattern.length();\n    for (int i = 0; i < end; i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FMT) {\n            if (i > start) {\n                result.append(pattern.substring(start, i));\n            }\n            final int idx = readArgumentIndex(pattern, new ParsePosition(i + 1));\n            final String desc = parseFormatDescription(pattern, new ParsePosition(i + 1));\n            Format format = getFormat(desc);\n            if (format == null) {\n                if (customPatterns != null) {\n                    for (String custom : customPatterns) {\n                        format = getFormat(custom);\n                        if (format != null) {\n                            break;\n                        }\n                    }\n                }\n                if (format == null) {\n                    throw new IllegalArgumentException(\"Invalid format element at position \" + start + \": \" + pattern.substring(start, i + 1));\n                }\n            }\n            result.append(format.getPattern());\n            start = i + desc.length();\n        }\n    }\n    if (start < end) {\n        result.append(pattern.substring(start));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FMT) {\n            result.append(pattern, start, i);\n            start = i;\n            if (customPatterns != null) {\n                for (String customPattern : customPatterns) {\n                    int index = readArgumentIndex(customPattern, new ParsePosition(0));\n                    if (index == i + 1) {\n                        result.append(customPattern);\n                        i += customPattern.length() - 1;\n                        break;\n                    }\n                }\n            } else {\n                result.append(parseFormatDescription(pattern, new ParsePosition(i + 1)));\n            }\n        }\n    }\n    result.append(pattern, start, pattern.length());\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        final int start = pos;\n        seekNonWs(pattern, pos);\n        final char c = pattern.charAt(pos);\n        if (c != START_FMT) {\n            result.append(pattern.substring(start, pos));\n            next(pos);\n            continue;\n        }\n        final int index = readArgumentIndex(pattern, pos);\n        final StringBuilder desc = new StringBuilder();\n        while (pos < pattern.length() && pattern.charAt(pos) != END_FE) {\n            desc.append(pattern.charAt(pos++));\n        }\n        result.append(pattern.substring(start, pos));\n        if (customPatterns != null && customPatterns.size() > index) {\n            result.append(customPatterns.get(index));\n        } else {\n            final Format fmt = getFormat(desc.toString());\n            if (fmt != null) {\n                result.append(fmt.toPattern(getLocale()));\n            } else {\n                result.append(desc);\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    int start = -1;\n    while (pos.getIndex() < pattern.length()) {\n        final char c = pattern.charAt(pos.getIndex());\n        if (c == START_FMT) {\n            if (start >= 0) {\n                result.append(pattern.substring(start, pos.getIndex()));\n            }\n            final int index = readArgumentIndex(pattern, pos);\n            if (index >= customPatterns.size()) {\n                throw new IllegalArgumentException(\n                        \"Invalid format argument index: \" + index);\n            }\n            final String replacement = customPatterns.get(index);\n            result.append(replacement);\n            start = -1;\n            next(pos);\n        } else if (c == START_FE) {\n            if (start >= 0) {\n                result.append(pattern.substring(start, pos.getIndex()));\n            }\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) {\n                final String replacement = format.toPattern(getLocale());\n                result.append(replacement);\n            } else {\n                result.append(START_FMT).append(desc).append(END_FE);\n            }\n            start = -1;\n        } else {\n            if (start < 0) {\n                start = pos.getIndex();\n            }\n        }\n    }\n    if (start >= 0) {\n        result.append(pattern.substring(start));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    int start = 0;\n    for (; pos.getIndex() < pattern.length(); next(pos)) {\n        if (pattern.charAt(pos.getIndex()) == START_FMT) {\n            if (customPatterns != null) {\n                for (final String customPattern : customPatterns) {\n                    if (customPattern.startsWith(pattern.substring(start, pos.getIndex()))) {\n                        result.append(customPattern);\n                        start = pos.getIndex();\n                        break;\n                    }\n                }\n            }\n            final int argIndex = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format == null) {\n                throw new IllegalArgumentException(\n                        \"Invalid format character at position \" + start + \": \" + desc);\n            }\n            result.append(pattern.substring(start, pos.getIndex()));\n            result.append(format.toPattern(getLocale()));\n            start = pos.getIndex();\n        }\n    }\n    result.append(pattern.substring(start));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (registry == null) {\n        return pattern;\n    }\n    int pos = 0;\n    StringBuilder result = new StringBuilder(pattern.length());\n    while (pos < pattern.length()) {\n        final int start = pos;\n        if (pattern.charAt(pos) == START_FMT) {\n            pos++;\n            final int startArgIndex = readArgumentIndex(pattern, new ParsePosition(pos));\n            if (customPatterns != null && customPatterns.size() > startArgIndex) {\n                final String customFormat = customPatterns.get(startArgIndex);\n                if (customFormat != null) {\n                    pos += customFormat.length();\n                    result.append(customFormat);\n                    continue;\n                }\n            }\n            final String description = parseFormatDescription(pattern, new ParsePosition(pos));\n            final int startQuote = pos;\n            final String quotedString = getQuotedString(pattern, new ParsePosition(pos), false);\n            if (quotedString != null) {\n                pos += quotedString.length();\n                result.append(quotedString);\n            } else {\n                final Format format = getFormat(description);\n                if (format != null) {\n                    final String formatText = format.toPattern(getLocale());\n                    pos += formatText.length();\n                    result.append(formatText);\n                } else {\n                    pos += description.length();\n                    result.append(description);\n                }\n            }\n        } else {\n            pos++;\n        }\n        if (pos > start) {\n            result.append(pattern.substring(start, pos));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final char c = pattern.charAt(pos.getIndex());\n        if (c == START_FMT) {\n            final int argumentIndex = readArgumentIndex(pattern, pos);\n            final String description = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(description);\n            if (format != null) {\n                result.append(pattern.substring(start, pos.getIndex()));\n                result.append(format.toPattern(customPatterns));\n                pos.setIndex(pos.getIndex() - 1); // Back up to the closing }\n            } else {\n                result.append(pattern.substring(start, pos.getIndex() + 1));\n            }\n        } else {\n            result.append(pattern.substring(start, pos.getIndex()));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    StringBuilder result = new StringBuilder(pattern.length() + customPatterns.size());\n    int pos = 0;\n    int customIndex = 0;\n    while (pos < pattern.length() && customIndex < customPatterns.size()) {\n        if (pattern.charAt(pos) == START_FMT) {\n            int argIndex = readArgumentIndex(pattern, new ParsePosition(pos));\n            if (argIndex >= customPatterns.size() || argIndex < customIndex) {\n                result.append(pattern.charAt(pos++));\n            } else {\n                result.append(customPatterns.get(argIndex));\n                customIndex++;\n            }\n        } else {\n            result.append(pattern.charAt(pos++));\n        }\n    }\n    if (pos < pattern.length()) {\n        result.append(pattern.substring(pos));\n    } else if (customIndex < customPatterns.size()) {\n        result.append(customPatterns.get(customIndex));\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType() != to.getRawType()) {\n    return false;\n  }\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // First check if they have the same raw type.\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  // Then compare the type arguments, doing variable replacements as necessary.\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n    if (!typeEquals(fromArg, toArg, typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // First, check the raw type.\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  // Then, check the type arguments.\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromType = fromArgs[i];\n    Type toType = toArgs[i];\n\n    if (fromType.equals(toType)) {\n      continue;\n    }\n\n    // Check if either type is a type variable.\n    if (fromType instanceof TypeVariable) {\n      fromType = typeVarMap.get(((TypeVariable<?>) fromType).getName());\n    }\n    if (toType instanceof TypeVariable) {\n      toType = typeVarMap.get(((TypeVariable<?>) toType).getName());\n    }\n\n    if (!fromType.equals(toType)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    Type fromArg = fromArgs[i];\n    Type toArg = toArgs[i];\n\n    if (fromArg instanceof TypeVariable && toArg instanceof TypeVariable) {\n      if (!fromArg.equals(toArg)) {\n        Type fromVarType = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n        Type toVarType = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n        if (fromVarType == null || toVarType == null) {\n          return false;\n        } else {\n          if (!typeEquals(fromVarType, toVarType, typeVarMap)) {\n            return false;\n          }\n        }\n      }\n    } else if (!fromArg.equals(toArg)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n\n      Type fromType = fromArgs[i];\n      Type toType = toArgs[i];\n\n      if (fromType.equals(toType)) {\n        continue;\n      }\n\n      if (fromType instanceof TypeVariable) {\n        Type replacement = typeVarMap.get(((TypeVariable<?>) fromType).getName());\n        if (replacement == null) {\n          return false;\n        }\n        fromType = replacement;\n      }\n\n      if (toType instanceof TypeVariable) {\n        Type replacement = typeVarMap.get(((TypeVariable<?>) toType).getName());\n        if (replacement == null) {\n          return false;\n        }\n        toType = replacement;\n      }\n\n      if (!fromType.equals(toType)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n\n      Type fromArg = resolveTypeArgument(fromArgs[i], typeVarMap);\n      Type toArg = resolveTypeArgument(toArgs[i], typeVarMap);\n\n      if (!isAssignableFrom(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType() != to.getRawType()) {\n    return false;\n  }\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterDurationConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\n    checkAlterDurationConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n\ncheckAlterPeriodConverters();\nif (converter == null) {\nreturn null;\n}\nPeriodConverter[] removed = new PeriodConverter[1];\niPeriodConverters = iPeriodConverters.add(converter, removed);\nreturn removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n        if (iterator == null) {\n            throw new NullPointerException(\"iterator cannot be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        } else {\n            return new UnmodifiableIterator<E>(iterator);\n        }\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n    if (iterator == null) {\n        throw new NullPointerException(\"iterator cannot be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator cannot be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        } else {\n            return new UnmodifiableIterator<>(iterator);\n        }\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"iterator cannot be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n        if (iterator == null) {\n            throw new NullPointerException(\"iterator cannot be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator cannot be null\");\n        }\n        if (iterator instanceof Unmodifiable) {\n            return iterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n        if (iterator == null) {\n            throw new NullPointerException(\"The iterator cannot be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator) {\n            return iterator;\n        } else {\n            return new UnmodifiableIterator<E>(iterator);\n        }\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator cannot be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator cannot be null\");\n    }\n\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\")\n        final Iterator<E> unmodifiableIterator = (Iterator<E>) iterator;\n        return unmodifiableIterator;\n    }\n\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  throws NullPointerException {\n    if (iterator == null) {\n        throw new NullPointerException(\"The iterator cannot be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        return iterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\nPreconditions.checkNotNull(node, \"node\");\nfor (int i = 0; i < colorToNodeMap.length; i++) {\nif (node.equals(colorToNodeMap[i])) {\nreturn colorToNodeMap[i];\n}\n}\nreturn null;\n}",
      "public N getPartitionSuperNode(N node)  {\n   Preconditions.checkNotNull(node);\n   if (colorToNodeMap[graph.getAnnotation(node).color] == null) {\n      colorToNodeMap[graph.getAnnotation(node).color] = node;\n   }\n   return colorToNodeMap[graph.getAnnotation(node).color];\n}",
      "public N getPartitionSuperNode(N node)  {\nPreconditions.checkNotNull(node);\nif (colorToNodeMap != null && colorToNodeMap[graph.getAnnotation(node).color()] == node)\n{\n  return node;\n}\nreturn colorToNodeMap[graph.getAnnotation(node).color()];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getAnnotation(node).getValue()];\n}",
      "public N getPartitionSuperNode(N node)  {\n   Preconditions.checkNotNull(node);\n   int color = graph.getGraphNode(node).getAnnotation(Color.class).color;\n   if (colorToNodeMap[color] == null) {\n       colorToNodeMap[color] = node;\n   }\n   return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n\tPreconditions.checkNotNull(node);\n\tif (colorToNodeMap[graph.getAnnotation(node).color] == null)\n\t\tcolorToNodeMap[graph.getAnnotation(node).color] = node;\n\treturn colorToNodeMap[graph.getAnnotation(node).color];\n}",
      "public N getPartitionSuperNode(N node)  {\nPreconditions.checkNotNull(node, \"node cannot be null\");\nfor (int i = 0; i < graph.getGraphNodeCount(); i++) {\nif (graph.getGraphNode(i).getAnnotation() == node) {\nreturn graph.getGraphNode(i);\n}\n}\nreturn null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    return this.graph.getNode(node).getAnnotation();\n}",
      "public N getPartitionSuperNode(N node)  {\n    Preconditions.checkNotNull(node);\n    return colorToNodeMap[graph.getGraphNode(node).getAnnotation(Color.class).colorIndex];\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap[graph.getGraphNode(node).getAnnotation(Color.class).getColor()] == null)\n    {\n        colorToNodeMap[graph.getGraphNode(node).getAnnotation(Color.class).getColor()] = node;\n    }\n    return colorToNodeMap[graph.getGraphNode(node).getAnnotation(Color.class).getColor()];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; ++i) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; ++i) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; ++i) {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null)\n        return true;\n    else if (map1 == null || map2 == null)\n        return false;\n    else if (map1.size() != map2.size())\n        return false;\n    else\n    {\n        for (Object key : map1.keySet())\n        {\n            if (!map2.containsKey(key))\n                return false;\n            else\n            {\n                if (!map1.get(key).equals(map2.get(key)))\n                    return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    Iterator iterator1 = keys1.iterator();\n    Iterator iterator2 = keys2.iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) \n    {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) \n        {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null)\n        return true;\n    if (map1 == null ^ map2 == null)\n        return false;\n    if (map1.size() != map2.size())\n        return false;\n    Set keys = map1.keySet();\n    for (Comparable key : keys) {\n        Paint paint = map2.get(key);\n        if (paint == null ^ map2.get(key) == null)\n            return false;\n        if (!paint.equals(map2.get(key)))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    else if ((map1 == null && map2 != null) || (map1 != null && map2 == null)) {\n        return false;\n    }\n    else if (map1.size() != map2.size()) {\n        return false;\n    }\n    else {\n        for (Map.Entry entry : map1.entrySet()) {\n            Comparable key = (Comparable) entry.getKey();\n            Paint paint1 = (Paint) entry.getValue();\n            Paint paint2 = (Paint) map2.get(key);\n            if (!paint1.equals(paint2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        if (!keys2.contains(key1)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key1);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) \n    {\n        return true;\n    }\n    else if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    else if (map1.keySet().size() != map2.keySet().size()) \n    {\n        return false;\n    }\n    else \n    {\n        for (Comparable key : map1.keySet()) \n        {\n            if (!((Comparable) map2.get(key)).equals(key)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null)\n        return true;\n    if (map1 == null ^ map2 == null)\n        return false;\n    if (map1.size() != map2.size())\n        return false;\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    Iterator iterator1 = keys1.iterator();\n    Iterator iterator2 = keys2.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (key1 == null && key2 == null)\n            continue;\n        if (key1 == null ^ key2 == null)\n            return false;\n        if (!key1.equals(key2))\n            return false;\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (paint1 == null && paint2 == null)\n            continue;\n        if (paint1 == null ^ paint2 == null)\n            return false;\n        if (!paint1.equals(paint2))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    for (Comparable key : map1.keySet()) \n    {\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) \n    {\n        return true;\n    }\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.keySet().size() != map2.keySet().size()) \n    {\n        return false;\n    }\n    Iterator iterator1 = map1.keySet().iterator();\n    while (iterator1.hasNext()) \n    {\n        Comparable key1 = (Comparable) iterator1.next();\n        if (!map2.containsKey(key1)) \n        {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key1);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String string = expr.getString();\n    if (string.length() <= 500) {\n      return new StringLiteral(t, string);\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"s('\");\n    char[] chars = string.toCharArray();\n    for (char c : chars) {\n      switch (c) {\n        case '\\u0000':\n          builder.append(\"\\\\0\");\n          break;\n        case '\\u0007':\n          builder.append(\"\\\\a\");\n          break;\n        case '\\b':\n          builder.append(\"\\\\b\");\n          break;\n        case '\\t':\n          builder.append(\"\\\\t\");\n          break;\n        case '\\n':\n          builder.append(\"\\\\n\");\n          break;\n        case '\\u000C':\n          builder.append(\"\\\\f\");\n          break;\n        case '\\r':\n          builder.append(\"\\\\r\");\n          break;\n        default:\n          if (c < 0x20 || (c >= 0x7F && c <= 0x9F)) {\n            builder.append(\"\\\\u\");\n            char[] hex = Character.toChars(c);\n            builder.append(hex[0]);\n            builder.append(hex[1]);\n          } else {\n            builder.append(c);\n          }\n      }\n    }\n    builder.append(\"')\");\n    return new StringLiteral(t, builder.toString());\n  }\n\n  if (expr.isName()) {\n    String name = expr.getString();\n    if (name.startsWith(\"LAMBDA$\")) {\n      String newExpr = name.replaceFirst(\"LAMBDA$\", \"\");\n      Node newExprNode = new Name(t, newExpr);\n      newExprNode.copyJSDocFrom(expr);\n      return newExprNode;\n    }\n  }\n\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String string = expr.getString();\n        String encodedString = StringEscapeUtils.escapeJavaScript(string);\n        Node replacementNode = new StringLiteral(encodedString);\n        parent.replaceChild(expr, replacementNode);\n        t.register(replacementNode);\n        return replacementNode;\n    } else {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String str = expr.getString();\n      int len = str.length();\n      char[] arr = str.toCharArray();\n\n      // Check for special cases.\n      if (len == 0) {\n        return new StringLiteral(\"\");\n      } else if (len == 1 && (arr[0] == '\\n' || arr[0] == '\\r' || arr[0] == '\\t')) {\n        return new StringLiteral(\"\\\\\" + arr[0]);\n      } else if (arr[0] == '\"' && arr[len - 1] == '\"') {\n        String escaped = escapeString(str);\n        return new StringLiteral(\"\\\"\" + escaped + \"\\\"\");\n      } else if (arr[0] == '\\'' && arr[len - 1] == '\\'') {\n        String escaped = escapeString(str);\n        return new StringLiteral(\"'\" + escaped + \"'\");\n      }\n\n      // Encode the string.\n      StringBuilder sb = new StringBuilder(len + 6);\n      for (int i = 0; i < len; i++) {\n        char ch = arr[i];\n        switch (ch) {\n          case '\\b':\n            sb.append('\\\\');\n            sb.append('b');\n            break;\n          case '\\n':\n            sb.append('\\\\');\n            sb.append('n');\n            break;\n          case '\\r':\n            sb.append('\\\\');\n            sb.append('r');\n            break;\n          case '\\t':\n            sb.append('\\\\');\n            sb.append('t');\n            break;\n          case '\"':\n            sb.append('\\\\');\n            sb.append('\"');\n            break;\n          case '\\\\':\n            sb.append('\\\\');\n            sb.append('\\\\');\n            break;\n          default:\n            // Encode Unicode characters above ASCII.\n            if (ch > 0x7F) {\n              sb.append('\\\\');\n              sb.append('u');\n              String hex = Integer.toHexString(ch);\n              for (int j = 0; j < 4 - hex.length(); j++) {\n                sb.append('0');\n              }\n              sb.append(hex);\n            } else {\n}\n}\n}\n}\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (!expr.isString()) {\n    return expr;\n  }\n  // Replace the string with a short encoded string.\n  String value = expr.getString();\n  short encodedValue = encodeString(value);\n  String encodedValueStr = String.format(\"/*%d*/\", encodedValue);\n  return t.replaceNode(expr, new StringLiteral(encodedValueStr));\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String value = expr.getString();\n      if (value.length() > 2) {\n        String encoded = value.substring(1, value.length() - 1);\n        expr = new StringLiteral(encoded);\n        parent.replaceChild(expr, parent.indexOf(expr));\n        t.report(Diagnostic.Kind.WARNING,\n            \"Short string literal used\", expr);\n      }\n    } else if (expr.isName()) {\n      String name = expr.getString();\n      if (\"undefined\".equals(name) || \"null\".equals(name)) {\n        expr = new Literal(name);\n        parent.replaceChild(expr, parent.indexOf(expr));\n      }\n    }\n\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        return new StringLiteral(str).toAST();\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String string = expr.getString().replace('\\'', '\\\"');\n      return new StringLiteral(string);\n    } else if (expr.isName()) {\n      String name = expr.getString();\n      Config config = findMatching(name);\n      if (config != null) {\n        Node replacement = config.replacement;\n        if (replacement != null) {\n          replacement = replacement.cloneTree();\n          replacement = t.replace(replacement, parent, expr);\n          replacement = t.replace(replacement, parent, expr);\n          return replacement;\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String string = expr.getString().replace(\"\\\"\", \"\\\\\\\"\");\n      expr = new StringLiteralImpl(\"\\\"\" + string + \"\\\"\");\n      parent.replaceChild(expr, parent.indexOf(expr.getOriginalNode()));\n    } else if (expr.isName()) {\n      String name = expr.getString();\n      if (methods.containsKey(name)) {\n        Collection<String> classes = methods.get(name);\n        for (String className : classes) {\n          JSType callClassType = registry.getType(className);\n          Config config = findMatchingClass(callClassType, classes);\n          if (config != null) {\n            Node methodCall = parent.getFirstChild().getNext().getNext();\n            methodCall = methodCall.getFirstChild();\n            if (methodCall.getString().equals(name)) {\n              doSubstitutions(t, config, parent);\n            }\n          }\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String value = expr.getString().replace('\\n', ' ');\n      value = value.replaceAll(\"\\\\s+\", \"\");\n      return new StringLiteral(value).toAST();\n    } else {\n      return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (!expr.isString()) {\n    return expr;\n  }\n  // Replace the string literal with a short encoded string literal.\n  String str = expr.getString();\n  if (str.startsWith(\"u00\") && str.length() == 6) {\n    str = str.substring(2);\n    char ch = (char) Integer.parseInt(str, 16);\n    return createString(t, Character.toString(ch));\n  }\n  return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length - 1];\n    System.arraycopy(a, 1, out, 0, a.length - 1);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length - 1];\n    System.arraycopy(a, 1, out, 0, a.length - 1);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length - 1];\n    System.arraycopy(a, 1, out, 0, a.length - 1);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length - 1];\n    System.arraycopy(a, 1, out, 0, a.length - 1);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length - 1];\n    System.arraycopy(a, 1, out, 0, a.length - 1);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJsDoc()) {\n        for (Node child : node.getChildren()) {\n            if (child.isProperty()) {\n                Node keyNode = child.getFirstChild();\n                if (keyNode.getString().equals(\"description\")\n                    || keyNode.getString().equals(\"desc\")) {\n                    Node descNode = child.getNext();\n                    String desc = extractStringFromStringExprNode(descNode);\n                    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                        builder.setIsHidden(true);\n                    } else {\n                        builder.setDesc(desc);\n                    }\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (!node.isComment()) {\n    return false;\n  }\n  String jsDoc = node.getString();\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node == null || !node.isJSDoc()) {\n        return false;\n    }\n    for (Node tag : node.getAllChildren()) {\n        if (tag.isJSDocTag()) {\n            String tagName = tag.getString().toLowerCase();\n            if (tagName.equals(\"desc\") || tagName.equals(\"description\")) {\n                Node valueNode = tag.getFirstChild();\n                String desc = extractStringFromStringExprNode(valueNode);\n                desc = desc.startsWith(HIDDEN_DESC_PREFIX) ?\n                        desc.substring(HIDDEN_DESC_PREFIX.length()).trim()\n                        : desc;\n                builder.setDesc(desc);\n                builder.setIsHidden(desc.startsWith(HIDDEN_DESC_PREFIX));\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isJSDoc()) {\n      Node descNode = node.getChildByName(DESCRIPTION);\n      if (descNode != null) {\n        String desc = extractStringFromStringExprNode(descNode);\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JsDoc jsDoc = extractJsDoc(node);\n    if (jsDoc == null) {\n      return false;\n    }\n    for (JsDoc.Tag jsDocTag : jsDoc.getTags()) {\n      if (jsDocTag.getName().equalsIgnoreCase(\"desc\")) {\n        String desc = jsDocTag.getContent().trim();\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.isJsDoc()) {\n    Node commentNode = node.getFirstChild();\n    while (commentNode != null) {\n      if (commentNode.isTag()) {\n        String tagName = commentNode.getString();\n        if (tagName.equals(MSG_DESC_TAG)) {\n          Node descriptionNode = commentNode.getFirstChild();\n          if (descriptionNode != null) {\n            builder.setDesc(descriptionNode.getString());\n            return true;\n          }\n        }\n      }\n      commentNode = commentNode.getNext();\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (!node.hasJsDoc()) {\n    return false;\n  }\n\n  for (Node tagNode : node.getJsDoc().getTags()) {\n    if (tagNode.getKey().equals(JsDocUtil.DESC_TAG)) {\n      Node valueNode = tagNode.getFirstChild();\n      if (!valueNode.isString()) {\n        throw new MalformedException(\n            \"Invalid description for message \" + builder.getKey(), valueNode);\n      }\n      String desc = extractStringFromStringExprNode(valueNode);\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    if (node.isAnnotation() && node.getString().equals(JsDocHelper.JS_DOC)) {\n      Node commentNode = node.getNext();\n      while (commentNode != null) {\n        if (commentNode.isComment()) {\n          Node descNode = commentNode.getNext();\n          if (descNode.isAnnotation() &&\n              descNode.getString().equals(JsDocHelper.DESC_ANNOTATION)) {\n            Node descValueNode = descNode.getNext();\n            if (descValueNode.isString()) {\n              builder.setDesc(descValueNode.getString());\n              return true;\n            }\n          }\n        }\n        commentNode = commentNode.getNext();\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node == null) {\n    return false;\n  }\n  if (node instanceof VarNode) {\n    return false;\n  }\n  if (!(node instanceof BlockStmt)) {\n    return false;\n  }\n  BlockStmt blockStmt = (BlockStmt) node;\n  if (blockStmt.getJsDoc() == null) {\n    return false;\n  }\n  Node jsDoc = blockStmt.getJsDoc().getFirstChild();\n  if (!(jsDoc instanceof ArrayLiteral)) {\n    return false;\n  }\n  ArrayLiteral arrayLiteral = (ArrayLiteral) jsDoc;\n  for (Node jsDocProperty : arrayLiteral.getElements()) {\n    if (!(jsDocProperty instanceof ObjectLiteral)) {\n      continue;\n    }\n    ObjectLiteral objectLiteral = (ObjectLiteral) jsDocProperty;\n    String key = objectLiteral.getKey();\n    if (key == null) {\n      continue;\n    }\n    Node value = objectLiteral.getValue();\n    if (value == null) {\n      continue;\n    }\n    if (key.equals(\"desc\")) {\n      builder.setDesc(value.getString());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  if (node.isJsDoc()) {\n    Node jsDocNode = node;\n    while (jsDocNode.getNext() != null) {\n      jsDocNode = jsDocNode.getNext();\n    }\n    Node child = jsDocNode.getFirstChild();\n    if (child.getString().equals(DESC)) {\n      Node descNode = child.getFirstChild();\n      String desc = extractStringFromStringExprNode(descNode);\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n    // iterate over the points\n    int unassigned = 0;\n    for (int i = 0; i < points.size(); i++) {\n        // get the point we're currently checking\n        final T point = points.toArray(new T[points.size()])[i];\n\n        // check which cluster is closest to the point\n        int closest = -1;\n        double minDistance = Double.MAX_VALUE;\n        for (int j = 0; j < clusters.size(); j++) {\n            final double distance = clusters.get(j).getDistance(point);\n            if (distance < minDistance) {\n                closest = j;\n                minDistance = distance;\n            }\n        }\n\n        // update the assignment for this point\n        if (closest != assignments[i]) {\n            assignments[i] = closest;\n            unassigned++;\n        }\n    }\n    \n    return unassigned;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n\n    MathUtils.checkNotNull(points);\n    MathUtils.checkNotNull(assignments);\n\n    if (clusters.size() != assignments.length) {\n        throw new IllegalArgumentException(\"clusters.size() must be equal to assignments.length\");\n    }\n\n    int changes = 0;\n\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.toArray(new T[points.size()])[i];\n\n        // get the distance to each cluster and store it in an array\n        double[] distances = new double[clusters.size()];\n        for (int j = 0; j < clusters.size(); j++) {\n            distances[j] = clusters.get(j).distance(point);\n        }\n\n        // get the index of the closest cluster\n        int closestCluster = 0;\n        for (int j = 1; j < distances.length; j++) {\n            if (distances[j] < distances[closestCluster]) {\n                closestCluster = j;\n            }\n        }\n\n        // if the point is not assigned to the closest cluster, assign it and increment the changes count\n        if (assignments[i] != closestCluster) {\n            assignments[i] = closestCluster;\n            changes++;\n            clusters.get(closestCluster).addPoint(point);\n        }\n    }\n\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.iterator().next();\n        int closest = getClosestCluster(clusters, point);\n        if (assignments[i] != closest) {\n            assignments[i] = closest;\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        int currentAssignment = assignments[i];\n        CentroidCluster<T> closestCluster = getClosestCluster(clusters, points.toArray(new T[] { points.toArray()[i] }));\n\n        if (closestCluster.equals(clusters.get(currentAssignment))) {\n            continue;\n        }\n\n        changes++;\n        assignments[i] = clusters.indexOf(closestCluster);\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n\n        MathUtils.checkNotNull(points);\n        MathUtils.checkNotNull(assignments);\n\n        int changes = 0;\n        for (final T point : points) {\n            final int closestCluster = getClosestCluster(clusters, point);\n            if (closestCluster != assignments[points.indexOf(point)]) {\n                changes++;\n            }\n            clusters.get(closestCluster).addPoint(point);\n            assignments[points.indexOf(point)] = closestCluster;\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n\n        // sanity check\n        MathUtils.checkNotNull(points);\n\n        int changes = 0;\n\n        for (int i = 0; i < points.size(); i++) {\n            T p = points.iterator().next();\n\n            // get the current cluster of the point\n            int closest = assignments[i];\n            CentroidCluster<T> closestCluster = clusters.get(closest);\n\n            // find the new closest cluster\n            int newClosest = -1;\n            for (int j = 0; j < clusters.size(); j++) {\n                CentroidCluster<T> cluster = clusters.get(j);\n                if (newClosest < 0 || distance(cluster.getCenter().getPoint(), p)\n                        < distance(closestCluster.getCenter().getPoint(), p)) {\n                    newClosest = j;\n                    closestCluster = cluster;\n                }\n            }\n\n            // if the new closest is different from the current closest, update it\n            if (closest != newClosest) {\n                assignments[i] = newClosest;\n                changes++;\n                closestCluster.addPoint(p);\n            }\n        }\n        return changes;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.toArray(new T[0])[i];\n        int closest = -1;\n        double closestDistance = Double.POSITIVE_INFINITY;\n\n        // find the closest cluster for the point\n        for (int j = 0; j < clusters.size(); j++) {\n            double distance = distance(point, clusters.get(j).getCenter().getPoint());\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closest = j;\n            }\n        }\n        if (closest != assignments[i]) {\n            assignments[i] = closest;\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n    // iterate over all points and add them to the closest cluster\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        final T point = points.iterator().next();\n        final int currentClusterIndex = assignments[i];\n\n        // calculate the closest cluster for the current point\n        final int closestClusterIndex = getClosestClusterIndex(clusters, point);\n\n        // if the closest cluster is different from the current cluster, update the assignment\n        if (currentClusterIndex != closestClusterIndex) {\n            changes++;\n            assignments[i] = closestClusterIndex;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  throws MathIllegalArgumentException {\n    int changes = 0;\n    for (int i = 0; i < points.size(); i++) {\n        T point = points.toArray(new T[points.size()])[i];\n        int currentCluster = assignments[i];\n        int bestDistanceIndex = -1;\n        int bestDistance = Integer.MAX_VALUE;\n        for (int j = 0; j < clusters.size(); j++) {\n            final int distance = distance(point, clusters.get(j).getCenter().getPoint());\n            if (distance < bestDistance) {\n                bestDistanceIndex = j;\n                bestDistance = distance;\n            }\n        }\n        if (currentCluster != bestDistanceIndex) {\n            assignments[i] = bestDistanceIndex;\n            changes++;\n        }\n    }\n    return changes;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n    int changes = 0;\n    for (int p = 0; p < points.size(); p++) {\n        T point = points.iterator().next();\n        int closestClusterIndex = getClosestCluster(clusters, point);\n        if (assignments[p] != closestClusterIndex) {\n            changes++;\n            assignments[p] = closestClusterIndex;\n        }\n    }\n\n    for (int i = 0; i < clusters.size(); i++) {\n        clusters.get(i).clearPoints();\n    }\n    for (int p = 0; p < points.size(); p++) {\n        T point = points.iterator().next();\n        int closestClusterIndex = assignments[p];\n        clusters.get(closestClusterIndex).addPoint(point);\n    }\n\n    return changes;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Two arrays lengths differ\");\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n\n    double covariance = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xArray.average()) * (yArray[i] - yArray.average());\n    }\n\n    if (biasCorrected) {\n        covariance = covariance / (xArray.length - 1);\n    } else {\n        covariance = covariance / xArray.length;\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Input arrays must have the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Input arrays must have a length >= 2\");\n    }\n\n    double cov = 0.0;\n    double varianceX = 0.0;\n    double varianceY = 0.0;\n    int n = xArray.length;\n\n    for (int i = 0; i < n; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        cov += (x - xArray.mean()) * (y - yArray.mean());\n        varianceX += Math.pow(x - xArray.mean(), 2);\n        varianceY += Math.pow(y - yArray.mean(), 2);\n    }\n\n    if (biasCorrected) {\n        cov = cov / (n - 1);\n        varianceX = varianceX / (n - 1);\n        varianceY = varianceY / (n - 1);\n    } else {\n        cov = cov / n;\n        varianceX = varianceX / n;\n        varianceY = varianceY / n;\n    }\n\n    return cov / Math.sqrt(varianceX * varianceY);\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must be the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Array length must be at least two\");\n    }\n    double meanX = mean(xArray);\n    double meanY = mean(yArray);\n    double cov = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        cov += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    cov /= xArray.length - (biasCorrected ? 1 : 0);\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data for covariance estimation\");\n    }\n    double sumSquaredX = 0.0;\n    double sumSquaredY = 0.0;\n    double sumProducts = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumSquaredX += xArray[i] * xArray[i];\n        sumSquaredY += yArray[i] * yArray[i];\n        sumProducts += xArray[i] * yArray[i];\n    }\n    double n = xArray.length;\n    double varianceX = sumSquaredX / n - (sumX / n) * (sumX / n);\n    double varianceY = sumSquaredY / n - (sumY / n) * (sumY / n);\n    return (sumProducts / n - (sumX / n) * (sumY / n)) / (Math.sqrt(varianceX * varianceY));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Array length must be at least 2.\");\n    }\n\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xArray.average()) * (yArray[i] - yArray.average());\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Array length must be at least 2.\");\n    }\n    Variance variance = new Variance(biasCorrected);\n    double covariance = 0.0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - xArray.average()) * (yArray[i] - yArray.average());\n    }\n    covariance /= xArray.length - 1;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Array length must be at least 2.\");\n    }\n\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n    double sumX = 0.0;\n    double sumY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n\n        sumXY += x * y;\n        sumX2 += x * x;\n        sumY2 += y * y;\n        sumX += x;\n        sumY += y;\n    }\n\n    int n = xArray.length;\n\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n\n    double cov = (sumXY - n * meanX * meanY) / (n - 1);\n\n    if (biasCorrected) {\n        cov = (sumXY - n * meanX * meanY) / n;\n    }\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data for covariance estimation.\");\n    }\n    double sumx = 0.0;\n    double sumy = 0.0;\n    double sumxy = 0.0;\n    double sumxx = 0.0;\n    double sumyy = 0.0;\n    int n = xArray.length;\n    for (int i = 0; i < n; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        sumx += x;\n        sumy += y;\n        sumxy += x * y;\n        sumxx += x * x;\n        sumyy += y * y;\n    }\n    double meanx = sumx / n;\n    double meany = sumy / n;\n    double variance = (sumxx - n * meanx * meanx) / (n - 1);\n    double covariance = (sumxy - n * meanx * meany) / (n - 1);\n    if (biasCorrected) {\n        covariance = (covariance - variance * variance / n) / (1 - 1.0 / (n - 1));\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Arrays must have the same length.\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There must be at least two data points to compute the covariance.\");\n    }\n\n    double sumXY = 0.0;\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXSq = 0.0;\n    double sumYSq = 0.0;\n\n    // Compute the sums and squared sums of the arrays\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    // Calculate the covariance\n    double covariance = (sumXY - (sumX * sumY) / xArray.length) /\n            (xArray.length - (biasCorrected ? 1 : 0));\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Two arrays are of different lengths\");\n    }\n\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"At least two elements are needed to compute the covariance\");\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / yArray.length;\n\n    double covariance = (sumXY - xArray.length * meanX * meanY) / (xArray.length - (biasCorrected ? 1 : 0));\n\n    return covariance;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0L) \n    {\n        final int bytesRead = in.read(buf.array(), buf.position(), (int) Math.min(remaining, buf.remaining()));\n        if (bytesRead == -1) \n        {\n            throw new EOFException(\"Unexpected end of ZIP archive\");\n        }\n        remaining -= bytesRead;\n        bytesRead(bytesRead);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    while (value > 0) \n    {\n        final int skipped = in.read(buf.array(), 0, (int) Math.min(value, buf.remaining()));\n        if (skipped <= 0) \n        {\n            throw new IOException(\"Unexpected end of stream\");\n        }\n        bytesRead(skipped);\n        value -= skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    int read = 0;\n    while (read < value) {\n        read += in.read(buf.array(), (int) value - read, (int) (value - read));\n    }\n    bytesRead(read);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        int read = 0;\n        while (read < value) {\n            final int currentRead = in.read(buf.array(), read, (int) Math.min(value - read, buf.remaining()));\n            if (currentRead == -1) {\n                throw new EOFException(\"Unexpected end of stream\");\n            }\n            read += currentRead;\n            bytesRead += currentRead;\n        }\n    } else {\n        throw new IOException(\"Cannot skip backwards\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long read = Math.min(value, Long.MAX_VALUE - in.getBytesRead());\n    in.skip(read);\n    bytesRead(read);\n}",
      "private void realSkip(final long value) throws IOException  {\n    final long skipped = in.skip(value);\n    bytesRead += skipped;\n    if (skipped < value) {\n        throw new EOFException(\"Failed to skip \" + value + \" bytes\");\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    for (long i = value; i > 0; i -= buf.remaining()) \n    {\n        if (i > Integer.MAX_VALUE) \n        {\n            readFully(buf, (int) i);\n        } \n        else \n        {\n            readFully(buf, (int) i);\n        }\n    }\n    bytesRead += value;\n}",
      "private void realSkip(final long value) throws IOException  {\n    while (value > 0)\n    {\n        final int skipped = in.read(buf.array(), 0, (int)Math.min(value, buf.limit()));\n        if (skipped < 0)\n        {\n            throw new EOFException(\"Failed to skip requested bytes\");\n        }\n        bytesRead(skipped);\n        value -= skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    bytesRead += in.skip(value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        final int read = in.skip((int) value);\n        bytesRead += read;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = cls.getDeclaredField(fieldName);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    if (field.isAccessible()) {\n        return field.get(target);\n    }\n    if (!field.isAccessible()) {\n        field.setAccessible(true);\n    }\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = cls.getDeclaredField(fieldName);\n    if (forceAccess) \n    {\n        field.setAccessible(true);\n    }\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = cls.getDeclaredField(fieldName);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    if (!field.isAccessible()) \n    {\n        throw new IllegalAccessException(\"Cannot access field \" + fieldName + \" on \" + cls);\n    }\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n        throw new IllegalArgumentException(\"target object must not be null\");\n    if (fieldName == null) \n        throw new IllegalArgumentException(\"field name must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = cls.getDeclaredField(fieldName);\n    if (field == null) \n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    if (!field.isAccessible()) \n        field.setAccessible(true);\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n        throw new IllegalArgumentException(\"target object must not be null\");\n    if (fieldName == null) \n        throw new IllegalArgumentException(\"field name must not be null\");\n    final Class<?> cls = target.getClass();\n    final Field field = cls.getDeclaredField(fieldName);\n    if (field == null) \n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    if (!field.isAccessible()) \n        field.setAccessible(forceAccess);\n    return field.get(target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    if (fieldName == null) \n    {\n        throw new IllegalArgumentException(\"field name must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  long result = 0;\n  for (CharSequence part : messageParts) \n  {\n    result ^= part.toString().hashCode();\n  }\n  return String.format(\"%016x\", result).toUpperCase().substring(0, 6);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  return Long.toString(MurmurHash3.hash64(messageParts), Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  long fp = 0x42L;\n  for (CharSequence part : messageParts) \n  {\n    if (part instanceof String) \n    {\n      fp = 37L * fp + ((String) part).hashCode();\n    } \n    else if (part instanceof PlaceholderReference) \n    {\n      fp = 37L * fp + \"placeholder\".hashCode();\n    } \n    else \n    {\n      throw new IllegalArgumentException(\"Unexpected part: \" + part);\n    }\n  }\n  return Long.toString(fp, Character.MAX_RADIX).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long hash = 0x9E3779B97F4A7C15L;\n    for (CharSequence part : messageParts) {\n        if (part instanceof String) {\n            hash = 31L * hash ^ ((String) part).hashCode();\n        } else if (part instanceof PlaceholderReference) {\n            hash = 31L * hash ^ ((PlaceholderReference) part).getName().hashCode();\n        } else {\n            throw new IllegalArgumentException(\"Invalid part: \" + part);\n        }\n    }\n    return Long.toString(hash & 0x3FFFFFFFFFFFFFL, Character.MAX_RADIX).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement logic to generate the fingerprint here.\n    // ...\n    //\n    // Return the generated fingerprint as a string.\n    return fingerprintString;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long hash = Hashing.combineHashcodes(messageParts);\n    return Integer.toHexString((int) (hash ^ (hash >>> 32)));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement fingerprint generation logic here\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  // TODO: Implement fingerprint generation logic\n  return \"PLACEHOLDER_FINGERPRINT\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Create a 64-bit hash from the message parts\n    long hash = Hashing.murmur3_64().hashUnencodedChars(messageParts.toString()).asLong();\n\n    // Convert the hash to a 64-bit integer (necessary for Java)\n    long hashInt = hash & 0x7fffffffffffffffL;\n\n    // Convert the integer to a 32-bit integer\n    int hashInt32 = (int) hashInt;\n\n    // Base-36 encode the integer to get a string\n    return Long.toString(hashInt32, Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long hash = HashCode.newBuilder()\n        .seed(0x0706050403020100L)\n        .hashUnencodedChars()\n        .build()\n        .hashLong(messageParts.hashCode())\n        .hashLong(Objects.hash(messageParts));\n\n    char[] hexChars = Character.toChars(\n        Character.forDigit((int) ((hash >> 56) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 48) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 40) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 32) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 24) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 16) & 0xf), 16),\n        Character.forDigit((int) ((hash >> 8) & 0xf), 16),\n        Character.forDigit((int) ((hash) & 0xf), 16));\n\n    return new String(hexChars, 0, 8);\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.size() - minDistanceFromEnd;\n    if (position > archive.position()) {\n        position = archive.position();\n    }\n    final long stopPosition = Math.max(archive.position() - maxDistanceFromEnd, 0L);\n    while (position >= stopPosition) {\n        archive.seek(position);\n        if (IOUtils.readFully(archive, sig) == sig.length) {\n            return true;\n        }\n        position -= 2;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = maxDistanceFromEnd;\n    while (distance >= minDistanceFromEnd) {\n        long pos = archive.size() - distance;\n        archive.seek(pos);\n        if (Arrays.equals(sig, IOUtils.read(archive, sig.length))) {\n            return true;\n        }\n        distance -= 1;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPos = archive.length();\n    long startPos = endPos - Math.min(maxDistanceFromEnd, endPos);\n    if (startPos < minDistanceFromEnd) {\n        return false;\n    }\n    startPos -= minDistanceFromEnd;\n    archive.seek(startPos);\n    final byte[] readBuf = new byte[sig.length];\n    while (archive.read(readBuf) == sig.length) {\n        if (Arrays.equals(readBuf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long signatureLength = sig.length;\n    final long endPosition = archive.size();\n    final long startPosition = Math.max(0, endPosition - maxDistanceFromEnd);\n    archive.seek(endPosition - signatureLength);\n\n    while (archive.getFilePointer() >= startPosition) {\n        if (Arrays.equals(sig, IOUtils.readFully(archive, signatureLength))) {\n            return true;\n        }\n\n        archive.seek(archive.getFilePointer() - signatureLength + 1);\n    }\n\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long startPos = archive.position();\n    final long endPos = Math.max(archive.size() - maxDistanceFromEnd,\n                                  archive.size() - minDistanceFromEnd);\n    archive.position(endPos);\n    while (archive.position() >= startPos) {\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        archive.position(archive.position() - WORD);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long signatureLength = sig.length;\n    final long end = archive.size();\n    long position = end - maxDistanceFromEnd;\n    if (position < minDistanceFromEnd) {\n        return false;\n    }\n    position -= signatureLength - 1;\n    archive.position(position);\n    final ByteBuffer bbuf = ByteBuffer.wrap(sig);\n    while (position >= minDistanceFromEnd) {\n        bbuf.rewind();\n        if (IOUtils.readFully(archive, bbuf) == signatureLength) {\n            return true;\n        }\n        position -= signatureLength - 1;\n        archive.position(position);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.position();\n    final long startPosition = endPosition - maxDistanceFromEnd;\n\n    long position = endPosition;\n    while (position >= startPosition) {\n        archive.seek(position);\n        final boolean found = IOUtils.indexOf(archive, sig) == 0;\n        if (found) {\n            return true;\n        }\n        position -= WORD;\n    }\n\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPos = archive.size();\n    final long startPos = endPos - Math.max(maxDistanceFromEnd, minDistanceFromEnd);\n    archive.seek(startPos);\n    final byte[] tmpBuf = new byte[sig.length];\n    while (archive.getFilePointer() < endPos) {\n        IOUtils.readFully(archive, tmpBuf);\n        if (Arrays.equals(tmpBuf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.size() - minDistanceFromEnd;\n    if (position >= 0) {\n        archive.seek(position);\n        long remainingBytes = maxDistanceFromEnd;\n        while (remainingBytes > 0) {\n            if (remainingBytes <= WORD) {\n                byte[] word = new byte[(int) remainingBytes];\n                archive.read(word, 0, word.length);\n                if (Arrays.equals(word, sig)) {\n                    return true;\n                }\n                break;\n            }\n            archive.read(wordBuf, 0, WORD);\n            if (Arrays.equals(wordBuf, sig)) {\n                return true;\n            }\n            remainingBytes -= WORD;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = Math.min(archive.length() - archive.position(),\n                               maxDistanceFromEnd);\n    while (distance >= minDistanceFromEnd) {\n        archive.seek(archive.length() - distance);\n        if (Arrays.equals(sig, IOUtils.readFully(archive, sig.length))) {\n            return true;\n        }\n        distance -= 4;\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getPlotOrientation();\n    RectangleEdge edge = null;\n    if (location == AxisLocation.BOTTOM) {\n        edge = PlotUtil.getEdge(orientation, PlotUtil.DomainEdge.BOTTOM_RIGHT_CORNER);\n    }\n    if (location == AxisLocation.TOP) {\n        edge = PlotUtil.getEdge(orientation, PlotUtil.DomainEdge.TOP_LEFT_CORNER);\n    }\n    if (edge == null) {\n        edge = PlotUtil.getEdge(orientation, PlotUtil.DomainEdge.LEFT_BOTTOM_CORNER);\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getPlotOrientation();\n    RectangleEdge result = null;\n    if (location != null)\n    {\n        if (orientation == PlotOrientation.HORIZONTAL)\n        {\n            result = location.getEdge(RectangleEdge.LEFT);\n        }\n        else\n        {\n            result = location.getEdge(RectangleEdge.BOTTOM);\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n    if (location != null) {\n        edge = location.getEdge(getPlotOrientation());\n    }\n    if (edge == null) {\n        edge = RectangleEdge.LEFT_RIGHT;\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = null;\n    if (location == AxisLocation.BOTTOM) {\n        edge = RectangleEdge.BOTTOM_EDGE;\n    } else if (location == AxisLocation.TOP) {\n        edge = RectangleEdge.TOP_EDGE;\n    } else if (location == AxisLocation.LEFT) {\n        edge = RectangleEdge.LEFT_EDGE;\n    } else if (location == AxisLocation.RIGHT) {\n        edge = RectangleEdge.RIGHT_EDGE;\n    } else {\n        edge = RectangleEdge.RIGHT_EDGE; // default\n    }\n    if (getPlotOrientation() == PlotOrientation.VERTICAL) {\n        if (edge == RectangleEdge.BOTTOM_EDGE) {\n            edge = RectangleEdge.LEFT_EDGE;\n        } else if (edge == RectangleEdge.TOP_EDGE) {\n            edge = RectangleEdge.RIGHT_EDGE;\n        } else if (edge == RectangleEdge.LEFT_EDGE) {\n            edge = RectangleEdge.BOTTOM_EDGE;\n        } else if (edge == RectangleEdge.RIGHT_EDGE) {\n            edge = RectangleEdge.TOP_EDGE;\n        }\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge(getPlotOrientation(), this.insets);\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getPlotOrientation();\n    RectangleEdge result = null;\n    if (location != null && orientation != null) {\n        if (orientation.isVertical()) {\n            result = new RectangleEdge(location.getMinY(), location.getMaxY(), getBounds().getMinX(), getBounds().getMaxX());\n        } else {\n            result = new RectangleEdge(location.getMinX(), location.getMaxX(), getBounds().getMinY(), getBounds().getMaxY());\n        }\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge(getPlotOrientation());\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    PlotOrientation orientation = getPlotOrientation();\n    RectangleEdge result = location.getEdge(orientation);\n    if (result == null) {\n        result = location.getEdge(orientation.getOpposite());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge edge = location.getEdge();\n    if (edge == null) {\n        edge = getPlotOrientation() == PlotOrientation.VERTICAL ?\n                RectangleEdge.RIGHT : RectangleEdge.TOP;\n    }\n    return edge;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    return location.getEdge(getPlotOrientation(), null);\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\ncheckAlterPartialConverters();\nif (converter == null) {\nreturn null;\n}\nPartialConverter[] removed = new PartialConverter[1];\niPartialConverters = iPartialConverters.remove(converter, removed);\nreturn removed[0];\n}"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_match == null)\n    {\n        return _originalStream;\n    }\n    if (_bufferedData == null)\n    {\n        return _originalStream;\n    }\n    return new InputStream()\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    InputStream in = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    return new SequenceInputStream(in, _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    try {\n        long remaining = _originalStream.available();\n        if (remaining == 0) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n    } catch (IOException ignored) {\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null)\n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    if (_bufferedData != null)\n    {\n        return new ConcatInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_match == null) {\n        return _originalStream;\n    }\n    if (_bufferedData == null) {\n        return _originalStream;\n    }\n    if (_bufferedStart == 0 && _bufferedLength == _bufferedData.length) {\n        return new ByteArrayInputStream(_bufferedData);\n    } else {\n        byte[] data = new byte[_bufferedStart + _bufferedLength];\n        System.arraycopy(_bufferedData, _bufferedStart, data, 0, _bufferedLength);\n        return new ByteArrayInputStream(data);\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_bufferedData == null) {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_bufferedData == null) {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    if (_bufferedLength > 0) {\n        return new ConcatInputStream(_bufferedData, _bufferedStart, _bufferedLength, _originalStream);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    try \n    {\n        return new LimitedInputStream(_originalStream, _bufferedStart + _bufferedLength);\n    } catch (IOException e) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_match == null) \n    {\n        return _originalStream;\n    }\n    if (_bufferedData != null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n  Comparable result = this.sectionKeyMap.get(section);\n  if (result == null)\n  {\n    result = new Integer(section);\n    this.sectionKeyMap.put(section, result);\n  }\n  return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n\tComparable sectionKey = section;\n\t\n\tif (sectionKey == null) \n\t{\n\t\tsectionKey = section;\n\t}\n\t\n\treturn sectionKey;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeyMap.get(section);\n    if (key == null) {\n        key = generateSectionKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n\tComparable sectionKey = this.sectionKeyMap.get(section);\n\tif (sectionKey == null) {\n\t\tsectionKey = new SectionKey(this, section);\n\t\tthis.sectionKeyMap.put(section, sectionKey);\n\t}\n\treturn sectionKey;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (dataset != null) {\n        result = dataset.getSectionKey(section);\n    }\n    if (result == null) {\n        // generate a key\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n  //  return section; // OLD CODE\n  // NEW CODE\n  if (section >= 0 && section < getSectionCount()) \n  {\n    return getSection(section).getKey();\n  }\n  else \n  {\n    return null;\n  }\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = this.sectionKeyMap.get(section);\n    if (result == null) {\n        // generate a new key\n        result = section;\n        this.sectionKeyMap.put(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n  Comparable key = this.sectionKeyMap.get(section);\n  if (key != null) {\n    return key;\n  }\n  key = new Integer(section);\n  this.sectionKeyMap.put(section, key);\n  return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.sectionIndexMap.containsKey(section))\n    {\n        result = this.sectionIndexMap.get(section);\n    }\n    else\n    {\n        result = new Integer(section);\n        this.sectionIndexMap.put(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n  Comparable key = this.sectionMap.get(section);\n  if (key == null) \n  {\n    key = new Integer(section);\n    this.sectionMap.put(key, section);\n  }\n  return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number num = (Number) _currentObject();\n                if (num != null) {\n                    return Double.isNaN(num.doubleValue());\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN((float) _currentNumberValue);\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Float) _currentObject());\n            } else {\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Float) _currentObject());\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Float) _currentObject());\n            } else {\n                return false;\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = _currentObject();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                } else if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN((Float) _currentObject());\n            } else {\n                return Double.isNaN((Double) _currentObject());\n            }\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && Float.isNaN((float) _currentObject());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number num = (Number) _currentObject();\n                if (num != null) {\n                    return Double.isNaN(num.doubleValue());\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT\n                    && Double.isNaN((Number) _currentObject());\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null && prefix == null) {\n        return true;\n    } else if (prefix == null) {\n        return true;\n    } else if (str == null) {\n        return false;\n    } else {\n        final int strLen = str.length();\n        final int prefixLen = prefix.length();\n        if (strLen < prefixLen) {\n            return false;\n        } else {\n            for (int i = 0; i < prefixLen; i++) {\n                final char c1 = ignoreCase ? Character.toLowerCase(str.charAt(i)) : str.charAt(i);\n                final char c2 = ignoreCase ? Character.toLowerCase(prefix.charAt(i)) : prefix.charAt(i);\n                if (c1 != c2) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null) \n    {\n        return str == null;\n    } else if (str == null) \n    {\n        return false;\n    } else if (prefix.length() > str.length()) \n    {\n        return false;\n    } else if (ignoreCase) \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            if (Character.toLowerCase(prefix.charAt(i)) != Character.toLowerCase(str.charAt(i))) \n            {\n                return false;\n            }\n        }\n    } else \n    {\n        for (int i = 0; i < prefix.length(); i++) \n        {\n            if (prefix.charAt(i) != str.charAt(i)) \n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null) \n        return str == null ? true : false;\n    if (str == null) \n        return false;\n    if (str.length() < prefix.length()) \n        return false;\n    if (ignoreCase) {\n        for (int i = 0; i < prefix.length(); i++) {\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i))) {\n                return false;\n            }\n        }\n    } else {\n        for (int i = 0; i < prefix.length(); i++) {\n            if (str.charAt(i) != prefix.charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null)\n    {\n        return str == null;\n    }\n    if (str == null)\n    {\n        return false;\n    }\n    if (prefix.length() > str.length())\n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); ++i)\n    {\n        char c1 = ignoreCase ? Character.toLowerCase(str.charAt(i)) : str.charAt(i);\n        char c2 = ignoreCase ? Character.toLowerCase(prefix.charAt(i)) : prefix.charAt(i);\n        if (c1 != c2)\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null) \n        return str == null || str.length() == 0;\n    if (str == null || str.length() < prefix.length()) \n        return false;\n\n    final int strLen = str.length();\n    final int prefixLen = prefix.length();\n\n    if (ignoreCase)\n    {\n        for (int i = 0; i < prefixLen; i++)\n            if (Character.toLowerCase(str.charAt(i)) != Character.toLowerCase(prefix.charAt(i)))\n                return false;\n    }\n    else\n    {\n        for (int i = 0; i < prefixLen; i++)\n            if (str.charAt(i) != prefix.charAt(i))\n                return false;\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null)\n    {\n        return str == null;\n    }\n    if (str == null)\n    {\n        return false;\n    }\n    if (ignoreCase)\n    {\n        return str.toLowerCase().startsWith(prefix.toLowerCase());\n    }\n    else\n    {\n        return str.startsWith(prefix);\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null && prefix == null) {\n        return true;\n    } else if (str == null || prefix == null) {\n        return false;\n    }\n\n    final int strLen = str.length();\n    final int prefixLen = prefix.length();\n\n    if (strLen < prefixLen) {\n        return false;\n    }\n\n    for (int i = 0; i < prefixLen; i++) {\n        final char c1 = str.charAt(i);\n        final char c2 = prefix.charAt(i);\n\n        if (ignoreCase) {\n            if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                return false;\n            }\n        } else {\n            if (c1 != c2) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null) \n        return str == null ? true : false;\n    if (str == null) \n        return false;\n    if (ignoreCase) \n        return str.toString().toLowerCase().startsWith(prefix.toString().toLowerCase());\n    else \n        return str.toString().startsWith(prefix.toString());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (prefix == null) \n        return str == null ? true : false;\n    if (str == null) \n        return false;\n    if (str.length() < prefix.length()) \n        return false;\n    \n    if (!ignoreCase)\n        return str.subSequence(0, prefix.length()).equals(prefix);\n    else\n        return str.subSequence(0, prefix.length()).toString().toLowerCase().equals(prefix.toString().toLowerCase());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (null == str && null == prefix)\n    {\n        return true;\n    }\n    \n    if (null == str || null == prefix)\n    {\n        return false;\n    }\n    \n    for (int i = 0; i < prefix.length(); i++)\n    {\n        char c = prefix.charAt(i);\n        if (ignoreCase)\n        {\n            c = Character.toLowerCase(c);\n        }\n        \n        if (i >= str.length() || str.charAt(i) != c)\n        {\n            return false;\n        }\n    }\n    \n    return true;\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    String result;\n    switch (p)\n    {\n        case PEEKED_UNQUOTED_STRING:\n        {\n            result = nextUnquotedValue();\n            break;\n        }\n        case PEEKED_SINGLE_QUOTED_STRING:\n        {\n            result = nextQuotedValue('\\'');\n            break;\n        }\n        case PEEKED_DOUBLE_QUOTED_STRING:\n        {\n            result = nextQuotedValue('\"');\n            break;\n        }\n        default:\n        {\n            throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n        }\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) \n    {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\"');\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_VALUE) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_VALUE) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_VALUE) {\n    result = nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  return result;\n}",
      "public String nextString() throws IOException  {\n\tint p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED_STRING) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = String.valueOf(peekedLong);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    String result;\n    switch (p)\n    {\n        case PEEKED_UNQUOTED_STRING:\n        {\n            result = nextUnquotedValue();\n            break;\n        }\n        case PEEKED_SINGLE_QUOTED_STRING:\n        {\n            result = nextQuotedValue('\\'');\n            break;\n        }\n        case PEEKED_DOUBLE_QUOTED_STRING:\n        {\n            result = nextQuotedValue('\"');\n            break;\n        }\n        case PEEKED_LONG:\n        {\n            result = \"\" + peekedLong;\n            break;\n        }\n        case PEEKED_NUMBER:\n        {\n            if (peekedNumberLength == 1 && peekedNumber[0] == '0') {\n                result = \"0\";\n            } else {\n                result = peekedNumber;\n            }\n            break;\n        }\n        default:\n        {\n            throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n        }\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}",
      "public String nextString() throws IOException  {\n\tint p = peeked;\n\tif (p == PEEKED_NONE)\n\t{\n\t\tp = doPeek();\n\t}\n\tString result;\n\tif (p == PEEKED_UNQUOTED_VALUE) \n\t{\n\t\tresult = nextUnquotedValue();\n\t} \n\telse if (p == PEEKED_SINGLE_QUOTED_VALUE) \n\t{\n\t\tresult = nextQuotedValue('\\'');\n\t} \n\telse if (p == PEEKED_DOUBLE_QUOTED_VALUE) \n\t{\n\t\tresult = nextQuotedValue('\"');\n\t} \n\telse if (p == PEEKED_LONG) \n\t{\n\t\tresult = String.valueOf(peekedLong);\n\t} \n\telse if (p == PEEKED_NUMBER) \n\t{\n\t\tresult = String.valueOf(peekedNumber);\n\t} \n\telse \n\t{\n\t\tthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n\t}\n\tpeeked = PEEKED_NONE;\n\treturn result;\n}",
      "public String nextString() throws IOException  {\n\tint p = peeked;\n\tif (p == PEEKED_NONE)\n\t{\n\t\tp = doPeek();\n\t}\n\tString result;\n\tif (p == PEEKED_UNQUOTED_VALUE) \n\t{\n\t\tresult = nextUnquotedValue();\n\t} \n\telse if (p == PEEKED_SINGLE_QUOTED_VALUE) \n\t{\n\t\tresult = nextQuotedValue('\\'');\n\t} \n\telse if (p == PEEKED_DOUBLE_QUOTED_VALUE) \n\t{\n\t\tresult = nextQuotedValue('\"');\n\t} \n\telse if (p == PEEKED_NUMBER) \n\t{\n\t\tresult = nextNumberString();\n\t} \n\telse \n\t{\n\t\tthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n\t}\n\tpeeked = PEEKED_NONE;\n\treturn result;\n}",
      "public String nextString() throws IOException  {\n\tint p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n      result = \"\" + peekedNumberLength;\n      peeked = PEEKED_NONE;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    pathValues[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED_STRING) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n    result = nextQuotedValue('\"');\n  } else if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n    peeked = PEEKED_NONE;\n  } else if (p == PEEKED_NUMBER) {\n    result = Double.toString(peekedNumber);\n    peeked = PEEKED_NONE;\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  pathValues[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n\tint p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_STRING) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_STRING) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_STRING) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n      result = nextNumber().toString();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"width must be >= 4\");\n    }\n    if (offset < 0 || offset >= str.length()) {\n        throw new IllegalArgumentException(\"offset must be >= 0 and < src.length()\");\n    }\n    int length = str.length();\n    if (length <= maxWidth) {\n        return str;\n    } else {\n        return \"...\" + str.substring(offset, Math.min(length, offset + (maxWidth - 3)));\n    }\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null || str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset < 0 || offset >= str.length()) {\n        throw new IllegalArgumentException(\"Offset out of bounds\");\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str.substring(offset, str.length()) + \"...\";\n    } else {\n        return \"... \" + str.substring(offset, offset + maxWidth);\n    }\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n    if (offset > str.length()) {\n        return \"\";\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str;\n    }\n    return \"...\" + str.substring(offset, offset + maxWidth - 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (str.length() <= offset + maxWidth - 3) {\n        return str;\n    }\n    return \"...\" + str.substring(offset, offset + maxWidth - 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null || str.length() <= maxWidth) {\n        return str;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be >= 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    } else if (offset < 0) {\n        offset = 0;\n    }\n    return \"...\" + str.substring(offset, Math.min(str.length(), offset + (maxWidth - 3)));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > str.length()) {\n        return str;\n    }\n    if (maxWidth >= str.length() - offset) {\n        return str;\n    }\n    return \"...\" + str.substring(offset, str.length() - offset - maxWidth + 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null || str.isEmpty()) {\n        return str;\n    }\n\n    final int strLength = str.length();\n    if (offset < 0) {\n        offset = 0;\n    } else if (offset > strLength) {\n        offset = strLength;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException();\n    }\n\n    if (offset == strLength || maxWidth == strLength) {\n        return str;\n    }\n\n    if (offset + maxWidth >= strLength) {\n        return str.substring(offset) + \"...\";\n    } else {\n        return \"...\" + str.substring(offset, offset + maxWidth);\n    }\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be >= 4\");\n    }\n    if (offset < 0 || offset > str.length()) {\n        throw new IllegalArgumentException(\"Offset must be >= 0 and <= String length\");\n    }\n    if (maxWidth >= str.length() - offset) {\n        return str;\n    }\n    return \"...\" + str.substring(offset, offset + (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Abbreviated String would be empty\");\n    }\n    int stringLength = str.length();\n    if (stringLength <= maxWidth) {\n        return str;\n    }\n    if (offset < 0) {\n        offset = 0;\n    } else if (offset > stringLength) {\n        offset = stringLength;\n    }\n    int newLength = offset + (maxWidth - 3);\n    if (newLength > stringLength) {\n        newLength = stringLength;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"...\");\n    sb.append(str.substring(offset, newLength));\n    return sb.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null || str.length() <= maxWidth) {\n        return str;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > str.length() - 4) {\n        offset = str.length() - 4;\n    }\n    return \"...\" + str.substring(offset, offset + (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n\n    if (s1 == null || s2 == null || s1.length != s2.length) {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null && s2 == null) \n    {\n        return true;\n    }\n    if (s1 == null || s2 == null || s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n\n    if (s1.length != s2.length) {\n        return false;\n    }\n\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return s2 == null;\n    }\n    else if (s2 == null) \n    {\n        return false;\n    }\n    else if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!s1[i].equals(s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        return s2 == null;\n    }\n    else if (s2 == null)\n    {\n        return false;\n    }\n    else if (s1.length != s2.length)\n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++)\n    {\n        if (!s1[i].equals(s2[i]))\n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == s2) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n        return s2 == null;\n    if (s2 == null)\n        return false;\n    if (s1.length != s2.length)\n        return false;\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i]))\n            return false;\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        } else {\n            return false;\n        }\n    } else if (s2 == null) {\n        return false;\n    } else if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null)\n    {\n        if (s2 == null)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    else if (s2 == null)\n    {\n        return false;\n    }\n    else if (s1.length != s2.length)\n    {\n        return false;\n    }\n    else\n    {\n        for (int i = 0; i < s1.length; i++)\n        {\n            if (!s1[i].equals(s2[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        if (s2 == null) {\n            return true;\n        } else {\n            return false;\n        }\n    } else if (s2 == null) {\n        return false;\n    } else if (s1.length != s2.length) {\n        return false;\n    } else {\n        for (int i = 0; i < s1.length; i++) {\n            if (!s1[i].equals(s2[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolFile) {\n    lastSymbolFile = symbolName;\n    Integer index = symbolFileMap.get(symbolName);\n    if (index != null) {\n      lastSymbolFileIndex = index;\n    } else {\n      lastSymbolFileIndex = symbolFileMap.size();\n      symbolFileMap.put(symbolName, lastSymbolFileIndex);\n    }\n  }\n  return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) \n    {\n        lastSymbolFile = symbolName;\n        Integer index = symbolFileMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolFileIndex = index;\n        } else \n        {\n            lastSymbolFileIndex = symbolFileMap.size();\n            symbolFileMap.put(symbolName, lastSymbolFileIndex);\n        }\n    }\n    return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName)\n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null)\n        {\n            lastSymbolNameIndex = index;\n        }\n        else\n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName)\n    {\n        lastSymbolName = symbolName;\n        Integer index = nameMap.get(symbolName);\n        if (index != null)\n        {\n            lastSymbolIndex = index;\n        }\n        else\n        {\n            lastSymbolIndex = nameMap.size();\n            nameMap.put(symbolName, lastSymbolIndex);\n        }\n    }\n    return lastSymbolIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) {\n      lastSymbolNameIndex = index;\n    } else {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolFile) \n  {\n    lastSymbolFile = symbolName;\n    Integer index = symbolFileMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolFileIndex = index;\n    } else \n    {\n      lastSymbolFileIndex = symbolFileMap.size();\n      symbolFileMap.put(symbolName, lastSymbolFileIndex);\n    }\n  }\n  return lastSymbolFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) {\n            lastSymbolNameIndex = index;\n        } else {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) \n    {\n        lastSymbolFile = symbolName;\n        Integer index = symbolFileMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolFileIndex = index;\n        }\n        else \n        {\n            lastSymbolFileIndex = symbolFileMap.size();\n            symbolFileMap.put(symbolName, lastSymbolFileIndex);\n        }\n    }\n    return lastSymbolFileIndex;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    try {\n        return Double.parseDouble(result);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a double but was \" + result + \" \" + locationString(), e);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(result);\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_LONG) {\n      long longValue = peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) longValue;\n    } else if (p == PEEKED_UNQUOTED) {\n      String string = nextUnquotedValue();\n      try {\n        double result = Double.parseDouble(string);\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ex) {\n        throw new NumberFormatException(\"Expected a double literal but was \" + string + locationString());\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a double literal but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_LONG) {\n      double result = (double) peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      String result = nextQuotedValue('\"');\n      double doubleValue = Double.parseDouble(result);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return doubleValue;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_LONG) {\n      long value = peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) value;\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      String result = nextQuotedValue('\"');\n      return Double.parseDouble(result);\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      String result = nextQuotedValue('\\'');\n      return Double.parseDouble(result);\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_UNQUOTED) {\n      double result = Double.parseDouble(nextUnquotedValue());\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      double result = Double.parseDouble(nextQuotedValue('\\''));\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      double result = Double.parseDouble(nextQuotedValue('\"'));\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_LONG) {\n      double result = (double) peekedLong;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else if (p == PEEKED_STRING) {\n      double result = Double.parseDouble(peekedString);\n      peekedString = null;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    \n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        String result = nextUnquotedValue();\n        try\n        {\n            double doubleResult = Double.parseDouble(result);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return doubleResult;\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Unable to parse double from unquoted value: \" + result + locationString());\n        }\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        String result = nextQuotedValue('\\'');\n        try\n        {\n            double doubleResult = Double.parseDouble(result);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return doubleResult;\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Unable to parse double from single quoted value: \" + result + locationString());\n        }\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        String result = nextQuotedValue('\"');\n        try\n        {\n            double doubleResult = Double.parseDouble(result);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return doubleResult;\n        } \n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Unable to parse double from double quoted value: \" + result + locationString());\n        }\n    } \n    else if (p == PEEKED_LONG) \n    {\n        double doubleResult = Double.longBitsToDouble(peekedLong);\n}\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n    else if (p == PEEKED_NUMBER)\n    {\n        String result = new String(buffer, pos, peekedNumberLength);\n        peekedNumberLength = 0;\n        pos += peekedNumberLength;\n        try\n        {\n            return Double.parseDouble(result);\n        }\n        catch (NumberFormatException e)\n        {\n            throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString(), e);\n        }\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_STRING) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(peekedString);\n    } else {\n        throw new IllegalStateException(\"Expected a numeric literal but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    return new StringBuilder().append(str).append(str, 0, repeat - 1).toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat == 0) \n    {\n        return EMPTY;\n    }\n    if (repeat < 0) \n    {\n        return EMPTY;\n    }\n    if (repeat == 1) \n    {\n        return str;\n    }\n    final char[] cbuf = new char[Math.max(str.length() * repeat, 16)];\n    final int len = str.length();\n    for (int i = 0; i < repeat; i++) \n    {\n        str.getChars(0, len, cbuf, i * len);\n    }\n    return new String(cbuf, 0, len * repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (str.length() == 1) {\n        return str.repeat(repeat);\n    }\n    final StringBuilder sb = new StringBuilder(repeat * str.length());\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat < 1) \n    {\n        return EMPTY;\n    }\n    if (repeat == 1) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] cbuf = new char[strLen * repeat];\n    for (int i = 0; i < repeat; i++) \n    {\n        str.getChars(0, strLen, cbuf, i * strLen);\n    }\n    return new String(cbuf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (repeat == 1) {\n        return str;\n    }\n    char[] buf = new char[str.length() * repeat];\n    int pos = 0;\n    for (int i = 0; i < repeat; i++) {\n        str.getChars(0, str.length(), buf, pos);\n        pos += str.length();\n    }\n    return new String(buf, 0, pos);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    if (repeat < 0) {\n        repeat = 0;\n    }\n    return str.repeat(repeat);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final StringBuilder sb = new StringBuilder(len * repeat);\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    return new String(new char[repeat]).replace(\"\\u0000\", str);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    if (repeat < 0) {\n        repeat = 0;\n    }\n    return new StringBuilder(repeat * str.length()).append(str).toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    final Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField(headerId);\n        }\n\n        return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> c = implementations.get(headerId);\n    if (c == null) {\n        c = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) c.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (implementations.containsKey(headerId)) {\n        final Class<?> c = implementations.get(headerId);\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        if (!implementations.containsKey(headerId)) {\n            return new UnrecognizedExtraField(headerId);\n        }\n        Class<?> c = implementations.get(headerId);\n        ZipExtraField instance = null;\n        if (c != null) {\n            instance = (ZipExtraField) c.newInstance();\n        }\n        if (instance == null) {\n            instance = new UnrecognizedExtraField(headerId);\n        }\n        return instance;\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        if (!implementations.containsKey(headerId)) {\n            return new UnrecognizedExtraField(headerId);\n        }\n        Class<?> c = implementations.get(headerId);\n        ZipExtraField extraField = (ZipExtraField) c.newInstance();\n        return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField(headerId);\n        }\n\n        return (ZipExtraField) c.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField(headerId, new byte[0]);\n        }\n        return (ZipExtraField) c.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    if (map != null) {\n        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry = (Map.Entry) it.next();\n            clone.put((Comparable) entry.getKey(), (Object) entry.getValue());\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = (Map) map.clone();\n    for (Iterator it = clone.keySet().iterator(); it.hasNext();) {\n        Object key = it.next();\n        Object value = clone.get(key);\n        if (key instanceof Marker && value instanceof Marker) {\n            clone.put(key, ((Marker) key).clone());\n            clone.put(value, ((Marker) value).clone());\n        } else if (key instanceof List && value instanceof List) {\n            List list = (List) key;\n            List cloneList = (List) ((List) key).clone();\n            clone.remove(list);\n            clone.put(cloneList, (List) ((List) value).clone());\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map cloneMap = new HashMap();\n    Iterator it = map.keySet().iterator();\n    while (it.hasNext()) {\n        Comparable key = (Comparable) it.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            cloneMap.put(key, ((PublicCloneable) value).clone());\n        } else {\n            cloneMap.put(key, value);\n        }\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map cloneMap = new HashMap();\n    Iterator it = map.entrySet().iterator();\n    while (it.hasNext()) {\n        Map.Entry entry = (Map.Entry) it.next();\n        cloneMap.put(entry.getKey(), (Comparable) entry.getValue().clone());\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put((Comparable) entry.getKey(), (Comparable) entry.getValue());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map clone = new HashMap();\n    for (Iterator it = map.keySet().iterator(); it.hasNext();) {\n        Comparable key = (Comparable) it.next();\n        Object marker = (Object) map.get(key);\n        if (marker instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) marker;\n            Object clonedMarker = pc.clone();\n            clone.put(key, clonedMarker);\n        }\n    }\n    return clone;\n\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) {\n        clone.put(key, (Comparable) map.get(key).clone());\n    }\n    return clone;\n\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloneMap = new TreeMap();\n    for (Object key : map.keySet()) {\n        Object value = (Marker) map.get(key);\n        if (value != null) {\n            cloneMap.put(key, (Marker) value.clone());\n        }\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map cloneMap = new HashMap();\n    for (Object key : map.keySet()) \n    {\n        cloneMap.put(key, (Number) map.get(key).clone());\n    }\n    return cloneMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n\n    Map clone = new TreeMap();\n    if (map != null) {\n        for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {\n            Comparable key = (Comparable) iter.next();\n            Comparable value = (Comparable) map.get(key);\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\n\tsum += element.getCentralDirectoryLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\n\tSystem.arraycopy(data[i].getHeaderId().getBytes(),\n\t\t\t0, result, start, 2);\n\tSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n\t\t\t0, result, start + 2, 2);\n\tstart += WORD;\n\tfinal byte[] central = data[i].getCentralDirectoryData();\n\tif (central != null) {\n\t\tSystem.arraycopy(central, 0, result, start, central.length);\n\t\tstart += central.length;\n\t}\n}\nif (lastIsUnparseableHolder) {\n\tfinal byte[] central = data[data.length - 1].getCentralDirectoryData();\n\tif (central != null) {\n\t\tSystem.arraycopy(central, 0, result, start, central.length);\n\t}\n}\nreturn result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n\n        final boolean lastIsUnparseableHolder = data.length > 0 &&\n            data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\n    sum += element.getCentralDirectoryLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\n    System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n    System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n    start += WORD;\n    final byte[] local = data[i].getCentralDirectoryData();\n    if (local != null) {\n        System.arraycopy(local, 0, result, start, local.length);\n        start += local.length;\n    }\n}\nif (lastIsUnparseableHolder) {\n    final byte[] local = data[data.length - 1].getCentralDirectoryData();\n    if (local != null) {\n        System.arraycopy(local, 0, result, start, local.length);\n    }\n}\nreturn result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int sum = data.length * WORD;\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int regularExtraFieldCount = data.length;\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getCentralDirectoryData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nfinal int regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nsum += element.getCentralDirectoryLength().getValue();\n}\n\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n0, result, start + 2, 2);\nstart += WORD;\nfinal byte[] central = data[i].getCentralDirectoryData();\nif (central != null) {\nSystem.arraycopy(central, 0, result, start, central.length);\nstart += central.length;\n}\n}\nif (lastIsUnparseableHolder) {\nfinal byte[] central = data[data.length - 1].getCentralDirectoryData();\nif (central != null) {\nSystem.arraycopy(central, 0, result, start, central.length);\n}\n}\nreturn result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int sum = data.length * WORD;\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean change = false;\n\n        // loop through the collection and add unique elements\n        for (E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                change = true;\n                add(index++, element);\n                set.add(element);\n            }\n        }\n        return change;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll) {\n            if (!contains(element)) {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean modified = false;\n        for (E e : coll) \n        {\n            if (!set.contains(e)) \n            {\n                add(index, e);\n                modified = true;\n            }\n        }\n        return modified;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean added = false;\n        for (E e : coll) {\n            if (!set.contains(e)) {\n                add(index, e);\n                added = true;\n            }\n        }\n        return added;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean modified = false;\n        for(E element : coll) {\n            if(set.contains(element)) continue;\n            add(index++, element);\n            modified = true;\n        }\n        return modified;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean added = false;\n        for (E element : coll) \n        {\n            if (!set.contains(element)) \n            {\n                add(index++, element);\n                set.add(element);\n                added = true;\n            }\n        }\n        return added;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean added = false;\n        for (E element : coll) {\n            if (set.contains(element) == false) {\n                add(index, element);\n                added = true;\n            }\n        }\n        return added;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean added = false;\n        for (E e : coll) {\n            if (!set.contains(e)) {\n                add(index++, e);\n                added = true;\n            }\n        }\n        return added;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (E element : coll)\n        {\n            if (set.contains(element) == false)\n            {\n                add(index, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll)\n        {\n            if (set.contains(e) == false)\n            {\n                add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    Evaluations.increment();\n    if (Evaluations.getCount() > Evaluations.getMaximalCount()) {\n        throw new TooManyEvaluationsException();\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    double result = f.value(x);\n    evaluations.increment();\n    if (evaluations.getCount() > evaluations.getMaximalCount()) {\n        throw new TooManyEvaluationsException();\n    }\n    return result;\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    double result = f.evaluate(x);\n\n    if (evaluations.add(1)) {\n        if (evaluations.isMinimal()) {\n            throw new TooManyEvaluationsException(evaluations.getMaximalCount());\n        }\n    }\n    return result;\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluation.increment();\n    if (evaluation.getCount() > evaluation.getMaximalCount()) {\n        throw new TooManyEvaluationsException();\n    }\n    return f.evaluate(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    if (evaluations.increment() > getMaxEvaluations()) {\n        throw new TooManyEvaluationsException(\"Max evaluations exceeded\");\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.increment();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    Evaluations.incrementCount();\n    if (Evaluations.getCount() > evaluations.getMaximalCount()) {\n        throw new TooManyEvaluationsException(Evaluations.getMaximalCount());\n    }\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    Evaluations.increment();\n    if (Evaluations.getCount() > evaluations.getMaximalCount())\n        throw new TooManyEvaluationsException();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    double result = f.value(x);\n    evaluations.incrementCount();\n    if (evaluations.getCount() > evaluations.getMaximalCount()) {\n        throw new TooManyEvaluationsException();\n    }\n    return result;\n}",
      "private double eval(UnivariateFunction f, double x)  "
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            List<RealVector> newCoefficients = new ArrayList<>();\n            for (RealVector coefficient : constraint.getCoefficients()) \n            {\n                newCoefficients.add(coefficient.mapMultiply(-1));\n            }\n            RealVector newRightHandSide = constraint.getValue().multiply(-1);\n            normalizedConstraints.add(new LinearConstraint(newCoefficients, Relationship.LEQ, newRightHandSide));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            RealVector newCoefficients = constraint.getCoefficients().mapMultiply(-1);\n            double newValue = -1 * constraint.getValue();\n            normalizedConstraints.add(new LinearConstraint(newCoefficients, Relationship.LEQ, newValue));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients().mapMultiply(-1);\n            double newRHS = -constraint.getValue();\n            normalizedConstraints.add(new SimpleLinearConstraint(coefficients, Relationship.EQ, newRHS));\n        } else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        RealVector coefficients = constraint.getCoefficients();\n        double constantTerm = constraint.getValue();\n\n        if (coefficients.getEntry(coefficients.dimension() - 1) < 0) \n        {\n            coefficients = coefficients.mapMultiply(-1);\n            constantTerm *= -1;\n        }\n\n        normalizedConstraints.add(new LinearConstraint(coefficients, constraint.getRelationship(), constantTerm));\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) {\n        RealVector coefficients = constraint.getCoefficients();\n        double value = constraint.getValue();\n\n        if (value < 0) {\n            coefficients = coefficients.mapMultiply(-1);\n            value = -value;\n        }\n\n        normalizedConstraints.add(new LinearConstraint(coefficients, constraint.getRelationship(), value));\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            RealVector coefficients = constraint.getCoefficients().mapMultiply(-1);\n            double newValue = -1 * constraint.getValue();\n            normalizedConstraints.add(new LinearConstraint(coefficients, Relationship.EQ, newValue));\n        } \n        else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        double rhs = constraint.getValue();\n        if (rhs < 0) \n        {\n            RealVector newCoefficients = constraint.getCoefficients().mapMultiply(-1);\n            double newRHS = -rhs;\n            normalizedConstraints.add(new SimpleLinearConstraint(newCoefficients, newRHS, Relationship.GEQ));\n        } else \n        {\n            normalizedConstraints.add(constraint);\n        }\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint constraint : originalConstraints) {\n        RealVector coefficients = constraint.getCoefficients();\n        double value = constraint.getValue();\n\n        if (value < 0) {\n            coefficients = coefficients.mapMultiply(-1);\n            value *= -1;\n        }\n\n        normalizedConstraints.add(new SimpleLinearConstraint(coefficients, value, constraint.getRelationship()));\n    }\n\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        RealVector coefficients = constraint.getCoefficients();\n        double value = constraint.getValue();\n        if (value < 0) \n        {\n            coefficients = coefficients.mapMultiply(-1);\n            value *= -1;\n        }\n        normalizedConstraints.add(new SimpleLinearConstraint(coefficients, value,\n                constraint.getRelationship(), constraint.isSkipInfeasible()));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n\n    for (LinearConstraint originalConstraint : originalConstraints) {\n        if (originalConstraint.getValue() < 0) {\n            // Create a new constraint with the negative of the right hand side\n            LinearConstraint normalizedConstraint = new SimpleLinearConstraint(\n                originalConstraint.getCoefficients(),\n                originalConstraint.getRelationship(),\n                -1 * originalConstraint.getValue()\n            );\n            normalizedConstraints.add(normalizedConstraint);\n        } else {\n            normalizedConstraints.add(originalConstraint);\n        }\n    }\n\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"null argument\");\n    }\n\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    } else if (this.lowerBound <= bin.lowerBound && bin.lowerBound <= this.upperBound) {\n        return true;\n    } else if (bin.lowerBound <= this.lowerBound && this.lowerBound <= bin.upperBound) {\n        return true;\n    } else if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.upperBound) {\n        return true;\n    } else if (bin.lowerBound <= this.lowerBound && bin.upperBound >= this.upperBound) {\n        return true;\n    } else {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin may not be null\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n    if (bin == this) {\n        return false;\n    }\n    if (bin.upperBound < lowerBound) {\n        return false;\n    }\n    if (bin.lowerBound > upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n\n    if (this.lowerBound >= bin.lowerBound && this.upperBound <= bin.upperBound) {\n        return true;\n    }\n\n    if (this.lowerBound == bin.lowerBound) {\n        if (this.includeLowerBound && bin.includeLowerBound) {\n            return true;\n        }\n    }\n\n    if (this.upperBound == bin.upperBound) {\n        if (this.includeUpperBound && bin.includeUpperBound) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin == null\");\n    }\n    return (!(this.upperBound < bin.lowerBound) \n            && !(this.lowerBound > bin.upperBound));\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"bin may not be null\");\n    }\n\n    if (bin.getLowerBound() > this.upperBound) {\n        return false;\n    }\n    if (bin.getUpperBound() < this.lowerBound) {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n\n    if (this.lowerBound == bin.lowerBound && !this.includeLowerBound) {\n        return false;\n    }\n\n    if (this.upperBound == bin.upperBound && !this.includeUpperBound) {\n        return false;\n    }\n\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n    if (bin == this) {\n        return true;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (bin.lowerBound > this.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin cannot be null\");\n    }\n\n    if (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound) {\n        return true;\n    }\n\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n\n    if (this.lowerBound >= bin.lowerBound && this.upperBound <= bin.upperBound) {\n        return true;\n    }\n\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final List<String> list = new ArrayList<>();\n    if (len == 0) {\n        list.add(\"\");\n        return list.toArray(new String[list.size()]);\n    }\n    final char[] separatorChars = {'\\t', '\\n', '\\f', ' ', ',', ';', ':', '\\\"', '\\'', '(', ')', '[', ']', '{', '}', '<', '>', '\\\\', '|', '^', '$', '@', '%', '&', '*', '+', '=', '!', '~'};\n    final int max = len + 1;\n    int sizePlus1 = 0;\n    final boolean preserveAllTokens = false;\n    int i = 0;\n    int start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (Character.isLowerCase(str.charAt(i)) && lastMatch && camelCase) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            lastMatch = true;\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n\n    final List<String> list = new ArrayList<>(Arrays.asList(str.split(\"\")));\n\n    final char[] separatorChars = new char[]{' ','\\t'};\n    final char[] letterChars = new char[]{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'\n        ,'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};\n    final boolean[] letterTypes = new boolean[len];\n\n    for (int i = 0; i < len; ++i) {\n        letterTypes[i] = false;\n        if (Character.getType(str.charAt(i)) == Character.UPPERCASE_LETTER) {\n            if (i > 0 && letterTypes[i - 1] && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                list.set(i, list.get(i - 1) + list.get(i));\n                list.remove(i - 1);\n                i--;\n            } else {\n                letterTypes[i] = true;\n            }\n        }\n    }\n\n    int start = 0;\n    boolean lastMatch = false;\n    boolean match = false;\n\n    for (int i = 0; i <= len; ++i) {\n        if (i == len || separatorChars.indexOf(str.charAt(i)) >= 0) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        final List<String> list = new ArrayList<>();\n\n        final char[] separatorChars = {' '}; // Customize separator characters as needed\n        final int max = Integer.MAX_VALUE; // Customize maximum number of tokens as needed\n\n        int start = 0;\n        int i = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        int sizePlus1 = 0;\n\n        if (camelCase) {\n            // camel case splitting logic\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                if (i > start && Character.isLowerCase(str.charAt(i)) && Character.isUpperCase(str.charAt(i - 1))) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case splitting logic\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return new String[0];\n        }\n        final List<String> list = new ArrayList<>();\n        final char[] separatorChars = {' ', '.', '\\n', '\\t', '\\r'};\n        int start = 0, i = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        int sizePlus1 = 0;\n        int max = Integer.MAX_VALUE;\n        if (camelCase) {\n            while (i < len) {\n                if (Character.getType(str.charAt(i)) == Character.LOWERCASE_LETTER && (i == start || Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER)) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        } else {\n            // standard case\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                lastMatch = false;\n                match = true;\n                i++;\n            }\n        }\n        if (match || preserveAllTokens && lastMatch) {\n            list.add(str.substring(start, i));\n        }\n        return list.toArray(new String[list.size()]);\n    }",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return new String[0];\n        }\n\n        final List<String> list = new ArrayList<>();\n        final StringBuilder buf = new StringBuilder(len);\n\n        final char[] separatorChars = { '\\u0000' }; // empty array\n\n        int i = 0;\n        int start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        boolean preserveAllTokens = false;\n        int sizePlus1 = 0;\n        int max = 0;\n\n        if (camelCase) {\n            // camel case specific logic\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(buf.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                char c = str.charAt(i);\n                int type = Character.getType(c);\n                if (type == Character.LOWERCASE_LETTER) {\n                    if (lastMatch && match) {\n                        lastMatch = false;\n                        match = false;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(buf.substring(start, i));\n                    }\n                } else if (type == Character.UPPERCASE_LETTER) {\n                    if (!lastMatch || !match) {\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(buf.substring(start, i));\n                    }\n                    match = true;\n                } else if (type == Character.TITLECASE_LETTER) {\n                    if (!lastMatch && !match) {\n                        if (sizePlus1++ == max) {\n                            i = len;\n}\n}\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        final String[] separatorChars = {\" \", \"_\", \"\\t\", \"\\n\", \"\\r\"};\n        final List<String> list = new ArrayList<>();\n        if (len == 0) {\n            list.add(\"\");\n            return list.toArray(new String[list.size()]);\n        }\n        int i = 0;\n        int start = 0;\n        boolean match = false;\n        boolean preserveAllTokens = false;\n        int max = 0;\n        int sizePlus1 = 0;\n        boolean lastMatch = false;\n        if (camelCase) {\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        lastMatch = true;\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n                int ch = Character.getType(str.charAt(i));\n                if (Character.isLowerCase(str.charAt(i))) {\n                    if (lastMatch && Character.isUpperCase(str.charAt(i - 1))) {\n                        match = false;\n                    } else {\n                        match = true;\n                    }\n                } else if (Character.isUpperCase(str.charAt(i))) {\n                    if (match) {\n                        if (sizePlus1++ == max) {\n                            i = len;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = i;\n                } else if (Character.isTitleCase(str.charAt(i))) {\n                    if (match) {\n                        if (sizePlus1++ == max) {\n                            i = len;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = i;\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final List<String> list = new ArrayList<>();\n    if (len == 0) {\n        list.add(\"\");\n        return list.toArray(new String[list.size()]);\n    }\n    final char[] separatorChars = Character.getChars(Character.DASH_PUNCTUATION);\n    int start = 0;\n    int i = 0;\n    boolean match;\n    boolean lastMatch = false;\n    final char[] arr = str.toCharArray();\n    while (i < len) {\n        final char ch = arr[i];\n        final int chType = Character.getType(ch);\n        if (separatorChars.indexOf(ch) >= 0) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (Character.isLetter(ch)) {\n            if (camelCase) {\n                if (i > 0 && Character.isLowerCase(arr[i - 1]) && Character.isUpperCase(ch)) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || preserveAllTokens && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n    final List<String> list = new ArrayList<>(4);\n    final char[] separatorChars = new char[24];\n    final int[] letterTypes = new int[24];\n    final int[] letterStarts = new int[24];\n    final StringBuilder sb = new StringBuilder();\n    char ch;\n    for (int i = 0; i < len; i++) {\n        ch = str.charAt(i);\n        final int chType = Character.getType(ch);\n        if (i == 0 || chType != letterTypes[i - 1]) {\n            if (i != 0) {\n                separatorChars[i - 1] = ch;\n                letterTypes[i - 1] = chType;\n                letterStarts[i - 1] = i;\n            }\n            letterTypes[i] = chType;\n            letterStarts[i] = i;\n        }\n        sb.append(ch);\n    }\n    separatorChars[len - 1] = ch;\n    letterTypes[len - 1] = chType;\n    letterStarts[len - 1] = len;\n\n    final int sizePlus1;\n    final int max;\n    if (camelCase) {\n        int start = 0;\n        int lastMatch = false;\n        boolean match = false;\n        sizePlus1 = 0;\n        max = Integer.MAX_VALUE;\n        for (int i = 0; i <= len; i++) {\n            final char c = i == len ? 0 : separatorChars[i];\n            final int type = i == len ? 0 : letterTypes[i];\n            final int letterStart = i == len ? len : letterStarts[i];\n            if (type == Character.LOWERCASE_LETTER && match) {\n                if (start < letterStart - 1) {\n                    list.add(sb.substring(start, letterStart - 1));\n                    match = false;\n                }\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final List<String> list = new ArrayList<>();\n    if (len == 0) {\n        list.add(\"\");\n        return list.toArray(new String[list.size()]);\n    }\n    final char[] separatorChars = Character.toChars(\n            Character.DASH_PUNCTUATION, Character.START_PUNCTUATION, Character.END_PUNCTUATION,\n            Character.CONNECTOR_PUNCTUATION, Character.OTHER_PUNCTUATION, Character.MATH_SYMBOL,\n            Character.CURRENCY_SYMBOL, Character.MODIFIER_SYMBOL, Character.INITIAL_QUOTE,\n            Character.FINAL_QUOTE, Character.OTHER_SYMBOL, Character.SPACE, Character.LINE_SEPARATOR,\n            Character.PARAGRAPH_SEPARATOR, Character.CONTROL, Character.FORMAT, Character.PRIVATE_USE,\n            Character.SURROGATE, Character.OTHER_PRIVATE_USE);\n    final char[] letterChars = Character.toChars(Character.UPPERCASE_LETTER, Character.LOWERCASE_LETTER);\n    int start = 0;\n    int i = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    int sizePlus1 = 0;\n    int max = Integer.MAX_VALUE;\n    while (i < len) {\n        if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n            if (match || preserveAllTokens) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        } else if (camelCase && i > start && letterChars.indexOf(str.charAt(i)) >= 0 && letterChars.indexOf(str.charAt(i - 1)) >= 0\n                && Character.getType(str.charAt(i)) == Character.LOWERCASE_LETTER\n                && Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER) {\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return new String[0];\n        }\n\n        final List<String> list = new ArrayList<String>();\n        final int[] type = new int[len];\n        final char[] buf = str.toCharArray();\n\n        for (int i = 0; i < len; i++) {\n            type[i] = Character.getType(buf[i]);\n        }\n\n        final char[] separatorChars = {' '};\n\n        int i = 0;\n        int start = 0;\n        boolean match = false;\n        boolean lastMatch = false;\n        int max = 2;\n        int sizePlus1 = 0;\n        boolean preserveAllTokens = false;\n\n        if (camelCase) {\n            while (i < len) {\n                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n                    if (match || preserveAllTokens) {\n                        if (sizePlus1++ == max) {\n                            i = len;\n                            lastMatch = false;\n                        }\n                        list.add(str.substring(start, i));\n                        match = false;\n                    }\n                    start = ++i;\n                    continue;\n                }\n\n                if (i == 0 || type[i] == type[i - 1]) {\n                    match = true;\n                } else {\n                    if (Character.getType(buf[i]) == Character.LOWERCASE_LETTER) {\n                        if (Character.getType(buf[i - 1]) == Character.UPPERCASE_LETTER) {\n                            match = false;\n                        } else {\n                            match = true;\n                        }\n                    } else {\n                        match = false;\n                    }\n                }\n\n                if (match) {\n                    lastMatch = true;\n                    continue;\n                }\n\n                if (match || preserveAllTokens && lastMatch) {\n                    list.add(str.substring(start, i));\n                }\n\n                start = ++i;\n                match = false;\n                lastMatch = false;\n            }\n\n            if (match || preserveAllTokens && lastMatch) {\n}\n}\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    int pos = parseInto(new ReadWritableInstant(), text, 0);\n    if (pos < 0) \n    {\n        throw new IllegalArgumentException(\"Invalid text to parse\");\n    }\n    return new ReadWritableInstant().getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    if (text == null) {\n        throw new IllegalArgumentException(\"text must not be null\");\n    }\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        0L, Chronology.ISO, iLocale, iPivotYear, DateTimeUtils.getISOChronology().year().get(0));\n    int newPos = parser.parseInto(bucket, text, 0);\n    long millis = bucket.computeMillis(false, text);\n    if (bucket.getOffsetInteger() != null) {\n        DateTimeZone zone = DateTimeZone.forOffsetMillis(bucket.getOffsetInteger());\n        millis = DateTimeUtils.getChronology(zone).date().withMillis(millis).getMillis();\n    }\n    return millis;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    long instantMillis = 0L;\n    try \n    {\n        DateTimeParserBucket bucket = new DateTimeParserBucket(instantMillis, ISOChronology.INSTANCE, iLocale, iPivotYear, DateTimeUtils.getChronology(ISOChronology.INSTANCE).year().get(instantMillis));\n        int position = parser.parseInto(bucket, text, 0);\n        instantMillis = bucket.computeMillis(false, text);\n        DateTimeZone parsedZone = bucket.getZone();\n        if (parsedZone != null) {\n            instantMillis += parsedZone.getOffset(instantMillis);\n        }\n        return instantMillis;\n    } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Invalid date/time string: \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    int pos = parseInto(new ReadWritableInstant(), text, 0);\n    if (pos < 0) \n    {\n        throw new IllegalArgumentException(\"Invalid datetime string: \" + text);\n    } \n    else \n    {\n        return millis;\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    long instantMillis = System.currentTimeMillis();\n    Chronology chrono = Chronology.ISO;\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    instantMillis = bucket.computeMillis(false, text);\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n\n    return instantMillis;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    long millis = parser.parseMillis(text);\n    return millis;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    long millis = parser.parseMillis(text);\n    \n    return millis;\n}",
      "public long parseMillis(String text)  {\n    int pos = parseInto(new ReadWritableInstant(), text, 0);\n    if (pos >= 0)\n    {\n        return readInstant().getMillis();\n    }\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0L, Chronology.ISO, iLocale, iPivotYear, 1970);\n    int newPos = parser.parseInto(bucket, text, 0);\n    return bucket.computeMillis(false, text);\n}",
      "public long parseMillis(String text)  {\n    int position = 0;\n    ReadWritableInstant instant = ReadWritableInstant.INSTANCE;\n    int newPosition = parseInto(instant, text, position);\n    if (newPosition >= 0) {\n        return instant.getMillis();\n    } else {\n        throw new IllegalArgumentException(\"Invalid datetime string: \" + text);\n    }\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n   MeasuredNode p = new MeasuredNode(n);\n   MeasuredNode n2 = new MeasuredNode(Token.SCRIPT, 1 << 20);\n   return new MinimizedCondition(p, n2);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n\t// Create a new node with the same type as the original node.\n\tNode newnode = new Node(n.getType());\n\t\n\t// Copy the original node's children to the new node.\n\tfor (Node child : n.getChildren()) {\n\t    newnode.addChild(child);\n\t}\n\t\n\t// Create a new MeasuredNode with the new node.\n\tMeasuredNode newmeasured = new MeasuredNode(newnode, 0);\n\t\n\t// Create a new MeasuredNode with the original node negated.\n\tMeasuredNode newnegated = new MeasuredNode(new Node(Token.NOT, n), 0);\n\t\n\t// Create a new MinimizedCondition with the new measured nodes.\n\treturn new MinimizedCondition(newmeasured, newnegated);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n\treturn new MinimizedCondition(MeasuredNode.of(n), MeasuredNode.of(new ScriptToken()));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n\treturn new MinimizedCondition(\n\t\t\tMeasuredNode.of(n),\n\t\t\tMeasuredNode.of(new ScriptNode()));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n   Preconditions.checkArgument(n.getParent() != null);\n   MeasuredNode positive = MeasuredNode.create(n);\n   MeasuredNode negative = MeasuredNode.create(Token.SCRIPT, \"dummy\", 0).change();\n   return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(MeasuredNode.wrap(n), \n                                MeasuredNode.wrap(new Script(new Token[] {Token.EMPTY})));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n\treturn new MinimizedCondition(new MeasuredNode(n), new MeasuredNode(Token.SCRIPT, 1));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n   return new MinimizedCondition(\n      MeasuredNode.create(n),\n      MeasuredNode.create(Token.SCRIPT, Collections.emptyList()));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n   return new MinimizedCondition(\n      MeasuredNode.create(n),\n      MeasuredNode.create(\n         new Script(new Node[0], Token.SCRIPT),\n         Token.SCRIPT));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n\treturn new MinimizedCondition(MeasuredNode.of(n), MeasuredNode.of(new ScriptLiteral(false)));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> longs = new ArrayList<>();\n    long total = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        if (total + (1 << constant.ordinal()) >= Long.MAX_VALUE) {\n            longs.add(total);\n            total = 0;\n        }\n        total |= 1 << constant.ordinal();\n    }\n    longs.add(total);\n    long[] result = new long[longs.size()];\n    for (int i = 0; i < longs.size(); i++) {\n        result[i] = longs.get(i);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<E> validValues = new ArrayList<>();\n\n    for (E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        validValues.add(constant);\n    }\n    long[] result = new long[validValues.size()];\n    for (int i = 0; i < validValues.size(); i++) {\n        result[i] = 1L << validValues.get(i).ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<E> constants = new ArrayList<>(values);\n    EnumUtils.validateEnumValues(enumClass, constants);\n    if (constants.size() == 1) {\n        return new long[] {generateBitVector(enumClass, constants)};\n    }\n    List<Long> longs = new ArrayList<>();\n    while (!constants.isEmpty()) {\n        List<E> subset = constants.size() <= 64 ? constants : constants.subList(0, 64);\n        long value = generateBitVector(enumClass, subset);\n        longs.add(value);\n        constants.removeAll(subset);\n    }\n    return longs.toArray(new long[longs.size()]);\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n\n    List<E> sortedValues = new ArrayList<>(values);\n    sortedValues.sort(Enum::compareTo);\n\n    long[] result = new long[1 + sortedValues.size() / Long.BYTES];\n\n    for (int i = 0; i < sortedValues.size(); i++) {\n        Validate.isTrue(sortedValues.get(i) != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[i / Long.BYTES] |= 1L << sortedValues.get(i).ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        long bitVector = 1L << constant.ordinal();\n        if (bitVectors.isEmpty()) {\n            bitVectors.add(bitVector);\n        } else {\n            for (int i = bitVectors.size() - 1; i >= 0; i--) {\n                if ((bitVectors.get(i) & bitVector) == 0) {\n                    bitVectors.add(bitVector | bitVectors.get(i));\n                    bitVectors.remove(i);\n                    break;\n                }\n            }\n        }\n    }\n    long[] result = new long[bitVectors.size()];\n    for (int i = 0; i < bitVectors.size(); i++) {\n        result[i] = bitVectors.get(i);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        if (bitVectors.isEmpty() || bitVectors.get(bitVectors.size() - 1).equals(Long.MAX_VALUE)) {\n            bitVectors.add(0L);\n        }\n        bitVectors.set(bitVectors.size() - 1, bitVectors.get(bitVectors.size() - 1) | (1 << constant.ordinal()));\n    }\n\n    long[] result = new long[bitVectors.size()];\n    for (int i = 0; i < bitVectors.size(); i++) {\n        result[i] = bitVectors.get(i);\n    }\n\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> bitVectors = new ArrayList<>();\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        int bitPosition = constant.ordinal();\n        int vectorPosition = bitPosition / 64;\n        long bitVector = 1L << bitPosition % 64;\n        while (bitVectors.size() <= vectorPosition) {\n            bitVectors.add(0L);\n        }\n        bitVectors.set(vectorPosition, bitVectors.get(vectorPosition) | bitVector);\n    }\n    return bitVectors.stream().mapToLong(Long::longValue).toArray();\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<Long> result = new ArrayList<>();\n    int bitsUsed = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        if (bitsUsed >= 64) {\n            result.add(bitsUsed);\n            bitsUsed = 0;\n        }\n        result.add(constant.ordinal() >> bitsUsed);\n        bitsUsed += 6;\n    }\n    if (bitsUsed > 0) {\n        result.add(bitsUsed);\n    }\n\n    long[] longArray = new long[result.size()];\n    for (int i = 0; i < result.size(); i++) {\n        longArray[i] = result.get(i);\n    }\n\n    return longArray;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<E> sortedValues = new ArrayList<>(values);\n    sortedValues.sort((o1, o2) -> o1.compareTo(o2));\n    long[] vector = new long[1 + (int) Math.floor(Math.log(sortedValues.size()) / Math.log(Long.BYTES))];\n    for (final E constant : sortedValues) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        vector[constant.ordinal() / Long.BYTES] |= 1L << (constant.ordinal() % Long.BYTES);\n    }\n    return vector;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    List<E> list= new ArrayList<>(Arrays.asList(enumClass.getEnumConstants()));\n    long[] total = new long[list.size()];\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        total[list.indexOf(constant)] |= 1 << constant.ordinal();\n    }\n    return total;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    }\n    int depth = 0;\n    while (scope != null && !scope.isLexicalScope()) {\n        depth++;\n        scope = scope.getParent();\n    }\n    return depth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    }\n    int depth = 0;\n    while (!scope.isLexicalScope()) {\n        scope = scope.getOwnerScope();\n        depth++;\n    }\n    return depth + scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getDepth();\n  }\n\n  if (scope.isPropertyScope()) \n  {\n    SymbolScope currentScope = scope;\n    int depth = 0;\n    while (!currentScope.isLexicalScope()) \n    {\n      currentScope = currentScope.getParentScope();\n      depth++;\n    }\n    return depth + currentScope.getDepth();\n  }\n\n  return 0;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope == null)\n    return -1;\n  if (scope.isLexicalScope())\n    return scope.getDepth();\n  if (scope.isPropertyScope()) {\n    SymbolScope current = (SymbolScope)scope.getParent();\n    int result = 0;\n    while (!current.isLexicalScope()) {\n      current = (SymbolScope)current.getParent();\n      result++;\n    }\n    return current.getDepth() + result;\n  }\n  if (scope.isDocInfoScope())\n    return 0;\n  return -1;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexical = scope.getNearestEnclosingLexicalScope();\n    if (lexical != null) {\n      return lexical.getScopeDepth() + 1;\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n      return scope.getDepth();\n    } else if (scope.isPropertyScope()) \n    {\n      SymbolScope parent = scope.getParent();\n      int depth = scope.getDepth();\n      while (parent != null)\n      {\n        depth++;\n        if (parent.isLexicalScope()) \n        {\n          return depth;\n        }\n        parent = parent.getParent();\n      }\n    }\n    return 0;\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope parent = scope;\n        int depth = 0;\n        while (!parent.isLexicalScope()) {\n            parent = parent.getEnclosingScope();\n            depth++;\n        }\n        return depth + scope.getDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    }\n    int depth = 0;\n    SymbolScope parent = scope.getParent();\n    while (parent != null) {\n        if (parent.isLexicalScope()) {\n            depth += parent.getDepth();\n            break;\n        }\n        parent = parent.getParent();\n        depth++;\n    }\n    return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n      return scope.getDepth(); \n    }\n\n    if (scope.isPropertyScope()) \n    {\n      SymbolScope propertyScope = scope;\n      int lexicalScopeDepth = 0;\n\n      while (!propertyScope.isLexicalScope()) \n      {\n        propertyScope = propertyScope.getParent();\n        lexicalScopeDepth++;\n      }\n\n      return lexicalScopeDepth + propertyScope.getDepth();\n    }\n\n    return 0;\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope == null)\n    return -1;\n\n  int depth = 0;\n  while (scope != null && !scope.isLexicalScope()) {\n    scope = scope.getParent();\n    depth++;\n  }\n  return depth + (scope == null ? 0 : scope.getScopeDepth());\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        throw new DimensionMismatchException(rawData.length, rawData[0].length);\n    }\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final double[][] blocks = createBlocksLayout(rows, columns);\n    for (int iBlock = 0; iBlock < blocks.length; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blocks[iBlock].length; ++jBlock) {\n            for (int iRow = 0; iRow < iHeight; ++iRow) {\n                for (int jColumn = 0; jColumn < blockWidth(jBlock); ++jColumn) {\n                    blocks[iBlock][jBlock][iRow * blockWidth(jBlock) + jColumn] =\n                            rawData[iRow + iBlock * blockHeight(iBlock)][jColumn + jBlock * blockWidth(jBlock)];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int iRow = 0; iRow < iHeight; ++iRow) {\n                for (int jColumn = 0; jColumn < blockWidth(jBlock); ++jColumn) {\n                    final int iRaw = iBlock * BLOCK_SIZE + iRow;\n                    final int jRaw = jBlock * BLOCK_SIZE + jColumn;\n                    if (iRaw >= rows || jRaw >= columns) {\n                        continue;\n                    }\n                    blocks[index][iRow * blockWidth(jBlock) + jColumn] = rawData[iRaw][jRaw];\n                }\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        throw new IllegalArgumentException(\"Argument must be non-empty\");\n    }\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n\n    if (columns == rows) {\n        // simple case: square matrix\n        final double[][] blocks = new double[rows / BLOCK_SIZE][];\n        int index = 0;\n        for (int iBlock = 0; iBlock < blocks.length; ++iBlock) {\n            final int iHeight = BLOCK_SIZE;\n            blocks[iBlock] = new double[iHeight * iHeight];\n            for (int jBlock = 0; jBlock < blocks.length; ++jBlock) {\n                System.arraycopy(rawData[index], 0, blocks[iBlock],\n                                     iHeight * jBlock, iHeight);\n                index++;\n            }\n        }\n        return blocks;\n    }\n\n    final double[][] blocks = new double[rows / BLOCK_SIZE * columns / BLOCK_SIZE][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < rows / BLOCK_SIZE; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < columns / BLOCK_SIZE; ++jBlock) {\n            final int iWidth = blockWidth(jBlock);\n            blocks[index] = new double[iHeight * iWidth];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                     jBlock * BLOCK_SIZE, blocks[index],\n                                     i * iWidth, iWidth);\n            }\n            index++;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    // check input dimensions\n    if (rawData.length == 0 || rawData[0].length == 0) {\n        throw new IllegalArgumentException(\"Zero-dimensional arrays are not supported\");\n    }\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // create output array in blocks layout\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int iRow = 0; iRow < iHeight; ++iRow) {\n                final int offsetRow = iBlock * BLOCK_SIZE + iRow;\n                for (int jColumn = 0; jColumn < blockWidth(jBlock); ++jColumn) {\n                    final int offsetColumn = jBlock * BLOCK_SIZE + jColumn;\n                    blocks[index][iRow * blockWidth(jBlock) + jColumn] =\n                        rawData[offsetRow][offsetColumn];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    if (rawData[0].length != rawData.length) {\n        throw new DimensionMismatchException(rawData.length, rawData[0].length);\n    }\n\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            double[] block = new double[iHeight * blockWidth(jBlock)];\n            int offsetRow = iBlock * BLOCK_SIZE;\n            int offsetColumn = jBlock * BLOCK_SIZE;\n            for (int iRow = 0; iRow < iHeight; ++iRow) {\n                System.arraycopy(rawData[offsetRow + iRow], offsetColumn, block,\n                        iRow * blockWidth(jBlock), blockWidth(jBlock));\n            }\n            blocks[index] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    int numRows = rawData.length;\n    int numCols = rawData[0].length;\n\n    if (numRows == 0 || numCols == 0) {\n        throw new DimensionMismatchException(numRows, numCols);\n    }\n\n    if (numRows != rawData[0].length) {\n        throw new DimensionMismatchException(numRows, numCols);\n    }\n\n    // number of blocks\n    int blockRows = (numRows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (numCols + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // allocate blocks array\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n            blocks[blockIndex] = new double[iHeight * blockWidth(jBlock)];\n\n            int rowIndex = 0;\n            for (int iRow = iBlock * BLOCK_SIZE;\n                 iRow < (iBlock + 1) * BLOCK_SIZE && iRow < numRows;\n                 ++iRow, ++rowIndex) {\n                int colIndex = 0;\n                for (int jCol = jBlock * BLOCK_SIZE;\n                     jCol < (jBlock + 1) * BLOCK_SIZE && jCol < numCols;\n                     ++jCol, ++colIndex) {\n                    blocks[blockIndex][rowIndex * blockWidth(jBlock) + colIndex] = rawData[iRow][jCol];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    if (rows == 0 || columns == 0) {\n        return new double[0][0];\n    }\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            blocks[index] = new double[iHeight * blockWidth(jBlock)];\n            for (int iRow = 0; iRow < iHeight; ++iRow) {\n                final int rowOffset = iRow * blockWidth(jBlock);\n                System.arraycopy(rawData[iRow + iBlock * BLOCK_SIZE], 0,\n                                     blocks[index], rowOffset, blockWidth(jBlock));\n            }\n        }\n    }\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    // number of blocks\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            if (rawData[index].length != iHeight * blockWidth(jBlock)) {\n                throw new DimensionMismatchException(rawData[index].length,\n                iHeight * blockWidth(jBlock));\n            }\n            blocks[index] = rawData[index];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    int rows = rawData.length;\n    int columns = rawData[0].length;\n\n    if (rows <= 0 || columns <= 0) {\n        throw new NotStrictlyPositiveException(\"Row and column dimensions must be positive\");\n    }\n\n    if (!isRectangular(rawData)) {\n        throw new DimensionMismatchException(\"Input array must be rectangular\");\n    }\n\n    int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = createBlocksLayout(rows, columns);\n\n    int index = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n            double[] block = new double[iHeight * blockWidth(jBlock)];\n            for (int i = 0; i < iHeight; ++i) {\n                System.arraycopy(rawData[iBlock * BLOCK_SIZE + i],\n                                jBlock * BLOCK_SIZE, block,\n                                i * blockWidth(jBlock), blockWidth(jBlock));\n            }\n            blocks[index] = block;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    int blockRows = (rawData.length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    int blockColumns = (rawData[0].length + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            int index = iBlock * blockColumns + jBlock;\n            if (blocks[index].length != iHeight * blockWidth(jBlock)) {\n                throw new DimensionMismatchException(blocks[index].length,\n                iHeight * blockWidth(jBlock));\n            }\n        }\n    }\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iHeight = blockHeight(iBlock);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            int index = iBlock * blockColumns + jBlock;\n            for (int i = 0; i < iHeight; ++i) {\n                for (int j = 0; j < blockWidth(jBlock); ++j) {\n                    blocks[index][i * blockWidth(jBlock) + j] = rawData[iBlock * iHeight + i][jBlock * blockWidth(jBlock) + j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass and values cannot be null\");\n    }\n\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"enumClass is not an enum class\");\n    }\n\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enum class cannot have more than 64 values\");\n    }\n\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values cannot contain null\");\n        }\n    }\n\n    long bitVector = 0;\n    for (E value : values) {\n        bitVector |= (1L << value.ordinal());\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"Enum class or values cannot be null\");\n    }\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"Enum class must be an Enum\");\n    }\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enum class cannot have more than 64 values\");\n    }\n    long result = 0;\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value cannot be null\");\n        }\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    // Validate input parameters\n    if (enumClass == null || values == null) {\n        throw new NullPointerException();\n    }\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"EnumUtils#generateBitVector: invalid enum class\");\n    }\n\n    // Create a set from the input iterable to remove duplicates\n    Set<E> uniqueValues = new HashSet<>(values);\n\n    // Check for null values in the set\n    if (uniqueValues.contains(null)) {\n        throw new IllegalArgumentException(\"EnumUtils#generateBitVector: null value is not allowed\");\n    }\n\n    // Calculate the number of bits required to represent the enum set\n    int requiredBits = Math.max(uniqueValues.size(), Long.BYTES * Byte.SIZE);\n\n    // Create a long bit vector with enough space to hold the set\n    long bitVector = 0L;\n\n    // Set the corresponding bits for each value in the set\n    for (E value : uniqueValues) {\n        if (value == null) {\n            continue;\n        }\n        int bitIndex = value.ordinal() % Long.BYTES;\n        bitVector |= 1L << (bitIndex * Byte.SIZE);\n    }\n\n    // Ensure the bit vector does not exceed the maximum long value\n    if (bitVector > Long.MAX_VALUE) {\n        throw new IllegalArgumentException(\"EnumUtils#generateBitVector: bit vector exceeds maximum value\");\n    }\n\n    // Return the bit vector\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException();\n    }\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"null value\");\n        }\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"not an enum class\");\n    }\n    if (Enum.getEnumConstants(enumClass).length > 64) {\n        throw new IllegalArgumentException(\"too many enum values\");\n    }\n    long bitVector = 0L;\n    for (E value : values) {\n        bitVector |= value.ordinal() << (value.ordinal() + 1);\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"EnumClass and Values cannot be null\");\n    }\n\n    if (enumClass.isEnum() == false) {\n        throw new IllegalArgumentException(\"EnumClass must be an Enum\");\n    }\n\n    if (values.size() > 64) {\n        throw new IllegalArgumentException(\"EnumClass cannot have more than 64 values\");\n    }\n\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"EnumValues cannot be null\");\n        }\n    }\n\n    long bitVector = 0L;\n    for (E value : values) {\n        bitVector |= (1L << value.ordinal());\n    }\n\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null) {\n        throw new NullPointerException(\"enumClass cannot be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"values cannot be null\");\n    }\n\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"enumClass must be an enum class\");\n    }\n\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enums with more than 64 values are not supported\");\n    }\n\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"All values in the Iterable must be non-null\");\n        }\n    }\n\n    long bitVector = 0L;\n    for (final E value : values) {\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass or values cannot be null\");\n    }\n    for (final E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values cannot contain null values\");\n        }\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"enumClass is not an enum\");\n    }\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"enumClass cannot have more than 64 values\");\n    }\n    long bitVector = 0L;\n    for (final E value : values) {\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"enumClass and values may not be null\");\n    }\n\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"enumClass must be an Enum type\");\n    }\n\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Enum class may not contain more than 64 values\");\n    }\n\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"values may not contain null\");\n        }\n    }\n\n    long bitVector = 0;\n\n    for (E value : values) {\n        bitVector |= 1L << value.ordinal();\n    }\n\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException();\n    }\n    if (!Enum.class.isAssignableFrom(enumClass)) {\n        throw new IllegalArgumentException(\"Class \" + enumClass + \" is not an Enum\");\n    }\n    if (enumClass.getEnumConstants().length > 64) {\n        throw new IllegalArgumentException(\"Class \" + enumClass + \" has more than 64 values\");\n    }\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Value \" + value + \" is null\");\n        }\n    }\n    long result = 0L;\n    for (E value : values) {\n        result |= 1L << (value.ordinal() % 64);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    if (enumClass == null || values == null) {\n        throw new NullPointerException(\"EnumClass or values cannot be null\");\n    }\n    if (!enumClass.isEnum()) {\n        throw new IllegalArgumentException(\"EnumClass must be an enum class\");\n    }\n    if (EnumUtils.getEnumMap(enumClass).size() > 64) {\n        throw new IllegalArgumentException(\"EnumClass cannot have more than 64 values\");\n    }\n    for (E value : values) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"Values cannot contain null\");\n        }\n    }\n    long result = 0L;\n    for (E value : values) {\n        result |= (1L << value.ordinal());\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n\tint x = 0;\n\tDfp result = a.newInstance(1);\n\tDfp term = a.newInstance(1);\n\n\twhile (x <= 100) {\n\t\tterm = term.multiply(a).divide(new Dfp(x+1));\n\t\tif(x % 2 == 0) {\n\t\t\tresult = result.add(term);\n\t\t}\n\t\telse {\n\t\t\tresult = result.subtract(term);\n\t\t}\n\t\tx++;\n\t}\n\t\n\treturn result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    int i = 0;\n    Dfp ai = a;\n    while (true) {\n        i++;\n        ai = ai.multiply(a);\n        if (ai.isZero()) break;\n        final Dfp bi = a.getField().getSplit(i);\n        final Dfp aiDi = ai.divide(bi);\n        result = result.add(aiDi);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final int aexp = (int) (a.getExponent() & 0x7fffffffL);\n        final int ashift = 53 - (aexp + 1) & 63;\n        final int aexp2 = aexp + ashift;\n        final long significand = a.getSignificand() >>> ashift;\n\n        if (aexp2 >= 30) {\n            final Dfp t = a.newInstance(1L << ashift, 0);\n            t.setExponent(aexp2 - 30);\n            return expInternal(t).multiply(a);\n        }\n\n        final Dfp result = a.newInstance();\n        long s = 1;\n        for (int i = 0; i <= aexp2; i++) {\n            final Dfp term = a.newInstance(s, 0);\n            term.setExponent(-i);\n            result.add(term);\n            s *= significand;\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final int n = 20;\n    Dfp result = a.newInstance(Dfp.ONE);\n    Dfp factor = a.newInstance(1.0);\n    for (int i = 1; i <= n; i++)\n    {\n        factor = factor.multiply(a).divide(i);\n        result = result.add(factor);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance((byte)1, Dfp.ONE);\n    Dfp term = a.newInstance();\n    int n = 2;\n\n    while (n <= 500)\n    {\n        term = term.divide(n);\n        term = term.multiply(a);\n        result = result.add(term);\n        ++n;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\tDfp result = a.getField().getONE();\n\tint n = 1;\n\tdouble term = a.doubleValue();\n\twhile (term>DBL_EPSILON)\n\t{\n\t\tterm *= a.doubleValue();\n\t\tterm /= (double) n;\n\t\tresult = result.add(a.newInstance(term));\n\t\tn++;\n\t}\n\treturn result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\tfinal Dfp result = a.newInstance(a.getField().getZero(), 1);\n\tDfp term = a;\n\tint i = 1;\n\twhile (true) {\n\t\tterm = term.divide(i);\n\t\tfinal Dfp oldResult = result;\n\t\tresult = result.add(term);\n\t\tif (oldResult.equals(result)) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\tfinal Dfp result = a.getField().getZero();\n\tDfp term = a.getField().getOne();\n\tint i=0;\n\tdo\n\t{\n\t\tresult = result.add(term);\n\t\ti++;\n\t\tterm = term.multiply(a).divide(i);\n\t}\n\twhile(term.compareTo(a.getField().getEpsilon())>0);\n\treturn result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance();\n    Dfp prevResult = result;\n    Dfp x = a.newInstance();\n    int factorial = 1;\n    int term = 1;\n    while (term > 0)\n    {\n        term = term / 2;\n        result = result.add(prevResult.multiply(x.pow(term).divide(factorial)));\n        prevResult = result;\n        factorial = factorial * (term + 1) * (term + 2);\n        x = x.multiply(a);\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final int N = 24;\n        final Dfp[] fact = a.getField().getFFact();\n\n        Dfp result = a.getField().getOOne();\n\n        for (int i = 0; i < N; ++i) {\n            final int j = i + 1;\n            final Dfp term = a.pow(j).divide(fact[j]);\n            result = result.add(term);\n        }\n\n        return result;\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_ZERO_NORM_VECTOR);\n    }\n    final FieldVector3D<T> result = new FieldVector3D<T>(x, y, z);\n    result.scale(n.negate());\n    return result;\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_ZERO_NORM_VECTOR);\n    }\n    return new FieldVector3D<T>(y.clone().multiply(z.clone().scalarMultiply(n.reciprocal()).minus(z.clone().multiply(y.clone().scalarMultiply(n.reciprocal())))),\n            z.clone().multiply(x.clone().scalarMultiply(n.reciprocal()).minus(x.clone().multiply(z.clone().scalarMultiply(n.reciprocal())))),\n            x.clone().multiply(y.clone().scalarMultiply(n.reciprocal()).minus(y.clone().multiply(x.clone().scalarMultiply(n.reciprocal())))));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_COMPUTE_A_UNIT_VECTOR_FOR_A_ZERO_NORM_VECTOR);\n    }\n    FieldVector3D<T> v = new FieldVector3D<T>(x.subtract(n.multiply(x.dotProduct(n))),\n                                              y.subtract(n.multiply(y.dotProduct(n))),\n                                              z.subtract(n.multiply(z.dotProduct(n))));\n    return v.normalize();\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONAL_A_ZERO_NORM_VECTOR);\n    }\n    FieldVector3D<T> v = new FieldVector3D<T>(x, y, z);\n    v = v.scalarMultiply(s.reciprocal());\n    return v.subtract(this);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T s = getNorm();\n    if (s.getReal() == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    FieldVector3D<T> v = new FieldVector3D<T>(x.subtract(s.multiply(y)), y.add(s.multiply(x)), z);\n    return v.normalize();\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(\"Cannot orthogonal a zero norm vector\");\n    }\n    \n    return new FieldVector3D<T>(x.subtract(n.multiply(y)),\n                                    y.add(n.multiply(x)),\n                                    z.copy());\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_ZERO_NORM_VECTOR);\n    }\n    final T factor = n.getField().create(x.subtract(y).cross(x.subtract(z)).dot(x.subtract(y).cross(x.subtract(z)))).reciprocal();\n    return new FieldVector3D<T>(y.subtract(z).cross(x.subtract(y).cross(x.subtract(z))).scalarMultiply(factor),\n                                  x.subtract(y).cross(x.subtract(z).cross(x.subtract(y))).scalarMultiply(factor),\n                                  x.subtract(z).cross(x.subtract(y).cross(x.subtract(z))).scalarMultiply(factor));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n\n    // Generate a random vector orthogonal to the normalized instance\n    T orthogonalComponent = this.y.subtract(this.z.scalarMultiply(this.y.dot(this.z) / n.pow(2)));\n    orthogonalComponent = orthogonalComponent.minus(this.x.scalarMultiply(this.x.dot(orthogonalComponent) / n.pow(2)));\n    orthogonalComponent = orthogonalComponent.normalize();\n\n    // Scale the orthogonal vector by the norm of the instance\n    return orthogonalComponent.scalarMultiply(n);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_ORTHOGONALIZE_A_ZERO_NORM_VECTOR);\n    }\n    final FieldVector3D<T> v = new FieldVector3D<T>(x.subtract(n.multiply(v.x)), y.subtract(n.multiply(v.y)), z.subtract(n.multiply(v.z)));\n    return v.normalize();\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T n = getNorm();\n    if (n.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n    }\n    if (z.equals(n)) {\n        if (x.equals(0)) {\n            return new FieldVector3D<T>(1.0, this, -1.0, y);\n        } else {\n            return new FieldVector3D<T>(1.0, this, -1.0, x);\n        }\n    }\n    if (y.equals(n)) {\n        if (x.equals(0)) {\n            return new FieldVector3D<T>(1.0, this, -1.0, z);\n        } else {\n            return new FieldVector3D<T>(1.0, this, -1.0, x);\n        }\n    }\n    if (x.equals(n)) {\n        if (z.equals(0)) {\n            return new FieldVector3D<T>(1.0, this, -1.0, y);\n        } else {\n            return new FieldVector3D<T>(1.0, this, -1.0, z);\n        }\n    }\n    return new FieldVector3D<T>(y.subtract(n.multiply(z)),\n            z.subtract(n.multiply(x)),\n            x.subtract(n.multiply(y)));\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Cannot find intersection of non-overlapping ranges\");\n    }\n    final T low = maximum.min(other.minimum);\n    final T high = minimum.max(other.maximum);\n    return new Range<T>(low, high);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges are not overlapped\");\n    }\n    Range<T> result = new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n    return result;\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (isBeforeRange(other)) \n    {\n        throw new IllegalArgumentException(\"Invalid range: \" + other);\n    }\n    if (other.isBeforeRange(this)) \n    {\n        throw new IllegalArgumentException(\"Invalid range: \" + other);\n    }\n    return new RangeImpl<>(minimum, other.maximum);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range is not overlapped by this\");\n    }\n    if (this.equals(other)) {\n        return this;\n    } else {\n        return new Range<>(maximum(this.minimum, other.minimum), \n                minimum(this.maximum, other.maximum));\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"This method requires two overlapping ranges\");\n    } else if (isBeforeRange(other)) {\n        return new Range<>(minimum, other.maximum);\n    } else if (isAfterRange(other)) {\n        return new Range<>(other.minimum, maximum);\n    } else {\n        return this;\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Range: \" + this + \" does not overlap with: \" + other);\n    }\n    return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Cannot find intersection of non-overlapping ranges\");\n    }\n    if (other.minimum.compareTo(minimum) > 0) {\n        return new Range<>(other.minimum, maximum);\n    } else {\n        return new Range<>(minimum, other.maximum);\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if ( ! this.isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Range's cannot be intersected because \" +\n                \"the first one does not overlap the second one\");\n    }\n\n    if (this.equals(other)) {\n        return new RangeImpl<>(minimum, maximum);\n    } else if (this.isAfter(other.minimum) && this.isBefore(other.maximum)) {\n        return new RangeImpl<>(maximum, other.maximum);\n    } else if (this.isAfter(other.minimum) && this.isBeforeRange(other)) {\n        return new RangeImpl<>(maximum, minimum);\n    } else if (this.isBefore(other.maximum) && this.isAfterRange(other)) {\n        return new RangeImpl<>(minimum, minimum);\n    } else {\n        return new RangeImpl<>(minimum, maximum);\n    }\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\n                \"Cannot calculate intersection of non-overlapping ranges\");\n    }\n    if (containsRange(other)) {\n        return this;\n    }\n    T lowerIntersection = maximum.min(other.maximum);\n    T upperIntersection = minimum.max(other.minimum);\n    return new Range<>(lowerIntersection, upperIntersection);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Range intersection requires overlap\");\n    }\n    else\n    {\n        return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n    }\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _characterEscapes, \n            _maximumNonEscapedChar, _rootValueSeparator);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createUTF8Generator(out, ctxt, UTF8Writer.getDefaultEncoding());\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8OutputStream(out));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, \n            _maximumNonEscapedChar, _characterEscapes, _rootValueSeparator);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, UTF8.getDecoder()));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return _createUTF8Generator(out, ctxt, false);\n}\n\nprotected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt, boolean recyclable) throws IOException \n{\n    return new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out, recyclable);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new UTF8OutputStream(out));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return Arrays.equals((Object[]) o1, (Object[]) o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isAnnotation()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive()) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isPrimitive()) {\n        if (type == Integer.TYPE) {\n            return (int) o1 == (int) o2;\n        }\n        if (type == Long.TYPE) {\n            return (long) o1 == (long) o2;\n        }\n        if (type == Float.TYPE) {\n            return (float) o1 == (float) o2;\n        }\n        if (type == Double.TYPE) {\n            return (double) o1 == (double) o2;\n        }\n        if (type == Boolean.TYPE) {\n            return (boolean) o1 == (boolean) o2;\n        }\n        if (type == Byte.TYPE) {\n            return (byte) o1 == (byte) o2;\n        }\n        if (type == Character.TYPE) {\n            return (char) o1 == (char) o2;\n        }\n    } else if (type == String.class) {\n        return o1.equals(o2);\n    } else if (type == Class.class) {\n        return o1.equals(o2);\n    } else if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    } else if (type.isEnum()) {\n        return o1.equals(o2);\n    } else if (type.isAnnotation()) {\n        return o1.equals(o2);\n    } else {\n        return o1.equals(o2);\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (type.isPrimitive()) {\n        return o1.equals(o2);\n    }\n    if (o1 instanceof Annotation && o2 instanceof Annotation) {\n        return o1.equals(o2);\n    }\n    if (type.isArray()) {\n        if (!o1.getClass().getComponentType().equals(o2.getClass().getComponentType())) {\n            return false;\n        }\n        final Object[] a1 = (Object[]) o1;\n        final Object[] a2 = (Object[]) o2;\n        if (a1.length != a2.length) {\n            return false;\n        }\n        for (int i = 0; i < a1.length; i++) {\n            if (!memberEquals(type.getComponentType(), a1[i], a2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.equals(Annotation.class)) \n    {\n        return o1.equals(o2);\n    }\n    if (o1 == o2)\n    {\n        return true;\n    }\n    if (o1 == null || o2 == null)\n    {\n        return false;\n    }\n    if (type.isArray())\n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return type.equals(o1.getClass()) && o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 == null || o2 == null || o1.getClass() != o2.getClass()) {\n        return false;\n    }\n    if (type.isEnum()) {\n        return type.cast(o1).equals(type.cast(o2));\n    }\n    if (type.isAnnotation()) {\n        return o1.equals(o2);\n    }\n    if (type == String.class) {\n        return ((String) o1).equals((String) o2);\n    }\n    if (type == Class.class) {\n        return ((Class<?>) o1).equals((Class<?>) o2);\n    }\n    if (type.isPrimitive()) {\n        return type.cast(o1).equals(type.cast(o2));\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.equals(Class.class)) {\n        return ((Class<?>) o1).getName().equals(((Class<?>) o2).getName());\n    }\n    if (type.equals(Annotation.class)) {\n        return o1.toString().equals(o2.toString());\n    }\n    if (type.isEnum()) {\n        return type.getMethod(\"valueOf\", String.class).invoke(null, o1.toString()).equals(type.getMethod(\"valueOf\", String.class).invoke(null, o2.toString()));\n    }\n    if (type.isArray()) {\n        if (!o1.getClass().getComponentType().equals(o2.getClass().getComponentType())) {\n            return false;\n        }\n        Object[] a1 = (Object[]) o1;\n        Object[] a2 = (Object[]) o2;\n        if (a1.length != a2.length) {\n            return false;\n        }\n        for (int i = 0; i < a1.length; i++) {\n            if (!memberEquals(o1.getClass().getComponentType(), a1[i], a2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isPrimitive()) {\n        return type.cast(o1).equals(type.cast(o2));\n    }\n    if (type == String.class || type == Class.class) {\n        return type.cast(o1).equals(type.cast(o2));\n    }\n    if (type == Annotation.class) {\n        return o1 == o2; //annotation equality\n    }\n    if (type.isArray()) {\n        final Class<?> componentType = type.getComponentType();\n        return arrayMemberEquals(componentType, o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof Annotation && o2 instanceof Annotation) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (o1 == o2) {\n        return true;\n    }\n    if ((o1 == null) || (o2 == null)) {\n        return false;\n    }\n    if (type.isPrimitive()) {\n        return type.isBoolean() ? (Boolean) o1 == (Boolean) o2\n                : (Number) o1 == (Number) o2;\n    }\n    if (type.isEnum()) {\n        return type.isEnum() && type.equals(o1.getClass()) && o1.equals(o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isResolved()) \n    {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    return new UnionTypeImpl(unionType.getElements().stream()\n        .filter(e -> !e.isUnresolvedType())\n        .map(e -> filterNoResolvedType(e))\n        .toArray(JSType[]::new), unionType.registry);\n  }\n  if (type.isTemplatizedType()) {\n    TemplatizedType templatizedType = type.toMaybeTemplatizedType();\n    return new TemplatizedTypeImpl(templatizedType.getOrigin(), templatizedType.getArguments().stream()\n        .map(a -> filterNoResolvedType(a))\n        .toArray(JSType[]::new), templatizedType.registry);\n  }\n  if (type.isRecordType()) {\n    RecordType recordType = type.toMaybeRecordType();\n    return new RecordTypeImpl(recordType.getOrigin(), recordType.getElements().stream()\n        .filter(e -> !e.getUnionType().isUnresolvedType())\n        .map(e -> filterNoResolvedType(e.getUnionType()))\n        .toArray(UnionType[]::new), recordType.registry);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isResolved()) {\n    return type;\n  } else {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}\n\n// Complete the getGreatestSubtype function with the correct and functional code\nstatic JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n  if (thisType.isUnionType()) {\n    return thisType.toMaybeUnionType().meet(thatType);\n  } else if (thatType.isUnionType()) {\n    return thatType.toMaybeUnionType().meet(thisType);\n  } else if (thisType.isTemplatizedType()) {\n    return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n        thatType);\n  }  else if (thatType.isTemplatizedType()) {\n    return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(\n        thisType);\n  } else if (thisType.isRecordType()) {\n    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);\n  } else if (thatType.isRecordType()) {\n    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);\n  }\n\n  if (thisType.isEnumElementType()) {\n    JSType inf = thisType.toMaybeEnumElementType().meet(thatType);\n    if (inf != null) {\n      return inf;\n    }\n  } else if (thatType.isEnumElementType()) {\n    JSType inf = thatType.toMaybeEnumElementType().meet(thisType);\n    if (inf != null) {\n      return inf;\n    }\n  }\n\n  if (thisType.isObject() && thatType.isObject()) {\n    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return thisType.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnresolvedType()) {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (type.isSubtype(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE))) {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else {\n        return type;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isResolved()) {\n    return type;\n  } else if (!type.isNoResolvedType()) {\n    // This case should not be necessary, but it is included to be safe.\n    // It should also not be possible to reach this code.\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isUnresolvedType()) {\n    return type.registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  \n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    UnionType filteredUnionType = unionType.filter(filterNoResolvedType);\n    if (filteredUnionType.getElements().size() == 1) {\n      return filteredUnionType.getElements().get(0);\n    }\n    return filteredUnionType;\n  }\n  \n  if (type.isRecordType()) {\n    RecordType recordType = type.toMaybeRecordType();\n    RecordType filteredRecordType = recordType.filter(filterNoResolvedType);\n    if (filteredRecordType.getElements().size() == 1) {\n      return filteredRecordType.getElements().get(0);\n    }\n    return filteredRecordType;\n  }\n  \n  return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    // If the restrictedType differs from the originalType, then we should\n    // branch the current flow scope and create a new flow scope with the name\n    // declared with the new type.\n    if (originalType != restrictedType) {\n      // If the original type is null, we can't restrict it.\n      if (originalType == null) {\n        return blindScope;\n      }\n      // If the restricted type is null, we need to remove the original type.\n      if (restrictedType == null) {\n        StaticSlot<JSType> slot = blindScope.findUniqueRefinedSlot(node);\n        if (slot != null) {\n          blindScope.removeRefinedSlot(slot);\n        }\n      } else {\n        // Otherwise, we need to create a new flow scope with the new type.\n        FlowScope newScope = blindScope.createChildFlowScope();\n        StaticSlot<JSType> slot = newScope.findUniqueRefinedSlot(node);\n        if (slot == null) {\n          slot = newScope.addRefinedSlot(node, restrictedType);\n        } else {\n          slot.setType(restrictedType);\n        }\n        return newScope;\n      }\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n    if (originalType != restrictedType && originalType != null && restrictedType != null) {\n      // creating new scope\n      return blindScope.createChildFlowScope(node, restrictedType);\n    } else {\n      return blindScope;\n    }\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n    // If we have a restricted type, we must create a new flow scope\n    if (restrictedType != null) \n    {\n        // If the type is the same, we don't need a new flow scope\n        if (!restrictedType.equals(originalType)) \n        {\n            // Create a new flow scope with the new type\n            return blindScope.createChildFlowScope().inferSlotType(\n                    node.getName(), restrictedType);\n        }\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n    // If there is no type to restrict, bail early.\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    // If the types are the same, bail early.\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    // If the node is a name, create a new flow scope with the new type.\n    if (node instanceof Name) {\n        return blindScope.createChildFlowScope().inferSlotType(\n                ((Name) node).getName(), restrictedType);\n    }\n\n    // Otherwise, bail early.\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n  // If there is no restriction, we can simply return the current flow scope.\n  if (restrictedType == null) {\n    return blindScope;\n  }\n\n  // If the current flow scope is the same as the blind scope, we need to create\n  // a new flow scope to avoid creating spurious child flow scopes.\n  if (blindScope == blindScope.getParentFlowScope()) {\n    blindScope = blindScope.createChildFlowScope();\n  }\n\n  // We need to create a new slot in the new flow scope with the new type.\n  StaticSlot<JSType> slot = blindScope.addFreshlyNamedSlot(node);\n  slot.setType(restrictedType);\n\n  // We need to refine the scope to ensure that the new slot is used.\n  blindScope.inferSlotType(slot.getName(), restrictedType);\n\n  // We need to return the new flow scope.\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n  // If we don't have a restricted type, we have nothing to do.\n  if (restrictedType == null) {\n    return blindScope;\n  }\n\n  // If we don't have a slot to refine, we have nothing to do.\n  StaticSlot<JSType> var = blindScope.findUniqueRefinedSlot(node);\n  if (var == null) {\n    return blindScope;\n  }\n\n  // If the slot type is the same, we have nothing to do.\n  if (var.getType().equals(restrictedType)) {\n    return blindScope;\n  }\n\n  // Otherwise, we need to create a new flow scope.\n  FlowScope informed = blindScope.createChildFlowScope();\n  informed.inferSlotType(var.getName(), restrictedType);\n  return informed;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n    // if no restriction then just return the current flow scope\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    // if the original type is null then we need to create a new scope and add the type to it\n    if (originalType == null) {\n        FlowScope newScope = blindScope.createChildFlowScope();\n        newScope.inferSlotType(node.getName(), restrictedType);\n        return newScope;\n    }\n\n    // if the original and restricted types are the same then we don't need to do anything\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    // if the original type is a supertype of the restricted type then we can leave it as is\n    if (originalType.isSupertype(restrictedType)) {\n        return blindScope;\n    }\n\n    // otherwise we need to create a new scope and add the type to it\n    FlowScope newScope = blindScope.createChildFlowScope();\n    newScope.inferSlotType(node.getName(), restrictedType);\n    return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n  // If we don't have a type, we can't restrict it\n  if (restrictedType == null) {\n    return blindScope;\n  }\n\n  // If the types are the same, we don't need to do anything\n  if (originalType.equals(restrictedType)) {\n    return blindScope;\n  }\n\n  // Otherwise, we need to create a new flow scope\n  FlowScope newScope = blindScope.createChildFlowScope();\n\n  // And we need to add a new slot with the new type\n  StaticSlot<JSType> newSlot = newScope.addLocalSlot(node.getName(), restrictedType);\n\n  // And we need to mark the new slot as \"checked unknown\"\n  newSlot.setFlag(StaticSlot.FLAG_CHECKED_UNKNOWN);\n\n  // And we need to return the new flow scope\n  return newScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n  if (originalType == restrictedType) {\n    return blindScope;\n  }\n  if (node instanceof Name) {\n    FlowScope restrictedScope = blindScope.createChildFlowScope();\n    restrictedScope.inferSlotType(((Name) node).getName(), restrictedType);\n    return restrictedScope;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n\n    // If restricted type is null, there is no restriction.\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    // If original type is null, we need to create a new scope with the restricted type.\n    if (originalType == null) {\n        return blindScope.createChildFlowScope().apply({\n            s -> s.inferSlotType(node.getName(), restrictedType)\n        });\n    }\n\n    // If the original type and restricted type are the same, we don't need to do anything.\n    if (originalType.equals(restrictedType)) {\n        return blindScope;\n    }\n\n    // Otherwise, we need to create a new scope with the restricted type.\n    return blindScope.createChildFlowScope().apply({\n        s -> s.inferSlotType(node.getName(), restrictedType)\n    });\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    String string = stream.getString();\n    if (!\"function\".equals(string)) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n\n    next();\n    skipEOLs();\n\n    List<Node> typeParameters = new ArrayList<>();\n    while (match(JsDocToken.STRING) && stream.getString().equals(\"this\")) \n    {\n        skipEOLs();\n        Node typeParameterNode = new StringNode(\"this\", stream.getLineno(), stream.getCharno());\n        typeParameters.add(typeParameterNode);\n        if (!match(JsDocToken.Colon)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.IDENTIFIER)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n        }\n\n        typeParameterNode.addChildToFront(new StringNode(stream.getString()));\n        next();\n        skipEOLs();\n    }\n\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType != null) \n    {\n        for (Node typeParameter : typeParameters) \n        {\n            parametersType.addChild(typeParameter);\n        }\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (parametersType == null || resultType == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paramresult\");\n    }\n\n    return wrapNode(Token.FUNCTION, resultType, parametersType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    \n    next();\n    skipEOLs();\n    \n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n    next();\n    skipEOLs();\n    \n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    \n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    \n    Node thisType = parseTypeName(next());\n    \n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n    next();\n    skipEOLs();\n    \n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n    next();\n    skipEOLs();\n    \n    Node parameters = parseParametersType(next());\n    \n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n    next();\n    skipEOLs();\n    \n    Node result = parseResultType(next());\n    \n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n    next();\n    \n    return wrapNode(Token.FUNCTION, new NodeList(thisType, parameters, result));\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    next();\n    skipEOLs();\n    Node typeParams = parseTypeParameters();\n    if (typeParams != null) {\n        typeParams.setParent(null);\n        Node thisType = parseTypeName(JsDocToken.STRING);\n        thisType.setParent(null);\n        if (!match(JsDocToken.COLON)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        Node parametersType = parseParametersType();\n        if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        next();\n        skipEOLs();\n        Node resultType = parseResultType();\n        if (resultType != null) {\n            resultType.setParent(null);\n            Node functionTypeNode = newFunctionNodeType(typeParams, thisType, parametersType, resultType, null);\n            return functionTypeNode;\n        }\n    }\n    return reportGenericTypeSyntaxWarning();\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString()))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    if (!match(JsDocToken.LP))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString()))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.COLON))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null)\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    if (!match(JsDocToken.RP))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.LP))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    Node parameters = parseParametersType(next());\n    if (parameters == null)\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    if (!match(JsDocToken.RP))\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null)\n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    skipEOLs();\n\n    return wrapNode(Token.FUNCTION, thisType, parameters, resultType);\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    if (!\"function\".equals(stream.getString()))\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.LP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.STRING))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n    }\n\n    Node thisTypeNode = newStringNode(stream.getString(), stream.getLineno(), stream.getCharno());\n    next();\n    skipEOLs();\n\n    if (!match(JsDocToken.RP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node parameters = parseParametersType(next());\n    if (parameters == null)\n    {\n        return null;\n    }\n\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null)\n    {\n        return null;\n    }\n\n    skipEOLs();\n\n    return wrapNode(Token.FUNCTION, new Node(Token.FUNCTION, new Node(Token.TYPE_PARAMETERS, new Node(Token.LP), thisTypeNode, new Node(Token.RP)), new Node(Token.LP), parameters, new Node(Token.RP), resultType));\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    if (!\"function\".equals(stream.getString()))\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paren\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeParameters = null;\n    if (match(JsDocToken.LAMBDA))\n    {\n        typeParameters = parseTypeParameters(next());\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LB))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n\n    next();\n    Node thisParameter = newNode(Token.NAME, \"this\");\n    thisParameter.addChild(parseTypeName(JsDocToken.STRING));\n    skipEOLs();\n\n    if (!match(JsDocToken.RB))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n\n    skipEOLs();\n    if (!match(JsDocToken.RB))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null)\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n    }\n\n    return wrapNode(Token.FUN, newCompoundTypeNode(\n            typeParameters, thisParameter, parametersType, resultType));\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    if (!\"function\".equals(stream.getString()))\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n\n    skipEOLs();\n    if (!match(JsDocToken.LP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.LP\");\n    }\n\n    next();\n\n    skipEOLs();\n    Node thisType = parseTypeName(next());\n\n    skipEOLs();\n    if (!match(JsDocToken.CP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.RP\");\n    }\n\n    next();\n\n    Node parametersType = parseParametersType(next());\n\n    skipEOLs();\n    if (!match(JsDocToken.RP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.RP\");\n    }\n\n    next();\n\n    Node resultType = parseTypeExpression(next());\n\n    if (resultType != null)\n    {\n        return newFunctionTypeNode(typeParameters, thisType, parametersType, resultType);\n    }\n\n    return null;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  if (!match(JsDocToken.LP)) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node thisType = newStringNode(\"this\");\n  Node thisTypeNode = newVarNode(thisType);\n\n  if (!match(JsDocToken.COLON)) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node typeParams = parseTypeParameters(next());\n\n  if (!match(JsDocToken.RP)) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node parametersNode = parseParameters(next());\n\n  if (!match(JsDocToken.RP)) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  next();\n  skipEOLs();\n\n  Node resultNode = parseResult(next());\n\n  Node functionNode = newFunctionNode(thisTypeNode, typeParams, parametersNode, resultNode);\n  return functionNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n  Node thisType = parseContextTypeExpression(next());\n  if (thisType == null) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  Node parameters = parseParametersType(next());\n  if (parameters == null) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    if (!\"function\".equals(stream.getString()))\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisNode = newStringNode(\"this\");\n\n    if (!match(JsDocToken.COLON))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n\n    if (thisType == null)\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n\n    thisNode.addChildToFront(thisType);\n\n    Node parameters = parseParametersType(next());\n\n    if (parameters == null)\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameterlist\");\n    }\n\n    thisNode.addChildToFront(parameters);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP))\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n    skipEOLs();\n\n    Node resultType = parseResultType(next());\n\n    if (resultType == null)\n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n\n    thisNode.addChildToFront(resultType);\n\n    return thisNode;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  { \n    if (str == null)\n    {\n        return null;\n    }\n    if (str.isEmpty())\n    {\n        return \"\";\n    }\n    \n    final StringBuilder buf = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++)\n    {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch))\n        {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  { \n    if (str == null)\n    {\n        return null;\n    }\n    else\n    {\n        return str.replaceAll(\"\\\\s+\", \"\");\n    }\n}",
      "public static String deleteWhitespace(final String str)  {\n\n    if (str == null) {\n        return null;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n\n    if (str == null) {\n        return null;\n    }\n    int len = str.length();\n    if (len == 0) {\n        return EMPTY;\n    }\n    int st = 0;\n    int end = len - 1;\n    while (st <= end && Character.isWhitespace(str.charAt(st))) {\n        st++;\n    }\n    if (st == end) {\n        return EMPTY;\n    }\n    while (st <= end && Character.isWhitespace(str.charAt(end))) {\n        end--;\n    }\n    return str.substring(st, end + 1);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  { \n    if (str == null) \n    { \n        return null; \n    } \n    if (str.isEmpty()) \n    { \n        return \"\"; \n    } \n    StringBuilder sb = new StringBuilder(); \n    for (int i = 0; i < str.length(); i++) \n    { \n        char c = str.charAt(i); \n        if (!Character.isWhitespace(c)) \n        { \n            sb.append(c); \n        } \n    } \n    return sb.toString(); \n}",
      "public static String deleteWhitespace(final String str)  {\n\n    if (str == null) {\n        return null;\n    }\n\n    final StringBuilder sb = new StringBuilder(str.length());\n\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            sb.append(c);\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder buf = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            sb.append(str.charAt(i));\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  { \n    if (str == null) \n    { \n        return null; \n    } \n    if (str.isEmpty()) \n    { \n        return \"\"; \n    } \n    StringBuilder sb = new StringBuilder(str.length()); \n    for (int i = 0; i < str.length(); i++) \n    { \n        if (!Character.isWhitespace(str.charAt(i))) \n        { \n            sb.append(str.charAt(i)); \n        } \n    } \n    return sb.toString(); \n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues aggregatedStats = null;\n\n    if (statistics != null && statistics.size() > 0) {\n        aggregatedStats = new StatisticalSummaryValues(statistics.iterator().next());\n\n        for (SummaryStatistics stats : statistics) {\n            aggregatedStats.add(stats);\n        }\n    }\n\n    return aggregatedStats;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues summaryValues = null;\n    for (SummaryStatistics ss: statistics) {\n        if (summaryValues == null) {\n            summaryValues = new StatisticalSummaryValues(ss.getMean(), ss.getVariance(), ss.getN(),\n                    ss.getMax(), ss.getMin(), ss.getSum());\n        } else {\n            summaryValues.update(ss);\n        }\n    }\n    return summaryValues;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n        return null;\n\n    SummaryStatistics result = statistics.iterator().next();\n    for (SummaryStatistics s : statistics)\n        SummaryStatistics.combine(result, s);\n\n    return new StatisticalSummaryValues(result.getMean(), result.getVariance(),\n            result.getN(), result.getMax(), result.getMin(), result.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues summaryValues = null;\n    for (SummaryStatistics stat : statistics) {\n        if (summaryValues == null) {\n            summaryValues = new StatisticalSummaryValues(stat.getMean(), stat.getVariance(), stat.getN(),\n                    stat.getMax(), stat.getMin(), stat.getSum());\n        } else {\n            summaryValues.addValue(stat.getMean());\n            summaryValues.addValue(stat.getVariance());\n            summaryValues.addValue(stat.getN());\n            summaryValues.addValue(stat.getMax());\n            summaryValues.addValue(stat.getMin());\n            summaryValues.addValue(stat.getSum());\n        }\n    }\n\n    return summaryValues;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues summary = null;\n    for (SummaryStatistics stat : statistics) {\n        if (summary == null) {\n            summary = stat.getSummary();\n        } else {\n            summary.combine(stat.getSummary());\n        }\n    }\n\n    return summary;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues aggregate = null;\n\n    if (statistics != null && !statistics.isEmpty()) \n    {\n        double sum = 0, sumsq = 0, sumOfLogs = 0, max = Double.NEGATIVE_INFINITY, min = Double.POSITIVE_INFINITY;\n        int n = 0;\n\n        for (SummaryStatistics stat : statistics) \n        {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            sumOfLogs += stat.getSumOfLogs();\n\n            if (stat.getMax() > max) \n            {\n                max = stat.getMax();\n            }\n\n            if (stat.getMin() < min) \n            {\n                min = stat.getMin();\n            }\n        }\n\n        aggregate = new StatisticalSummaryValues(sum / n, sumsq / n - Math.pow(sum / n, 2), n, max, min, sum);\n    }\n\n    return aggregate;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues aggregatedValues = new StatisticalSummaryValues(\n            0, 0, 0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 0);\n\n    for (SummaryStatistics stats : statistics) {\n        aggregatedValues = aggregatedValues.mergeWith(stats.getSummary());\n    }\n\n    return aggregatedValues;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues result = null;\n\n    if (statistics != null) \n    {\n        double newSum = 0;\n        double newSumsq = 0;\n        double newSumOfLogs = 0;\n        double newGeometricMean = 0;\n        long newN = 0L;\n        double newMin = Double.MAX_VALUE;\n        double newMax = Double.MIN_VALUE;\n\n        for (SummaryStatistics s : statistics) \n        {\n            newSum += s.getSum();\n            newSumsq += s.getSumsq();\n            newSumOfLogs += s.getSumOfLogs();\n            newGeometricMean += s.getGeometricMean();\n            newN += s.getN();\n            newMin = Math.min(s.getMin(), newMin);\n            newMax = Math.max(s.getMax(), newMax);\n        }\n\n        result = new StatisticalSummaryValues(newSum / newN, newSumsq / newN, newN,\n                newMax, newMin, newSum);\n    }\n\n    return result;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    StatisticalSummaryValues aggregatedStats = null;\n\n    if (statistics != null && !statistics.isEmpty()) {\n        aggregatedStats = statistics.iterator().next().copy();\n        for (SummaryStatistics stat : statistics) {\n            if (!stat.equals(aggregatedStats)) {\n                aggregatedStats.merge(stat);\n            }\n        }\n    }\n    return aggregatedStats;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues aggregateStats = new StatisticalSummaryValues(0, 0, 0, Double.NaN, Double.NaN, 0);\n\n    for (SummaryStatistics stat : statistics) {\n        aggregateStats.addValue(stat.getMean(), stat.getVariance(), stat.getN(),\n                stat.getMax(), stat.getMin(), stat.getSum());\n    }\n\n    return aggregateStats;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.INCORRECT_NUMBER_OF_ARGUMENTS,\n                n, 2);\n    }\n\n    double sqDevSum = 0.0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i] - meanDifference;\n        sqDevSum += diff * diff;\n    }\n    return sqDevSum / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.NOT_ENOUGH_DATA);\n    }\n\n    double temp = 0;\n    for (int i = 0; i < n; i++) {\n        temp += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n    }\n    return temp / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(2, n, LocalizedFormats.INSUFFICIENT_PAIR_SAMPLE_SIZE);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += Math.pow(diff - meanDifference, 2);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.VARIANCE_REQUIREMENTS, 2, n);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += (diff - meanDifference) * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double variance = 0;\n    for (int i = 0; i < n; i++) {\n        variance += Math.pow(sample1[i] - sample2[i] - meanDifference,2);\n    }\n    return variance / (n-1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(2, n, LocalizedFormats.INCORRECT_NUMBER_OF_ELEMENTS);\n    }\n\n    double variance = 0;\n    for (int i = 0; i < n; i++) {\n        variance += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n\n    return variance / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.FEW_ARGUMENTS);\n    }\n\n    double variance = 0;\n    for (int i = 0; i < n; i++) {\n        variance += Math.pow((sample1[i] - sample2[i] - meanDifference), 2);\n    }\n    return variance / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.TWO_POINTS_MINIMUM,\n                n, 2);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        result += difference * difference;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(2, n, LocalizedFormats.INSUFFICIENT_DATA);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += Math.pow((sample1[i] - sample2[i]) - meanDifference, 2);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA, n, 2);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double temp = sample1[i] - sample2[i] - meanDifference;\n        result += temp * temp;\n    }\n    return result / n;\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Object[] keys = dataset.getKeys();\n    for (Object key : keys) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Number value;\n    for (Iterator iterator = dataset.iterator(); iterator.hasNext();) {\n        value = dataset.getValue((Comparable) iterator.next());\n        if (value != null && value.doubleValue() >= 0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    double value;\n    Comparable key;\n\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    for (Iterator it = dataset.iterator(); it.hasNext();) {\n        key = (Comparable) it.next();\n        value = dataset.getValue(key);\n        if (value >= 0.0) {\n            total += value;\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset is null\");\n    }\n    double total = 0.0;\n    for (Iterator iterator = dataset.iterator(); iterator.hasNext();) {\n        Number value = (Number) iterator.next();\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (Iterator it = dataset.getKeys(); it.hasNext();) {\n        Comparable key = (Comparable) it.next();\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() >= 0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Number value;\n    for (Iterator iterator = dataset.iterator(); iterator.hasNext();) {\n        value = (Number) iterator.next();\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (Iterator iterator = dataset.iterator(); iterator.hasNext();) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() >= 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    Object[] keys = dataset.getKeys();\n    for (Object key : keys) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() > 0.0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    if (dataset != null) {\n        Iterator iterator = dataset.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number value = dataset.getValue(key);\n            if (value != null && value.doubleValue() >= 0.0) {\n                total += value.doubleValue();\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Dataset is null\");\n    }\n\n    double total = 0.0;\n    Iterator iterator = dataset.iterator();\n    while (iterator.hasNext()) {\n        Number value = (Number) iterator.next();\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NONE) \n  {\n    readNextName();\n  }\n  if (peeked == PEEKED_NONE) \n  {\n    throw new IOException(\"Expected a name but was \" + peeked.name());\n  }\n  String result = peekedName;\n  peeked = PEEKED_NONE;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    if (peeked == PEEKED_NAME) {\n        String name = peekedName;\n        peeked = PEEKED_NONE;\n        return name;\n    }\n\n    if (peeked == PEEKED_NONE) {\n        peeked = nextToken();\n    }\n\n    if (peeked == PEEKED_LONG) {\n        String name = String.valueOf(peekedLong);\n        peeked = PEEKED_NONE;\n        return name;\n    }\n\n    if (peeked == PEEKED_NUMBER) {\n        String name = text.substring(textStart, textStart + peekedNumberLength);\n        peeked = PEEKED_NONE;\n        return name;\n    }\n\n    if (peeked != PEEKED_NONE) {\n        return null;\n    }\n\n    StringBuilder builder = new StringBuilder(32);\n\n    int c;\n    while (true) {\n        c = peek();\n\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            builder.append((char) c);\n            skip();\n        } else {\n            break;\n        }\n    }\n\n    if (builder.length() == 0) {\n        throw new IOException(\"Expected a name but found: \" + peek());\n    }\n\n    peeked = nextToken();\n    return builder.toString();\n}",
      "public String nextName() throws IOException  {\n    int peeked = peek();\n    if (peeked == PEEKED_NONE) {\n      return null;\n    }\n    if (peeked == PEEKED_NUMBER) {\n      throw new IOException(\"nextName() called in the middle of a number\");\n    }\n    if (peeked == PEEKED_LONG) {\n      throw new IOException(\"nextName() called after nextLong()\");\n    }\n    if (peeked == PEEKED_STRING) {\n      return (String) peekedString;\n    }\n    if (peeked == PEEKED_NULL) {\n      next();\n      return JsonToken.NULL.name();\n    }\n    if (peeked == PEEKED_EOF) {\n      return null;\n    }\n    String result = (String) peekedString;\n    next();\n    return result;\n}",
      "public String nextName() throws IOException  {\n    if (peeked == PEEKED_NAME) {\n        String result = peekedName;\n        peeked = PEEKED_NONE;\n        return result;\n    }\n\n    if (pos >= len) {\n        return null;\n    }\n\n    char c = peek();\n    if (c == '\"') {\n        return readString();\n    } else if (c == '{') {\n        pos++;\n        return \"$\";\n    } else if (c == '[') {\n        pos++;\n        return \"#\";\n    } else {\n        return readPropertyName();\n    }\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NAME)\n  {\n    String result = peekedName;\n    peekedName = null;\n    peeked = PEEKED_NONE;\n    pos += peekedNumberLength;\n    return result;\n  }\n  else\n  {\n    int c = read();\n    if (c == -1) throw new EOFException();\n\n    if (c == '\"')\n    {\n      StringBuilder sb = new StringBuilder();\n      int escapeCount = 0;\n      int escapeNext = 0;\n\n      while (true)\n      {\n        int c2 = read();\n        if (c2 == -1) throw new EOFException();\n\n        if (escapeNext == 1)\n        {\n          switch (c2)\n          {\n            case 'u':\n              c2 = readHex4();\n              if (c2 == -1) throw new EOFException();\n              sb.append((char) c2);\n              break;\n            case '\"':\n              sb.append('\"');\n              break;\n            case '\\\\':\n              sb.append('\\\\');\n              break;\n            case 'b':\n              sb.append('\\b');\n              break;\n            case 't':\n              sb.append('\\t');\n              break;\n            case 'n':\n              sb.append('\\n');\n              break;\n            case 'f':\n              sb.append('\\f');\n              break;\n            case 'r':\n              sb.append('\\r');\n              break;\n            default:\n              throw new MalformedJsonException(\"Invalid escape sequence: \\\\\" + (char) c2);\n          }\n          escapeNext = 0;\n        }\n        else\n        {\n          if (escapeCount > 0)\n          {\n            escapeCount--;\n            if (escapeCount == 0)\n            {\n              if (c2 == '\"')\n              {\n                break;\n              }\n              else if (c2 == '\\\\')\n              {\n                escapeNext = 1;\n              }\n              else\n              {\n                throw new MalformedJsonException(\"Expected '\"' or '\\\\' after escape sequence\");\n              }\n            }\n          }\n}\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NONE) \n  {\n    if (pos >= len) {\n      return null;\n    }\n\n    char c = buffer[pos++];\n    if (c == '{' || c == '[') {\n      depth++;\n    } else if (c == '}' || c == ']') {\n      depth--;\n    }\n\n    charactersOfNumber:\n    {\n      boolean negative = false;\n      long value = 0;\n      boolean fitsInLong = true;\n\n      for (int i = 0;;) {\n        char last = this.last;\n\n        switch (c) {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n            value = c - '0';\n            last = NUMBER_CHAR_DIGIT;\n          } else if (last == NUMBER_CHAR_DIGIT) {\n            if (value == 0) {\n              return null; // Leading '0' prefix is not allowed (since it could be octal).\n            }\n            long newValue = value * 10 + (c - '0');\n            fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n            value = newValue;\n          } else if (last == NUMBER_CHAR_DECIMAL) {\n            last = NUMBER_CHAR_FRACTION_DIGIT;\n          } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n            last = NUMBER_CHAR_EXP_DIGIT;\n          }\n          break charactersOfNumber;\n        case '-':\n          if (last == NUMBER_CHAR_EXP_E) {\n            last = NUMBER_CHAR_EXP_SIGN;\n            continue;\n          }\n          return PEEKED_NONE;\n        case '+':\n          if (last == NUMBER_CHAR_EXP_E) {\n            last = NUMBER_CHAR_EXP_SIGN;\n            continue;\n          }\n}\n}\n}\n}\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NAME)\n  {\n    String result = peekedName;\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  \n  int c = read();\n  if (c == -1)\n    throw new IOException(\"Expected a name but found EOF\");\n  \n  StringBuilder sb = new StringBuilder(32);\n  while (true)\n  {\n    if (c == '\"')\n    {\n      pos++;\n      if (peeked == PEEKED_NONE)\n      {\n        return peekedName = sb.toString();\n      }\n      else\n      {\n        String result = peekedName;\n        peeked = PEEKED_NONE;\n        return result;\n      }\n    }\n    else if (c == '\\\\')\n    {\n      c = read();\n      if (c == -1)\n        throw new IOException(\"Expected escaped character but found EOF\");\n      if (c >= '\\u0080')\n        throw new IOException(\"Invalid unicode escape\");\n      if (c >= '0' && c <= '7')\n      {\n        int n = c - '0';\n        c = read();\n        if (c >= '0' && c <= '7')\n        {\n          n = (n << 3) + (c - '0');\n          c = read();\n          if (c >= '0' && c <= '7')\n          {\n            n = (n << 3) + (c - '0');\n            sb.append((char) n);\n            continue;\n          }\n        }\n      }\n      if (c >= '0' && c <= '3')\n      {\n        int n = c - '0';\n        c = read();\n        if (c >= '0' && c <= '7')\n        {\n          n = (n << 3) + (c - '0');\n          c = read();\n          if (c >= '0' && c <= '3')\n          {\n            n = (n << 4) + (c - '0');\n            sb.append((char) n);\n            continue;\n          }\n        }\n      }\n}\n}\n}",
      "public String nextName() throws IOException  {\n    while (true) {\n        switch (next()) {\n        case '{':\n        case '[':\n            return readName();\n        case ':':\n            throw new IOException(\"Expected a name but found a colon.\");\n        case PEEKED_NONE:\n            break;\n        default:\n            return readName();\n        }\n    }\n}\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NONE) \n  {\n    if (pos < limit) \n    {\n      char c = buffer[pos++];\n      if (c == '\\\"') \n      {\n        return readEscapedName();\n      }\n      else\n      {\n        StringBuilder nameBuilder = new StringBuilder();\n        while (pos < limit && isLiteral(buffer[pos])) \n        {\n          nameBuilder.append(buffer[pos++]);\n        }\n        return nameBuilder.toString();\n      }\n    }\n    else \n    {\n      return null;\n    }\n  }\n  else \n  {\n    String peekedName = peekedName;\n    peeked = PEEKED_NONE;\n    return peekedName;\n  }\n}",
      "public String nextName() throws IOException  {\n  if (peeked == PEEKED_NONE)\n    peek();\n  if (peeked == PEEKED_LONG)\n  {\n    String result = peekedLongString();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_NUMBER)\n  {\n    String result = peekedNumber();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_STRING)\n  {\n    String result = peekedString();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_NULL)\n  {\n    String result = peekedNull();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_BOOLEAN)\n  {\n    String result = peekedBoolean();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_EOF)\n  {\n    String result = peekedEOF();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_NUMBER)\n  {\n    String result = peekedNumber();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  if (peeked == PEEKED_LONG)\n  {\n    String result = peekedLongString();\n    peeked = PEEKED_NONE;\n    return result;\n  }\n  return null;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        return readUncompressedChunk(b, off, len);\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n            return -1;\n        }\n        int bytesToCopy = Math.min(len, uncompressedBytesRemaining);\n        in.read(b, off, bytesToCopy);\n        uncompressedBytesRemaining -= bytesToCopy;\n        return bytesToCopy;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            return -1;\n        }\n        final int toRead = Math.min(len, uncompressedBytesRemaining);\n        in.read(b, off, toRead);\n        uncompressedBytesRemaining -= toRead;\n        return toRead;\n    } else if (currentCompressedChunk != null) {\n        final int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n            readNextBlock();\n            return readNext(b, off, len);\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n            return -1;\n        }\n        int bytesLeft = Math.min(uncompressedBytesRemaining, len);\n        in.read(b, off, bytesLeft);\n        uncompressedBytesRemaining -= bytesLeft;\n        return bytesLeft;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        final int bytesLeft = Math.min(uncompressedBytesRemaining, len);\n        in.read(b, off, bytesLeft);\n        uncompressedBytesRemaining -= bytesLeft;\n        return bytesLeft;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        final int bytesLeft = uncompressedBytesRemaining;\n        final int bytesToRead = Math.min(len, bytesLeft);\n        in.read(b, off, bytesToRead);\n        uncompressedBytesRemaining -= bytesToRead;\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return bytesToRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    } else {\n        return -1;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            return -1;\n        }\n        final int toRead = Math.min(len, uncompressedBytesRemaining);\n        in.read(b, off, toRead);\n        uncompressedBytesRemaining -= toRead;\n        return toRead;\n    } else {\n        if (currentCompressedChunk == null || currentCompressedChunk.available() == 0) {\n            readNextBlock();\n            if (currentCompressedChunk == null) {\n                return -1;\n            }\n        }\n        final int toRead = Math.min(len, currentCompressedChunk.available());\n        currentCompressedChunk.read(b, off, toRead);\n        return toRead;\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        return readUncompressed(b, off, len);\n    } else {\n        return readCompressed(b, off, len);\n    }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            return -1;\n        }\n        final int read = Math.min(len, uncompressedBytesRemaining);\n        in.read(b, off, read);\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        final int bytesRead = Math.min(len, uncompressedBytesRemaining);\n        in.read(b, off, bytesRead);\n        uncompressedBytesRemaining -= bytesRead;\n        return bytesRead;\n    } else {\n        return currentCompressedChunk != null ? currentCompressedChunk.read(b, off, len) : -1;\n    }\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node expr = site.getExpression();\n    if (expr instanceof CallExpr callExpr) {\n        return callExpr.getArgument(argIndex);\n    } else if (expr instanceof NewExpr newExpr) {\n        return newExpr.getArgument(argIndex);\n    } else if (expr instanceof DotExpr dotExpr) {\n        if (dotExpr.getArgument(0) == null) {\n            return null;\n        }\n        Node arg = dotExpr.getArgument(argIndex);\n        if (arg.isVariable() && ((Variable) arg).isParameter()) {\n            return null;\n        }\n        return arg;\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node expr = site.getExpression();\n    if (expr instanceof CallExpr || expr instanceof NewExpr) {\n      CallExpr callExpr = (CallExpr) expr;\n      if (callExpr.getArguments().size() > argIndex) {\n        return callExpr.getArguments().get(argIndex);\n      }\n    } else if (expr instanceof DotExpr) {\n      DotExpr dotExpr = (DotExpr) expr;\n      if (dotExpr.getArguments().size() > argIndex) {\n        return dotExpr.getArguments().get(argIndex);\n      }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    return null; // TODO(johnlenz): Implement this logic\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof CallUseSite) {\n        return ((CallUseSite) site).getArguments().get(argIndex);\n    } else if (site instanceof NewUseSite) {\n        return ((NewUseSite) site).getArguments().get(argIndex);\n    } else if (site instanceof DotCallUseSite) {\n        return ((DotCallUseSite) site).getArguments().get(argIndex);\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    return argIndex >= 0\n        ? site.getValue()\n        : ((ExpressionStatement) site.getValue()).getExpression();\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    return null; // TODO(johnlenz): implement\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof FunctionCallUseSite) {\n        return ((FunctionCallUseSite) site).getArgumentList().get(argIndex);\n    }\n    if (site instanceof NewExprUseSite) {\n        return ((NewExprUseSite) site).getArgumentList().get(argIndex);\n    }\n    if (site instanceof DotCallUseSite) {\n        DotCallUseSite callSite = (DotCallUseSite) site;\n        List<Node> args = callSite.getArgumentList();\n        if (callSite.getOp() == Token.DOT && callSite.getArguments().size() == 1) {\n            args.add(0, callSite.getBaseExpr());\n        }\n        return args.get(argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    return null; // TODO(johnlenz): implement this method\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site instanceof DirectUseSite) {\n      return ((DirectUseSite) site).getUse().getArgument(argIndex);\n    } else {\n      Node call = ((MethodCallUseSite) site).getCall();\n      if (call instanceof NewExpr) {\n        return ((NewExpr) call).getArgument(argIndex);\n      } else {\n        return ((MethodCallExpr) call).getArgument(argIndex);\n      }\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node expr = site.getExpression();\n    if (expr instanceof DirectMethodCallExpr) {\n      return ((DirectMethodCallExpr) expr).getArgument(argIndex);\n    } else if (expr instanceof NewExpr) {\n      return ((NewExpr) expr).getArgument(argIndex);\n    } else if (expr instanceof MethodCallExpr) {\n      if (((MethodCallExpr) expr).getArguments().size() > argIndex) {\n        return ((MethodCallExpr) expr).getArguments().get(argIndex);\n      }\n    } else if (expr instanceof DotCallExpr) {\n      if (((DotCallExpr) expr).getArguments().size() > argIndex) {\n        return ((DotCallExpr) expr).getArguments().get(argIndex);\n      }\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  // ... complete code here ...\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    String deprecatedType = get(type.toString());\n    if (deprecatedType != null) \n    {\n        return deprecatedType;\n    }\n    for (Map.Entry<String, String> entry : deprecatedTypes.entrySet()) \n    {\n        if (type.toString().contains(entry.getKey()))\n        {\n            return entry.getValue();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    String reason = type.getDocumentation().get('deprecated');\n    if (reason == null) \n    {\n        reason = type.getDocumentation().get('experimental');\n    } \n    return reason;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isDeprecated()) {\n    String reason = type.getDocumentation().getDeprecationReason();\n    if (reason == null || reason.isEmpty()) {\n      return \"Deprecated\";\n    } else {\n      return reason;\n    }\n  } else {\n    return null;\n  }\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isDeprecated()) {\n    String reason = type.getDeprecationReason();\n    if (reason != null && !reason.isEmpty()) {\n      return reason;\n    } else {\n      return \"\";\n    }\n  }\n  return null;\n}\n\n// Complete the Java function with correct and functional code,",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    String deprecatedMessage = type.getMetaInfo(\"deprecation\");\n    if (deprecatedMessage != null)\n        return deprecatedMessage;\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    return \"This type is deprecated\";\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  // TODO: Implement logic to retrieve deprecation information from the type object.\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isDeprecated()) {\n        return type.getDeprecationReason();\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  return type.getDeprecationInfo().getReason();\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String cached = cTimeZoneDisplayCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n    String display = tz.getDisplayName(daylight, style, locale);\n    cTimeZoneDisplayCache.put(key, display);\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(daylight, style, locale);\n    return cTimeZoneDisplayCache.computeIfAbsent(key, k -> {\n        String display = tz.getDisplayName(daylight, style, locale);\n        if (style == TimeZone.SHORT && display.equals(tz.getID())) {\n            Calendar cal = Calendar.getInstance(tz);\n            cal.setTime(new Date());\n            NumberRule rule = getDisplayNumberRule(cal, locale);\n            rule.append(new StringBuffer(), cal);\n            return rule.toString();\n        } else {\n            return display;\n        }\n    });\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String cached = cTimeZoneDisplayCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n    String display = tz.getDisplayName(daylight, style, locale);\n    cTimeZoneDisplayCache.put(key, display);\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(daylight, style, locale);\n    return cTimeZoneDisplayCache.computeIfAbsent(key, k -> {\n        String result = tz.getDisplayName(daylight, style, locale);\n        if (result == null) {\n            result = tz.getID();\n        }\n        return result;\n    });\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    if (style == TimeZone.LONG) {\n        result = tz.getDisplayName(daylight, TimeZone.LONG, locale);\n    } else {\n        result = tz.getDisplayName(daylight, TimeZone.SHORT, locale);\n    }\n\n    cTimeZoneDisplayCache.put(key, result);\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n    result = tz.getDisplayName(daylight, style, locale);\n    cTimeZoneDisplayCache.put(key, result);\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) \n    {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, result);\n    }\n    return result;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    for (int i = firstCategoryIndex; i <= lastCategoryIndex(); i++)\n    {\n        if (key.equals(underlying.getColumnKey(i))) return i - firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tfor (int i = 0; i < this.underlying.getColumnCount(); i++)\n\t{\n\t\tif (this.underlying.getColumnKey(i).equals(key))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\treturn this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null.\");\n    }\n    int column = firstCategoryIndex();\n    for (int i = column; i <= lastCategoryIndex(); i++) \n    {\n        if (underlying.getColumnKey(i).equals(key)) \n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    for (int i = this.firstCategoryIndex; i <= lastCategoryIndex(); i++) {\n        if (key.equals(this.underlying.getColumnKey(i))) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    String keyString = key.toString();\n    for (int i = 0; i < this.underlying.getColumnCount(); i++) {\n        if (this.underlying.getColumnKey(i).toString().equals(keyString)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    for (int i = this.firstCategoryIndex; i <= lastCategoryIndex(); i++) \n    {\n        if (this.underlying.getColumnKey(i).equals(key))\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    for (int i = 0; i < this.underlying.getColumnCount(); i++)\n    {\n        if (this.underlying.getColumnKey(i).equals(key))\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n\tif (key == null) {\n\t    throw new IllegalArgumentException(\"Null key\");\n\t}\n\tint column = this.underlying.getColumnIndex(key);\n\tif (column >= this.firstCategoryIndex && column <= lastCategoryIndex()) {\n\t    return column - this.firstCategoryIndex;\n\t} else {\n\t    return -1;\n\t}\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = underlying.getColumnIndex(key);\n    if (index >= firstCategoryIndex && index <= lastCategoryIndex()) \n    {\n        return index;\n    }\n    else \n    {\n        return -1;\n    }\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point <= lower + tolerance && point >= upper - tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else if(point < lower - tolerance || point > upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if ((point >= lower - tolerance) && (point <= upper + tolerance))\n    {\n        if ((point > lower + tolerance) && (point < upper - tolerance))\n        {\n            return Location.INSIDE;\n        }\n        else\n        {\n            return Location.BOUNDARY;\n        }\n    }\n    else\n    {\n        return Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(Math.abs(point - lower) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else if(Math.abs(point - upper) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else if(point >= lower && point <= upper)\n    {\n        return Location.INSIDE;\n    }\n    else \n    {\n        return Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point > lower + tolerance && point < upper - tolerance) {\n        return Location.INSIDE;\n    } else if (point <= lower - tolerance || point >= upper + tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= getInf() - tolerance && point <= getSup() + tolerance) \n    {\n        return Location.BOUNDARY;\n    } else if (point < getInf() - tolerance) \n    {\n        return Location.OUTSIDE;\n    } else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if ((point >= lower - tolerance) && (point <= upper + tolerance)) {\n        return Location.BOUNDARY;\n    }\n    else if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    else {\n        return Location.INSIDE;\n    }\n}\n\nenum Location {\n    INSIDE,\n    OUTSIDE,\n    BOUNDARY\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= upper - tolerance && point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper) {\n        return Location.OUTSIDE;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if ((point >= lower - tolerance) && (point <= upper + tolerance))\n    {\n        return Location.BOUNDARY;\n    }\n    else if (point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if ((point >= lower - tolerance) && (point <= upper + tolerance)) {\n        return Location.BOUNDARY;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point <= lower && point >= upper)\n    {\n        return Location.BOUNDARY;\n    }\n    else if(point > upper)\n    {\n        return Location.OUTSIDE;\n    }\n    else if(point < lower)\n    {\n        return Location.OUTSIDE;\n    }\n    else if(Math.abs(point - lower) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else if(Math.abs(point - upper) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> units = new ArrayList<>();\n    for (int i = 0; i < 25; i++) {\n        double value = Math.pow(10, i);\n        String label = createTickLabel(value, locale);\n        units.add(new TickUnit(label, value));\n    }\n    return new TickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> result = new ArrayList<>();\n\n    // Add unit for 1\n    TickUnit tu = new TickUnit(1.0, DecimalFormat.getInstance(locale));\n    tu.setLabel(\"\");\n    result.add(tu);\n\n    // Add unit for 10\n    tu = new TickUnit(10.0, DecimalFormat.getInstance(locale));\n    tu.setLabel(\"1\");\n    result.add(tu);\n\n    // Add units for powers of 10 from 10^2 to 10^21\n    for (int i = 2; i <= 21; i++)\n    {\n        tu = new TickUnit(Math.pow(10, i), DecimalFormat.getInstance(locale));\n        tu.setLabel(String.valueOf(i));\n        result.add(tu);\n    }\n\n    return result;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // create a list of tick units\n    List<TickUnit> tickUnits = new ArrayList<>();\n\n    // create a formatter for the tick units\n    DecimalFormat formatter = new DecimalFormat();\n    formatter.setGroupingUsed(false);\n    formatter.setMaximumFractionDigits(0);\n    formatter.setMinimumFractionDigits(0);\n\n    // create tick units for each integer power of 10\n    for (int i = -9; i <= 9; i++) \n    {\n        tickUnits.add(new LogTickUnit(Math.pow(10, i), formatter));\n    }\n\n    // create a TickUnitSource from the list of tick units\n    return new DefaultTickUnitSource(tickUnits);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> result = new ArrayList<>();\n\n    // Create a helper method to create a TickUnit based on a given base and digit\n    BiFunction<Integer, Integer, TickUnit> makeTU = (base, digits) -> {\n        String pattern = \"0.\";\n        for (int i = 0; i < digits - 1; i++) {\n            pattern += \"0\";\n        }\n        DecimalFormat format = new DecimalFormat(pattern, new DecimalFormatSymbols(locale));\n        format.setParseBigDecimal(true);\n        return new CustomTickUnit(format, base);\n    };\n\n    // Add the units for bases 2 through 9\n    for (int i = 2; i <= 9; i++) {\n        result.add(makeTU.apply(i, 0));\n        for (int j = 1; j <= 4; j++) {\n            result.add(makeTU.apply(i, j));\n        }\n    }\n\n    // Add the unit for base 10\n    result.add(new CustomTickUnit(new DecimalFormat(\"0\", new DecimalFormatSymbols(locale)), 10));\n\n    // Add the unit for base 10 with a leading digit\n    for (int j = 1; j <= 4; j++) {\n        result.add(makeTU.apply(10, j));\n    }\n\n    // Add the unit for base 10 with two leading digits\n    result.add(new CustomTickUnit(new DecimalFormat(\"00\", new DecimalFormatSymbols(locale)), 10));\n\n    // Add the unit for base 10 with three leading digits\n    result.add(makeTU.apply(10, 5));\n\n    return new DefaultTickUnitSource(result);\n}\n\n// CustomTickUnit class (unchanged from the original code)",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // Define the number of decimal places for each tick unit\n    int[] decimalPlaces = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Create an array of tick units with the appropriate labels\n    TickUnit[] units = new TickUnit[decimalPlaces.length];\n    for (int i = 0; i < decimalPlaces.length; i++) \n    {\n        String label = \"10^\" + decimalPlaces[i];\n        units[i] = new SimpleTickUnit(label, 10, decimalPlaces[i]);\n    }\n\n    // Create a tick unit source from the array of units\n    return new DefaultTickUnitSource(units);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> result = new ArrayList<>();\n    DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(locale);\n    char zeroDigit = dfs.getZeroDigit();\n    char digitSeparator = dfs.getDigitSeparator();\n    String decimalSeparator = dfs.getDecimalSeparatorString();\n    String exponentSeparator = dfs.getExponentSeparatorString();\n\n    // Create tick units for integer values\n    for (int i = 0; i < 24; i++) {\n        result.add(new LogTickUnit(Math.pow(10, i), String.valueOf(zeroDigit + i)));\n    }\n\n    // Create tick units for fractional values (using decimal separator)\n    for (int i = 0; i < 9; i++) {\n        char[] fractionDigits = new char[] { zeroDigit + i, decimalSeparator, zeroDigit };\n        result.add(new LogTickUnit(Math.pow(10, i / 2d), new String(fractionDigits)));\n    }\n\n    // Create tick units for fractional values (using digit separator)\n    for (int i = 0; i < 9; i++) {\n        char[] fractionDigits = new char[] { zeroDigit + i, digitSeparator, zeroDigit };\n        result.add(new LogTickUnit(Math.pow(10, i / 2d), new String(fractionDigits)));\n    }\n\n    // Create tick units for exponential values (using exponent separator)\n    for (int i = -2; i <= 2; i++) {\n        char[] exponentDigits = new char[] { zeroDigit, exponentSeparator, zeroDigit + i };\n        result.add(new LogTickUnit(Math.pow(10, i), new String(exponentDigits)));\n    }\n\n    return () -> result.iterator();\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    List<TickUnit> tickUnits = new ArrayList<>();\n\n    for (int exponent = -20; exponent <= 20; ++exponent) {\n        String label;\n\n        if (exponent <= 0) {\n            label = \"10<sup>\" + exponent + \"</sup>\";\n        } else {\n            label = \"10<sup>\" + exponent + \"</sup>\";\n        }\n\n        tickUnits.add(new TickUnit(label, Math.pow(10, exponent)));\n    }\n    \n    return new DefaultTickUnitSource(tickUnits, locale);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // TODO: Implement method here.\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // Use the locale to create the DecimalFormat\n    DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(locale);\n    df.setParseBigDecimal(true);\n\n    // Create a list of tick units for integer values\n    List<TickUnit> tickUnits = new ArrayList<>();\n    tickUnits.add(new LogTickUnit(10, df));\n    tickUnits.add(new LogTickUnit(20, df));\n    tickUnits.add(new LogTickUnit(50, df));\n    tickUnits.add(new LogTickUnit(100, df));\n    tickUnits.add(new LogTickUnit(200, df));\n    tickUnits.add(new LogTickUnit(500, df));\n    tickUnits.add(new LogTickUnit(1000, df));\n\n    // Create a TickUnitSource from the list of tick units\n    return new DefaultTickUnitSource(tickUnits);\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    // Use the default Locale if none specified\n    if (locale == null) \n    {\n        locale = Locale.getDefault();\n    }\n\n    // Create a DecimalFormat for formatting tick labels\n    DecimalFormat format = (DecimalFormat)NumberFormat.getInstance(locale);\n    format.applyPattern(\"0.###E0\");\n\n    // Create a collection of tick units\n    ArrayList<TickUnit> units = new ArrayList<>();\n\n    // Add tick units for integer values\n    for (int i = -9; i <= 9; i++) \n    {\n        units.add(new NumberTickUnit(i, format));\n    }\n\n    // Add tick units for decimal values\n    for (int i = -4; i <= 4; i++) \n    {\n        units.add(new NumberTickUnit(Math.pow(10, i), format));\n    }\n\n    // Create a TickUnitSource from the list of tick units\n    return new DefaultTickUnitSource(units);\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Get the objective function row.\n    RealVector objectiveRow = tableau.getRow(tableau.getNumRows() - 1);\n\n    // Find the minimum value in the objective function row.\n    double min = objectiveRow.getEntry(0);\n    int pivotColumn = 0;\n    for (int i = 1; i < objectiveRow.getDimension(); i++) {\n        if (objectiveRow.getEntry(i) < min) {\n            min = objectiveRow.getEntry(i);\n            pivotColumn = i;\n        }\n    }\n\n    // Return the column with the most negative coefficient.\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = tableau.getObjectiveFunctionValue(0);\n    Integer minCol = 0;\n    for (int c = 1; c < tableau.getNumColumns(); ++c) {\n        double coeff = tableau.getObjectiveFunctionValue(c);\n        if (coeff < minCoeff) {\n            minCoeff = coeff;\n            minCol = c;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotIndex = -1;\n    double min = Double.MAX_VALUE;\n\n    // Find the column with the most negative coefficient in the objective function row.\n    for (int i = 0; i < tableau.getColumnCount(); i++) {\n        if (tableau.getEntry(0, i).getValue() < min) {\n            min = tableau.getEntry(0, i).getValue();\n            pivotIndex = i;\n        }\n    }\n    return pivotIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Get the objective function row from the tableau.\n    List<RealVector> rows = tableau.getRows();\n    RealVector objectiveRow = rows.get(0);\n\n    // Initialize variables to track the most negative coefficient and its column index.\n    double minCoefficient = objectiveRow.getEntry(0);\n    int pivotColumn = 0;\n\n    // Iterate through the columns of the objective function row.\n    for (int j = 1; j < objectiveRow.getDimension(); j++) {\n        double coefficient = objectiveRow.getEntry(j);\n\n        // If the current coefficient is more negative than the previous one, update the minimum coefficient and column index.\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            pivotColumn = j;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Get the objective function row from the tableau\n    double[] objectiveRow = tableau.getRow(tableau.getRows() - 1);\n    \n    // Initialize the pivot column to the first column\n    int pivotColumn = 0;\n    \n    // Iterate through the columns to find the one with the most negative coefficient\n    for (int i = 1; i < objectiveRow.length; i++) \n    {\n        if (objectiveRow[i] < objectiveRow[pivotColumn]) \n        {\n            pivotColumn = i;\n        }\n    }\n    \n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double maxNegativeValue = Double.NEGATIVE_INFINITY;\n\n    // Iterate through all columns to find the one with the most negative value.\n    for (int column = 0; column < tableau.getColumnCount(); column++) {\n        double value = tableau.getEntry(tableau.getRowCount() - 1, column);\n\n        if (value < maxNegativeValue) {\n            maxNegativeValue = value;\n            pivotColumn = column;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Get the objective function row.\n    RealVector objectiveRow = tableau.getRow(tableau.getNumberOfRows() - 1);\n\n    // Find the column with the most negative coefficient.\n    int pivotColumn = 0;\n    double minValue = Double.MAX_VALUE;\n    for (int i = 0; i < objectiveRow.getDimension(); i++)\n    {\n        if (objectiveRow.getEntry(i) < minValue)\n        {\n            minValue = objectiveRow.getEntry(i);\n            pivotColumn = i;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getColumnCount(); ++col) {\n        double coeff = tableau.getObjectiveFunctionRow()[col];\n        if (coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotColumn = 0;\n    double pivotValue = tableau.getEntry(tableau.getNumberOfRows() - 1, 0);\n\n    for (int column = 1; column < tableau.getNumberOfColumns(); column++) {\n        double value = tableau.getEntry(tableau.getNumberOfRows() - 1, column);\n        if (value < pivotValue) {\n            pivotValue = value;\n            pivotColumn = column;\n        }\n    }\n\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int c = tableau.getNumColumns() - 1; c >= tableau.getNumObjectiveFunctions(); c--) {\n        double sum = tableau.getEntry(tableau.getNumRows() - 1, c);\n        for (int r = tableau.getNumRows() - 2; r >= 0; r--) {\n            sum += tableau.getEntry(r, c);\n        }\n        if (sum < min) {\n            min = sum;\n            pivotColumn = c;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}